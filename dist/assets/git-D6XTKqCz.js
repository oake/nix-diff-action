import { createRequire } from "node:module";
import * as os from "os";
import * as fs from "fs";
import * as nodePath from "path";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esmMin = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (all$9, symbols) => {
	let target = {};
	for (var name in all$9) __defProp(target, name, {
		get: all$9[name],
		enumerable: true
	});
	if (symbols) __defProp(target, Symbol.toStringTag, { value: "Module" });
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys$5 = __getOwnPropNames(from), i = 0, n = keys$5.length, key; i < n; i++) {
		key = keys$5[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __toCommonJS = (mod) => __hasOwnProp.call(mod, "module.exports") ? mod["module.exports"] : __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __require = /* @__PURE__ */ createRequire(import.meta.url);
var require_utils$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toCommandValue = toCommandValue;
	exports.toCommandProperties = toCommandProperties;
	function toCommandValue(input) {
		if (input === null || input === void 0) return "";
		else if (typeof input === "string" || input instanceof String) return input;
		return JSON.stringify(input);
	}
	function toCommandProperties(annotationProperties) {
		if (!Object.keys(annotationProperties).length) return {};
		return {
			title: annotationProperties.title,
			file: annotationProperties.file,
			line: annotationProperties.startLine,
			endLine: annotationProperties.endLine,
			col: annotationProperties.startColumn,
			endColumn: annotationProperties.endColumn
		};
	}
}));
var require_command = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.issueCommand = issueCommand;
	exports.issue = issue;
	var os$4 = __importStar(__require("os"));
	var utils_1 = require_utils$1();
	function issueCommand(command, properties, message) {
		const cmd = new Command(command, properties, message);
		process.stdout.write(cmd.toString() + os$4.EOL);
	}
	function issue(name, message = "") {
		issueCommand(name, {}, message);
	}
	var CMD_STRING = "::";
	var Command = class {
		constructor(command, properties, message) {
			if (!command) command = "missing.command";
			this.command = command;
			this.properties = properties;
			this.message = message;
		}
		toString() {
			let cmdStr = CMD_STRING + this.command;
			if (this.properties && Object.keys(this.properties).length > 0) {
				cmdStr += " ";
				let first$2 = true;
				for (const key in this.properties) if (this.properties.hasOwnProperty(key)) {
					const val = this.properties[key];
					if (val) {
						if (first$2) first$2 = false;
						else cmdStr += ",";
						cmdStr += `${key}=${escapeProperty(val)}`;
					}
				}
			}
			cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
			return cmdStr;
		}
	};
	function escapeData(s) {
		return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
	}
	function escapeProperty(s) {
		return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
	}
}));
var require_file_command = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.issueFileCommand = issueFileCommand;
	exports.prepareKeyValueMessage = prepareKeyValueMessage;
	var crypto = __importStar(__require("crypto"));
	var fs$2 = __importStar(__require("fs"));
	var os$3 = __importStar(__require("os"));
	var utils_1 = require_utils$1();
	function issueFileCommand(command, message) {
		const filePath = process.env[`GITHUB_${command}`];
		if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);
		if (!fs$2.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);
		fs$2.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os$3.EOL}`, { encoding: "utf8" });
	}
	function prepareKeyValueMessage(key, value$2) {
		const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
		const convertedValue = (0, utils_1.toCommandValue)(value$2);
		if (key.includes(delimiter)) throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
		if (convertedValue.includes(delimiter)) throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
		return `${key}<<${delimiter}${os$3.EOL}${convertedValue}${os$3.EOL}${delimiter}`;
	}
}));
var require_proxy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getProxyUrl = getProxyUrl;
	exports.checkBypass = checkBypass;
	function getProxyUrl(reqUrl) {
		const usingSsl = reqUrl.protocol === "https:";
		if (checkBypass(reqUrl)) return;
		const proxyVar = (() => {
			if (usingSsl) return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
			else return process.env["http_proxy"] || process.env["HTTP_PROXY"];
		})();
		if (proxyVar) try {
			return new DecodedURL(proxyVar);
		} catch (_a) {
			if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://")) return new DecodedURL(`http://${proxyVar}`);
		}
		else return;
	}
	function checkBypass(reqUrl) {
		if (!reqUrl.hostname) return false;
		const reqHost = reqUrl.hostname;
		if (isLoopbackAddress(reqHost)) return true;
		const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
		if (!noProxy) return false;
		let reqPort;
		if (reqUrl.port) reqPort = Number(reqUrl.port);
		else if (reqUrl.protocol === "http:") reqPort = 80;
		else if (reqUrl.protocol === "https:") reqPort = 443;
		const upperReqHosts = [reqUrl.hostname.toUpperCase()];
		if (typeof reqPort === "number") upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
		for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) return true;
		return false;
	}
	function isLoopbackAddress(host) {
		const hostLower = host.toLowerCase();
		return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
	}
	var DecodedURL = class extends URL {
		constructor(url$2, base) {
			super(url$2, base);
			this._decodedUsername = decodeURIComponent(super.username);
			this._decodedPassword = decodeURIComponent(super.password);
		}
		get username() {
			return this._decodedUsername;
		}
		get password() {
			return this._decodedPassword;
		}
	};
}));
var require_tunnel$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	__require("net");
	var tls = __require("tls");
	var http$2 = __require("http");
	var https$1 = __require("https");
	var events$1 = __require("events");
	__require("assert");
	var util$1 = __require("util");
	exports.httpOverHttp = httpOverHttp;
	exports.httpsOverHttp = httpsOverHttp;
	exports.httpOverHttps = httpOverHttps;
	exports.httpsOverHttps = httpsOverHttps;
	function httpOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$2.request;
		return agent;
	}
	function httpsOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$2.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function httpOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$1.request;
		return agent;
	}
	function httpsOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$1.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function TunnelingAgent(options) {
		var self = this;
		self.options = options || {};
		self.proxyOptions = self.options.proxy || {};
		self.maxSockets = self.options.maxSockets || http$2.Agent.defaultMaxSockets;
		self.requests = [];
		self.sockets = [];
		self.on("free", function onFree(socket, host, port$2, localAddress) {
			var options$1 = toOptions(host, port$2, localAddress);
			for (var i = 0, len = self.requests.length; i < len; ++i) {
				var pending$2 = self.requests[i];
				if (pending$2.host === options$1.host && pending$2.port === options$1.port) {
					self.requests.splice(i, 1);
					pending$2.request.onSocket(socket);
					return;
				}
			}
			socket.destroy();
			self.removeSocket(socket);
		});
	}
	util$1.inherits(TunnelingAgent, events$1.EventEmitter);
	TunnelingAgent.prototype.addRequest = function addRequest(req, host, port$2, localAddress) {
		var self = this;
		var options = mergeOptions({ request: req }, self.options, toOptions(host, port$2, localAddress));
		if (self.sockets.length >= this.maxSockets) {
			self.requests.push(options);
			return;
		}
		self.createSocket(options, function(socket) {
			socket.on("free", onFree);
			socket.on("close", onCloseOrRemove);
			socket.on("agentRemove", onCloseOrRemove);
			req.onSocket(socket);
			function onFree() {
				self.emit("free", socket, options);
			}
			function onCloseOrRemove(err) {
				self.removeSocket(socket);
				socket.removeListener("free", onFree);
				socket.removeListener("close", onCloseOrRemove);
				socket.removeListener("agentRemove", onCloseOrRemove);
			}
		});
	};
	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
		var self = this;
		var placeholder = {};
		self.sockets.push(placeholder);
		var connectOptions = mergeOptions({}, self.proxyOptions, {
			method: "CONNECT",
			path: options.host + ":" + options.port,
			agent: false,
			headers: { host: options.host + ":" + options.port }
		});
		if (options.localAddress) connectOptions.localAddress = options.localAddress;
		if (connectOptions.proxyAuth) {
			connectOptions.headers = connectOptions.headers || {};
			connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
		}
		debug("making CONNECT request");
		var connectReq = self.request(connectOptions);
		connectReq.useChunkedEncodingByDefault = false;
		connectReq.once("response", onResponse);
		connectReq.once("upgrade", onUpgrade);
		connectReq.once("connect", onConnect);
		connectReq.once("error", onError$2);
		connectReq.end();
		function onResponse(res) {
			res.upgrade = true;
		}
		function onUpgrade(res, socket, head$4) {
			process.nextTick(function() {
				onConnect(res, socket, head$4);
			});
		}
		function onConnect(res, socket, head$4) {
			connectReq.removeAllListeners();
			socket.removeAllListeners();
			if (res.statusCode !== 200) {
				debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
				socket.destroy();
				var error = /* @__PURE__ */ new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
				error.code = "ECONNRESET";
				options.request.emit("error", error);
				self.removeSocket(placeholder);
				return;
			}
			if (head$4.length > 0) {
				debug("got illegal response body from proxy");
				socket.destroy();
				var error = /* @__PURE__ */ new Error("got illegal response body from proxy");
				error.code = "ECONNRESET";
				options.request.emit("error", error);
				self.removeSocket(placeholder);
				return;
			}
			debug("tunneling connection has established");
			self.sockets[self.sockets.indexOf(placeholder)] = socket;
			return cb(socket);
		}
		function onError$2(cause$2) {
			connectReq.removeAllListeners();
			debug("tunneling socket could not be established, cause=%s\n", cause$2.message, cause$2.stack);
			var error = /* @__PURE__ */ new Error("tunneling socket could not be established, cause=" + cause$2.message);
			error.code = "ECONNRESET";
			options.request.emit("error", error);
			self.removeSocket(placeholder);
		}
	};
	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
		var pos = this.sockets.indexOf(socket);
		if (pos === -1) return;
		this.sockets.splice(pos, 1);
		var pending$2 = this.requests.shift();
		if (pending$2) this.createSocket(pending$2, function(socket$1) {
			pending$2.request.onSocket(socket$1);
		});
	};
	function createSecureSocket(options, cb) {
		var self = this;
		TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
			var hostHeader = options.request.getHeader("host");
			var tlsOptions = mergeOptions({}, self.options, {
				socket,
				servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
			});
			var secureSocket = tls.connect(0, tlsOptions);
			self.sockets[self.sockets.indexOf(socket)] = secureSocket;
			cb(secureSocket);
		});
	}
	function toOptions(host, port$2, localAddress) {
		if (typeof host === "string") return {
			host,
			port: port$2,
			localAddress
		};
		return host;
	}
	function mergeOptions(target) {
		for (var i = 1, len = arguments.length; i < len; ++i) {
			var overrides = arguments[i];
			if (typeof overrides === "object") {
				var keys$5 = Object.keys(overrides);
				for (var j = 0, keyLen = keys$5.length; j < keyLen; ++j) {
					var k = keys$5[j];
					if (overrides[k] !== void 0) target[k] = overrides[k];
				}
			}
		}
		return target;
	}
	var debug;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) debug = function() {
		var args$1 = Array.prototype.slice.call(arguments);
		if (typeof args$1[0] === "string") args$1[0] = "TUNNEL: " + args$1[0];
		else args$1.unshift("TUNNEL:");
		console.error.apply(console, args$1);
	};
	else debug = function() {};
	exports.debug = debug;
}));
var require_tunnel = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_tunnel$1();
}));
var require_symbols$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kClose: Symbol("close"),
		kDestroy: Symbol("destroy"),
		kDispatch: Symbol("dispatch"),
		kUrl: Symbol("url"),
		kWriting: Symbol("writing"),
		kResuming: Symbol("resuming"),
		kQueue: Symbol("queue"),
		kConnect: Symbol("connect"),
		kConnecting: Symbol("connecting"),
		kHeadersList: Symbol("headers list"),
		kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
		kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
		kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
		kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
		kKeepAlive: Symbol("keep alive"),
		kHeadersTimeout: Symbol("headers timeout"),
		kBodyTimeout: Symbol("body timeout"),
		kServerName: Symbol("server name"),
		kLocalAddress: Symbol("local address"),
		kHost: Symbol("host"),
		kNoRef: Symbol("no ref"),
		kBodyUsed: Symbol("used"),
		kRunning: Symbol("running"),
		kBlocking: Symbol("blocking"),
		kPending: Symbol("pending"),
		kSize: Symbol("size"),
		kBusy: Symbol("busy"),
		kQueued: Symbol("queued"),
		kFree: Symbol("free"),
		kConnected: Symbol("connected"),
		kClosed: Symbol("closed"),
		kNeedDrain: Symbol("need drain"),
		kReset: Symbol("reset"),
		kDestroyed: Symbol.for("nodejs.stream.destroyed"),
		kMaxHeadersSize: Symbol("max headers size"),
		kRunningIdx: Symbol("running index"),
		kPendingIdx: Symbol("pending index"),
		kError: Symbol("error"),
		kClients: Symbol("clients"),
		kClient: Symbol("client"),
		kParser: Symbol("parser"),
		kOnDestroyed: Symbol("destroy callbacks"),
		kPipelining: Symbol("pipelining"),
		kSocket: Symbol("socket"),
		kHostHeader: Symbol("host header"),
		kConnector: Symbol("connector"),
		kStrictContentLength: Symbol("strict content length"),
		kMaxRedirections: Symbol("maxRedirections"),
		kMaxRequests: Symbol("maxRequestsPerClient"),
		kProxy: Symbol("proxy agent options"),
		kCounter: Symbol("socket request counter"),
		kInterceptors: Symbol("dispatch interceptors"),
		kMaxResponseSize: Symbol("max response size"),
		kHTTP2Session: Symbol("http2Session"),
		kHTTP2SessionState: Symbol("http2Session state"),
		kHTTP2BuildRequest: Symbol("http2 build request"),
		kHTTP1BuildRequest: Symbol("http1 build request"),
		kHTTP2CopyHeaders: Symbol("http2 copy headers"),
		kHTTPConnVersion: Symbol("http connection version"),
		kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
		kConstruct: Symbol("constructable")
	};
}));
var require_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var UndiciError = class extends Error {
		constructor(message) {
			super(message);
			this.name = "UndiciError";
			this.code = "UND_ERR";
		}
	};
	var ConnectTimeoutError = class ConnectTimeoutError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ConnectTimeoutError);
			this.name = "ConnectTimeoutError";
			this.message = message || "Connect Timeout Error";
			this.code = "UND_ERR_CONNECT_TIMEOUT";
		}
	};
	var HeadersTimeoutError = class HeadersTimeoutError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersTimeoutError);
			this.name = "HeadersTimeoutError";
			this.message = message || "Headers Timeout Error";
			this.code = "UND_ERR_HEADERS_TIMEOUT";
		}
	};
	var HeadersOverflowError = class HeadersOverflowError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersOverflowError);
			this.name = "HeadersOverflowError";
			this.message = message || "Headers Overflow Error";
			this.code = "UND_ERR_HEADERS_OVERFLOW";
		}
	};
	var BodyTimeoutError = class BodyTimeoutError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, BodyTimeoutError);
			this.name = "BodyTimeoutError";
			this.message = message || "Body Timeout Error";
			this.code = "UND_ERR_BODY_TIMEOUT";
		}
	};
	var ResponseStatusCodeError = class ResponseStatusCodeError extends UndiciError {
		constructor(message, statusCode, headers, body) {
			super(message);
			Error.captureStackTrace(this, ResponseStatusCodeError);
			this.name = "ResponseStatusCodeError";
			this.message = message || "Response Status Code Error";
			this.code = "UND_ERR_RESPONSE_STATUS_CODE";
			this.body = body;
			this.status = statusCode;
			this.statusCode = statusCode;
			this.headers = headers;
		}
	};
	var InvalidArgumentError = class InvalidArgumentError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidArgumentError);
			this.name = "InvalidArgumentError";
			this.message = message || "Invalid Argument Error";
			this.code = "UND_ERR_INVALID_ARG";
		}
	};
	var InvalidReturnValueError = class InvalidReturnValueError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidReturnValueError);
			this.name = "InvalidReturnValueError";
			this.message = message || "Invalid Return Value Error";
			this.code = "UND_ERR_INVALID_RETURN_VALUE";
		}
	};
	var RequestAbortedError = class RequestAbortedError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestAbortedError);
			this.name = "AbortError";
			this.message = message || "Request aborted";
			this.code = "UND_ERR_ABORTED";
		}
	};
	var InformationalError = class InformationalError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InformationalError);
			this.name = "InformationalError";
			this.message = message || "Request information";
			this.code = "UND_ERR_INFO";
		}
	};
	var RequestContentLengthMismatchError = class RequestContentLengthMismatchError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestContentLengthMismatchError);
			this.name = "RequestContentLengthMismatchError";
			this.message = message || "Request body length does not match content-length header";
			this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ResponseContentLengthMismatchError = class ResponseContentLengthMismatchError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseContentLengthMismatchError);
			this.name = "ResponseContentLengthMismatchError";
			this.message = message || "Response body length does not match content-length header";
			this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ClientDestroyedError = class ClientDestroyedError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientDestroyedError);
			this.name = "ClientDestroyedError";
			this.message = message || "The client is destroyed";
			this.code = "UND_ERR_DESTROYED";
		}
	};
	var ClientClosedError = class ClientClosedError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientClosedError);
			this.name = "ClientClosedError";
			this.message = message || "The client is closed";
			this.code = "UND_ERR_CLOSED";
		}
	};
	var SocketError = class SocketError extends UndiciError {
		constructor(message, socket) {
			super(message);
			Error.captureStackTrace(this, SocketError);
			this.name = "SocketError";
			this.message = message || "Socket error";
			this.code = "UND_ERR_SOCKET";
			this.socket = socket;
		}
	};
	var NotSupportedError = class NotSupportedError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError);
			this.name = "NotSupportedError";
			this.message = message || "Not supported error";
			this.code = "UND_ERR_NOT_SUPPORTED";
		}
	};
	var BalancedPoolMissingUpstreamError = class extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError);
			this.name = "MissingUpstreamError";
			this.message = message || "No upstream has been added to the BalancedPool";
			this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
		}
	};
	module.exports = {
		HTTPParserError: class HTTPParserError extends Error {
			constructor(message, code, data) {
				super(message);
				Error.captureStackTrace(this, HTTPParserError);
				this.name = "HTTPParserError";
				this.code = code ? `HPE_${code}` : void 0;
				this.data = data ? data.toString() : void 0;
			}
		},
		UndiciError,
		HeadersTimeoutError,
		HeadersOverflowError,
		BodyTimeoutError,
		RequestContentLengthMismatchError,
		ConnectTimeoutError,
		ResponseStatusCodeError,
		InvalidArgumentError,
		InvalidReturnValueError,
		RequestAbortedError,
		ClientDestroyedError,
		ClientClosedError,
		InformationalError,
		SocketError,
		NotSupportedError,
		ResponseContentLengthMismatchError,
		BalancedPoolMissingUpstreamError,
		ResponseExceededMaxSizeError: class ResponseExceededMaxSizeError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, ResponseExceededMaxSizeError);
				this.name = "ResponseExceededMaxSizeError";
				this.message = message || "Response content exceeded max size";
				this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
			}
		},
		RequestRetryError: class RequestRetryError extends UndiciError {
			constructor(message, code, { headers, data }) {
				super(message);
				Error.captureStackTrace(this, RequestRetryError);
				this.name = "RequestRetryError";
				this.message = message || "Request retry error";
				this.code = "UND_ERR_REQ_RETRY";
				this.statusCode = code;
				this.data = data;
				this.headers = headers;
			}
		}
	};
}));
var require_constants$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var headerNameLowerCasedRecord = {};
	var wellknownHeaderNames = [
		"Accept",
		"Accept-Encoding",
		"Accept-Language",
		"Accept-Ranges",
		"Access-Control-Allow-Credentials",
		"Access-Control-Allow-Headers",
		"Access-Control-Allow-Methods",
		"Access-Control-Allow-Origin",
		"Access-Control-Expose-Headers",
		"Access-Control-Max-Age",
		"Access-Control-Request-Headers",
		"Access-Control-Request-Method",
		"Age",
		"Allow",
		"Alt-Svc",
		"Alt-Used",
		"Authorization",
		"Cache-Control",
		"Clear-Site-Data",
		"Connection",
		"Content-Disposition",
		"Content-Encoding",
		"Content-Language",
		"Content-Length",
		"Content-Location",
		"Content-Range",
		"Content-Security-Policy",
		"Content-Security-Policy-Report-Only",
		"Content-Type",
		"Cookie",
		"Cross-Origin-Embedder-Policy",
		"Cross-Origin-Opener-Policy",
		"Cross-Origin-Resource-Policy",
		"Date",
		"Device-Memory",
		"Downlink",
		"ECT",
		"ETag",
		"Expect",
		"Expect-CT",
		"Expires",
		"Forwarded",
		"From",
		"Host",
		"If-Match",
		"If-Modified-Since",
		"If-None-Match",
		"If-Range",
		"If-Unmodified-Since",
		"Keep-Alive",
		"Last-Modified",
		"Link",
		"Location",
		"Max-Forwards",
		"Origin",
		"Permissions-Policy",
		"Pragma",
		"Proxy-Authenticate",
		"Proxy-Authorization",
		"RTT",
		"Range",
		"Referer",
		"Referrer-Policy",
		"Refresh",
		"Retry-After",
		"Sec-WebSocket-Accept",
		"Sec-WebSocket-Extensions",
		"Sec-WebSocket-Key",
		"Sec-WebSocket-Protocol",
		"Sec-WebSocket-Version",
		"Server",
		"Server-Timing",
		"Service-Worker-Allowed",
		"Service-Worker-Navigation-Preload",
		"Set-Cookie",
		"SourceMap",
		"Strict-Transport-Security",
		"Supports-Loading-Mode",
		"TE",
		"Timing-Allow-Origin",
		"Trailer",
		"Transfer-Encoding",
		"Upgrade",
		"Upgrade-Insecure-Requests",
		"User-Agent",
		"Vary",
		"Via",
		"WWW-Authenticate",
		"X-Content-Type-Options",
		"X-DNS-Prefetch-Control",
		"X-Frame-Options",
		"X-Permitted-Cross-Domain-Policies",
		"X-Powered-By",
		"X-Requested-With",
		"X-XSS-Protection"
	];
	for (let i = 0; i < wellknownHeaderNames.length; ++i) {
		const key = wellknownHeaderNames[i];
		const lowerCasedKey = key.toLowerCase();
		headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
	}
	Object.setPrototypeOf(headerNameLowerCasedRecord, null);
	module.exports = {
		wellknownHeaderNames,
		headerNameLowerCasedRecord
	};
}));
var require_util$6 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert$19 = __require("assert");
	var { kDestroyed, kBodyUsed } = require_symbols$4();
	var { IncomingMessage } = __require("http");
	var stream = __require("stream");
	var net$2 = __require("net");
	var { InvalidArgumentError } = require_errors();
	var { Blob: Blob$4 } = __require("buffer");
	var nodeUtil = __require("util");
	var { stringify } = __require("querystring");
	var { headerNameLowerCasedRecord } = require_constants$4();
	var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
	function nop() {}
	function isStream(obj) {
		return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
	}
	function isBlobLike(object) {
		return Blob$4 && object instanceof Blob$4 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
	}
	function buildURL(url$2, queryParams) {
		if (url$2.includes("?") || url$2.includes("#")) throw new Error("Query params cannot be passed when url already contains \"?\" or \"#\".");
		const stringified = stringify(queryParams);
		if (stringified) url$2 += "?" + stringified;
		return url$2;
	}
	function parseURL(url$2) {
		if (typeof url$2 === "string") {
			url$2 = new URL(url$2);
			if (!/^https?:/.test(url$2.origin || url$2.protocol)) throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
			return url$2;
		}
		if (!url$2 || typeof url$2 !== "object") throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
		if (!/^https?:/.test(url$2.origin || url$2.protocol)) throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
		if (!(url$2 instanceof URL)) {
			if (url$2.port != null && url$2.port !== "" && !Number.isFinite(parseInt(url$2.port))) throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
			if (url$2.path != null && typeof url$2.path !== "string") throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
			if (url$2.pathname != null && typeof url$2.pathname !== "string") throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
			if (url$2.hostname != null && typeof url$2.hostname !== "string") throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
			if (url$2.origin != null && typeof url$2.origin !== "string") throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
			const port$2 = url$2.port != null ? url$2.port : url$2.protocol === "https:" ? 443 : 80;
			let origin = url$2.origin != null ? url$2.origin : `${url$2.protocol}//${url$2.hostname}:${port$2}`;
			let path$5 = url$2.path != null ? url$2.path : `${url$2.pathname || ""}${url$2.search || ""}`;
			if (origin.endsWith("/")) origin = origin.substring(0, origin.length - 1);
			if (path$5 && !path$5.startsWith("/")) path$5 = `/${path$5}`;
			url$2 = new URL(origin + path$5);
		}
		return url$2;
	}
	function parseOrigin(url$2) {
		url$2 = parseURL(url$2);
		if (url$2.pathname !== "/" || url$2.search || url$2.hash) throw new InvalidArgumentError("invalid url");
		return url$2;
	}
	function getHostname(host) {
		if (host[0] === "[") {
			const idx$1 = host.indexOf("]");
			assert$19(idx$1 !== -1);
			return host.substring(1, idx$1);
		}
		const idx = host.indexOf(":");
		if (idx === -1) return host;
		return host.substring(0, idx);
	}
	function getServerName(host) {
		if (!host) return null;
		assert$19.strictEqual(typeof host, "string");
		const servername = getHostname(host);
		if (net$2.isIP(servername)) return "";
		return servername;
	}
	function deepClone(obj) {
		return JSON.parse(JSON.stringify(obj));
	}
	function isAsyncIterable(obj) {
		return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
	}
	function isIterable(obj) {
		return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
	}
	function bodyLength(body) {
		if (body == null) return 0;
		else if (isStream(body)) {
			const state = body._readableState;
			return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
		} else if (isBlobLike(body)) return body.size != null ? body.size : null;
		else if (isBuffer(body)) return body.byteLength;
		return null;
	}
	function isDestroyed(stream$1) {
		return !stream$1 || !!(stream$1.destroyed || stream$1[kDestroyed]);
	}
	function isReadableAborted(stream$1) {
		const state = stream$1 && stream$1._readableState;
		return isDestroyed(stream$1) && state && !state.endEmitted;
	}
	function destroy(stream$1, err) {
		if (stream$1 == null || !isStream(stream$1) || isDestroyed(stream$1)) return;
		if (typeof stream$1.destroy === "function") {
			if (Object.getPrototypeOf(stream$1).constructor === IncomingMessage) stream$1.socket = null;
			stream$1.destroy(err);
		} else if (err) process.nextTick((stream$2, err$1) => {
			stream$2.emit("error", err$1);
		}, stream$1, err);
		if (stream$1.destroyed !== true) stream$1[kDestroyed] = true;
	}
	var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
	function parseKeepAliveTimeout(val) {
		const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
		return m ? parseInt(m[1], 10) * 1e3 : null;
	}
	function headerNameToString(value$2) {
		return headerNameLowerCasedRecord[value$2] || value$2.toLowerCase();
	}
	function parseHeaders(headers, obj = {}) {
		if (!Array.isArray(headers)) return headers;
		for (let i = 0; i < headers.length; i += 2) {
			const key = headers[i].toString().toLowerCase();
			let val = obj[key];
			if (!val) if (Array.isArray(headers[i + 1])) obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
			else obj[key] = headers[i + 1].toString("utf8");
			else {
				if (!Array.isArray(val)) {
					val = [val];
					obj[key] = val;
				}
				val.push(headers[i + 1].toString("utf8"));
			}
		}
		if ("content-length" in obj && "content-disposition" in obj) obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
		return obj;
	}
	function parseRawHeaders(headers) {
		const ret = [];
		let hasContentLength = false;
		let contentDispositionIdx = -1;
		for (let n = 0; n < headers.length; n += 2) {
			const key = headers[n + 0].toString();
			const val = headers[n + 1].toString("utf8");
			if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
				ret.push(key, val);
				hasContentLength = true;
			} else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) contentDispositionIdx = ret.push(key, val) - 1;
			else ret.push(key, val);
		}
		if (hasContentLength && contentDispositionIdx !== -1) ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
		return ret;
	}
	function isBuffer(buffer) {
		return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
	}
	function validateHandler(handler, method, upgrade) {
		if (!handler || typeof handler !== "object") throw new InvalidArgumentError("handler must be an object");
		if (typeof handler.onConnect !== "function") throw new InvalidArgumentError("invalid onConnect method");
		if (typeof handler.onError !== "function") throw new InvalidArgumentError("invalid onError method");
		if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) throw new InvalidArgumentError("invalid onBodySent method");
		if (upgrade || method === "CONNECT") {
			if (typeof handler.onUpgrade !== "function") throw new InvalidArgumentError("invalid onUpgrade method");
		} else {
			if (typeof handler.onHeaders !== "function") throw new InvalidArgumentError("invalid onHeaders method");
			if (typeof handler.onData !== "function") throw new InvalidArgumentError("invalid onData method");
			if (typeof handler.onComplete !== "function") throw new InvalidArgumentError("invalid onComplete method");
		}
	}
	function isDisturbed(body) {
		return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
	}
	function isErrored(body) {
		return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
	}
	function isReadable(body) {
		return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
	}
	function getSocketInfo(socket) {
		return {
			localAddress: socket.localAddress,
			localPort: socket.localPort,
			remoteAddress: socket.remoteAddress,
			remotePort: socket.remotePort,
			remoteFamily: socket.remoteFamily,
			timeout: socket.timeout,
			bytesWritten: socket.bytesWritten,
			bytesRead: socket.bytesRead
		};
	}
	async function* convertIterableToBuffer(iterable) {
		for await (const chunk$4 of iterable) yield Buffer.isBuffer(chunk$4) ? chunk$4 : Buffer.from(chunk$4);
	}
	var ReadableStream;
	function ReadableStreamFrom(iterable) {
		if (!ReadableStream) ReadableStream = __require("stream/web").ReadableStream;
		if (ReadableStream.from) return ReadableStream.from(convertIterableToBuffer(iterable));
		let iterator;
		return new ReadableStream({
			async start() {
				iterator = iterable[Symbol.asyncIterator]();
			},
			async pull(controller) {
				const { done: done$8, value: value$2 } = await iterator.next();
				if (done$8) queueMicrotask(() => {
					controller.close();
				});
				else {
					const buf = Buffer.isBuffer(value$2) ? value$2 : Buffer.from(value$2);
					controller.enqueue(new Uint8Array(buf));
				}
				return controller.desiredSize > 0;
			},
			async cancel(reason) {
				await iterator.return();
			}
		}, 0);
	}
	function isFormDataLike(object) {
		return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
	}
	function throwIfAborted(signal) {
		if (!signal) return;
		if (typeof signal.throwIfAborted === "function") signal.throwIfAborted();
		else if (signal.aborted) {
			const err = /* @__PURE__ */ new Error("The operation was aborted");
			err.name = "AbortError";
			throw err;
		}
	}
	function addAbortListener(signal, listener) {
		if ("addEventListener" in signal) {
			signal.addEventListener("abort", listener, { once: true });
			return () => signal.removeEventListener("abort", listener);
		}
		signal.addListener("abort", listener);
		return () => signal.removeListener("abort", listener);
	}
	var hasToWellFormed = !!String.prototype.toWellFormed;
	function toUSVString(val) {
		if (hasToWellFormed) return `${val}`.toWellFormed();
		else if (nodeUtil.toUSVString) return nodeUtil.toUSVString(val);
		return `${val}`;
	}
	function parseRangeHeader(range) {
		if (range == null || range === "") return {
			start: 0,
			end: null,
			size: null
		};
		const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
		return m ? {
			start: parseInt(m[1]),
			end: m[2] ? parseInt(m[2]) : null,
			size: m[3] ? parseInt(m[3]) : null
		} : null;
	}
	var kEnumerableProperty = Object.create(null);
	kEnumerableProperty.enumerable = true;
	module.exports = {
		kEnumerableProperty,
		nop,
		isDisturbed,
		isErrored,
		isReadable,
		toUSVString,
		isReadableAborted,
		isBlobLike,
		parseOrigin,
		parseURL,
		getServerName,
		isStream,
		isIterable,
		isAsyncIterable,
		isDestroyed,
		headerNameToString,
		parseRawHeaders,
		parseHeaders,
		parseKeepAliveTimeout,
		destroy,
		bodyLength,
		deepClone,
		ReadableStreamFrom,
		isBuffer,
		validateHandler,
		getSocketInfo,
		isFormDataLike,
		buildURL,
		throwIfAborted,
		addAbortListener,
		parseRangeHeader,
		nodeMajor,
		nodeMinor,
		nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
		safeHTTPMethods: [
			"GET",
			"HEAD",
			"OPTIONS",
			"TRACE"
		]
	};
}));
var require_timers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var fastNow = Date.now();
	var fastNowTimeout;
	var fastTimers = [];
	function onTimeout() {
		fastNow = Date.now();
		let len = fastTimers.length;
		let idx = 0;
		while (idx < len) {
			const timer = fastTimers[idx];
			if (timer.state === 0) timer.state = fastNow + timer.delay;
			else if (timer.state > 0 && fastNow >= timer.state) {
				timer.state = -1;
				timer.callback(timer.opaque);
			}
			if (timer.state === -1) {
				timer.state = -2;
				if (idx !== len - 1) fastTimers[idx] = fastTimers.pop();
				else fastTimers.pop();
				len -= 1;
			} else idx += 1;
		}
		if (fastTimers.length > 0) refreshTimeout();
	}
	function refreshTimeout() {
		if (fastNowTimeout && fastNowTimeout.refresh) fastNowTimeout.refresh();
		else {
			clearTimeout(fastNowTimeout);
			fastNowTimeout = setTimeout(onTimeout, 1e3);
			if (fastNowTimeout.unref) fastNowTimeout.unref();
		}
	}
	var Timeout = class {
		constructor(callback, delay$2, opaque) {
			this.callback = callback;
			this.delay = delay$2;
			this.opaque = opaque;
			this.state = -2;
			this.refresh();
		}
		refresh() {
			if (this.state === -2) {
				fastTimers.push(this);
				if (!fastNowTimeout || fastTimers.length === 1) refreshTimeout();
			}
			this.state = 0;
		}
		clear() {
			this.state = -1;
		}
	};
	module.exports = {
		setTimeout(callback, delay$2, opaque) {
			return delay$2 < 1e3 ? setTimeout(callback, delay$2, opaque) : new Timeout(callback, delay$2, opaque);
		},
		clearTimeout(timeout$2) {
			if (timeout$2 instanceof Timeout) timeout$2.clear();
			else clearTimeout(timeout$2);
		}
	};
}));
var require_sbmh = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var EventEmitter$2 = __require("node:events").EventEmitter;
	var inherits$5 = __require("node:util").inherits;
	function SBMH(needle) {
		if (typeof needle === "string") needle = Buffer.from(needle);
		if (!Buffer.isBuffer(needle)) throw new TypeError("The needle has to be a String or a Buffer.");
		const needleLength = needle.length;
		if (needleLength === 0) throw new Error("The needle cannot be an empty String/Buffer.");
		if (needleLength > 256) throw new Error("The needle cannot have a length bigger than 256.");
		this.maxMatches = Infinity;
		this.matches = 0;
		this._occ = new Array(256).fill(needleLength);
		this._lookbehind_size = 0;
		this._needle = needle;
		this._bufpos = 0;
		this._lookbehind = Buffer.alloc(needleLength);
		for (var i = 0; i < needleLength - 1; ++i) this._occ[needle[i]] = needleLength - 1 - i;
	}
	inherits$5(SBMH, EventEmitter$2);
	SBMH.prototype.reset = function() {
		this._lookbehind_size = 0;
		this.matches = 0;
		this._bufpos = 0;
	};
	SBMH.prototype.push = function(chunk$4, pos) {
		if (!Buffer.isBuffer(chunk$4)) chunk$4 = Buffer.from(chunk$4, "binary");
		const chlen = chunk$4.length;
		this._bufpos = pos || 0;
		let r;
		while (r !== chlen && this.matches < this.maxMatches) r = this._sbmh_feed(chunk$4);
		return r;
	};
	SBMH.prototype._sbmh_feed = function(data) {
		const len = data.length;
		const needle = this._needle;
		const needleLength = needle.length;
		const lastNeedleChar = needle[needleLength - 1];
		let pos = -this._lookbehind_size;
		let ch;
		if (pos < 0) {
			while (pos < 0 && pos <= len - needleLength) {
				ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
				if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
					this._lookbehind_size = 0;
					++this.matches;
					this.emit("info", true);
					return this._bufpos = pos + needleLength;
				}
				pos += this._occ[ch];
			}
			if (pos < 0) while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) ++pos;
			if (pos >= 0) {
				this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
				this._lookbehind_size = 0;
			} else {
				const bytesToCutOff = this._lookbehind_size + pos;
				if (bytesToCutOff > 0) this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
				this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
				this._lookbehind_size -= bytesToCutOff;
				data.copy(this._lookbehind, this._lookbehind_size);
				this._lookbehind_size += len;
				this._bufpos = len;
				return len;
			}
		}
		pos += (pos >= 0) * this._bufpos;
		if (data.indexOf(needle, pos) !== -1) {
			pos = data.indexOf(needle, pos);
			++this.matches;
			if (pos > 0) this.emit("info", true, data, this._bufpos, pos);
			else this.emit("info", true);
			return this._bufpos = pos + needleLength;
		} else pos = len - needleLength;
		while (pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)) ++pos;
		if (pos < len) {
			data.copy(this._lookbehind, 0, pos, pos + (len - pos));
			this._lookbehind_size = len - pos;
		}
		if (pos > 0) this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
		this._bufpos = len;
		return len;
	};
	SBMH.prototype._sbmh_lookup_char = function(data, pos) {
		return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
	};
	SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
		for (var i = 0; i < len; ++i) if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) return false;
		return true;
	};
	module.exports = SBMH;
}));
var require_PartStream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var inherits$4 = __require("node:util").inherits;
	var ReadableStream$1 = __require("node:stream").Readable;
	function PartStream(opts) {
		ReadableStream$1.call(this, opts);
	}
	inherits$4(PartStream, ReadableStream$1);
	PartStream.prototype._read = function(n) {};
	module.exports = PartStream;
}));
var require_getLimit = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function getLimit(limits, name, defaultLimit) {
		if (!limits || limits[name] === void 0 || limits[name] === null) return defaultLimit;
		if (typeof limits[name] !== "number" || isNaN(limits[name])) throw new TypeError("Limit " + name + " is not a valid number");
		return limits[name];
	};
}));
var require_HeaderParser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var EventEmitter$1 = __require("node:events").EventEmitter;
	var inherits$3 = __require("node:util").inherits;
	var getLimit = require_getLimit();
	var StreamSearch = require_sbmh();
	var B_DCRLF = Buffer.from("\r\n\r\n");
	var RE_CRLF = /\r\n/g;
	var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
	function HeaderParser(cfg) {
		EventEmitter$1.call(this);
		cfg = cfg || {};
		const self = this;
		this.nread = 0;
		this.maxed = false;
		this.npairs = 0;
		this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
		this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
		this.buffer = "";
		this.header = {};
		this.finished = false;
		this.ss = new StreamSearch(B_DCRLF);
		this.ss.on("info", function(isMatch, data, start$2, end$2) {
			if (data && !self.maxed) {
				if (self.nread + end$2 - start$2 >= self.maxHeaderSize) {
					end$2 = self.maxHeaderSize - self.nread + start$2;
					self.nread = self.maxHeaderSize;
					self.maxed = true;
				} else self.nread += end$2 - start$2;
				self.buffer += data.toString("binary", start$2, end$2);
			}
			if (isMatch) self._finish();
		});
	}
	inherits$3(HeaderParser, EventEmitter$1);
	HeaderParser.prototype.push = function(data) {
		const r = this.ss.push(data);
		if (this.finished) return r;
	};
	HeaderParser.prototype.reset = function() {
		this.finished = false;
		this.buffer = "";
		this.header = {};
		this.ss.reset();
	};
	HeaderParser.prototype._finish = function() {
		if (this.buffer) this._parseHeader();
		this.ss.matches = this.ss.maxMatches;
		const header = this.header;
		this.header = {};
		this.buffer = "";
		this.finished = true;
		this.nread = this.npairs = 0;
		this.maxed = false;
		this.emit("header", header);
	};
	HeaderParser.prototype._parseHeader = function() {
		if (this.npairs === this.maxHeaderPairs) return;
		const lines = this.buffer.split(RE_CRLF);
		const len = lines.length;
		let m, h;
		for (var i = 0; i < len; ++i) {
			if (lines[i].length === 0) continue;
			if (lines[i][0] === "	" || lines[i][0] === " ") {
				if (h) {
					this.header[h][this.header[h].length - 1] += lines[i];
					continue;
				}
			}
			const posColon = lines[i].indexOf(":");
			if (posColon === -1 || posColon === 0) return;
			m = RE_HDR.exec(lines[i]);
			h = m[1].toLowerCase();
			this.header[h] = this.header[h] || [];
			this.header[h].push(m[2] || "");
			if (++this.npairs === this.maxHeaderPairs) break;
		}
	};
	module.exports = HeaderParser;
}));
var require_Dicer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var WritableStream$1 = __require("node:stream").Writable;
	var inherits$2 = __require("node:util").inherits;
	var StreamSearch = require_sbmh();
	var PartStream = require_PartStream();
	var HeaderParser = require_HeaderParser();
	var DASH = 45;
	var B_ONEDASH = Buffer.from("-");
	var B_CRLF = Buffer.from("\r\n");
	var EMPTY_FN = function() {};
	function Dicer(cfg) {
		if (!(this instanceof Dicer)) return new Dicer(cfg);
		WritableStream$1.call(this, cfg);
		if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") throw new TypeError("Boundary required");
		if (typeof cfg.boundary === "string") this.setBoundary(cfg.boundary);
		else this._bparser = void 0;
		this._headerFirst = cfg.headerFirst;
		this._dashes = 0;
		this._parts = 0;
		this._finished = false;
		this._realFinish = false;
		this._isPreamble = true;
		this._justMatched = false;
		this._firstWrite = true;
		this._inHeader = true;
		this._part = void 0;
		this._cb = void 0;
		this._ignoreData = false;
		this._partOpts = { highWaterMark: cfg.partHwm };
		this._pause = false;
		const self = this;
		this._hparser = new HeaderParser(cfg);
		this._hparser.on("header", function(header) {
			self._inHeader = false;
			self._part.emit("header", header);
		});
	}
	inherits$2(Dicer, WritableStream$1);
	Dicer.prototype.emit = function(ev) {
		if (ev === "finish" && !this._realFinish) {
			if (!this._finished) {
				const self = this;
				process.nextTick(function() {
					self.emit("error", /* @__PURE__ */ new Error("Unexpected end of multipart data"));
					if (self._part && !self._ignoreData) {
						const type = self._isPreamble ? "Preamble" : "Part";
						self._part.emit("error", /* @__PURE__ */ new Error(type + " terminated early due to unexpected end of multipart data"));
						self._part.push(null);
						process.nextTick(function() {
							self._realFinish = true;
							self.emit("finish");
							self._realFinish = false;
						});
						return;
					}
					self._realFinish = true;
					self.emit("finish");
					self._realFinish = false;
				});
			}
		} else WritableStream$1.prototype.emit.apply(this, arguments);
	};
	Dicer.prototype._write = function(data, encoding, cb) {
		if (!this._hparser && !this._bparser) return cb();
		if (this._headerFirst && this._isPreamble) {
			if (!this._part) {
				this._part = new PartStream(this._partOpts);
				if (this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
				else this._ignore();
			}
			const r = this._hparser.push(data);
			if (!this._inHeader && r !== void 0 && r < data.length) data = data.slice(r);
			else return cb();
		}
		if (this._firstWrite) {
			this._bparser.push(B_CRLF);
			this._firstWrite = false;
		}
		this._bparser.push(data);
		if (this._pause) this._cb = cb;
		else cb();
	};
	Dicer.prototype.reset = function() {
		this._part = void 0;
		this._bparser = void 0;
		this._hparser = void 0;
	};
	Dicer.prototype.setBoundary = function(boundary) {
		const self = this;
		this._bparser = new StreamSearch("\r\n--" + boundary);
		this._bparser.on("info", function(isMatch, data, start$2, end$2) {
			self._oninfo(isMatch, data, start$2, end$2);
		});
	};
	Dicer.prototype._ignore = function() {
		if (this._part && !this._ignoreData) {
			this._ignoreData = true;
			this._part.on("error", EMPTY_FN);
			this._part.resume();
		}
	};
	Dicer.prototype._oninfo = function(isMatch, data, start$2, end$2) {
		let buf;
		const self = this;
		let i = 0;
		let r;
		let shouldWriteMore = true;
		if (!this._part && this._justMatched && data) {
			while (this._dashes < 2 && start$2 + i < end$2) if (data[start$2 + i] === DASH) {
				++i;
				++this._dashes;
			} else {
				if (this._dashes) buf = B_ONEDASH;
				this._dashes = 0;
				break;
			}
			if (this._dashes === 2) {
				if (start$2 + i < end$2 && this.listenerCount("trailer") !== 0) this.emit("trailer", data.slice(start$2 + i, end$2));
				this.reset();
				this._finished = true;
				if (self._parts === 0) {
					self._realFinish = true;
					self.emit("finish");
					self._realFinish = false;
				}
			}
			if (this._dashes) return;
		}
		if (this._justMatched) this._justMatched = false;
		if (!this._part) {
			this._part = new PartStream(this._partOpts);
			this._part._read = function(n) {
				self._unpause();
			};
			if (this._isPreamble && this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
			else if (this._isPreamble !== true && this.listenerCount("part") !== 0) this.emit("part", this._part);
			else this._ignore();
			if (!this._isPreamble) this._inHeader = true;
		}
		if (data && start$2 < end$2 && !this._ignoreData) {
			if (this._isPreamble || !this._inHeader) {
				if (buf) shouldWriteMore = this._part.push(buf);
				shouldWriteMore = this._part.push(data.slice(start$2, end$2));
				if (!shouldWriteMore) this._pause = true;
			} else if (!this._isPreamble && this._inHeader) {
				if (buf) this._hparser.push(buf);
				r = this._hparser.push(data.slice(start$2, end$2));
				if (!this._inHeader && r !== void 0 && r < end$2) this._oninfo(false, data, start$2 + r, end$2);
			}
		}
		if (isMatch) {
			this._hparser.reset();
			if (this._isPreamble) this._isPreamble = false;
			else if (start$2 !== end$2) {
				++this._parts;
				this._part.on("end", function() {
					if (--self._parts === 0) if (self._finished) {
						self._realFinish = true;
						self.emit("finish");
						self._realFinish = false;
					} else self._unpause();
				});
			}
			this._part.push(null);
			this._part = void 0;
			this._ignoreData = false;
			this._justMatched = true;
			this._dashes = 0;
		}
	};
	Dicer.prototype._unpause = function() {
		if (!this._pause) return;
		this._pause = false;
		if (this._cb) {
			const cb = this._cb;
			this._cb = void 0;
			cb();
		}
	};
	module.exports = Dicer;
}));
var require_decodeText = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var utf8Decoder = new TextDecoder("utf-8");
	var textDecoders = new Map([["utf-8", utf8Decoder], ["utf8", utf8Decoder]]);
	function getDecoder(charset) {
		let lc;
		while (true) switch (charset) {
			case "utf-8":
			case "utf8": return decoders.utf8;
			case "latin1":
			case "ascii":
			case "us-ascii":
			case "iso-8859-1":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "windows-1252":
			case "iso_8859-1:1987":
			case "cp1252":
			case "x-cp1252": return decoders.latin1;
			case "utf16le":
			case "utf-16le":
			case "ucs2":
			case "ucs-2": return decoders.utf16le;
			case "base64": return decoders.base64;
			default:
				if (lc === void 0) {
					lc = true;
					charset = charset.toLowerCase();
					continue;
				}
				return decoders.other.bind(charset);
		}
	}
	var decoders = {
		utf8: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.utf8Slice(0, data.length);
		},
		latin1: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") return data;
			return data.latin1Slice(0, data.length);
		},
		utf16le: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.ucs2Slice(0, data.length);
		},
		base64: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.base64Slice(0, data.length);
		},
		other: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			if (textDecoders.has(exports.toString())) try {
				return textDecoders.get(exports).decode(data);
			} catch {}
			return typeof data === "string" ? data : data.toString();
		}
	};
	function decodeText(text, sourceEncoding, destEncoding) {
		if (text) return getDecoder(destEncoding)(text, sourceEncoding);
		return text;
	}
	module.exports = decodeText;
}));
var require_parseParams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var decodeText = require_decodeText();
	var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
	var EncodedLookup = {
		"%00": "\0",
		"%01": "",
		"%02": "",
		"%03": "",
		"%04": "",
		"%05": "",
		"%06": "",
		"%07": "\x07",
		"%08": "\b",
		"%09": "	",
		"%0a": "\n",
		"%0A": "\n",
		"%0b": "\v",
		"%0B": "\v",
		"%0c": "\f",
		"%0C": "\f",
		"%0d": "\r",
		"%0D": "\r",
		"%0e": "",
		"%0E": "",
		"%0f": "",
		"%0F": "",
		"%10": "",
		"%11": "",
		"%12": "",
		"%13": "",
		"%14": "",
		"%15": "",
		"%16": "",
		"%17": "",
		"%18": "",
		"%19": "",
		"%1a": "",
		"%1A": "",
		"%1b": "\x1B",
		"%1B": "\x1B",
		"%1c": "",
		"%1C": "",
		"%1d": "",
		"%1D": "",
		"%1e": "",
		"%1E": "",
		"%1f": "",
		"%1F": "",
		"%20": " ",
		"%21": "!",
		"%22": "\"",
		"%23": "#",
		"%24": "$",
		"%25": "%",
		"%26": "&",
		"%27": "'",
		"%28": "(",
		"%29": ")",
		"%2a": "*",
		"%2A": "*",
		"%2b": "+",
		"%2B": "+",
		"%2c": ",",
		"%2C": ",",
		"%2d": "-",
		"%2D": "-",
		"%2e": ".",
		"%2E": ".",
		"%2f": "/",
		"%2F": "/",
		"%30": "0",
		"%31": "1",
		"%32": "2",
		"%33": "3",
		"%34": "4",
		"%35": "5",
		"%36": "6",
		"%37": "7",
		"%38": "8",
		"%39": "9",
		"%3a": ":",
		"%3A": ":",
		"%3b": ";",
		"%3B": ";",
		"%3c": "<",
		"%3C": "<",
		"%3d": "=",
		"%3D": "=",
		"%3e": ">",
		"%3E": ">",
		"%3f": "?",
		"%3F": "?",
		"%40": "@",
		"%41": "A",
		"%42": "B",
		"%43": "C",
		"%44": "D",
		"%45": "E",
		"%46": "F",
		"%47": "G",
		"%48": "H",
		"%49": "I",
		"%4a": "J",
		"%4A": "J",
		"%4b": "K",
		"%4B": "K",
		"%4c": "L",
		"%4C": "L",
		"%4d": "M",
		"%4D": "M",
		"%4e": "N",
		"%4E": "N",
		"%4f": "O",
		"%4F": "O",
		"%50": "P",
		"%51": "Q",
		"%52": "R",
		"%53": "S",
		"%54": "T",
		"%55": "U",
		"%56": "V",
		"%57": "W",
		"%58": "X",
		"%59": "Y",
		"%5a": "Z",
		"%5A": "Z",
		"%5b": "[",
		"%5B": "[",
		"%5c": "\\",
		"%5C": "\\",
		"%5d": "]",
		"%5D": "]",
		"%5e": "^",
		"%5E": "^",
		"%5f": "_",
		"%5F": "_",
		"%60": "`",
		"%61": "a",
		"%62": "b",
		"%63": "c",
		"%64": "d",
		"%65": "e",
		"%66": "f",
		"%67": "g",
		"%68": "h",
		"%69": "i",
		"%6a": "j",
		"%6A": "j",
		"%6b": "k",
		"%6B": "k",
		"%6c": "l",
		"%6C": "l",
		"%6d": "m",
		"%6D": "m",
		"%6e": "n",
		"%6E": "n",
		"%6f": "o",
		"%6F": "o",
		"%70": "p",
		"%71": "q",
		"%72": "r",
		"%73": "s",
		"%74": "t",
		"%75": "u",
		"%76": "v",
		"%77": "w",
		"%78": "x",
		"%79": "y",
		"%7a": "z",
		"%7A": "z",
		"%7b": "{",
		"%7B": "{",
		"%7c": "|",
		"%7C": "|",
		"%7d": "}",
		"%7D": "}",
		"%7e": "~",
		"%7E": "~",
		"%7f": "",
		"%7F": "",
		"%80": "",
		"%81": "",
		"%82": "",
		"%83": "",
		"%84": "",
		"%85": "",
		"%86": "",
		"%87": "",
		"%88": "",
		"%89": "",
		"%8a": "",
		"%8A": "",
		"%8b": "",
		"%8B": "",
		"%8c": "",
		"%8C": "",
		"%8d": "",
		"%8D": "",
		"%8e": "",
		"%8E": "",
		"%8f": "",
		"%8F": "",
		"%90": "",
		"%91": "",
		"%92": "",
		"%93": "",
		"%94": "",
		"%95": "",
		"%96": "",
		"%97": "",
		"%98": "",
		"%99": "",
		"%9a": "",
		"%9A": "",
		"%9b": "",
		"%9B": "",
		"%9c": "",
		"%9C": "",
		"%9d": "",
		"%9D": "",
		"%9e": "",
		"%9E": "",
		"%9f": "",
		"%9F": "",
		"%a0": "\xA0",
		"%A0": "\xA0",
		"%a1": "",
		"%A1": "",
		"%a2": "",
		"%A2": "",
		"%a3": "",
		"%A3": "",
		"%a4": "",
		"%A4": "",
		"%a5": "",
		"%A5": "",
		"%a6": "",
		"%A6": "",
		"%a7": "",
		"%A7": "",
		"%a8": "",
		"%A8": "",
		"%a9": "",
		"%A9": "",
		"%aa": "",
		"%Aa": "",
		"%aA": "",
		"%AA": "",
		"%ab": "",
		"%Ab": "",
		"%aB": "",
		"%AB": "",
		"%ac": "",
		"%Ac": "",
		"%aC": "",
		"%AC": "",
		"%ad": "",
		"%Ad": "",
		"%aD": "",
		"%AD": "",
		"%ae": "",
		"%Ae": "",
		"%aE": "",
		"%AE": "",
		"%af": "",
		"%Af": "",
		"%aF": "",
		"%AF": "",
		"%b0": "",
		"%B0": "",
		"%b1": "",
		"%B1": "",
		"%b2": "",
		"%B2": "",
		"%b3": "",
		"%B3": "",
		"%b4": "",
		"%B4": "",
		"%b5": "",
		"%B5": "",
		"%b6": "",
		"%B6": "",
		"%b7": "",
		"%B7": "",
		"%b8": "",
		"%B8": "",
		"%b9": "",
		"%B9": "",
		"%ba": "",
		"%Ba": "",
		"%bA": "",
		"%BA": "",
		"%bb": "",
		"%Bb": "",
		"%bB": "",
		"%BB": "",
		"%bc": "",
		"%Bc": "",
		"%bC": "",
		"%BC": "",
		"%bd": "",
		"%Bd": "",
		"%bD": "",
		"%BD": "",
		"%be": "",
		"%Be": "",
		"%bE": "",
		"%BE": "",
		"%bf": "",
		"%Bf": "",
		"%bF": "",
		"%BF": "",
		"%c0": "",
		"%C0": "",
		"%c1": "",
		"%C1": "",
		"%c2": "",
		"%C2": "",
		"%c3": "",
		"%C3": "",
		"%c4": "",
		"%C4": "",
		"%c5": "",
		"%C5": "",
		"%c6": "",
		"%C6": "",
		"%c7": "",
		"%C7": "",
		"%c8": "",
		"%C8": "",
		"%c9": "",
		"%C9": "",
		"%ca": "",
		"%Ca": "",
		"%cA": "",
		"%CA": "",
		"%cb": "",
		"%Cb": "",
		"%cB": "",
		"%CB": "",
		"%cc": "",
		"%Cc": "",
		"%cC": "",
		"%CC": "",
		"%cd": "",
		"%Cd": "",
		"%cD": "",
		"%CD": "",
		"%ce": "",
		"%Ce": "",
		"%cE": "",
		"%CE": "",
		"%cf": "",
		"%Cf": "",
		"%cF": "",
		"%CF": "",
		"%d0": "",
		"%D0": "",
		"%d1": "",
		"%D1": "",
		"%d2": "",
		"%D2": "",
		"%d3": "",
		"%D3": "",
		"%d4": "",
		"%D4": "",
		"%d5": "",
		"%D5": "",
		"%d6": "",
		"%D6": "",
		"%d7": "",
		"%D7": "",
		"%d8": "",
		"%D8": "",
		"%d9": "",
		"%D9": "",
		"%da": "",
		"%Da": "",
		"%dA": "",
		"%DA": "",
		"%db": "",
		"%Db": "",
		"%dB": "",
		"%DB": "",
		"%dc": "",
		"%Dc": "",
		"%dC": "",
		"%DC": "",
		"%dd": "",
		"%Dd": "",
		"%dD": "",
		"%DD": "",
		"%de": "",
		"%De": "",
		"%dE": "",
		"%DE": "",
		"%df": "",
		"%Df": "",
		"%dF": "",
		"%DF": "",
		"%e0": "",
		"%E0": "",
		"%e1": "",
		"%E1": "",
		"%e2": "",
		"%E2": "",
		"%e3": "",
		"%E3": "",
		"%e4": "",
		"%E4": "",
		"%e5": "",
		"%E5": "",
		"%e6": "",
		"%E6": "",
		"%e7": "",
		"%E7": "",
		"%e8": "",
		"%E8": "",
		"%e9": "",
		"%E9": "",
		"%ea": "",
		"%Ea": "",
		"%eA": "",
		"%EA": "",
		"%eb": "",
		"%Eb": "",
		"%eB": "",
		"%EB": "",
		"%ec": "",
		"%Ec": "",
		"%eC": "",
		"%EC": "",
		"%ed": "",
		"%Ed": "",
		"%eD": "",
		"%ED": "",
		"%ee": "",
		"%Ee": "",
		"%eE": "",
		"%EE": "",
		"%ef": "",
		"%Ef": "",
		"%eF": "",
		"%EF": "",
		"%f0": "",
		"%F0": "",
		"%f1": "",
		"%F1": "",
		"%f2": "",
		"%F2": "",
		"%f3": "",
		"%F3": "",
		"%f4": "",
		"%F4": "",
		"%f5": "",
		"%F5": "",
		"%f6": "",
		"%F6": "",
		"%f7": "",
		"%F7": "",
		"%f8": "",
		"%F8": "",
		"%f9": "",
		"%F9": "",
		"%fa": "",
		"%Fa": "",
		"%fA": "",
		"%FA": "",
		"%fb": "",
		"%Fb": "",
		"%fB": "",
		"%FB": "",
		"%fc": "",
		"%Fc": "",
		"%fC": "",
		"%FC": "",
		"%fd": "",
		"%Fd": "",
		"%fD": "",
		"%FD": "",
		"%fe": "",
		"%Fe": "",
		"%fE": "",
		"%FE": "",
		"%ff": "",
		"%Ff": "",
		"%fF": "",
		"%FF": ""
	};
	function encodedReplacer(match$15) {
		return EncodedLookup[match$15];
	}
	var STATE_KEY = 0;
	var STATE_VALUE = 1;
	var STATE_CHARSET = 2;
	var STATE_LANG = 3;
	function parseParams(str) {
		const res = [];
		let state = STATE_KEY;
		let charset = "";
		let inquote = false;
		let escaping = false;
		let p = 0;
		let tmp = "";
		const len = str.length;
		for (var i = 0; i < len; ++i) {
			const char = str[i];
			if (char === "\\" && inquote) if (escaping) escaping = false;
			else {
				escaping = true;
				continue;
			}
			else if (char === "\"") if (!escaping) {
				if (inquote) {
					inquote = false;
					state = STATE_KEY;
				} else inquote = true;
				continue;
			} else escaping = false;
			else {
				if (escaping && inquote) tmp += "\\";
				escaping = false;
				if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
					if (state === STATE_CHARSET) {
						state = STATE_LANG;
						charset = tmp.substring(1);
					} else state = STATE_VALUE;
					tmp = "";
					continue;
				} else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
					state = char === "*" ? STATE_CHARSET : STATE_VALUE;
					res[p] = [tmp, void 0];
					tmp = "";
					continue;
				} else if (!inquote && char === ";") {
					state = STATE_KEY;
					if (charset) {
						if (tmp.length) tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
						charset = "";
					} else if (tmp.length) tmp = decodeText(tmp, "binary", "utf8");
					if (res[p] === void 0) res[p] = tmp;
					else res[p][1] = tmp;
					tmp = "";
					++p;
					continue;
				} else if (!inquote && (char === " " || char === "	")) continue;
			}
			tmp += char;
		}
		if (charset && tmp.length) tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
		else if (tmp) tmp = decodeText(tmp, "binary", "utf8");
		if (res[p] === void 0) {
			if (tmp) res[p] = tmp;
		} else res[p][1] = tmp;
		return res;
	}
	module.exports = parseParams;
}));
var require_basename = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function basename(path$5) {
		if (typeof path$5 !== "string") return "";
		for (var i = path$5.length - 1; i >= 0; --i) switch (path$5.charCodeAt(i)) {
			case 47:
			case 92:
				path$5 = path$5.slice(i + 1);
				return path$5 === ".." || path$5 === "." ? "" : path$5;
		}
		return path$5 === ".." || path$5 === "." ? "" : path$5;
	};
}));
var require_multipart = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Readable: Readable$3 } = __require("node:stream");
	var { inherits: inherits$1 } = __require("node:util");
	var Dicer = require_Dicer();
	var parseParams = require_parseParams();
	var decodeText = require_decodeText();
	var basename = require_basename();
	var getLimit = require_getLimit();
	var RE_BOUNDARY = /^boundary$/i;
	var RE_FIELD = /^form-data$/i;
	var RE_CHARSET = /^charset$/i;
	var RE_FILENAME = /^filename$/i;
	var RE_NAME = /^name$/i;
	Multipart.detect = /^multipart\/form-data/i;
	function Multipart(boy, cfg) {
		let i;
		let len;
		const self = this;
		let boundary;
		const limits = cfg.limits;
		const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
		const parsedConType = cfg.parsedConType || [];
		const defCharset = cfg.defCharset || "utf8";
		const preservePath = cfg.preservePath;
		const fileOpts = { highWaterMark: cfg.fileHwm };
		for (i = 0, len = parsedConType.length; i < len; ++i) if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
			boundary = parsedConType[i][1];
			break;
		}
		function checkFinished() {
			if (nends === 0 && finished$1 && !boy._done) {
				finished$1 = false;
				self.end();
			}
		}
		if (typeof boundary !== "string") throw new Error("Multipart: Boundary not found");
		const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
		const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
		const filesLimit = getLimit(limits, "files", Infinity);
		const fieldsLimit = getLimit(limits, "fields", Infinity);
		const partsLimit = getLimit(limits, "parts", Infinity);
		const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
		const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
		let nfiles = 0;
		let nfields = 0;
		let nends = 0;
		let curFile;
		let curField;
		let finished$1 = false;
		this._needDrain = false;
		this._pause = false;
		this._cb = void 0;
		this._nparts = 0;
		this._boy = boy;
		this.parser = new Dicer({
			boundary,
			maxHeaderPairs: headerPairsLimit,
			maxHeaderSize: headerSizeLimit,
			partHwm: fileOpts.highWaterMark,
			highWaterMark: cfg.highWaterMark
		});
		this.parser.on("drain", function() {
			self._needDrain = false;
			if (self._cb && !self._pause) {
				const cb = self._cb;
				self._cb = void 0;
				cb();
			}
		}).on("part", function onPart(part) {
			if (++self._nparts > partsLimit) {
				self.parser.removeListener("part", onPart);
				self.parser.on("part", skipPart);
				boy.hitPartsLimit = true;
				boy.emit("partsLimit");
				return skipPart(part);
			}
			if (curField) {
				const field = curField;
				field.emit("end");
				field.removeAllListeners("end");
			}
			part.on("header", function(header) {
				let contype;
				let fieldname;
				let parsed;
				let charset;
				let encoding;
				let filename;
				let nsize = 0;
				if (header["content-type"]) {
					parsed = parseParams(header["content-type"][0]);
					if (parsed[0]) {
						contype = parsed[0].toLowerCase();
						for (i = 0, len = parsed.length; i < len; ++i) if (RE_CHARSET.test(parsed[i][0])) {
							charset = parsed[i][1].toLowerCase();
							break;
						}
					}
				}
				if (contype === void 0) contype = "text/plain";
				if (charset === void 0) charset = defCharset;
				if (header["content-disposition"]) {
					parsed = parseParams(header["content-disposition"][0]);
					if (!RE_FIELD.test(parsed[0])) return skipPart(part);
					for (i = 0, len = parsed.length; i < len; ++i) if (RE_NAME.test(parsed[i][0])) fieldname = parsed[i][1];
					else if (RE_FILENAME.test(parsed[i][0])) {
						filename = parsed[i][1];
						if (!preservePath) filename = basename(filename);
					}
				} else return skipPart(part);
				if (header["content-transfer-encoding"]) encoding = header["content-transfer-encoding"][0].toLowerCase();
				else encoding = "7bit";
				let onData, onEnd;
				if (isPartAFile(fieldname, contype, filename)) {
					if (nfiles === filesLimit) {
						if (!boy.hitFilesLimit) {
							boy.hitFilesLimit = true;
							boy.emit("filesLimit");
						}
						return skipPart(part);
					}
					++nfiles;
					if (boy.listenerCount("file") === 0) {
						self.parser._ignore();
						return;
					}
					++nends;
					const file = new FileStream(fileOpts);
					curFile = file;
					file.on("end", function() {
						--nends;
						self._pause = false;
						checkFinished();
						if (self._cb && !self._needDrain) {
							const cb = self._cb;
							self._cb = void 0;
							cb();
						}
					});
					file._read = function(n) {
						if (!self._pause) return;
						self._pause = false;
						if (self._cb && !self._needDrain) {
							const cb = self._cb;
							self._cb = void 0;
							cb();
						}
					};
					boy.emit("file", fieldname, file, filename, encoding, contype);
					onData = function(data) {
						if ((nsize += data.length) > fileSizeLimit) {
							const extralen = fileSizeLimit - nsize + data.length;
							if (extralen > 0) file.push(data.slice(0, extralen));
							file.truncated = true;
							file.bytesRead = fileSizeLimit;
							part.removeAllListeners("data");
							file.emit("limit");
							return;
						} else if (!file.push(data)) self._pause = true;
						file.bytesRead = nsize;
					};
					onEnd = function() {
						curFile = void 0;
						file.push(null);
					};
				} else {
					if (nfields === fieldsLimit) {
						if (!boy.hitFieldsLimit) {
							boy.hitFieldsLimit = true;
							boy.emit("fieldsLimit");
						}
						return skipPart(part);
					}
					++nfields;
					++nends;
					let buffer = "";
					let truncated = false;
					curField = part;
					onData = function(data) {
						if ((nsize += data.length) > fieldSizeLimit) {
							const extralen = fieldSizeLimit - (nsize - data.length);
							buffer += data.toString("binary", 0, extralen);
							truncated = true;
							part.removeAllListeners("data");
						} else buffer += data.toString("binary");
					};
					onEnd = function() {
						curField = void 0;
						if (buffer.length) buffer = decodeText(buffer, "binary", charset);
						boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
						--nends;
						checkFinished();
					};
				}
				part._readableState.sync = false;
				part.on("data", onData);
				part.on("end", onEnd);
			}).on("error", function(err) {
				if (curFile) curFile.emit("error", err);
			});
		}).on("error", function(err) {
			boy.emit("error", err);
		}).on("finish", function() {
			finished$1 = true;
			checkFinished();
		});
	}
	Multipart.prototype.write = function(chunk$4, cb) {
		const r = this.parser.write(chunk$4);
		if (r && !this._pause) cb();
		else {
			this._needDrain = !r;
			this._cb = cb;
		}
	};
	Multipart.prototype.end = function() {
		const self = this;
		if (self.parser.writable) self.parser.end();
		else if (!self._boy._done) process.nextTick(function() {
			self._boy._done = true;
			self._boy.emit("finish");
		});
	};
	function skipPart(part) {
		part.resume();
	}
	function FileStream(opts) {
		Readable$3.call(this, opts);
		this.bytesRead = 0;
		this.truncated = false;
	}
	inherits$1(FileStream, Readable$3);
	FileStream.prototype._read = function(n) {};
	module.exports = Multipart;
}));
var require_Decoder = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var RE_PLUS = /\+/g;
	var HEX = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	function Decoder() {
		this.buffer = void 0;
	}
	Decoder.prototype.write = function(str) {
		str = str.replace(RE_PLUS, " ");
		let res = "";
		let i = 0;
		let p = 0;
		const len = str.length;
		for (; i < len; ++i) if (this.buffer !== void 0) if (!HEX[str.charCodeAt(i)]) {
			res += "%" + this.buffer;
			this.buffer = void 0;
			--i;
		} else {
			this.buffer += str[i];
			++p;
			if (this.buffer.length === 2) {
				res += String.fromCharCode(parseInt(this.buffer, 16));
				this.buffer = void 0;
			}
		}
		else if (str[i] === "%") {
			if (i > p) {
				res += str.substring(p, i);
				p = i;
			}
			this.buffer = "";
			++p;
		}
		if (p < len && this.buffer === void 0) res += str.substring(p);
		return res;
	};
	Decoder.prototype.reset = function() {
		this.buffer = void 0;
	};
	module.exports = Decoder;
}));
var require_urlencoded = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Decoder = require_Decoder();
	var decodeText = require_decodeText();
	var getLimit = require_getLimit();
	var RE_CHARSET = /^charset$/i;
	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded(boy, cfg) {
		const limits = cfg.limits;
		const parsedConType = cfg.parsedConType;
		this.boy = boy;
		this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
		this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
		this.fieldsLimit = getLimit(limits, "fields", Infinity);
		let charset;
		for (var i = 0, len = parsedConType.length; i < len; ++i) if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
			charset = parsedConType[i][1].toLowerCase();
			break;
		}
		if (charset === void 0) charset = cfg.defCharset || "utf8";
		this.decoder = new Decoder();
		this.charset = charset;
		this._fields = 0;
		this._state = "key";
		this._checkingBytes = true;
		this._bytesKey = 0;
		this._bytesVal = 0;
		this._key = "";
		this._val = "";
		this._keyTrunc = false;
		this._valTrunc = false;
		this._hitLimit = false;
	}
	UrlEncoded.prototype.write = function(data, cb) {
		if (this._fields === this.fieldsLimit) {
			if (!this.boy.hitFieldsLimit) {
				this.boy.hitFieldsLimit = true;
				this.boy.emit("fieldsLimit");
			}
			return cb();
		}
		let idxeq;
		let idxamp;
		let i;
		let p = 0;
		const len = data.length;
		while (p < len) if (this._state === "key") {
			idxeq = idxamp = void 0;
			for (i = p; i < len; ++i) {
				if (!this._checkingBytes) ++p;
				if (data[i] === 61) {
					idxeq = i;
					break;
				} else if (data[i] === 38) {
					idxamp = i;
					break;
				}
				if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesKey;
			}
			if (idxeq !== void 0) {
				if (idxeq > p) this._key += this.decoder.write(data.toString("binary", p, idxeq));
				this._state = "val";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._val = "";
				this._bytesVal = 0;
				this._valTrunc = false;
				this.decoder.reset();
				p = idxeq + 1;
			} else if (idxamp !== void 0) {
				++this._fields;
				let key;
				const keyTrunc = this._keyTrunc;
				if (idxamp > p) key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
				else key = this._key;
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				if (key.length) this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);
				p = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i > p) this._key += this.decoder.write(data.toString("binary", p, i));
				p = i;
				if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
					this._checkingBytes = false;
					this._keyTrunc = true;
				}
			} else {
				if (p < len) this._key += this.decoder.write(data.toString("binary", p));
				p = len;
			}
		} else {
			idxamp = void 0;
			for (i = p; i < len; ++i) {
				if (!this._checkingBytes) ++p;
				if (data[i] === 38) {
					idxamp = i;
					break;
				}
				if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesVal;
			}
			if (idxamp !== void 0) {
				++this._fields;
				if (idxamp > p) this._val += this.decoder.write(data.toString("binary", p, idxamp));
				this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
				this._state = "key";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				p = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i > p) this._val += this.decoder.write(data.toString("binary", p, i));
				p = i;
				if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
					this._checkingBytes = false;
					this._valTrunc = true;
				}
			} else {
				if (p < len) this._val += this.decoder.write(data.toString("binary", p));
				p = len;
			}
		}
		cb();
	};
	UrlEncoded.prototype.end = function() {
		if (this.boy._done) return;
		if (this._state === "key" && this._key.length > 0) this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);
		else if (this._state === "val") this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
		this.boy._done = true;
		this.boy.emit("finish");
	};
	module.exports = UrlEncoded;
}));
var require_main = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var WritableStream = __require("node:stream").Writable;
	var { inherits } = __require("node:util");
	var Dicer = require_Dicer();
	var MultipartParser = require_multipart();
	var UrlencodedParser = require_urlencoded();
	var parseParams = require_parseParams();
	function Busboy(opts) {
		if (!(this instanceof Busboy)) return new Busboy(opts);
		if (typeof opts !== "object") throw new TypeError("Busboy expected an options-Object.");
		if (typeof opts.headers !== "object") throw new TypeError("Busboy expected an options-Object with headers-attribute.");
		if (typeof opts.headers["content-type"] !== "string") throw new TypeError("Missing Content-Type-header.");
		const { headers, ...streamOptions } = opts;
		this.opts = {
			autoDestroy: false,
			...streamOptions
		};
		WritableStream.call(this, this.opts);
		this._done = false;
		this._parser = this.getParserByHeaders(headers);
		this._finished = false;
	}
	inherits(Busboy, WritableStream);
	Busboy.prototype.emit = function(ev) {
		if (ev === "finish") {
			if (!this._done) {
				this._parser?.end();
				return;
			} else if (this._finished) return;
			this._finished = true;
		}
		WritableStream.prototype.emit.apply(this, arguments);
	};
	Busboy.prototype.getParserByHeaders = function(headers) {
		const parsed = parseParams(headers["content-type"]);
		const cfg = {
			defCharset: this.opts.defCharset,
			fileHwm: this.opts.fileHwm,
			headers,
			highWaterMark: this.opts.highWaterMark,
			isPartAFile: this.opts.isPartAFile,
			limits: this.opts.limits,
			parsedConType: parsed,
			preservePath: this.opts.preservePath
		};
		if (MultipartParser.detect.test(parsed[0])) return new MultipartParser(this, cfg);
		if (UrlencodedParser.detect.test(parsed[0])) return new UrlencodedParser(this, cfg);
		throw new Error("Unsupported Content-Type.");
	};
	Busboy.prototype._write = function(chunk$4, encoding, cb) {
		this._parser.write(chunk$4, cb);
	};
	module.exports = Busboy;
	module.exports.default = Busboy;
	module.exports.Busboy = Busboy;
	module.exports.Dicer = Dicer;
}));
var require_constants$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
	var corsSafeListedMethods = [
		"GET",
		"HEAD",
		"POST"
	];
	var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
	var nullBodyStatus = [
		101,
		204,
		205,
		304
	];
	var redirectStatus = [
		301,
		302,
		303,
		307,
		308
	];
	var redirectStatusSet = new Set(redirectStatus);
	var badPorts = [
		"1",
		"7",
		"9",
		"11",
		"13",
		"15",
		"17",
		"19",
		"20",
		"21",
		"22",
		"23",
		"25",
		"37",
		"42",
		"43",
		"53",
		"69",
		"77",
		"79",
		"87",
		"95",
		"101",
		"102",
		"103",
		"104",
		"109",
		"110",
		"111",
		"113",
		"115",
		"117",
		"119",
		"123",
		"135",
		"137",
		"139",
		"143",
		"161",
		"179",
		"389",
		"427",
		"465",
		"512",
		"513",
		"514",
		"515",
		"526",
		"530",
		"531",
		"532",
		"540",
		"548",
		"554",
		"556",
		"563",
		"587",
		"601",
		"636",
		"989",
		"990",
		"993",
		"995",
		"1719",
		"1720",
		"1723",
		"2049",
		"3659",
		"4045",
		"5060",
		"5061",
		"6000",
		"6566",
		"6665",
		"6666",
		"6667",
		"6668",
		"6669",
		"6697",
		"10080"
	];
	var badPortsSet = new Set(badPorts);
	var referrerPolicy = [
		"",
		"no-referrer",
		"no-referrer-when-downgrade",
		"same-origin",
		"origin",
		"strict-origin",
		"origin-when-cross-origin",
		"strict-origin-when-cross-origin",
		"unsafe-url"
	];
	var referrerPolicySet = new Set(referrerPolicy);
	var requestRedirect = [
		"follow",
		"manual",
		"error"
	];
	var safeMethods = [
		"GET",
		"HEAD",
		"OPTIONS",
		"TRACE"
	];
	var safeMethodsSet = new Set(safeMethods);
	var requestMode = [
		"navigate",
		"same-origin",
		"no-cors",
		"cors"
	];
	var requestCredentials = [
		"omit",
		"same-origin",
		"include"
	];
	var requestCache = [
		"default",
		"no-store",
		"reload",
		"no-cache",
		"force-cache",
		"only-if-cached"
	];
	var requestBodyHeader = [
		"content-encoding",
		"content-language",
		"content-location",
		"content-type",
		"content-length"
	];
	var requestDuplex = ["half"];
	var forbiddenMethods = [
		"CONNECT",
		"TRACE",
		"TRACK"
	];
	var forbiddenMethodsSet = new Set(forbiddenMethods);
	var subresource = [
		"audio",
		"audioworklet",
		"font",
		"image",
		"manifest",
		"paintworklet",
		"script",
		"style",
		"track",
		"video",
		"xslt",
		""
	];
	var subresourceSet = new Set(subresource);
	var DOMException = globalThis.DOMException ?? (() => {
		try {
			atob("~");
		} catch (err) {
			return Object.getPrototypeOf(err).constructor;
		}
	})();
	var channel;
	module.exports = {
		DOMException,
		structuredClone: globalThis.structuredClone ?? function structuredClone(value$2, options = void 0) {
			if (arguments.length === 0) throw new TypeError("missing argument");
			if (!channel) channel = new MessageChannel();
			channel.port1.unref();
			channel.port2.unref();
			channel.port1.postMessage(value$2, options?.transfer);
			return receiveMessageOnPort(channel.port2).message;
		},
		subresource,
		forbiddenMethods,
		requestBodyHeader,
		referrerPolicy,
		requestRedirect,
		requestMode,
		requestCredentials,
		requestCache,
		redirectStatus,
		corsSafeListedMethods,
		nullBodyStatus,
		safeMethods,
		badPorts,
		requestDuplex,
		subresourceSet,
		badPortsSet,
		redirectStatusSet,
		corsSafeListedMethodsSet,
		safeMethodsSet,
		forbiddenMethodsSet,
		referrerPolicySet
	};
}));
var require_global$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var globalOrigin = Symbol.for("undici.globalOrigin.1");
	function getGlobalOrigin() {
		return globalThis[globalOrigin];
	}
	function setGlobalOrigin(newOrigin) {
		if (newOrigin === void 0) {
			Object.defineProperty(globalThis, globalOrigin, {
				value: void 0,
				writable: true,
				enumerable: false,
				configurable: false
			});
			return;
		}
		const parsedURL = new URL(newOrigin);
		if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
		Object.defineProperty(globalThis, globalOrigin, {
			value: parsedURL,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	module.exports = {
		getGlobalOrigin,
		setGlobalOrigin
	};
}));
var require_util$5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants$3();
	var { getGlobalOrigin } = require_global$1();
	var { performance: performance$1 } = __require("perf_hooks");
	var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util$6();
	var assert$18 = __require("assert");
	var { isUint8Array: isUint8Array$2 } = __require("util/types");
	var supportedHashes = [];
	var crypto;
	try {
		crypto = __require("crypto");
		const possibleRelevantHashes = [
			"sha256",
			"sha384",
			"sha512"
		];
		supportedHashes = crypto.getHashes().filter((hash$1) => possibleRelevantHashes.includes(hash$1));
	} catch {}
	function responseURL(response) {
		const urlList = response.urlList;
		const length$1 = urlList.length;
		return length$1 === 0 ? null : urlList[length$1 - 1].toString();
	}
	function responseLocationURL(response, requestFragment) {
		if (!redirectStatusSet.has(response.status)) return null;
		let location = response.headersList.get("location");
		if (location !== null && isValidHeaderValue(location)) location = new URL(location, responseURL(response));
		if (location && !location.hash) location.hash = requestFragment;
		return location;
	}
	function requestCurrentURL(request$1) {
		return request$1.urlList[request$1.urlList.length - 1];
	}
	function requestBadPort(request$1) {
		const url$2 = requestCurrentURL(request$1);
		if (urlIsHttpHttpsScheme(url$2) && badPortsSet.has(url$2.port)) return "blocked";
		return "allowed";
	}
	function isErrorLike(object) {
		return object instanceof Error || object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException";
	}
	function isValidReasonPhrase(statusText) {
		for (let i = 0; i < statusText.length; ++i) {
			const c = statusText.charCodeAt(i);
			if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) return false;
		}
		return true;
	}
	function isTokenCharCode(c) {
		switch (c) {
			case 34:
			case 40:
			case 41:
			case 44:
			case 47:
			case 58:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 91:
			case 92:
			case 93:
			case 123:
			case 125: return false;
			default: return c >= 33 && c <= 126;
		}
	}
	function isValidHTTPToken(characters) {
		if (characters.length === 0) return false;
		for (let i = 0; i < characters.length; ++i) if (!isTokenCharCode(characters.charCodeAt(i))) return false;
		return true;
	}
	function isValidHeaderName(potentialValue) {
		return isValidHTTPToken(potentialValue);
	}
	function isValidHeaderValue(potentialValue) {
		if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) return false;
		if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) return false;
		return true;
	}
	function setRequestReferrerPolicyOnRedirect(request$1, actualResponse) {
		const { headersList } = actualResponse;
		const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
		let policy = "";
		if (policyHeader.length > 0) for (let i = policyHeader.length; i !== 0; i--) {
			const token = policyHeader[i - 1].trim();
			if (referrerPolicyTokens.has(token)) {
				policy = token;
				break;
			}
		}
		if (policy !== "") request$1.referrerPolicy = policy;
	}
	function crossOriginResourcePolicyCheck() {
		return "allowed";
	}
	function corsCheck() {
		return "success";
	}
	function TAOCheck() {
		return "success";
	}
	function appendFetchMetadata(httpRequest) {
		let header = null;
		header = httpRequest.mode;
		httpRequest.headersList.set("sec-fetch-mode", header);
	}
	function appendRequestOriginHeader(request$1) {
		let serializedOrigin = request$1.origin;
		if (request$1.responseTainting === "cors" || request$1.mode === "websocket") {
			if (serializedOrigin) request$1.headersList.append("origin", serializedOrigin);
		} else if (request$1.method !== "GET" && request$1.method !== "HEAD") {
			switch (request$1.referrerPolicy) {
				case "no-referrer":
					serializedOrigin = null;
					break;
				case "no-referrer-when-downgrade":
				case "strict-origin":
				case "strict-origin-when-cross-origin":
					if (request$1.origin && urlHasHttpsScheme(request$1.origin) && !urlHasHttpsScheme(requestCurrentURL(request$1))) serializedOrigin = null;
					break;
				case "same-origin":
					if (!sameOrigin(request$1, requestCurrentURL(request$1))) serializedOrigin = null;
					break;
				default:
			}
			if (serializedOrigin) request$1.headersList.append("origin", serializedOrigin);
		}
	}
	function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
		return performance$1.now();
	}
	function createOpaqueTimingInfo(timingInfo) {
		return {
			startTime: timingInfo.startTime ?? 0,
			redirectStartTime: 0,
			redirectEndTime: 0,
			postRedirectStartTime: timingInfo.startTime ?? 0,
			finalServiceWorkerStartTime: 0,
			finalNetworkResponseStartTime: 0,
			finalNetworkRequestStartTime: 0,
			endTime: 0,
			encodedBodySize: 0,
			decodedBodySize: 0,
			finalConnectionTimingInfo: null
		};
	}
	function makePolicyContainer() {
		return { referrerPolicy: "strict-origin-when-cross-origin" };
	}
	function clonePolicyContainer(policyContainer) {
		return { referrerPolicy: policyContainer.referrerPolicy };
	}
	function determineRequestsReferrer(request$1) {
		const policy = request$1.referrerPolicy;
		assert$18(policy);
		let referrerSource = null;
		if (request$1.referrer === "client") {
			const globalOrigin = getGlobalOrigin();
			if (!globalOrigin || globalOrigin.origin === "null") return "no-referrer";
			referrerSource = new URL(globalOrigin);
		} else if (request$1.referrer instanceof URL) referrerSource = request$1.referrer;
		let referrerURL = stripURLForReferrer(referrerSource);
		const referrerOrigin = stripURLForReferrer(referrerSource, true);
		if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
		const areSameOrigin = sameOrigin(request$1, referrerURL);
		const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request$1.url);
		switch (policy) {
			case "origin": return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
			case "unsafe-url": return referrerURL;
			case "same-origin": return areSameOrigin ? referrerOrigin : "no-referrer";
			case "origin-when-cross-origin": return areSameOrigin ? referrerURL : referrerOrigin;
			case "strict-origin-when-cross-origin": {
				const currentURL = requestCurrentURL(request$1);
				if (sameOrigin(referrerURL, currentURL)) return referrerURL;
				if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) return "no-referrer";
				return referrerOrigin;
			}
			case "strict-origin":
			case "no-referrer-when-downgrade":
			default: return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
		}
	}
	function stripURLForReferrer(url$2, originOnly) {
		assert$18(url$2 instanceof URL);
		if (url$2.protocol === "file:" || url$2.protocol === "about:" || url$2.protocol === "blank:") return "no-referrer";
		url$2.username = "";
		url$2.password = "";
		url$2.hash = "";
		if (originOnly) {
			url$2.pathname = "";
			url$2.search = "";
		}
		return url$2;
	}
	function isURLPotentiallyTrustworthy(url$2) {
		if (!(url$2 instanceof URL)) return false;
		if (url$2.href === "about:blank" || url$2.href === "about:srcdoc") return true;
		if (url$2.protocol === "data:") return true;
		if (url$2.protocol === "file:") return true;
		return isOriginPotentiallyTrustworthy(url$2.origin);
		function isOriginPotentiallyTrustworthy(origin) {
			if (origin == null || origin === "null") return false;
			const originAsURL = new URL(origin);
			if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") return true;
			if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.") || originAsURL.hostname.endsWith(".localhost")) return true;
			return false;
		}
	}
	function bytesMatch(bytes, metadataList) {
		/* istanbul ignore if: only if node is built with --without-ssl */
		if (crypto === void 0) return true;
		const parsedMetadata = parseMetadata(metadataList);
		if (parsedMetadata === "no metadata") return true;
		if (parsedMetadata.length === 0) return true;
		const metadata = filterMetadataListByAlgorithm(parsedMetadata, getStrongestMetadata(parsedMetadata));
		for (const item of metadata) {
			const algorithm = item.algo;
			const expectedValue = item.hash;
			let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
			if (actualValue[actualValue.length - 1] === "=") if (actualValue[actualValue.length - 2] === "=") actualValue = actualValue.slice(0, -2);
			else actualValue = actualValue.slice(0, -1);
			if (compareBase64Mixed(actualValue, expectedValue)) return true;
		}
		return false;
	}
	var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
	function parseMetadata(metadata) {
		const result = [];
		let empty$35 = true;
		for (const token of metadata.split(" ")) {
			empty$35 = false;
			const parsedToken = parseHashWithOptions.exec(token);
			if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) continue;
			const algorithm = parsedToken.groups.algo.toLowerCase();
			if (supportedHashes.includes(algorithm)) result.push(parsedToken.groups);
		}
		if (empty$35 === true) return "no metadata";
		return result;
	}
	function getStrongestMetadata(metadataList) {
		let algorithm = metadataList[0].algo;
		if (algorithm[3] === "5") return algorithm;
		for (let i = 1; i < metadataList.length; ++i) {
			const metadata = metadataList[i];
			if (metadata.algo[3] === "5") {
				algorithm = "sha512";
				break;
			} else if (algorithm[3] === "3") continue;
			else if (metadata.algo[3] === "3") algorithm = "sha384";
		}
		return algorithm;
	}
	function filterMetadataListByAlgorithm(metadataList, algorithm) {
		if (metadataList.length === 1) return metadataList;
		let pos = 0;
		for (let i = 0; i < metadataList.length; ++i) if (metadataList[i].algo === algorithm) metadataList[pos++] = metadataList[i];
		metadataList.length = pos;
		return metadataList;
	}
	function compareBase64Mixed(actualValue, expectedValue) {
		if (actualValue.length !== expectedValue.length) return false;
		for (let i = 0; i < actualValue.length; ++i) if (actualValue[i] !== expectedValue[i]) {
			if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") continue;
			return false;
		}
		return true;
	}
	function tryUpgradeRequestToAPotentiallyTrustworthyURL(request$1) {}
	function sameOrigin(A, B) {
		if (A.origin === B.origin && A.origin === "null") return true;
		if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) return true;
		return false;
	}
	function createDeferredPromise() {
		let res;
		let rej;
		return {
			promise: new Promise((resolve, reject) => {
				res = resolve;
				rej = reject;
			}),
			resolve: res,
			reject: rej
		};
	}
	function isAborted(fetchParams) {
		return fetchParams.controller.state === "aborted";
	}
	function isCancelled(fetchParams) {
		return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
	}
	var normalizeMethodRecord = {
		delete: "DELETE",
		DELETE: "DELETE",
		get: "GET",
		GET: "GET",
		head: "HEAD",
		HEAD: "HEAD",
		options: "OPTIONS",
		OPTIONS: "OPTIONS",
		post: "POST",
		POST: "POST",
		put: "PUT",
		PUT: "PUT"
	};
	Object.setPrototypeOf(normalizeMethodRecord, null);
	function normalizeMethod(method) {
		return normalizeMethodRecord[method.toLowerCase()] ?? method;
	}
	function serializeJavascriptValueToJSONString(value$2) {
		const result = JSON.stringify(value$2);
		if (result === void 0) throw new TypeError("Value is not JSON serializable");
		assert$18(typeof result === "string");
		return result;
	}
	var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
	function makeIterator(iterator, name, kind) {
		const object = {
			index: 0,
			kind,
			target: iterator
		};
		const i = {
			next() {
				if (Object.getPrototypeOf(this) !== i) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
				const { index, kind: kind$1, target } = object;
				const values$6 = target();
				if (index >= values$6.length) return {
					value: void 0,
					done: true
				};
				const pair = values$6[index];
				object.index = index + 1;
				return iteratorResult(pair, kind$1);
			},
			[Symbol.toStringTag]: `${name} Iterator`
		};
		Object.setPrototypeOf(i, esIteratorPrototype);
		return Object.setPrototypeOf({}, i);
	}
	function iteratorResult(pair, kind) {
		let result;
		switch (kind) {
			case "key":
				result = pair[0];
				break;
			case "value":
				result = pair[1];
				break;
			case "key+value":
				result = pair;
				break;
		}
		return {
			value: result,
			done: false
		};
	}
	async function fullyReadBody(body, processBody, processBodyError) {
		const successSteps = processBody;
		const errorSteps = processBodyError;
		let reader;
		try {
			reader = body.stream.getReader();
		} catch (e) {
			errorSteps(e);
			return;
		}
		try {
			successSteps(await readAllBytes(reader));
		} catch (e) {
			errorSteps(e);
		}
	}
	var ReadableStream = globalThis.ReadableStream;
	function isReadableStreamLike(stream$1) {
		if (!ReadableStream) ReadableStream = __require("stream/web").ReadableStream;
		return stream$1 instanceof ReadableStream || stream$1[Symbol.toStringTag] === "ReadableStream" && typeof stream$1.tee === "function";
	}
	var MAXIMUM_ARGUMENT_LENGTH = 65535;
	function isomorphicDecode(input) {
		if (input.length < MAXIMUM_ARGUMENT_LENGTH) return String.fromCharCode(...input);
		return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
	}
	function readableStreamClose(controller) {
		try {
			controller.close();
		} catch (err) {
			if (!err.message.includes("Controller is already closed")) throw err;
		}
	}
	function isomorphicEncode(input) {
		for (let i = 0; i < input.length; i++) assert$18(input.charCodeAt(i) <= 255);
		return input;
	}
	async function readAllBytes(reader) {
		const bytes = [];
		let byteLength = 0;
		while (true) {
			const { done: done$8, value: chunk$4 } = await reader.read();
			if (done$8) return Buffer.concat(bytes, byteLength);
			if (!isUint8Array$2(chunk$4)) throw new TypeError("Received non-Uint8Array chunk");
			bytes.push(chunk$4);
			byteLength += chunk$4.length;
		}
	}
	function urlIsLocal(url$2) {
		assert$18("protocol" in url$2);
		const protocol = url$2.protocol;
		return protocol === "about:" || protocol === "blob:" || protocol === "data:";
	}
	function urlHasHttpsScheme(url$2) {
		if (typeof url$2 === "string") return url$2.startsWith("https:");
		return url$2.protocol === "https:";
	}
	function urlIsHttpHttpsScheme(url$2) {
		assert$18("protocol" in url$2);
		const protocol = url$2.protocol;
		return protocol === "http:" || protocol === "https:";
	}
	module.exports = {
		isAborted,
		isCancelled,
		createDeferredPromise,
		ReadableStreamFrom,
		toUSVString,
		tryUpgradeRequestToAPotentiallyTrustworthyURL,
		coarsenedSharedCurrentTime,
		determineRequestsReferrer,
		makePolicyContainer,
		clonePolicyContainer,
		appendFetchMetadata,
		appendRequestOriginHeader,
		TAOCheck,
		corsCheck,
		crossOriginResourcePolicyCheck,
		createOpaqueTimingInfo,
		setRequestReferrerPolicyOnRedirect,
		isValidHTTPToken,
		requestBadPort,
		requestCurrentURL,
		responseURL,
		responseLocationURL,
		isBlobLike,
		isURLPotentiallyTrustworthy,
		isValidReasonPhrase,
		sameOrigin,
		normalizeMethod,
		serializeJavascriptValueToJSONString,
		makeIterator,
		isValidHeaderName,
		isValidHeaderValue,
		hasOwn: Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key)),
		isErrorLike,
		fullyReadBody,
		bytesMatch,
		isReadableStreamLike,
		readableStreamClose,
		isomorphicEncode,
		isomorphicDecode,
		urlIsLocal,
		urlHasHttpsScheme,
		urlIsHttpHttpsScheme,
		readAllBytes,
		normalizeMethodRecord,
		parseMetadata
	};
}));
var require_symbols$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kUrl: Symbol("url"),
		kHeaders: Symbol("headers"),
		kSignal: Symbol("signal"),
		kState: Symbol("state"),
		kGuard: Symbol("guard"),
		kRealm: Symbol("realm")
	};
}));
var require_webidl = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { types: types$4 } = __require("util");
	var { hasOwn, toUSVString } = require_util$5();
	var webidl = {};
	webidl.converters = {};
	webidl.util = {};
	webidl.errors = {};
	webidl.errors.exception = function(message) {
		return /* @__PURE__ */ new TypeError(`${message.header}: ${message.message}`);
	};
	webidl.errors.conversionFailed = function(context$3) {
		const plural = context$3.types.length === 1 ? "" : " one of";
		const message = `${context$3.argument} could not be converted to${plural}: ${context$3.types.join(", ")}.`;
		return webidl.errors.exception({
			header: context$3.prefix,
			message
		});
	};
	webidl.errors.invalidArgument = function(context$3) {
		return webidl.errors.exception({
			header: context$3.prefix,
			message: `"${context$3.value}" is an invalid ${context$3.type}.`
		});
	};
	webidl.brandCheck = function(V, I, opts = void 0) {
		if (opts?.strict !== false && !(V instanceof I)) throw new TypeError("Illegal invocation");
		else return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
	};
	webidl.argumentLengthCheck = function({ length: length$1 }, min$2, ctx) {
		if (length$1 < min$2) throw webidl.errors.exception({
			message: `${min$2} argument${min$2 !== 1 ? "s" : ""} required, but${length$1 ? " only" : ""} ${length$1} found.`,
			...ctx
		});
	};
	webidl.illegalConstructor = function() {
		throw webidl.errors.exception({
			header: "TypeError",
			message: "Illegal constructor"
		});
	};
	webidl.util.Type = function(V) {
		switch (typeof V) {
			case "undefined": return "Undefined";
			case "boolean": return "Boolean";
			case "string": return "String";
			case "symbol": return "Symbol";
			case "number": return "Number";
			case "bigint": return "BigInt";
			case "function":
			case "object":
				if (V === null) return "Null";
				return "Object";
		}
	};
	webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
		let upperBound;
		let lowerBound;
		if (bitLength === 64) {
			upperBound = Math.pow(2, 53) - 1;
			if (signedness === "unsigned") lowerBound = 0;
			else lowerBound = Math.pow(-2, 53) + 1;
		} else if (signedness === "unsigned") {
			lowerBound = 0;
			upperBound = Math.pow(2, bitLength) - 1;
		} else {
			lowerBound = Math.pow(-2, bitLength) - 1;
			upperBound = Math.pow(2, bitLength - 1) - 1;
		}
		let x = Number(V);
		if (x === 0) x = 0;
		if (opts.enforceRange === true) {
			if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) throw webidl.errors.exception({
				header: "Integer conversion",
				message: `Could not convert ${V} to an integer.`
			});
			x = webidl.util.IntegerPart(x);
			if (x < lowerBound || x > upperBound) throw webidl.errors.exception({
				header: "Integer conversion",
				message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
			});
			return x;
		}
		if (!Number.isNaN(x) && opts.clamp === true) {
			x = Math.min(Math.max(x, lowerBound), upperBound);
			if (Math.floor(x) % 2 === 0) x = Math.floor(x);
			else x = Math.ceil(x);
			return x;
		}
		if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) return 0;
		x = webidl.util.IntegerPart(x);
		x = x % Math.pow(2, bitLength);
		if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) return x - Math.pow(2, bitLength);
		return x;
	};
	webidl.util.IntegerPart = function(n) {
		const r = Math.floor(Math.abs(n));
		if (n < 0) return -1 * r;
		return r;
	};
	webidl.sequenceConverter = function(converter) {
		return (V) => {
			if (webidl.util.Type(V) !== "Object") throw webidl.errors.exception({
				header: "Sequence",
				message: `Value of type ${webidl.util.Type(V)} is not an Object.`
			});
			const method = V?.[Symbol.iterator]?.();
			const seq$1 = [];
			if (method === void 0 || typeof method.next !== "function") throw webidl.errors.exception({
				header: "Sequence",
				message: "Object is not an iterator."
			});
			while (true) {
				const { done: done$8, value: value$2 } = method.next();
				if (done$8) break;
				seq$1.push(converter(value$2));
			}
			return seq$1;
		};
	};
	webidl.recordConverter = function(keyConverter, valueConverter) {
		return (O) => {
			if (webidl.util.Type(O) !== "Object") throw webidl.errors.exception({
				header: "Record",
				message: `Value of type ${webidl.util.Type(O)} is not an Object.`
			});
			const result = {};
			if (!types$4.isProxy(O)) {
				const keys$6 = Object.keys(O);
				for (const key of keys$6) {
					const typedKey = keyConverter(key);
					result[typedKey] = valueConverter(O[key]);
				}
				return result;
			}
			const keys$5 = Reflect.ownKeys(O);
			for (const key of keys$5) if (Reflect.getOwnPropertyDescriptor(O, key)?.enumerable) {
				const typedKey = keyConverter(key);
				result[typedKey] = valueConverter(O[key]);
			}
			return result;
		};
	};
	webidl.interfaceConverter = function(i) {
		return (V, opts = {}) => {
			if (opts.strict !== false && !(V instanceof i)) throw webidl.errors.exception({
				header: i.name,
				message: `Expected ${V} to be an instance of ${i.name}.`
			});
			return V;
		};
	};
	webidl.dictionaryConverter = function(converters) {
		return (dictionary) => {
			const type = webidl.util.Type(dictionary);
			const dict = {};
			if (type === "Null" || type === "Undefined") return dict;
			else if (type !== "Object") throw webidl.errors.exception({
				header: "Dictionary",
				message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
			});
			for (const options of converters) {
				const { key, defaultValue, required, converter } = options;
				if (required === true) {
					if (!hasOwn(dictionary, key)) throw webidl.errors.exception({
						header: "Dictionary",
						message: `Missing required key "${key}".`
					});
				}
				let value$2 = dictionary[key];
				const hasDefault = hasOwn(options, "defaultValue");
				if (hasDefault && value$2 !== null) value$2 = value$2 ?? defaultValue;
				if (required || hasDefault || value$2 !== void 0) {
					value$2 = converter(value$2);
					if (options.allowedValues && !options.allowedValues.includes(value$2)) throw webidl.errors.exception({
						header: "Dictionary",
						message: `${value$2} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
					});
					dict[key] = value$2;
				}
			}
			return dict;
		};
	};
	webidl.nullableConverter = function(converter) {
		return (V) => {
			if (V === null) return V;
			return converter(V);
		};
	};
	webidl.converters.DOMString = function(V, opts = {}) {
		if (V === null && opts.legacyNullToEmptyString) return "";
		if (typeof V === "symbol") throw new TypeError("Could not convert argument of type symbol to string.");
		return String(V);
	};
	webidl.converters.ByteString = function(V) {
		const x = webidl.converters.DOMString(V);
		for (let index = 0; index < x.length; index++) if (x.charCodeAt(index) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
		return x;
	};
	webidl.converters.USVString = toUSVString;
	webidl.converters.boolean = function(V) {
		return Boolean(V);
	};
	webidl.converters.any = function(V) {
		return V;
	};
	webidl.converters["long long"] = function(V) {
		return webidl.util.ConvertToInt(V, 64, "signed");
	};
	webidl.converters["unsigned long long"] = function(V) {
		return webidl.util.ConvertToInt(V, 64, "unsigned");
	};
	webidl.converters["unsigned long"] = function(V) {
		return webidl.util.ConvertToInt(V, 32, "unsigned");
	};
	webidl.converters["unsigned short"] = function(V, opts) {
		return webidl.util.ConvertToInt(V, 16, "unsigned", opts);
	};
	webidl.converters.ArrayBuffer = function(V, opts = {}) {
		if (webidl.util.Type(V) !== "Object" || !types$4.isAnyArrayBuffer(V)) throw webidl.errors.conversionFailed({
			prefix: `${V}`,
			argument: `${V}`,
			types: ["ArrayBuffer"]
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V)) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl.converters.TypedArray = function(V, T, opts = {}) {
		if (webidl.util.Type(V) !== "Object" || !types$4.isTypedArray(V) || V.constructor.name !== T.name) throw webidl.errors.conversionFailed({
			prefix: `${T.name}`,
			argument: `${V}`,
			types: [T.name]
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl.converters.DataView = function(V, opts = {}) {
		if (webidl.util.Type(V) !== "Object" || !types$4.isDataView(V)) throw webidl.errors.exception({
			header: "DataView",
			message: "Object is not a DataView."
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl.converters.BufferSource = function(V, opts = {}) {
		if (types$4.isAnyArrayBuffer(V)) return webidl.converters.ArrayBuffer(V, opts);
		if (types$4.isTypedArray(V)) return webidl.converters.TypedArray(V, V.constructor);
		if (types$4.isDataView(V)) return webidl.converters.DataView(V, opts);
		throw new TypeError(`Could not convert ${V} to a BufferSource.`);
	};
	webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
	webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
	webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
	module.exports = { webidl };
}));
var require_dataURL = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert$17 = __require("assert");
	var { atob: atob$1 } = __require("buffer");
	var { isomorphicDecode } = require_util$5();
	var encoder = new TextEncoder();
	var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
	var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
	var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
	function dataURLProcessor(dataURL) {
		assert$17(dataURL.protocol === "data:");
		let input = URLSerializer(dataURL, true);
		input = input.slice(5);
		const position = { position: 0 };
		let mimeType = collectASequenceOfCodePointsFast(",", input, position);
		const mimeTypeLength = mimeType.length;
		mimeType = removeASCIIWhitespace(mimeType, true, true);
		if (position.position >= input.length) return "failure";
		position.position++;
		let body = stringPercentDecode(input.slice(mimeTypeLength + 1));
		if (/;(\u0020){0,}base64$/i.test(mimeType)) {
			body = forgivingBase64(isomorphicDecode(body));
			if (body === "failure") return "failure";
			mimeType = mimeType.slice(0, -6);
			mimeType = mimeType.replace(/(\u0020)+$/, "");
			mimeType = mimeType.slice(0, -1);
		}
		if (mimeType.startsWith(";")) mimeType = "text/plain" + mimeType;
		let mimeTypeRecord = parseMIMEType(mimeType);
		if (mimeTypeRecord === "failure") mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
		return {
			mimeType: mimeTypeRecord,
			body
		};
	}
	function URLSerializer(url$2, excludeFragment = false) {
		if (!excludeFragment) return url$2.href;
		const href = url$2.href;
		const hashLength = url$2.hash.length;
		return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
	}
	function collectASequenceOfCodePoints(condition, input, position) {
		let result = "";
		while (position.position < input.length && condition(input[position.position])) {
			result += input[position.position];
			position.position++;
		}
		return result;
	}
	function collectASequenceOfCodePointsFast(char, input, position) {
		const idx = input.indexOf(char, position.position);
		const start$2 = position.position;
		if (idx === -1) {
			position.position = input.length;
			return input.slice(start$2);
		}
		position.position = idx;
		return input.slice(start$2, position.position);
	}
	function stringPercentDecode(input) {
		return percentDecode(encoder.encode(input));
	}
	function percentDecode(input) {
		const output = [];
		for (let i = 0; i < input.length; i++) {
			const byte = input[i];
			if (byte !== 37) output.push(byte);
			else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) output.push(37);
			else {
				const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
				const bytePoint = Number.parseInt(nextTwoBytes, 16);
				output.push(bytePoint);
				i += 2;
			}
		}
		return Uint8Array.from(output);
	}
	function parseMIMEType(input) {
		input = removeHTTPWhitespace(input, true, true);
		const position = { position: 0 };
		const type = collectASequenceOfCodePointsFast("/", input, position);
		if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) return "failure";
		if (position.position > input.length) return "failure";
		position.position++;
		let subtype = collectASequenceOfCodePointsFast(";", input, position);
		subtype = removeHTTPWhitespace(subtype, false, true);
		if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return "failure";
		const typeLowercase = type.toLowerCase();
		const subtypeLowercase = subtype.toLowerCase();
		const mimeType = {
			type: typeLowercase,
			subtype: subtypeLowercase,
			parameters: /* @__PURE__ */ new Map(),
			essence: `${typeLowercase}/${subtypeLowercase}`
		};
		while (position.position < input.length) {
			position.position++;
			collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
			let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
			parameterName = parameterName.toLowerCase();
			if (position.position < input.length) {
				if (input[position.position] === ";") continue;
				position.position++;
			}
			if (position.position > input.length) break;
			let parameterValue = null;
			if (input[position.position] === "\"") {
				parameterValue = collectAnHTTPQuotedString(input, position, true);
				collectASequenceOfCodePointsFast(";", input, position);
			} else {
				parameterValue = collectASequenceOfCodePointsFast(";", input, position);
				parameterValue = removeHTTPWhitespace(parameterValue, false, true);
				if (parameterValue.length === 0) continue;
			}
			if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);
		}
		return mimeType;
	}
	function forgivingBase64(data) {
		data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
		if (data.length % 4 === 0) data = data.replace(/=?=$/, "");
		if (data.length % 4 === 1) return "failure";
		if (/[^+/0-9A-Za-z]/.test(data)) return "failure";
		const binary = atob$1(data);
		const bytes = new Uint8Array(binary.length);
		for (let byte = 0; byte < binary.length; byte++) bytes[byte] = binary.charCodeAt(byte);
		return bytes;
	}
	function collectAnHTTPQuotedString(input, position, extractValue) {
		const positionStart = position.position;
		let value$2 = "";
		assert$17(input[position.position] === "\"");
		position.position++;
		while (true) {
			value$2 += collectASequenceOfCodePoints((char) => char !== "\"" && char !== "\\", input, position);
			if (position.position >= input.length) break;
			const quoteOrBackslash = input[position.position];
			position.position++;
			if (quoteOrBackslash === "\\") {
				if (position.position >= input.length) {
					value$2 += "\\";
					break;
				}
				value$2 += input[position.position];
				position.position++;
			} else {
				assert$17(quoteOrBackslash === "\"");
				break;
			}
		}
		if (extractValue) return value$2;
		return input.slice(positionStart, position.position);
	}
	function serializeAMimeType(mimeType) {
		assert$17(mimeType !== "failure");
		const { parameters, essence } = mimeType;
		let serialization = essence;
		for (let [name, value$2] of parameters.entries()) {
			serialization += ";";
			serialization += name;
			serialization += "=";
			if (!HTTP_TOKEN_CODEPOINTS.test(value$2)) {
				value$2 = value$2.replace(/(\\|")/g, "\\$1");
				value$2 = "\"" + value$2;
				value$2 += "\"";
			}
			serialization += value$2;
		}
		return serialization;
	}
	function isHTTPWhiteSpace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === " ";
	}
	function removeHTTPWhitespace(str, leading = true, trailing = true) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
		if (trailing) for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
		return str.slice(lead, trail + 1);
	}
	function isASCIIWhitespace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
	}
	function removeASCIIWhitespace(str, leading = true, trailing = true) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
		if (trailing) for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
		return str.slice(lead, trail + 1);
	}
	module.exports = {
		dataURLProcessor,
		URLSerializer,
		collectASequenceOfCodePoints,
		collectASequenceOfCodePointsFast,
		stringPercentDecode,
		parseMIMEType,
		collectAnHTTPQuotedString,
		serializeAMimeType
	};
}));
var require_file = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Blob: Blob$3, File: NativeFile$2 } = __require("buffer");
	var { types: types$3 } = __require("util");
	var { kState } = require_symbols$3();
	var { isBlobLike } = require_util$5();
	var { webidl } = require_webidl();
	var { parseMIMEType, serializeAMimeType } = require_dataURL();
	var { kEnumerableProperty } = require_util$6();
	var encoder = new TextEncoder();
	var File = class File extends Blob$3 {
		constructor(fileBits, fileName, options = {}) {
			webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
			fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
			fileName = webidl.converters.USVString(fileName);
			options = webidl.converters.FilePropertyBag(options);
			const n = fileName;
			let t = options.type;
			let d;
			substep: {
				if (t) {
					t = parseMIMEType(t);
					if (t === "failure") {
						t = "";
						break substep;
					}
					t = serializeAMimeType(t).toLowerCase();
				}
				d = options.lastModified;
			}
			super(processBlobParts(fileBits, options), { type: t });
			this[kState] = {
				name: n,
				lastModified: d,
				type: t
			};
		}
		get name() {
			webidl.brandCheck(this, File);
			return this[kState].name;
		}
		get lastModified() {
			webidl.brandCheck(this, File);
			return this[kState].lastModified;
		}
		get type() {
			webidl.brandCheck(this, File);
			return this[kState].type;
		}
	};
	var FileLike = class FileLike {
		constructor(blobLike, fileName, options = {}) {
			this[kState] = {
				blobLike,
				name: fileName,
				type: options.type,
				lastModified: options.lastModified ?? Date.now()
			};
		}
		stream(...args$1) {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.stream(...args$1);
		}
		arrayBuffer(...args$1) {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.arrayBuffer(...args$1);
		}
		slice(...args$1) {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.slice(...args$1);
		}
		text(...args$1) {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.text(...args$1);
		}
		get size() {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.size;
		}
		get type() {
			webidl.brandCheck(this, FileLike);
			return this[kState].blobLike.type;
		}
		get name() {
			webidl.brandCheck(this, FileLike);
			return this[kState].name;
		}
		get lastModified() {
			webidl.brandCheck(this, FileLike);
			return this[kState].lastModified;
		}
		get [Symbol.toStringTag]() {
			return "File";
		}
	};
	Object.defineProperties(File.prototype, {
		[Symbol.toStringTag]: {
			value: "File",
			configurable: true
		},
		name: kEnumerableProperty,
		lastModified: kEnumerableProperty
	});
	webidl.converters.Blob = webidl.interfaceConverter(Blob$3);
	webidl.converters.BlobPart = function(V, opts) {
		if (webidl.util.Type(V) === "Object") {
			if (isBlobLike(V)) return webidl.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types$3.isAnyArrayBuffer(V)) return webidl.converters.BufferSource(V, opts);
		}
		return webidl.converters.USVString(V, opts);
	};
	webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(webidl.converters.BlobPart);
	webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
		{
			key: "lastModified",
			converter: webidl.converters["long long"],
			get defaultValue() {
				return Date.now();
			}
		},
		{
			key: "type",
			converter: webidl.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "endings",
			converter: (value$2) => {
				value$2 = webidl.converters.DOMString(value$2);
				value$2 = value$2.toLowerCase();
				if (value$2 !== "native") value$2 = "transparent";
				return value$2;
			},
			defaultValue: "transparent"
		}
	]);
	function processBlobParts(parts$1, options) {
		const bytes = [];
		for (const element of parts$1) if (typeof element === "string") {
			let s = element;
			if (options.endings === "native") s = convertLineEndingsNative(s);
			bytes.push(encoder.encode(s));
		} else if (types$3.isAnyArrayBuffer(element) || types$3.isTypedArray(element)) if (!element.buffer) bytes.push(new Uint8Array(element));
		else bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
		else if (isBlobLike(element)) bytes.push(element);
		return bytes;
	}
	function convertLineEndingsNative(s) {
		let nativeLineEnding = "\n";
		if (process.platform === "win32") nativeLineEnding = "\r\n";
		return s.replace(/\r?\n/g, nativeLineEnding);
	}
	function isFileLike(object) {
		return NativeFile$2 && object instanceof NativeFile$2 || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
	}
	module.exports = {
		File,
		FileLike,
		isFileLike
	};
}));
var require_formdata = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { isBlobLike, toUSVString, makeIterator } = require_util$5();
	var { kState } = require_symbols$3();
	var { File: UndiciFile, FileLike, isFileLike } = require_file();
	var { webidl } = require_webidl();
	var { Blob: Blob$2, File: NativeFile$1 } = __require("buffer");
	var File = NativeFile$1 ?? UndiciFile;
	var FormData = class FormData {
		constructor(form) {
			if (form !== void 0) throw webidl.errors.conversionFailed({
				prefix: "FormData constructor",
				argument: "Argument 1",
				types: ["undefined"]
			});
			this[kState] = [];
		}
		append(name, value$2, filename = void 0) {
			webidl.brandCheck(this, FormData);
			webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
			if (arguments.length === 3 && !isBlobLike(value$2)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl.converters.USVString(name);
			value$2 = isBlobLike(value$2) ? webidl.converters.Blob(value$2, { strict: false }) : webidl.converters.USVString(value$2);
			filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
			const entry = makeEntry(name, value$2, filename);
			this[kState].push(entry);
		}
		delete(name) {
			webidl.brandCheck(this, FormData);
			webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
			name = webidl.converters.USVString(name);
			this[kState] = this[kState].filter((entry) => entry.name !== name);
		}
		get(name) {
			webidl.brandCheck(this, FormData);
			webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
			name = webidl.converters.USVString(name);
			const idx = this[kState].findIndex((entry) => entry.name === name);
			if (idx === -1) return null;
			return this[kState][idx].value;
		}
		getAll(name) {
			webidl.brandCheck(this, FormData);
			webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
			name = webidl.converters.USVString(name);
			return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
		}
		has(name) {
			webidl.brandCheck(this, FormData);
			webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
			name = webidl.converters.USVString(name);
			return this[kState].findIndex((entry) => entry.name === name) !== -1;
		}
		set(name, value$2, filename = void 0) {
			webidl.brandCheck(this, FormData);
			webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
			if (arguments.length === 3 && !isBlobLike(value$2)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl.converters.USVString(name);
			value$2 = isBlobLike(value$2) ? webidl.converters.Blob(value$2, { strict: false }) : webidl.converters.USVString(value$2);
			filename = arguments.length === 3 ? toUSVString(filename) : void 0;
			const entry = makeEntry(name, value$2, filename);
			const idx = this[kState].findIndex((entry$1) => entry$1.name === name);
			if (idx !== -1) this[kState] = [
				...this[kState].slice(0, idx),
				entry,
				...this[kState].slice(idx + 1).filter((entry$1) => entry$1.name !== name)
			];
			else this[kState].push(entry);
		}
		entries() {
			webidl.brandCheck(this, FormData);
			return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
		}
		keys() {
			webidl.brandCheck(this, FormData);
			return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key");
		}
		values() {
			webidl.brandCheck(this, FormData);
			return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "value");
		}
		forEach(callbackFn, thisArg = globalThis) {
			webidl.brandCheck(this, FormData);
			webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
			for (const [key, value$2] of this) callbackFn.apply(thisArg, [
				value$2,
				key,
				this
			]);
		}
	};
	FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
	Object.defineProperties(FormData.prototype, { [Symbol.toStringTag]: {
		value: "FormData",
		configurable: true
	} });
	function makeEntry(name, value$2, filename) {
		name = Buffer.from(name).toString("utf8");
		if (typeof value$2 === "string") value$2 = Buffer.from(value$2).toString("utf8");
		else {
			if (!isFileLike(value$2)) value$2 = value$2 instanceof Blob$2 ? new File([value$2], "blob", { type: value$2.type }) : new FileLike(value$2, "blob", { type: value$2.type });
			if (filename !== void 0) {
				const options = {
					type: value$2.type,
					lastModified: value$2.lastModified
				};
				value$2 = NativeFile$1 && value$2 instanceof NativeFile$1 || value$2 instanceof UndiciFile ? new File([value$2], filename, options) : new FileLike(value$2, filename, options);
			}
		}
		return {
			name,
			value: value$2
		};
	}
	module.exports = { FormData };
}));
var require_body = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Busboy = require_main();
	var util = require_util$6();
	var { ReadableStreamFrom, isBlobLike, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody } = require_util$5();
	var { FormData } = require_formdata();
	var { kState } = require_symbols$3();
	var { webidl } = require_webidl();
	var { DOMException, structuredClone } = require_constants$3();
	var { Blob: Blob$1, File: NativeFile } = __require("buffer");
	var { kBodyUsed } = require_symbols$4();
	var assert$16 = __require("assert");
	var { isErrored } = require_util$6();
	var { isUint8Array: isUint8Array$1, isArrayBuffer } = __require("util/types");
	var { File: UndiciFile } = require_file();
	var { parseMIMEType, serializeAMimeType } = require_dataURL();
	var random;
	try {
		const crypto$1 = __require("node:crypto");
		random = (max$4) => crypto$1.randomInt(0, max$4);
	} catch {
		random = (max$4) => Math.floor(Math.random(max$4));
	}
	var ReadableStream = globalThis.ReadableStream;
	var File = NativeFile ?? UndiciFile;
	var textEncoder = new TextEncoder();
	var textDecoder = new TextDecoder();
	function extractBody(object, keepalive = false) {
		if (!ReadableStream) ReadableStream = __require("stream/web").ReadableStream;
		let stream$1 = null;
		if (object instanceof ReadableStream) stream$1 = object;
		else if (isBlobLike(object)) stream$1 = object.stream();
		else stream$1 = new ReadableStream({
			async pull(controller) {
				controller.enqueue(typeof source === "string" ? textEncoder.encode(source) : source);
				queueMicrotask(() => readableStreamClose(controller));
			},
			start() {},
			type: void 0
		});
		assert$16(isReadableStreamLike(stream$1));
		let action = null;
		let source = null;
		let length$1 = null;
		let type = null;
		if (typeof object === "string") {
			source = object;
			type = "text/plain;charset=UTF-8";
		} else if (object instanceof URLSearchParams) {
			source = object.toString();
			type = "application/x-www-form-urlencoded;charset=UTF-8";
		} else if (isArrayBuffer(object)) source = new Uint8Array(object.slice());
		else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
		else if (util.isFormDataLike(object)) {
			const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
			const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
			const escape$1 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
			const normalizeLinefeeds = (value$2) => value$2.replace(/\r?\n|\r/g, "\r\n");
			const blobParts = [];
			const rn = new Uint8Array([13, 10]);
			length$1 = 0;
			let hasUnknownSizeValue = false;
			for (const [name, value$2] of object) if (typeof value$2 === "string") {
				const chunk$5 = textEncoder.encode(prefix + `; name="${escape$1(normalizeLinefeeds(name))}"\r\n\r\n${normalizeLinefeeds(value$2)}\r\n`);
				blobParts.push(chunk$5);
				length$1 += chunk$5.byteLength;
			} else {
				const chunk$5 = textEncoder.encode(`${prefix}; name="${escape$1(normalizeLinefeeds(name))}"` + (value$2.name ? `; filename="${escape$1(value$2.name)}"` : "") + `\r
Content-Type: ${value$2.type || "application/octet-stream"}\r\n\r\n`);
				blobParts.push(chunk$5, value$2, rn);
				if (typeof value$2.size === "number") length$1 += chunk$5.byteLength + value$2.size + rn.byteLength;
				else hasUnknownSizeValue = true;
			}
			const chunk$4 = textEncoder.encode(`--${boundary}--`);
			blobParts.push(chunk$4);
			length$1 += chunk$4.byteLength;
			if (hasUnknownSizeValue) length$1 = null;
			source = object;
			action = async function* () {
				for (const part of blobParts) if (part.stream) yield* part.stream();
				else yield part;
			};
			type = "multipart/form-data; boundary=" + boundary;
		} else if (isBlobLike(object)) {
			source = object;
			length$1 = object.size;
			if (object.type) type = object.type;
		} else if (typeof object[Symbol.asyncIterator] === "function") {
			if (keepalive) throw new TypeError("keepalive");
			if (util.isDisturbed(object) || object.locked) throw new TypeError("Response body object should not be disturbed or locked");
			stream$1 = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
		}
		if (typeof source === "string" || util.isBuffer(source)) length$1 = Buffer.byteLength(source);
		if (action != null) {
			let iterator;
			stream$1 = new ReadableStream({
				async start() {
					iterator = action(object)[Symbol.asyncIterator]();
				},
				async pull(controller) {
					const { value: value$2, done: done$8 } = await iterator.next();
					if (done$8) queueMicrotask(() => {
						controller.close();
					});
					else if (!isErrored(stream$1)) controller.enqueue(new Uint8Array(value$2));
					return controller.desiredSize > 0;
				},
				async cancel(reason) {
					await iterator.return();
				},
				type: void 0
			});
		}
		return [{
			stream: stream$1,
			source,
			length: length$1
		}, type];
	}
	function safelyExtractBody(object, keepalive = false) {
		if (!ReadableStream)
 // istanbul ignore next
		ReadableStream = __require("stream/web").ReadableStream;
		if (object instanceof ReadableStream) {
			// istanbul ignore next
			assert$16(!util.isDisturbed(object), "The body has already been consumed.");
			// istanbul ignore next
			assert$16(!object.locked, "The stream is locked.");
		}
		return extractBody(object, keepalive);
	}
	function cloneBody(body) {
		const [out1, out2] = body.stream.tee();
		const [, finalClone] = structuredClone(out2, { transfer: [out2] }).tee();
		body.stream = out1;
		return {
			stream: finalClone,
			length: body.length,
			source: body.source
		};
	}
	async function* consumeBody(body) {
		if (body) if (isUint8Array$1(body)) yield body;
		else {
			const stream$1 = body.stream;
			if (util.isDisturbed(stream$1)) throw new TypeError("The body has already been consumed.");
			if (stream$1.locked) throw new TypeError("The stream is locked.");
			stream$1[kBodyUsed] = true;
			yield* stream$1;
		}
	}
	function throwIfAborted(state) {
		if (state.aborted) throw new DOMException("The operation was aborted.", "AbortError");
	}
	function bodyMixinMethods(instance) {
		return {
			blob() {
				return specConsumeBody(this, (bytes) => {
					let mimeType = bodyMimeType(this);
					if (mimeType === "failure") mimeType = "";
					else if (mimeType) mimeType = serializeAMimeType(mimeType);
					return new Blob$1([bytes], { type: mimeType });
				}, instance);
			},
			arrayBuffer() {
				return specConsumeBody(this, (bytes) => {
					return new Uint8Array(bytes).buffer;
				}, instance);
			},
			text() {
				return specConsumeBody(this, utf8DecodeBytes, instance);
			},
			json() {
				return specConsumeBody(this, parseJSONFromBytes, instance);
			},
			async formData() {
				webidl.brandCheck(this, instance);
				throwIfAborted(this[kState]);
				const contentType = this.headers.get("Content-Type");
				if (/multipart\/form-data/.test(contentType)) {
					const headers = {};
					for (const [key, value$2] of this.headers) headers[key.toLowerCase()] = value$2;
					const responseFormData = new FormData();
					let busboy;
					try {
						busboy = new Busboy({
							headers,
							preservePath: true
						});
					} catch (err) {
						throw new DOMException(`${err}`, "AbortError");
					}
					busboy.on("field", (name, value$2) => {
						responseFormData.append(name, value$2);
					});
					busboy.on("file", (name, value$2, filename, encoding, mimeType) => {
						const chunks = [];
						if (encoding === "base64" || encoding.toLowerCase() === "base64") {
							let base64chunk = "";
							value$2.on("data", (chunk$4) => {
								base64chunk += chunk$4.toString().replace(/[\r\n]/gm, "");
								const end$2 = base64chunk.length - base64chunk.length % 4;
								chunks.push(Buffer.from(base64chunk.slice(0, end$2), "base64"));
								base64chunk = base64chunk.slice(end$2);
							});
							value$2.on("end", () => {
								chunks.push(Buffer.from(base64chunk, "base64"));
								responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
							});
						} else {
							value$2.on("data", (chunk$4) => {
								chunks.push(chunk$4);
							});
							value$2.on("end", () => {
								responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
							});
						}
					});
					const busboyResolve = new Promise((resolve, reject) => {
						busboy.on("finish", resolve);
						busboy.on("error", (err) => reject(new TypeError(err)));
					});
					if (this.body !== null) for await (const chunk$4 of consumeBody(this[kState].body)) busboy.write(chunk$4);
					busboy.end();
					await busboyResolve;
					return responseFormData;
				} else if (/application\/x-www-form-urlencoded/.test(contentType)) {
					let entries$2;
					try {
						let text = "";
						const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
						for await (const chunk$4 of consumeBody(this[kState].body)) {
							if (!isUint8Array$1(chunk$4)) throw new TypeError("Expected Uint8Array chunk");
							text += streamingDecoder.decode(chunk$4, { stream: true });
						}
						text += streamingDecoder.decode();
						entries$2 = new URLSearchParams(text);
					} catch (err) {
						// istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
						throw Object.assign(/* @__PURE__ */ new TypeError(), { cause: err });
					}
					const formData = new FormData();
					for (const [name, value$2] of entries$2) formData.append(name, value$2);
					return formData;
				} else {
					await Promise.resolve();
					throwIfAborted(this[kState]);
					throw webidl.errors.exception({
						header: `${instance.name}.formData`,
						message: "Could not parse content as FormData."
					});
				}
			}
		};
	}
	function mixinBody(prototype) {
		Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}
	async function specConsumeBody(object, convertBytesToJSValue, instance) {
		webidl.brandCheck(object, instance);
		throwIfAborted(object[kState]);
		if (bodyUnusable(object[kState].body)) throw new TypeError("Body is unusable");
		const promise$2 = createDeferredPromise();
		const errorSteps = (error) => promise$2.reject(error);
		const successSteps = (data) => {
			try {
				promise$2.resolve(convertBytesToJSValue(data));
			} catch (e) {
				errorSteps(e);
			}
		};
		if (object[kState].body == null) {
			successSteps(new Uint8Array());
			return promise$2.promise;
		}
		await fullyReadBody(object[kState].body, successSteps, errorSteps);
		return promise$2.promise;
	}
	function bodyUnusable(body) {
		return body != null && (body.stream.locked || util.isDisturbed(body.stream));
	}
	function utf8DecodeBytes(buffer) {
		if (buffer.length === 0) return "";
		if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) buffer = buffer.subarray(3);
		return textDecoder.decode(buffer);
	}
	function parseJSONFromBytes(bytes) {
		return JSON.parse(utf8DecodeBytes(bytes));
	}
	function bodyMimeType(object) {
		const { headersList } = object[kState];
		const contentType = headersList.get("content-type");
		if (contentType === null) return "failure";
		return parseMIMEType(contentType);
	}
	module.exports = {
		extractBody,
		safelyExtractBody,
		cloneBody,
		mixinBody
	};
}));
var require_request$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { InvalidArgumentError, NotSupportedError } = require_errors();
	var assert$15 = __require("assert");
	var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols$4();
	var util = require_util$6();
	var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
	var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
	var invalidPathRegex = /[^\u0021-\u00ff]/;
	var kHandler = Symbol("handler");
	var channels = {};
	var extractBody;
	try {
		const diagnosticsChannel$2 = __require("diagnostics_channel");
		channels.create = diagnosticsChannel$2.channel("undici:request:create");
		channels.bodySent = diagnosticsChannel$2.channel("undici:request:bodySent");
		channels.headers = diagnosticsChannel$2.channel("undici:request:headers");
		channels.trailers = diagnosticsChannel$2.channel("undici:request:trailers");
		channels.error = diagnosticsChannel$2.channel("undici:request:error");
	} catch {
		channels.create = { hasSubscribers: false };
		channels.bodySent = { hasSubscribers: false };
		channels.headers = { hasSubscribers: false };
		channels.trailers = { hasSubscribers: false };
		channels.error = { hasSubscribers: false };
	}
	var Request = class Request {
		constructor(origin, { path: path$5, method, body, headers, query, idempotent, blocking, upgrade, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue }, handler) {
			if (typeof path$5 !== "string") throw new InvalidArgumentError("path must be a string");
			else if (path$5[0] !== "/" && !(path$5.startsWith("http://") || path$5.startsWith("https://")) && method !== "CONNECT") throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
			else if (invalidPathRegex.exec(path$5) !== null) throw new InvalidArgumentError("invalid request path");
			if (typeof method !== "string") throw new InvalidArgumentError("method must be a string");
			else if (tokenRegExp.exec(method) === null) throw new InvalidArgumentError("invalid request method");
			if (upgrade && typeof upgrade !== "string") throw new InvalidArgumentError("upgrade must be a string");
			if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError("invalid headersTimeout");
			if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError("invalid bodyTimeout");
			if (reset != null && typeof reset !== "boolean") throw new InvalidArgumentError("invalid reset");
			if (expectContinue != null && typeof expectContinue !== "boolean") throw new InvalidArgumentError("invalid expectContinue");
			this.headersTimeout = headersTimeout;
			this.bodyTimeout = bodyTimeout;
			this.throwOnError = throwOnError === true;
			this.method = method;
			this.abort = null;
			if (body == null) this.body = null;
			else if (util.isStream(body)) {
				this.body = body;
				const rState = this.body._readableState;
				if (!rState || !rState.autoDestroy) {
					this.endHandler = function autoDestroy() {
						util.destroy(this);
					};
					this.body.on("end", this.endHandler);
				}
				this.errorHandler = (err) => {
					if (this.abort) this.abort(err);
					else this.error = err;
				};
				this.body.on("error", this.errorHandler);
			} else if (util.isBuffer(body)) this.body = body.byteLength ? body : null;
			else if (ArrayBuffer.isView(body)) this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
			else if (body instanceof ArrayBuffer) this.body = body.byteLength ? Buffer.from(body) : null;
			else if (typeof body === "string") this.body = body.length ? Buffer.from(body) : null;
			else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) this.body = body;
			else throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
			this.completed = false;
			this.aborted = false;
			this.upgrade = upgrade || null;
			this.path = query ? util.buildURL(path$5, query) : path$5;
			this.origin = origin;
			this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
			this.blocking = blocking == null ? false : blocking;
			this.reset = reset == null ? null : reset;
			this.host = null;
			this.contentLength = null;
			this.contentType = null;
			this.headers = "";
			this.expectContinue = expectContinue != null ? expectContinue : false;
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError("headers array must be even");
				for (let i = 0; i < headers.length; i += 2) processHeader(this, headers[i], headers[i + 1]);
			} else if (headers && typeof headers === "object") {
				const keys$5 = Object.keys(headers);
				for (let i = 0; i < keys$5.length; i++) {
					const key = keys$5[i];
					processHeader(this, key, headers[key]);
				}
			} else if (headers != null) throw new InvalidArgumentError("headers must be an object or an array");
			if (util.isFormDataLike(this.body)) {
				if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
				if (!extractBody) extractBody = require_body().extractBody;
				const [bodyStream, contentType] = extractBody(body);
				if (this.contentType == null) {
					this.contentType = contentType;
					this.headers += `content-type: ${contentType}\r\n`;
				}
				this.body = bodyStream.stream;
				this.contentLength = bodyStream.length;
			} else if (util.isBlobLike(body) && this.contentType == null && body.type) {
				this.contentType = body.type;
				this.headers += `content-type: ${body.type}\r\n`;
			}
			util.validateHandler(handler, method, upgrade);
			this.servername = util.getServerName(this.host);
			this[kHandler] = handler;
			if (channels.create.hasSubscribers) channels.create.publish({ request: this });
		}
		onBodySent(chunk$4) {
			if (this[kHandler].onBodySent) try {
				return this[kHandler].onBodySent(chunk$4);
			} catch (err) {
				this.abort(err);
			}
		}
		onRequestSent() {
			if (channels.bodySent.hasSubscribers) channels.bodySent.publish({ request: this });
			if (this[kHandler].onRequestSent) try {
				return this[kHandler].onRequestSent();
			} catch (err) {
				this.abort(err);
			}
		}
		onConnect(abort) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			if (this.error) abort(this.error);
			else {
				this.abort = abort;
				return this[kHandler].onConnect(abort);
			}
		}
		onHeaders(statusCode, headers, resume$1, statusText) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			if (channels.headers.hasSubscribers) channels.headers.publish({
				request: this,
				response: {
					statusCode,
					headers,
					statusText
				}
			});
			try {
				return this[kHandler].onHeaders(statusCode, headers, resume$1, statusText);
			} catch (err) {
				this.abort(err);
			}
		}
		onData(chunk$4) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			try {
				return this[kHandler].onData(chunk$4);
			} catch (err) {
				this.abort(err);
				return false;
			}
		}
		onUpgrade(statusCode, headers, socket) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			return this[kHandler].onUpgrade(statusCode, headers, socket);
		}
		onComplete(trailers) {
			this.onFinally();
			assert$15(!this.aborted);
			this.completed = true;
			if (channels.trailers.hasSubscribers) channels.trailers.publish({
				request: this,
				trailers
			});
			try {
				return this[kHandler].onComplete(trailers);
			} catch (err) {
				this.onError(err);
			}
		}
		onError(error) {
			this.onFinally();
			if (channels.error.hasSubscribers) channels.error.publish({
				request: this,
				error
			});
			if (this.aborted) return;
			this.aborted = true;
			return this[kHandler].onError(error);
		}
		onFinally() {
			if (this.errorHandler) {
				this.body.off("error", this.errorHandler);
				this.errorHandler = null;
			}
			if (this.endHandler) {
				this.body.off("end", this.endHandler);
				this.endHandler = null;
			}
		}
		addHeader(key, value$2) {
			processHeader(this, key, value$2);
			return this;
		}
		static [kHTTP1BuildRequest](origin, opts, handler) {
			return new Request(origin, opts, handler);
		}
		static [kHTTP2BuildRequest](origin, opts, handler) {
			const headers = opts.headers;
			opts = {
				...opts,
				headers: null
			};
			const request$1 = new Request(origin, opts, handler);
			request$1.headers = {};
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError("headers array must be even");
				for (let i = 0; i < headers.length; i += 2) processHeader(request$1, headers[i], headers[i + 1], true);
			} else if (headers && typeof headers === "object") {
				const keys$5 = Object.keys(headers);
				for (let i = 0; i < keys$5.length; i++) {
					const key = keys$5[i];
					processHeader(request$1, key, headers[key], true);
				}
			} else if (headers != null) throw new InvalidArgumentError("headers must be an object or an array");
			return request$1;
		}
		static [kHTTP2CopyHeaders](raw) {
			const rawHeaders = raw.split("\r\n");
			const headers = {};
			for (const header of rawHeaders) {
				const [key, value$2] = header.split(": ");
				if (value$2 == null || value$2.length === 0) continue;
				if (headers[key]) headers[key] += `,${value$2}`;
				else headers[key] = value$2;
			}
			return headers;
		}
	};
	function processHeaderValue(key, val, skipAppend) {
		if (val && typeof val === "object") throw new InvalidArgumentError(`invalid ${key} header`);
		val = val != null ? `${val}` : "";
		if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError(`invalid ${key} header`);
		return skipAppend ? val : `${key}: ${val}\r\n`;
	}
	function processHeader(request$1, key, val, skipAppend = false) {
		if (val && typeof val === "object" && !Array.isArray(val)) throw new InvalidArgumentError(`invalid ${key} header`);
		else if (val === void 0) return;
		if (request$1.host === null && key.length === 4 && key.toLowerCase() === "host") {
			if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError(`invalid ${key} header`);
			request$1.host = val;
		} else if (request$1.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
			request$1.contentLength = parseInt(val, 10);
			if (!Number.isFinite(request$1.contentLength)) throw new InvalidArgumentError("invalid content-length header");
		} else if (request$1.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
			request$1.contentType = val;
			if (skipAppend) request$1.headers[key] = processHeaderValue(key, val, skipAppend);
			else request$1.headers += processHeaderValue(key, val);
		} else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") throw new InvalidArgumentError("invalid transfer-encoding header");
		else if (key.length === 10 && key.toLowerCase() === "connection") {
			const value$2 = typeof val === "string" ? val.toLowerCase() : null;
			if (value$2 !== "close" && value$2 !== "keep-alive") throw new InvalidArgumentError("invalid connection header");
			else if (value$2 === "close") request$1.reset = true;
		} else if (key.length === 10 && key.toLowerCase() === "keep-alive") throw new InvalidArgumentError("invalid keep-alive header");
		else if (key.length === 7 && key.toLowerCase() === "upgrade") throw new InvalidArgumentError("invalid upgrade header");
		else if (key.length === 6 && key.toLowerCase() === "expect") throw new NotSupportedError("expect header not supported");
		else if (tokenRegExp.exec(key) === null) throw new InvalidArgumentError("invalid header key");
		else if (Array.isArray(val)) for (let i = 0; i < val.length; i++) if (skipAppend) if (request$1.headers[key]) request$1.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
		else request$1.headers[key] = processHeaderValue(key, val[i], skipAppend);
		else request$1.headers += processHeaderValue(key, val[i]);
		else if (skipAppend) request$1.headers[key] = processHeaderValue(key, val, skipAppend);
		else request$1.headers += processHeaderValue(key, val);
	}
	module.exports = Request;
}));
var require_dispatcher = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var EventEmitter = __require("events");
	var Dispatcher = class extends EventEmitter {
		dispatch() {
			throw new Error("not implemented");
		}
		close() {
			throw new Error("not implemented");
		}
		destroy() {
			throw new Error("not implemented");
		}
	};
	module.exports = Dispatcher;
}));
var require_dispatcher_base = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Dispatcher = require_dispatcher();
	var { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = require_errors();
	var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols$4();
	var kDestroyed = Symbol("destroyed");
	var kClosed = Symbol("closed");
	var kOnDestroyed = Symbol("onDestroyed");
	var kOnClosed = Symbol("onClosed");
	var kInterceptedDispatch = Symbol("Intercepted Dispatch");
	var DispatcherBase = class extends Dispatcher {
		constructor() {
			super();
			this[kDestroyed] = false;
			this[kOnDestroyed] = null;
			this[kClosed] = false;
			this[kOnClosed] = [];
		}
		get destroyed() {
			return this[kDestroyed];
		}
		get closed() {
			return this[kClosed];
		}
		get interceptors() {
			return this[kInterceptors];
		}
		set interceptors(newInterceptors) {
			if (newInterceptors) {
				for (let i = newInterceptors.length - 1; i >= 0; i--) if (typeof this[kInterceptors][i] !== "function") throw new InvalidArgumentError("interceptor must be an function");
			}
			this[kInterceptors] = newInterceptors;
		}
		close(callback) {
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.close((err, data) => {
					return err ? reject(err) : resolve(data);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError("invalid callback");
			if (this[kDestroyed]) {
				queueMicrotask(() => callback(new ClientDestroyedError(), null));
				return;
			}
			if (this[kClosed]) {
				if (this[kOnClosed]) this[kOnClosed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			this[kClosed] = true;
			this[kOnClosed].push(callback);
			const onClosed = () => {
				const callbacks = this[kOnClosed];
				this[kOnClosed] = null;
				for (let i = 0; i < callbacks.length; i++) callbacks[i](null, null);
			};
			this[kClose]().then(() => this.destroy()).then(() => {
				queueMicrotask(onClosed);
			});
		}
		destroy(err, callback) {
			if (typeof err === "function") {
				callback = err;
				err = null;
			}
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.destroy(err, (err$1, data) => {
					return err$1 ? reject(err$1) : resolve(data);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError("invalid callback");
			if (this[kDestroyed]) {
				if (this[kOnDestroyed]) this[kOnDestroyed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			if (!err) err = new ClientDestroyedError();
			this[kDestroyed] = true;
			this[kOnDestroyed] = this[kOnDestroyed] || [];
			this[kOnDestroyed].push(callback);
			const onDestroyed = () => {
				const callbacks = this[kOnDestroyed];
				this[kOnDestroyed] = null;
				for (let i = 0; i < callbacks.length; i++) callbacks[i](null, null);
			};
			this[kDestroy](err).then(() => {
				queueMicrotask(onDestroyed);
			});
		}
		[kInterceptedDispatch](opts, handler) {
			if (!this[kInterceptors] || this[kInterceptors].length === 0) {
				this[kInterceptedDispatch] = this[kDispatch];
				return this[kDispatch](opts, handler);
			}
			let dispatch = this[kDispatch].bind(this);
			for (let i = this[kInterceptors].length - 1; i >= 0; i--) dispatch = this[kInterceptors][i](dispatch);
			this[kInterceptedDispatch] = dispatch;
			return dispatch(opts, handler);
		}
		dispatch(opts, handler) {
			if (!handler || typeof handler !== "object") throw new InvalidArgumentError("handler must be an object");
			try {
				if (!opts || typeof opts !== "object") throw new InvalidArgumentError("opts must be an object.");
				if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError();
				if (this[kClosed]) throw new ClientClosedError();
				return this[kInterceptedDispatch](opts, handler);
			} catch (err) {
				if (typeof handler.onError !== "function") throw new InvalidArgumentError("invalid onError method");
				handler.onError(err);
				return false;
			}
		}
	};
	module.exports = DispatcherBase;
}));
var require_connect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var net$1 = __require("net");
	var assert$14 = __require("assert");
	var util = require_util$6();
	var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
	var tls;
	var SessionCache;
	if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) SessionCache = class WeakSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = /* @__PURE__ */ new Map();
			this._sessionRegistry = new global.FinalizationRegistry((key) => {
				if (this._sessionCache.size < this._maxCachedSessions) return;
				const ref = this._sessionCache.get(key);
				if (ref !== void 0 && ref.deref() === void 0) this._sessionCache.delete(key);
			});
		}
		get(sessionKey) {
			const ref = this._sessionCache.get(sessionKey);
			return ref ? ref.deref() : null;
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			this._sessionCache.set(sessionKey, new WeakRef(session));
			this._sessionRegistry.register(session, sessionKey);
		}
	};
	else SessionCache = class SimpleSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = /* @__PURE__ */ new Map();
		}
		get(sessionKey) {
			return this._sessionCache.get(sessionKey);
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			if (this._sessionCache.size >= this._maxCachedSessions) {
				const { value: oldestKey } = this._sessionCache.keys().next();
				this._sessionCache.delete(oldestKey);
			}
			this._sessionCache.set(sessionKey, session);
		}
	};
	function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout: timeout$2, ...opts }) {
		if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
		const options = {
			path: socketPath,
			...opts
		};
		const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
		timeout$2 = timeout$2 == null ? 1e4 : timeout$2;
		allowH2 = allowH2 != null ? allowH2 : false;
		return function connect({ hostname, host, protocol, port: port$2, servername, localAddress, httpSocket }, callback) {
			let socket;
			if (protocol === "https:") {
				if (!tls) tls = __require("tls");
				servername = servername || options.servername || util.getServerName(host) || null;
				const sessionKey = servername || hostname;
				const session = sessionCache.get(sessionKey) || null;
				assert$14(sessionKey);
				socket = tls.connect({
					highWaterMark: 16384,
					...options,
					servername,
					session,
					localAddress,
					ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
					socket: httpSocket,
					port: port$2 || 443,
					host: hostname
				});
				socket.on("session", function(session$1) {
					sessionCache.set(sessionKey, session$1);
				});
			} else {
				assert$14(!httpSocket, "httpSocket can only be sent on TLS update");
				socket = net$1.connect({
					highWaterMark: 64 * 1024,
					...options,
					localAddress,
					port: port$2 || 80,
					host: hostname
				});
			}
			if (options.keepAlive == null || options.keepAlive) {
				const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
				socket.setKeepAlive(true, keepAliveInitialDelay);
			}
			const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout$2);
			socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(null, this);
				}
			}).on("error", function(err) {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(err);
				}
			});
			return socket;
		};
	}
	function setupTimeout(onConnectTimeout, timeout$2) {
		if (!timeout$2) return () => {};
		let s1 = null;
		let s2 = null;
		const timeoutId = setTimeout(() => {
			s1 = setImmediate(() => {
				if (process.platform === "win32") s2 = setImmediate(() => onConnectTimeout());
				else onConnectTimeout();
			});
		}, timeout$2);
		return () => {
			clearTimeout(timeoutId);
			clearImmediate(s1);
			clearImmediate(s2);
		};
	}
	function onConnectTimeout(socket) {
		util.destroy(socket, new ConnectTimeoutError());
	}
	module.exports = buildConnector;
}));
var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.enumToMap = void 0;
	function enumToMap(obj) {
		const res = {};
		Object.keys(obj).forEach((key) => {
			const value$2 = obj[key];
			if (typeof value$2 === "number") res[key] = value$2;
		});
		return res;
	}
	exports.enumToMap = enumToMap;
}));
var require_constants$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
	var utils_1 = require_utils();
	(function(ERROR) {
		ERROR[ERROR["OK"] = 0] = "OK";
		ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
		ERROR[ERROR["STRICT"] = 2] = "STRICT";
		ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
		ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
		ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		ERROR[ERROR["USER"] = 24] = "USER";
	})(exports.ERROR || (exports.ERROR = {}));
	(function(TYPE) {
		TYPE[TYPE["BOTH"] = 0] = "BOTH";
		TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
		TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
	})(exports.TYPE || (exports.TYPE = {}));
	(function(FLAGS) {
		FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
		FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
		FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
		FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
		FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
	})(exports.FLAGS || (exports.FLAGS = {}));
	(function(LENIENT_FLAGS) {
		LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
		LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
	})(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
	var METHODS;
	(function(METHODS) {
		METHODS[METHODS["DELETE"] = 0] = "DELETE";
		METHODS[METHODS["GET"] = 1] = "GET";
		METHODS[METHODS["HEAD"] = 2] = "HEAD";
		METHODS[METHODS["POST"] = 3] = "POST";
		METHODS[METHODS["PUT"] = 4] = "PUT";
		METHODS[METHODS["CONNECT"] = 5] = "CONNECT";
		METHODS[METHODS["OPTIONS"] = 6] = "OPTIONS";
		METHODS[METHODS["TRACE"] = 7] = "TRACE";
		METHODS[METHODS["COPY"] = 8] = "COPY";
		METHODS[METHODS["LOCK"] = 9] = "LOCK";
		METHODS[METHODS["MKCOL"] = 10] = "MKCOL";
		METHODS[METHODS["MOVE"] = 11] = "MOVE";
		METHODS[METHODS["PROPFIND"] = 12] = "PROPFIND";
		METHODS[METHODS["PROPPATCH"] = 13] = "PROPPATCH";
		METHODS[METHODS["SEARCH"] = 14] = "SEARCH";
		METHODS[METHODS["UNLOCK"] = 15] = "UNLOCK";
		METHODS[METHODS["BIND"] = 16] = "BIND";
		METHODS[METHODS["REBIND"] = 17] = "REBIND";
		METHODS[METHODS["UNBIND"] = 18] = "UNBIND";
		METHODS[METHODS["ACL"] = 19] = "ACL";
		METHODS[METHODS["REPORT"] = 20] = "REPORT";
		METHODS[METHODS["MKACTIVITY"] = 21] = "MKACTIVITY";
		METHODS[METHODS["CHECKOUT"] = 22] = "CHECKOUT";
		METHODS[METHODS["MERGE"] = 23] = "MERGE";
		METHODS[METHODS["M-SEARCH"] = 24] = "M-SEARCH";
		METHODS[METHODS["NOTIFY"] = 25] = "NOTIFY";
		METHODS[METHODS["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		METHODS[METHODS["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		METHODS[METHODS["PATCH"] = 28] = "PATCH";
		METHODS[METHODS["PURGE"] = 29] = "PURGE";
		METHODS[METHODS["MKCALENDAR"] = 30] = "MKCALENDAR";
		METHODS[METHODS["LINK"] = 31] = "LINK";
		METHODS[METHODS["UNLINK"] = 32] = "UNLINK";
		METHODS[METHODS["SOURCE"] = 33] = "SOURCE";
		METHODS[METHODS["PRI"] = 34] = "PRI";
		METHODS[METHODS["DESCRIBE"] = 35] = "DESCRIBE";
		METHODS[METHODS["ANNOUNCE"] = 36] = "ANNOUNCE";
		METHODS[METHODS["SETUP"] = 37] = "SETUP";
		METHODS[METHODS["PLAY"] = 38] = "PLAY";
		METHODS[METHODS["PAUSE"] = 39] = "PAUSE";
		METHODS[METHODS["TEARDOWN"] = 40] = "TEARDOWN";
		METHODS[METHODS["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		METHODS[METHODS["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		METHODS[METHODS["REDIRECT"] = 43] = "REDIRECT";
		METHODS[METHODS["RECORD"] = 44] = "RECORD";
		METHODS[METHODS["FLUSH"] = 45] = "FLUSH";
	})(METHODS = exports.METHODS || (exports.METHODS = {}));
	exports.METHODS_HTTP = [
		METHODS.DELETE,
		METHODS.GET,
		METHODS.HEAD,
		METHODS.POST,
		METHODS.PUT,
		METHODS.CONNECT,
		METHODS.OPTIONS,
		METHODS.TRACE,
		METHODS.COPY,
		METHODS.LOCK,
		METHODS.MKCOL,
		METHODS.MOVE,
		METHODS.PROPFIND,
		METHODS.PROPPATCH,
		METHODS.SEARCH,
		METHODS.UNLOCK,
		METHODS.BIND,
		METHODS.REBIND,
		METHODS.UNBIND,
		METHODS.ACL,
		METHODS.REPORT,
		METHODS.MKACTIVITY,
		METHODS.CHECKOUT,
		METHODS.MERGE,
		METHODS["M-SEARCH"],
		METHODS.NOTIFY,
		METHODS.SUBSCRIBE,
		METHODS.UNSUBSCRIBE,
		METHODS.PATCH,
		METHODS.PURGE,
		METHODS.MKCALENDAR,
		METHODS.LINK,
		METHODS.UNLINK,
		METHODS.PRI,
		METHODS.SOURCE
	];
	exports.METHODS_ICE = [METHODS.SOURCE];
	exports.METHODS_RTSP = [
		METHODS.OPTIONS,
		METHODS.DESCRIBE,
		METHODS.ANNOUNCE,
		METHODS.SETUP,
		METHODS.PLAY,
		METHODS.PAUSE,
		METHODS.TEARDOWN,
		METHODS.GET_PARAMETER,
		METHODS.SET_PARAMETER,
		METHODS.REDIRECT,
		METHODS.RECORD,
		METHODS.FLUSH,
		METHODS.GET,
		METHODS.POST
	];
	exports.METHOD_MAP = utils_1.enumToMap(METHODS);
	exports.H_METHOD_MAP = {};
	Object.keys(exports.METHOD_MAP).forEach((key) => {
		if (/^H/.test(key)) exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
	});
	(function(FINISH) {
		FINISH[FINISH["SAFE"] = 0] = "SAFE";
		FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
	})(exports.FINISH || (exports.FINISH = {}));
	exports.ALPHA = [];
	for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
		exports.ALPHA.push(String.fromCharCode(i));
		exports.ALPHA.push(String.fromCharCode(i + 32));
	}
	exports.NUM_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9
	};
	exports.HEX_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15
	};
	exports.NUM = [
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9"
	];
	exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
	exports.MARK = [
		"-",
		"_",
		".",
		"!",
		"~",
		"*",
		"'",
		"(",
		")"
	];
	exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
		"%",
		";",
		":",
		"&",
		"=",
		"+",
		"$",
		","
	]);
	exports.STRICT_URL_CHAR = [
		"!",
		"\"",
		"$",
		"%",
		"&",
		"'",
		"(",
		")",
		"*",
		"+",
		",",
		"-",
		".",
		"/",
		":",
		";",
		"<",
		"=",
		">",
		"@",
		"[",
		"\\",
		"]",
		"^",
		"_",
		"`",
		"{",
		"|",
		"}",
		"~"
	].concat(exports.ALPHANUM);
	exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
	for (let i = 128; i <= 255; i++) exports.URL_CHAR.push(i);
	exports.HEX = exports.NUM.concat([
		"a",
		"b",
		"c",
		"d",
		"e",
		"f",
		"A",
		"B",
		"C",
		"D",
		"E",
		"F"
	]);
	exports.STRICT_TOKEN = [
		"!",
		"#",
		"$",
		"%",
		"&",
		"'",
		"*",
		"+",
		"-",
		".",
		"^",
		"_",
		"`",
		"|",
		"~"
	].concat(exports.ALPHANUM);
	exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
	exports.HEADER_CHARS = ["	"];
	for (let i = 32; i <= 255; i++) if (i !== 127) exports.HEADER_CHARS.push(i);
	exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
	exports.MAJOR = exports.NUM_MAP;
	exports.MINOR = exports.MAJOR;
	var HEADER_STATE;
	(function(HEADER_STATE) {
		HEADER_STATE[HEADER_STATE["GENERAL"] = 0] = "GENERAL";
		HEADER_STATE[HEADER_STATE["CONNECTION"] = 1] = "CONNECTION";
		HEADER_STATE[HEADER_STATE["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		HEADER_STATE[HEADER_STATE["UPGRADE"] = 4] = "UPGRADE";
		HEADER_STATE[HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		HEADER_STATE[HEADER_STATE["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		HEADER_STATE[HEADER_STATE["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
	})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
	exports.SPECIAL_HEADERS = {
		"connection": HEADER_STATE.CONNECTION,
		"content-length": HEADER_STATE.CONTENT_LENGTH,
		"proxy-connection": HEADER_STATE.CONNECTION,
		"transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
		"upgrade": HEADER_STATE.UPGRADE
	};
}));
var require_RedirectHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var util = require_util$6();
	var { kBodyUsed } = require_symbols$4();
	var assert$13 = __require("assert");
	var { InvalidArgumentError } = require_errors();
	var EE$1 = __require("events");
	var redirectableStatusCodes = [
		300,
		301,
		302,
		303,
		307,
		308
	];
	var kBody = Symbol("body");
	var BodyAsyncIterable = class {
		constructor(body) {
			this[kBody] = body;
			this[kBodyUsed] = false;
		}
		async *[Symbol.asyncIterator]() {
			assert$13(!this[kBodyUsed], "disturbed");
			this[kBodyUsed] = true;
			yield* this[kBody];
		}
	};
	var RedirectHandler = class {
		constructor(dispatch, maxRedirections, opts, handler) {
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError("maxRedirections must be a positive number");
			util.validateHandler(handler, opts.method, opts.upgrade);
			this.dispatch = dispatch;
			this.location = null;
			this.abort = null;
			this.opts = {
				...opts,
				maxRedirections: 0
			};
			this.maxRedirections = maxRedirections;
			this.handler = handler;
			this.history = [];
			if (util.isStream(this.opts.body)) {
				if (util.bodyLength(this.opts.body) === 0) this.opts.body.on("data", function() {
					assert$13(false);
				});
				if (typeof this.opts.body.readableDidRead !== "boolean") {
					this.opts.body[kBodyUsed] = false;
					EE$1.prototype.on.call(this.opts.body, "data", function() {
						this[kBodyUsed] = true;
					});
				}
			} else if (this.opts.body && typeof this.opts.body.pipeTo === "function") this.opts.body = new BodyAsyncIterable(this.opts.body);
			else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) this.opts.body = new BodyAsyncIterable(this.opts.body);
		}
		onConnect(abort) {
			this.abort = abort;
			this.handler.onConnect(abort, { history: this.history });
		}
		onUpgrade(statusCode, headers, socket) {
			this.handler.onUpgrade(statusCode, headers, socket);
		}
		onError(error) {
			this.handler.onError(error);
		}
		onHeaders(statusCode, headers, resume$1, statusText) {
			this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
			if (this.opts.origin) this.history.push(new URL(this.opts.path, this.opts.origin));
			if (!this.location) return this.handler.onHeaders(statusCode, headers, resume$1, statusText);
			const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
			const path$5 = search ? `${pathname}${search}` : pathname;
			this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
			this.opts.path = path$5;
			this.opts.origin = origin;
			this.opts.maxRedirections = 0;
			this.opts.query = null;
			if (statusCode === 303 && this.opts.method !== "HEAD") {
				this.opts.method = "GET";
				this.opts.body = null;
			}
		}
		onData(chunk$4) {
			if (this.location) {} else return this.handler.onData(chunk$4);
		}
		onComplete(trailers) {
			if (this.location) {
				this.location = null;
				this.abort = null;
				this.dispatch(this.opts, this);
			} else this.handler.onComplete(trailers);
		}
		onBodySent(chunk$4) {
			if (this.handler.onBodySent) this.handler.onBodySent(chunk$4);
		}
	};
	function parseLocation(statusCode, headers) {
		if (redirectableStatusCodes.indexOf(statusCode) === -1) return null;
		for (let i = 0; i < headers.length; i += 2) if (headers[i].toString().toLowerCase() === "location") return headers[i + 1];
	}
	function shouldRemoveHeader(header, removeContent, unknownOrigin) {
		if (header.length === 4) return util.headerNameToString(header) === "host";
		if (removeContent && util.headerNameToString(header).startsWith("content-")) return true;
		if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
			const name = util.headerNameToString(header);
			return name === "authorization" || name === "cookie" || name === "proxy-authorization";
		}
		return false;
	}
	function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
		const ret = [];
		if (Array.isArray(headers)) {
			for (let i = 0; i < headers.length; i += 2) if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) ret.push(headers[i], headers[i + 1]);
		} else if (headers && typeof headers === "object") {
			for (const key of Object.keys(headers)) if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) ret.push(key, headers[key]);
		} else assert$13(headers == null, "headers must be an object or an array");
		return ret;
	}
	module.exports = RedirectHandler;
}));
var require_redirectInterceptor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var RedirectHandler = require_RedirectHandler();
	function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
		return (dispatch) => {
			return function Intercept(opts, handler) {
				const { maxRedirections = defaultMaxRedirections } = opts;
				if (!maxRedirections) return dispatch(opts, handler);
				const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
				opts = {
					...opts,
					maxRedirections: 0
				};
				return dispatch(opts, redirectHandler);
			};
		};
	}
	module.exports = createRedirectInterceptor;
}));
var require_llhttp_wasm = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
}));
var require_llhttp_simd_wasm = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
}));
var require_client = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert$12 = __require("assert");
	var net = __require("net");
	var http$1 = __require("http");
	var { pipeline: pipeline$1 } = __require("stream");
	var util = require_util$6();
	var timers = require_timers();
	var Request = require_request$1();
	var DispatcherBase = require_dispatcher_base();
	var { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError, RequestAbortedError, HeadersTimeoutError, HeadersOverflowError, SocketError, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = require_errors();
	var buildConnector = require_connect();
	var { kUrl, kReset, kServerName, kClient, kBusy, kParser, kConnect, kBlocking, kResuming, kRunning, kPending, kSize, kWriting, kQueue, kConnected, kConnecting, kNeedDrain, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections, kMaxRequests, kCounter, kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, kHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols$4();
	var http2;
	try {
		http2 = __require("http2");
	} catch {
		http2 = { constants: {} };
	}
	var { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
	var h2ExperimentalWarned = false;
	var FastBuffer = Buffer[Symbol.species];
	var kClosedResolve = Symbol("kClosedResolve");
	var channels = {};
	try {
		const diagnosticsChannel$2 = __require("diagnostics_channel");
		channels.sendHeaders = diagnosticsChannel$2.channel("undici:client:sendHeaders");
		channels.beforeConnect = diagnosticsChannel$2.channel("undici:client:beforeConnect");
		channels.connectError = diagnosticsChannel$2.channel("undici:client:connectError");
		channels.connected = diagnosticsChannel$2.channel("undici:client:connected");
	} catch {
		channels.sendHeaders = { hasSubscribers: false };
		channels.beforeConnect = { hasSubscribers: false };
		channels.connectError = { hasSubscribers: false };
		channels.connected = { hasSubscribers: false };
	}
	var Client = class extends DispatcherBase {
		constructor(url$2, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls: tls$1, strictContentLength, maxCachedSessions, maxRedirections, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, maxConcurrentStreams } = {}) {
			super();
			if (keepAlive !== void 0) throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
			if (socketTimeout !== void 0) throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
			if (requestTimeout !== void 0) throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
			if (idleTimeout !== void 0) throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
			if (maxKeepAliveTimeout !== void 0) throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
			if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError("invalid maxHeaderSize");
			if (socketPath != null && typeof socketPath !== "string") throw new InvalidArgumentError("invalid socketPath");
			if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError("invalid connectTimeout");
			if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError("invalid keepAliveTimeout");
			if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
			if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
			if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
			if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
			if (connect != null && typeof connect !== "function" && typeof connect !== "object") throw new InvalidArgumentError("connect must be a function or an object");
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError("maxRedirections must be a positive number");
			if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
			if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) throw new InvalidArgumentError("localAddress must be valid string IP address");
			if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError("maxResponseSize must be a positive number");
			if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
			if (allowH2 != null && typeof allowH2 !== "boolean") throw new InvalidArgumentError("allowH2 must be a valid boolean value");
			if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
			if (typeof connect !== "function") connect = buildConnector({
				...tls$1,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect
			});
			this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
			this[kUrl] = util.parseOrigin(url$2);
			this[kConnector] = connect;
			this[kSocket] = null;
			this[kPipelining] = pipelining != null ? pipelining : 1;
			this[kMaxHeadersSize] = maxHeaderSize || http$1.maxHeaderSize;
			this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
			this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
			this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
			this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
			this[kServerName] = null;
			this[kLocalAddress] = localAddress != null ? localAddress : null;
			this[kResuming] = 0;
			this[kNeedDrain] = 0;
			this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r\n`;
			this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
			this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
			this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
			this[kMaxRedirections] = maxRedirections;
			this[kMaxRequests] = maxRequestsPerClient;
			this[kClosedResolve] = null;
			this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
			this[kHTTPConnVersion] = "h1";
			this[kHTTP2Session] = null;
			this[kHTTP2SessionState] = !allowH2 ? null : {
				openStreams: 0,
				maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
			};
			this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
			this[kQueue] = [];
			this[kRunningIdx] = 0;
			this[kPendingIdx] = 0;
		}
		get pipelining() {
			return this[kPipelining];
		}
		set pipelining(value$2) {
			this[kPipelining] = value$2;
			resume(this, true);
		}
		get [kPending]() {
			return this[kQueue].length - this[kPendingIdx];
		}
		get [kRunning]() {
			return this[kPendingIdx] - this[kRunningIdx];
		}
		get [kSize]() {
			return this[kQueue].length - this[kRunningIdx];
		}
		get [kConnected]() {
			return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
		}
		get [kBusy]() {
			const socket = this[kSocket];
			return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
		}
		/* istanbul ignore: only used for test */
		[kConnect](cb) {
			connect(this);
			this.once("connect", cb);
		}
		[kDispatch](opts, handler) {
			const origin = opts.origin || this[kUrl].origin;
			const request$1 = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
			this[kQueue].push(request$1);
			if (this[kResuming]) {} else if (util.bodyLength(request$1.body) == null && util.isIterable(request$1.body)) {
				this[kResuming] = 1;
				process.nextTick(resume, this);
			} else resume(this, true);
			if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) this[kNeedDrain] = 2;
			return this[kNeedDrain] < 2;
		}
		async [kClose]() {
			return new Promise((resolve) => {
				if (!this[kSize]) resolve(null);
				else this[kClosedResolve] = resolve;
			});
		}
		async [kDestroy](err) {
			return new Promise((resolve) => {
				const requests = this[kQueue].splice(this[kPendingIdx]);
				for (let i = 0; i < requests.length; i++) {
					const request$1 = requests[i];
					errorRequest(this, request$1, err);
				}
				const callback = () => {
					if (this[kClosedResolve]) {
						this[kClosedResolve]();
						this[kClosedResolve] = null;
					}
					resolve();
				};
				if (this[kHTTP2Session] != null) {
					util.destroy(this[kHTTP2Session], err);
					this[kHTTP2Session] = null;
					this[kHTTP2SessionState] = null;
				}
				if (!this[kSocket]) queueMicrotask(callback);
				else util.destroy(this[kSocket].on("close", callback), err);
				resume(this);
			});
		}
	};
	function onHttp2SessionError(err) {
		assert$12(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		this[kSocket][kError] = err;
		onError(this[kClient], err);
	}
	function onHttp2FrameError(type, code, id$2) {
		const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
		if (id$2 === 0) {
			this[kSocket][kError] = err;
			onError(this[kClient], err);
		}
	}
	function onHttp2SessionEnd() {
		util.destroy(this, new SocketError("other side closed"));
		util.destroy(this[kSocket], new SocketError("other side closed"));
	}
	function onHTTP2GoAway(code) {
		const client = this[kClient];
		const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
		client[kSocket] = null;
		client[kHTTP2Session] = null;
		if (client.destroyed) {
			assert$12(this[kPending] === 0);
			const requests = client[kQueue].splice(client[kRunningIdx]);
			for (let i = 0; i < requests.length; i++) {
				const request$1 = requests[i];
				errorRequest(this, request$1, err);
			}
		} else if (client[kRunning] > 0) {
			const request$1 = client[kQueue][client[kRunningIdx]];
			client[kQueue][client[kRunningIdx]++] = null;
			errorRequest(client, request$1, err);
		}
		client[kPendingIdx] = client[kRunningIdx];
		assert$12(client[kRunning] === 0);
		client.emit("disconnect", client[kUrl], [client], err);
		resume(client);
	}
	var constants = require_constants$2();
	var createRedirectInterceptor = require_redirectInterceptor();
	var EMPTY_BUF = Buffer.alloc(0);
	async function lazyllhttp() {
		const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
		let mod;
		try {
			mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
		} catch (e) {
			/* istanbul ignore next */
			mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
		}
		return await WebAssembly.instantiate(mod, { env: {
			wasm_on_url: (p, at$2, len) => {
				/* istanbul ignore next */
				return 0;
			},
			wasm_on_status: (p, at$2, len) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start$2 = at$2 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start$2, len)) || 0;
			},
			wasm_on_message_begin: (p) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onMessageBegin() || 0;
			},
			wasm_on_header_field: (p, at$2, len) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start$2 = at$2 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start$2, len)) || 0;
			},
			wasm_on_header_value: (p, at$2, len) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start$2 = at$2 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start$2, len)) || 0;
			},
			wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
			},
			wasm_on_body: (p, at$2, len) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start$2 = at$2 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start$2, len)) || 0;
			},
			wasm_on_message_complete: (p) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onMessageComplete() || 0;
			}
		} });
	}
	var llhttpInstance = null;
	var llhttpPromise = lazyllhttp();
	llhttpPromise.catch();
	var currentParser = null;
	var currentBufferRef = null;
	var currentBufferSize = 0;
	var currentBufferPtr = null;
	var TIMEOUT_HEADERS = 1;
	var TIMEOUT_BODY = 2;
	var TIMEOUT_IDLE = 3;
	var Parser = class {
		constructor(client, socket, { exports: exports$1 }) {
			assert$12(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
			this.llhttp = exports$1;
			this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
			this.client = client;
			this.socket = socket;
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.statusCode = null;
			this.statusText = "";
			this.upgrade = false;
			this.headers = [];
			this.headersSize = 0;
			this.headersMaxSize = client[kMaxHeadersSize];
			this.shouldKeepAlive = false;
			this.paused = false;
			this.resume = this.resume.bind(this);
			this.bytesRead = 0;
			this.keepAlive = "";
			this.contentLength = "";
			this.connection = "";
			this.maxResponseSize = client[kMaxResponseSize];
		}
		setTimeout(value$2, type) {
			this.timeoutType = type;
			if (value$2 !== this.timeoutValue) {
				timers.clearTimeout(this.timeout);
				if (value$2) {
					this.timeout = timers.setTimeout(onParserTimeout, value$2, this);
					// istanbul ignore else: only for jest
					if (this.timeout.unref) this.timeout.unref();
				} else this.timeout = null;
				this.timeoutValue = value$2;
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
		}
		resume() {
			if (this.socket.destroyed || !this.paused) return;
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			this.llhttp.llhttp_resume(this.ptr);
			assert$12(this.timeoutType === TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			this.paused = false;
			this.execute(this.socket.read() || EMPTY_BUF);
			this.readMore();
		}
		readMore() {
			while (!this.paused && this.ptr) {
				const chunk$4 = this.socket.read();
				if (chunk$4 === null) break;
				this.execute(chunk$4);
			}
		}
		execute(data) {
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			assert$12(!this.paused);
			const { socket, llhttp } = this;
			if (data.length > currentBufferSize) {
				if (currentBufferPtr) llhttp.free(currentBufferPtr);
				currentBufferSize = Math.ceil(data.length / 4096) * 4096;
				currentBufferPtr = llhttp.malloc(currentBufferSize);
			}
			new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
			try {
				let ret;
				try {
					currentBufferRef = data;
					currentParser = this;
					ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
				} catch (err) {
					/* istanbul ignore next: difficult to make a test case for */
					throw err;
				} finally {
					currentParser = null;
					currentBufferRef = null;
				}
				const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
				if (ret === constants.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));
				else if (ret === constants.ERROR.PAUSED) {
					this.paused = true;
					socket.unshift(data.slice(offset));
				} else if (ret !== constants.ERROR.OK) {
					const ptr = llhttp.llhttp_get_error_reason(this.ptr);
					let message = "";
					/* istanbul ignore else: difficult to make a test case for */
					if (ptr) {
						const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
						message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
					}
					throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
				}
			} catch (err) {
				util.destroy(socket, err);
			}
		}
		destroy() {
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			this.llhttp.llhttp_free(this.ptr);
			this.ptr = null;
			timers.clearTimeout(this.timeout);
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.paused = false;
		}
		onStatus(buf) {
			this.statusText = buf.toString();
		}
		onMessageBegin() {
			const { socket, client } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			if (!client[kQueue][client[kRunningIdx]]) return -1;
		}
		onHeaderField(buf) {
			const len = this.headers.length;
			if ((len & 1) === 0) this.headers.push(buf);
			else this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
			this.trackHeader(buf.length);
		}
		onHeaderValue(buf) {
			let len = this.headers.length;
			if ((len & 1) === 1) {
				this.headers.push(buf);
				len += 1;
			} else this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
			const key = this.headers[len - 2];
			if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") this.keepAlive += buf.toString();
			else if (key.length === 10 && key.toString().toLowerCase() === "connection") this.connection += buf.toString();
			else if (key.length === 14 && key.toString().toLowerCase() === "content-length") this.contentLength += buf.toString();
			this.trackHeader(buf.length);
		}
		trackHeader(len) {
			this.headersSize += len;
			if (this.headersSize >= this.headersMaxSize) util.destroy(this.socket, new HeadersOverflowError());
		}
		onUpgrade(head$4) {
			const { upgrade, client, socket, headers, statusCode } = this;
			assert$12(upgrade);
			const request$1 = client[kQueue][client[kRunningIdx]];
			assert$12(request$1);
			assert$12(!socket.destroyed);
			assert$12(socket === client[kSocket]);
			assert$12(!this.paused);
			assert$12(request$1.upgrade || request$1.method === "CONNECT");
			this.statusCode = null;
			this.statusText = "";
			this.shouldKeepAlive = null;
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			socket.unshift(head$4);
			socket[kParser].destroy();
			socket[kParser] = null;
			socket[kClient] = null;
			socket[kError] = null;
			socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
			client[kSocket] = null;
			client[kQueue][client[kRunningIdx]++] = null;
			client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
			try {
				request$1.onUpgrade(statusCode, headers, socket);
			} catch (err) {
				util.destroy(socket, err);
			}
			resume(client);
		}
		onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
			const { client, socket, headers, statusText } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			const request$1 = client[kQueue][client[kRunningIdx]];
			/* istanbul ignore next: difficult to make a test case for */
			if (!request$1) return -1;
			assert$12(!this.upgrade);
			assert$12(this.statusCode < 200);
			if (statusCode === 100) {
				util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
				return -1;
			}
			if (upgrade && !request$1.upgrade) {
				util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
				return -1;
			}
			assert$12.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
			this.statusCode = statusCode;
			this.shouldKeepAlive = shouldKeepAlive || request$1.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
			if (this.statusCode >= 200) {
				const bodyTimeout = request$1.bodyTimeout != null ? request$1.bodyTimeout : client[kBodyTimeout];
				this.setTimeout(bodyTimeout, TIMEOUT_BODY);
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			if (request$1.method === "CONNECT") {
				assert$12(client[kRunning] === 1);
				this.upgrade = true;
				return 2;
			}
			if (upgrade) {
				assert$12(client[kRunning] === 1);
				this.upgrade = true;
				return 2;
			}
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (this.shouldKeepAlive && client[kPipelining]) {
				const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
				if (keepAliveTimeout != null) {
					const timeout$2 = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
					if (timeout$2 <= 0) socket[kReset] = true;
					else client[kKeepAliveTimeoutValue] = timeout$2;
				} else client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
			} else socket[kReset] = true;
			const pause = request$1.onHeaders(statusCode, headers, this.resume, statusText) === false;
			if (request$1.aborted) return -1;
			if (request$1.method === "HEAD") return 1;
			if (statusCode < 200) return 1;
			if (socket[kBlocking]) {
				socket[kBlocking] = false;
				resume(client);
			}
			return pause ? constants.ERROR.PAUSED : 0;
		}
		onBody(buf) {
			const { client, socket, statusCode, maxResponseSize } = this;
			if (socket.destroyed) return -1;
			const request$1 = client[kQueue][client[kRunningIdx]];
			assert$12(request$1);
			assert$12.strictEqual(this.timeoutType, TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			assert$12(statusCode >= 200);
			if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
				util.destroy(socket, new ResponseExceededMaxSizeError());
				return -1;
			}
			this.bytesRead += buf.length;
			if (request$1.onData(buf) === false) return constants.ERROR.PAUSED;
		}
		onMessageComplete() {
			const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
			if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
			if (upgrade) return;
			const request$1 = client[kQueue][client[kRunningIdx]];
			assert$12(request$1);
			assert$12(statusCode >= 100);
			this.statusCode = null;
			this.statusText = "";
			this.bytesRead = 0;
			this.contentLength = "";
			this.keepAlive = "";
			this.connection = "";
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (statusCode < 200) return;
			/* istanbul ignore next: should be handled by llhttp? */
			if (request$1.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
				util.destroy(socket, new ResponseContentLengthMismatchError());
				return -1;
			}
			request$1.onComplete(headers);
			client[kQueue][client[kRunningIdx]++] = null;
			if (socket[kWriting]) {
				assert$12.strictEqual(client[kRunning], 0);
				util.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (!shouldKeepAlive) {
				util.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (socket[kReset] && client[kRunning] === 0) {
				util.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (client[kPipelining] === 1) setImmediate(resume, client);
			else resume(client);
		}
	};
	function onParserTimeout(parser) {
		const { socket, timeoutType, client } = parser;
		/* istanbul ignore else */
		if (timeoutType === TIMEOUT_HEADERS) {
			if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
				assert$12(!parser.paused, "cannot be paused while waiting for headers");
				util.destroy(socket, new HeadersTimeoutError());
			}
		} else if (timeoutType === TIMEOUT_BODY) {
			if (!parser.paused) util.destroy(socket, new BodyTimeoutError());
		} else if (timeoutType === TIMEOUT_IDLE) {
			assert$12(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
			util.destroy(socket, new InformationalError("socket idle timeout"));
		}
	}
	function onSocketReadable() {
		const { [kParser]: parser } = this;
		if (parser) parser.readMore();
	}
	function onSocketError(err) {
		const { [kClient]: client, [kParser]: parser } = this;
		assert$12(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		if (client[kHTTPConnVersion] !== "h2") {
			if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
				parser.onMessageComplete();
				return;
			}
		}
		this[kError] = err;
		onError(this[kClient], err);
	}
	function onError(client, err) {
		if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
			assert$12(client[kPendingIdx] === client[kRunningIdx]);
			const requests = client[kQueue].splice(client[kRunningIdx]);
			for (let i = 0; i < requests.length; i++) {
				const request$1 = requests[i];
				errorRequest(client, request$1, err);
			}
			assert$12(client[kSize] === 0);
		}
	}
	function onSocketEnd() {
		const { [kParser]: parser, [kClient]: client } = this;
		if (client[kHTTPConnVersion] !== "h2") {
			if (parser.statusCode && !parser.shouldKeepAlive) {
				parser.onMessageComplete();
				return;
			}
		}
		util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
	}
	function onSocketClose() {
		const { [kClient]: client, [kParser]: parser } = this;
		if (client[kHTTPConnVersion] === "h1" && parser) {
			if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) parser.onMessageComplete();
			this[kParser].destroy();
			this[kParser] = null;
		}
		const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
		client[kSocket] = null;
		if (client.destroyed) {
			assert$12(client[kPending] === 0);
			const requests = client[kQueue].splice(client[kRunningIdx]);
			for (let i = 0; i < requests.length; i++) {
				const request$1 = requests[i];
				errorRequest(client, request$1, err);
			}
		} else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
			const request$1 = client[kQueue][client[kRunningIdx]];
			client[kQueue][client[kRunningIdx]++] = null;
			errorRequest(client, request$1, err);
		}
		client[kPendingIdx] = client[kRunningIdx];
		assert$12(client[kRunning] === 0);
		client.emit("disconnect", client[kUrl], [client], err);
		resume(client);
	}
	async function connect(client) {
		assert$12(!client[kConnecting]);
		assert$12(!client[kSocket]);
		let { host, hostname, protocol, port: port$2 } = client[kUrl];
		if (hostname[0] === "[") {
			const idx = hostname.indexOf("]");
			assert$12(idx !== -1);
			const ip = hostname.substring(1, idx);
			assert$12(net.isIP(ip));
			hostname = ip;
		}
		client[kConnecting] = true;
		if (channels.beforeConnect.hasSubscribers) channels.beforeConnect.publish({
			connectParams: {
				host,
				hostname,
				protocol,
				port: port$2,
				servername: client[kServerName],
				localAddress: client[kLocalAddress]
			},
			connector: client[kConnector]
		});
		try {
			const socket = await new Promise((resolve, reject) => {
				client[kConnector]({
					host,
					hostname,
					protocol,
					port: port$2,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				}, (err, socket$1) => {
					if (err) reject(err);
					else resolve(socket$1);
				});
			});
			if (client.destroyed) {
				util.destroy(socket.on("error", () => {}), new ClientDestroyedError());
				return;
			}
			client[kConnecting] = false;
			assert$12(socket);
			if (socket.alpnProtocol === "h2") {
				if (!h2ExperimentalWarned) {
					h2ExperimentalWarned = true;
					process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" });
				}
				const session = http2.connect(client[kUrl], {
					createConnection: () => socket,
					peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
				});
				client[kHTTPConnVersion] = "h2";
				session[kClient] = client;
				session[kSocket] = socket;
				session.on("error", onHttp2SessionError);
				session.on("frameError", onHttp2FrameError);
				session.on("end", onHttp2SessionEnd);
				session.on("goaway", onHTTP2GoAway);
				session.on("close", onSocketClose);
				session.unref();
				client[kHTTP2Session] = session;
				socket[kHTTP2Session] = session;
			} else {
				if (!llhttpInstance) {
					llhttpInstance = await llhttpPromise;
					llhttpPromise = null;
				}
				socket[kNoRef] = false;
				socket[kWriting] = false;
				socket[kReset] = false;
				socket[kBlocking] = false;
				socket[kParser] = new Parser(client, socket, llhttpInstance);
			}
			socket[kCounter] = 0;
			socket[kMaxRequests] = client[kMaxRequests];
			socket[kClient] = client;
			socket[kError] = null;
			socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
			client[kSocket] = socket;
			if (channels.connected.hasSubscribers) channels.connected.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port: port$2,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				},
				connector: client[kConnector],
				socket
			});
			client.emit("connect", client[kUrl], [client]);
		} catch (err) {
			if (client.destroyed) return;
			client[kConnecting] = false;
			if (channels.connectError.hasSubscribers) channels.connectError.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port: port$2,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				},
				connector: client[kConnector],
				error: err
			});
			if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
				assert$12(client[kRunning] === 0);
				while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
					const request$1 = client[kQueue][client[kPendingIdx]++];
					errorRequest(client, request$1, err);
				}
			} else onError(client, err);
			client.emit("connectionError", client[kUrl], [client], err);
		}
		resume(client);
	}
	function emitDrain(client) {
		client[kNeedDrain] = 0;
		client.emit("drain", client[kUrl], [client]);
	}
	function resume(client, sync$7) {
		if (client[kResuming] === 2) return;
		client[kResuming] = 2;
		_resume(client, sync$7);
		client[kResuming] = 0;
		if (client[kRunningIdx] > 256) {
			client[kQueue].splice(0, client[kRunningIdx]);
			client[kPendingIdx] -= client[kRunningIdx];
			client[kRunningIdx] = 0;
		}
	}
	function _resume(client, sync$7) {
		while (true) {
			if (client.destroyed) {
				assert$12(client[kPending] === 0);
				return;
			}
			if (client[kClosedResolve] && !client[kSize]) {
				client[kClosedResolve]();
				client[kClosedResolve] = null;
				return;
			}
			const socket = client[kSocket];
			if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
				if (client[kSize] === 0) {
					if (!socket[kNoRef] && socket.unref) {
						socket.unref();
						socket[kNoRef] = true;
					}
				} else if (socket[kNoRef] && socket.ref) {
					socket.ref();
					socket[kNoRef] = false;
				}
				if (client[kSize] === 0) {
					if (socket[kParser].timeoutType !== TIMEOUT_IDLE) socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
				} else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
					if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
						const request$2 = client[kQueue][client[kRunningIdx]];
						const headersTimeout = request$2.headersTimeout != null ? request$2.headersTimeout : client[kHeadersTimeout];
						socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
					}
				}
			}
			if (client[kBusy]) client[kNeedDrain] = 2;
			else if (client[kNeedDrain] === 2) {
				if (sync$7) {
					client[kNeedDrain] = 1;
					process.nextTick(emitDrain, client);
				} else emitDrain(client);
				continue;
			}
			if (client[kPending] === 0) return;
			if (client[kRunning] >= (client[kPipelining] || 1)) return;
			const request$1 = client[kQueue][client[kPendingIdx]];
			if (client[kUrl].protocol === "https:" && client[kServerName] !== request$1.servername) {
				if (client[kRunning] > 0) return;
				client[kServerName] = request$1.servername;
				if (socket && socket.servername !== request$1.servername) {
					util.destroy(socket, new InformationalError("servername changed"));
					return;
				}
			}
			if (client[kConnecting]) return;
			if (!socket && !client[kHTTP2Session]) {
				connect(client);
				return;
			}
			if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) return;
			if (client[kRunning] > 0 && !request$1.idempotent) return;
			if (client[kRunning] > 0 && (request$1.upgrade || request$1.method === "CONNECT")) return;
			if (client[kRunning] > 0 && util.bodyLength(request$1.body) !== 0 && (util.isStream(request$1.body) || util.isAsyncIterable(request$1.body))) return;
			if (!request$1.aborted && write(client, request$1)) client[kPendingIdx]++;
			else client[kQueue].splice(client[kPendingIdx], 1);
		}
	}
	function shouldSendContentLength(method) {
		return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
	}
	function write(client, request$1) {
		if (client[kHTTPConnVersion] === "h2") {
			writeH2(client, client[kHTTP2Session], request$1);
			return;
		}
		const { body, method, path: path$5, host, upgrade, headers, blocking, reset } = request$1;
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		const bodyLength = util.bodyLength(body);
		let contentLength = bodyLength;
		if (contentLength === null) contentLength = request$1.contentLength;
		if (contentLength === 0 && !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$1.contentLength !== null && request$1.contentLength !== contentLength) {
			if (client[kStrictContentLength]) {
				errorRequest(client, request$1, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		const socket = client[kSocket];
		try {
			request$1.onConnect((err) => {
				if (request$1.aborted || request$1.completed) return;
				errorRequest(client, request$1, err || new RequestAbortedError());
				util.destroy(socket, new InformationalError("aborted"));
			});
		} catch (err) {
			errorRequest(client, request$1, err);
		}
		if (request$1.aborted) return false;
		if (method === "HEAD") socket[kReset] = true;
		if (upgrade || method === "CONNECT") socket[kReset] = true;
		if (reset != null) socket[kReset] = reset;
		if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) socket[kReset] = true;
		if (blocking) socket[kBlocking] = true;
		let header = `${method} ${path$5} HTTP/1.1\r\n`;
		if (typeof host === "string") header += `host: ${host}\r\n`;
		else header += client[kHostHeader];
		if (upgrade) header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
		else if (client[kPipelining] && !socket[kReset]) header += "connection: keep-alive\r\n";
		else header += "connection: close\r\n";
		if (headers) header += headers;
		if (channels.sendHeaders.hasSubscribers) channels.sendHeaders.publish({
			request: request$1,
			headers: header,
			socket
		});
		/* istanbul ignore else: assertion */
		if (!body || bodyLength === 0) {
			if (contentLength === 0) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else {
				assert$12(contentLength === null, "no body must not have content length");
				socket.write(`${header}\r\n`, "latin1");
			}
			request$1.onRequestSent();
		} else if (util.isBuffer(body)) {
			assert$12(contentLength === body.byteLength, "buffer body must have content length");
			socket.cork();
			socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			socket.write(body);
			socket.uncork();
			request$1.onBodySent(body);
			request$1.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
		} else if (util.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
			body: body.stream(),
			client,
			request: request$1,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else writeBlob({
			body,
			client,
			request: request$1,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util.isStream(body)) writeStream({
			body,
			client,
			request: request$1,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util.isIterable(body)) writeIterable({
			body,
			client,
			request: request$1,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else assert$12(false);
		return true;
	}
	function writeH2(client, session, request$1) {
		const { body, method, path: path$5, host, upgrade, expectContinue, signal, headers: reqHeaders } = request$1;
		let headers;
		if (typeof reqHeaders === "string") headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
		else headers = reqHeaders;
		if (upgrade) {
			errorRequest(client, request$1, /* @__PURE__ */ new Error("Upgrade not supported for H2"));
			return false;
		}
		try {
			request$1.onConnect((err) => {
				if (request$1.aborted || request$1.completed) return;
				errorRequest(client, request$1, err || new RequestAbortedError());
			});
		} catch (err) {
			errorRequest(client, request$1, err);
		}
		if (request$1.aborted) return false;
		let stream$1;
		const h2State = client[kHTTP2SessionState];
		headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
		headers[HTTP2_HEADER_METHOD] = method;
		if (method === "CONNECT") {
			session.ref();
			stream$1 = session.request(headers, {
				endStream: false,
				signal
			});
			if (stream$1.id && !stream$1.pending) {
				request$1.onUpgrade(null, null, stream$1);
				++h2State.openStreams;
			} else stream$1.once("ready", () => {
				request$1.onUpgrade(null, null, stream$1);
				++h2State.openStreams;
			});
			stream$1.once("close", () => {
				h2State.openStreams -= 1;
				if (h2State.openStreams === 0) session.unref();
			});
			return true;
		}
		headers[HTTP2_HEADER_PATH] = path$5;
		headers[HTTP2_HEADER_SCHEME] = "https";
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		let contentLength = util.bodyLength(body);
		if (contentLength == null) contentLength = request$1.contentLength;
		if (contentLength === 0 || !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$1.contentLength != null && request$1.contentLength !== contentLength) {
			if (client[kStrictContentLength]) {
				errorRequest(client, request$1, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		if (contentLength != null) {
			assert$12(body, "no body must not have content length");
			headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
		}
		session.ref();
		const shouldEndStream = method === "GET" || method === "HEAD";
		if (expectContinue) {
			headers[HTTP2_HEADER_EXPECT] = "100-continue";
			stream$1 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			stream$1.once("continue", writeBodyH2);
		} else {
			stream$1 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			writeBodyH2();
		}
		++h2State.openStreams;
		stream$1.once("response", (headers$1) => {
			const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers$1;
			if (request$1.onHeaders(Number(statusCode), realHeaders, stream$1.resume.bind(stream$1), "") === false) stream$1.pause();
		});
		stream$1.once("end", () => {
			request$1.onComplete([]);
		});
		stream$1.on("data", (chunk$4) => {
			if (request$1.onData(chunk$4) === false) stream$1.pause();
		});
		stream$1.once("close", () => {
			h2State.openStreams -= 1;
			if (h2State.openStreams === 0) session.unref();
		});
		stream$1.once("error", function(err) {
			if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util.destroy(stream$1, err);
			}
		});
		stream$1.once("frameError", (type, code) => {
			const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
			errorRequest(client, request$1, err);
			if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util.destroy(stream$1, err);
			}
		});
		return true;
		function writeBodyH2() {
			/* istanbul ignore else: assertion */
			if (!body) request$1.onRequestSent();
			else if (util.isBuffer(body)) {
				assert$12(contentLength === body.byteLength, "buffer body must have content length");
				stream$1.cork();
				stream$1.write(body);
				stream$1.uncork();
				stream$1.end();
				request$1.onBodySent(body);
				request$1.onRequestSent();
			} else if (util.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
				client,
				request: request$1,
				contentLength,
				h2stream: stream$1,
				expectsPayload,
				body: body.stream(),
				socket: client[kSocket],
				header: ""
			});
			else writeBlob({
				body,
				client,
				request: request$1,
				contentLength,
				expectsPayload,
				h2stream: stream$1,
				header: "",
				socket: client[kSocket]
			});
			else if (util.isStream(body)) writeStream({
				body,
				client,
				request: request$1,
				contentLength,
				expectsPayload,
				socket: client[kSocket],
				h2stream: stream$1,
				header: ""
			});
			else if (util.isIterable(body)) writeIterable({
				body,
				client,
				request: request$1,
				contentLength,
				expectsPayload,
				header: "",
				h2stream: stream$1,
				socket: client[kSocket]
			});
			else assert$12(false);
		}
	}
	function writeStream({ h2stream, body, client, request: request$1, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
		if (client[kHTTPConnVersion] === "h2") {
			const pipe$1 = pipeline$1(body, h2stream, (err) => {
				if (err) {
					util.destroy(body, err);
					util.destroy(h2stream, err);
				} else request$1.onRequestSent();
			});
			pipe$1.on("data", onPipeData);
			pipe$1.once("end", () => {
				pipe$1.removeListener("data", onPipeData);
				util.destroy(pipe$1);
			});
			function onPipeData(chunk$4) {
				request$1.onBodySent(chunk$4);
			}
			return;
		}
		let finished$1 = false;
		const writer = new AsyncWriter({
			socket,
			request: request$1,
			contentLength,
			client,
			expectsPayload,
			header
		});
		const onData = function(chunk$4) {
			if (finished$1) return;
			try {
				if (!writer.write(chunk$4) && this.pause) this.pause();
			} catch (err) {
				util.destroy(this, err);
			}
		};
		const onDrain = function() {
			if (finished$1) return;
			if (body.resume) body.resume();
		};
		const onAbort = function() {
			if (finished$1) return;
			const err = new RequestAbortedError();
			queueMicrotask(() => onFinished(err));
		};
		const onFinished = function(err) {
			if (finished$1) return;
			finished$1 = true;
			assert$12(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
			socket.off("drain", onDrain).off("error", onFinished);
			body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
			if (!err) try {
				writer.end();
			} catch (er) {
				err = er;
			}
			writer.destroy(err);
			if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) util.destroy(body, err);
			else util.destroy(body);
		};
		body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
		if (body.resume) body.resume();
		socket.on("drain", onDrain).on("error", onFinished);
	}
	async function writeBlob({ h2stream, body, client, request: request$1, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength === body.size, "blob body must have content length");
		const isH2 = client[kHTTPConnVersion] === "h2";
		try {
			if (contentLength != null && contentLength !== body.size) throw new RequestContentLengthMismatchError();
			const buffer = Buffer.from(await body.arrayBuffer());
			if (isH2) {
				h2stream.cork();
				h2stream.write(buffer);
				h2stream.uncork();
			} else {
				socket.cork();
				socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
				socket.write(buffer);
				socket.uncork();
			}
			request$1.onBodySent(buffer);
			request$1.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
			resume(client);
		} catch (err) {
			util.destroy(isH2 ? h2stream : socket, err);
		}
	}
	async function writeIterable({ h2stream, body, client, request: request$1, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
		let callback = null;
		function onDrain() {
			if (callback) {
				const cb = callback;
				callback = null;
				cb();
			}
		}
		const waitForDrain = () => new Promise((resolve, reject) => {
			assert$12(callback === null);
			if (socket[kError]) reject(socket[kError]);
			else callback = resolve;
		});
		if (client[kHTTPConnVersion] === "h2") {
			h2stream.on("close", onDrain).on("drain", onDrain);
			try {
				for await (const chunk$4 of body) {
					if (socket[kError]) throw socket[kError];
					const res = h2stream.write(chunk$4);
					request$1.onBodySent(chunk$4);
					if (!res) await waitForDrain();
				}
			} catch (err) {
				h2stream.destroy(err);
			} finally {
				request$1.onRequestSent();
				h2stream.end();
				h2stream.off("close", onDrain).off("drain", onDrain);
			}
			return;
		}
		socket.on("close", onDrain).on("drain", onDrain);
		const writer = new AsyncWriter({
			socket,
			request: request$1,
			contentLength,
			client,
			expectsPayload,
			header
		});
		try {
			for await (const chunk$4 of body) {
				if (socket[kError]) throw socket[kError];
				if (!writer.write(chunk$4)) await waitForDrain();
			}
			writer.end();
		} catch (err) {
			writer.destroy(err);
		} finally {
			socket.off("close", onDrain).off("drain", onDrain);
		}
	}
	var AsyncWriter = class {
		constructor({ socket, request: request$1, contentLength, client, expectsPayload, header }) {
			this.socket = socket;
			this.request = request$1;
			this.contentLength = contentLength;
			this.client = client;
			this.bytesWritten = 0;
			this.expectsPayload = expectsPayload;
			this.header = header;
			socket[kWriting] = true;
		}
		write(chunk$4) {
			const { socket, request: request$1, contentLength, client, bytesWritten, expectsPayload, header } = this;
			if (socket[kError]) throw socket[kError];
			if (socket.destroyed) return false;
			const len = Buffer.byteLength(chunk$4);
			if (!len) return true;
			if (contentLength !== null && bytesWritten + len > contentLength) {
				if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
				process.emitWarning(new RequestContentLengthMismatchError());
			}
			socket.cork();
			if (bytesWritten === 0) {
				if (!expectsPayload) socket[kReset] = true;
				if (contentLength === null) socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
				else socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			}
			if (contentLength === null) socket.write(`\r\n${len.toString(16)}\r\n`, "latin1");
			this.bytesWritten += len;
			const ret = socket.write(chunk$4);
			socket.uncork();
			request$1.onBodySent(chunk$4);
			if (!ret) {
				if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
					// istanbul ignore else: only for jest
					if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
				}
			}
			return ret;
		}
		end() {
			const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request$1 } = this;
			request$1.onRequestSent();
			socket[kWriting] = false;
			if (socket[kError]) throw socket[kError];
			if (socket.destroyed) return;
			if (bytesWritten === 0) if (expectsPayload) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else socket.write(`${header}\r\n`, "latin1");
			else if (contentLength === null) socket.write("\r\n0\r\n\r\n", "latin1");
			if (contentLength !== null && bytesWritten !== contentLength) if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
			else process.emitWarning(new RequestContentLengthMismatchError());
			if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
				// istanbul ignore else: only for jest
				if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
			}
			resume(client);
		}
		destroy(err) {
			const { socket, client } = this;
			socket[kWriting] = false;
			if (err) {
				assert$12(client[kRunning] <= 1, "pipeline should only contain this request");
				util.destroy(socket, err);
			}
		}
	};
	function errorRequest(client, request$1, err) {
		try {
			request$1.onError(err);
			assert$12(request$1.aborted);
		} catch (err$1) {
			client.emit("error", err$1);
		}
	}
	module.exports = Client;
}));
var require_fixed_queue = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var kSize = 2048;
	var kMask = kSize - 1;
	var FixedCircularBuffer = class {
		constructor() {
			this.bottom = 0;
			this.top = 0;
			this.list = new Array(kSize);
			this.next = null;
		}
		isEmpty() {
			return this.top === this.bottom;
		}
		isFull() {
			return (this.top + 1 & kMask) === this.bottom;
		}
		push(data) {
			this.list[this.top] = data;
			this.top = this.top + 1 & kMask;
		}
		shift() {
			const nextItem = this.list[this.bottom];
			if (nextItem === void 0) return null;
			this.list[this.bottom] = void 0;
			this.bottom = this.bottom + 1 & kMask;
			return nextItem;
		}
	};
	module.exports = class FixedQueue {
		constructor() {
			this.head = this.tail = new FixedCircularBuffer();
		}
		isEmpty() {
			return this.head.isEmpty();
		}
		push(data) {
			if (this.head.isFull()) this.head = this.head.next = new FixedCircularBuffer();
			this.head.push(data);
		}
		shift() {
			const tail = this.tail;
			const next = tail.shift();
			if (tail.isEmpty() && tail.next !== null) this.tail = tail.next;
			return next;
		}
	};
}));
var require_pool_stats = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols$4();
	var kPool = Symbol("pool");
	var PoolStats = class {
		constructor(pool) {
			this[kPool] = pool;
		}
		get connected() {
			return this[kPool][kConnected];
		}
		get free() {
			return this[kPool][kFree];
		}
		get pending() {
			return this[kPool][kPending];
		}
		get queued() {
			return this[kPool][kQueued];
		}
		get running() {
			return this[kPool][kRunning];
		}
		get size() {
			return this[kPool][kSize];
		}
	};
	module.exports = PoolStats;
}));
var require_pool_base = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var DispatcherBase = require_dispatcher_base();
	var FixedQueue = require_fixed_queue();
	var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols$4();
	var PoolStats = require_pool_stats();
	var kClients = Symbol("clients");
	var kNeedDrain = Symbol("needDrain");
	var kQueue = Symbol("queue");
	var kClosedResolve = Symbol("closed resolve");
	var kOnDrain = Symbol("onDrain");
	var kOnConnect = Symbol("onConnect");
	var kOnDisconnect = Symbol("onDisconnect");
	var kOnConnectionError = Symbol("onConnectionError");
	var kGetDispatcher = Symbol("get dispatcher");
	var kAddClient = Symbol("add client");
	var kRemoveClient = Symbol("remove client");
	var kStats = Symbol("stats");
	var PoolBase = class extends DispatcherBase {
		constructor() {
			super();
			this[kQueue] = new FixedQueue();
			this[kClients] = [];
			this[kQueued] = 0;
			const pool = this;
			this[kOnDrain] = function onDrain(origin, targets) {
				const queue = pool[kQueue];
				let needDrain = false;
				while (!needDrain) {
					const item = queue.shift();
					if (!item) break;
					pool[kQueued]--;
					needDrain = !this.dispatch(item.opts, item.handler);
				}
				this[kNeedDrain] = needDrain;
				if (!this[kNeedDrain] && pool[kNeedDrain]) {
					pool[kNeedDrain] = false;
					pool.emit("drain", origin, [pool, ...targets]);
				}
				if (pool[kClosedResolve] && queue.isEmpty()) Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
			};
			this[kOnConnect] = (origin, targets) => {
				pool.emit("connect", origin, [pool, ...targets]);
			};
			this[kOnDisconnect] = (origin, targets, err) => {
				pool.emit("disconnect", origin, [pool, ...targets], err);
			};
			this[kOnConnectionError] = (origin, targets, err) => {
				pool.emit("connectionError", origin, [pool, ...targets], err);
			};
			this[kStats] = new PoolStats(this);
		}
		get [kBusy]() {
			return this[kNeedDrain];
		}
		get [kConnected]() {
			return this[kClients].filter((client) => client[kConnected]).length;
		}
		get [kFree]() {
			return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
		}
		get [kPending]() {
			let ret = this[kQueued];
			for (const { [kPending]: pending$2 } of this[kClients]) ret += pending$2;
			return ret;
		}
		get [kRunning]() {
			let ret = 0;
			for (const { [kRunning]: running$2 } of this[kClients]) ret += running$2;
			return ret;
		}
		get [kSize]() {
			let ret = this[kQueued];
			for (const { [kSize]: size$11 } of this[kClients]) ret += size$11;
			return ret;
		}
		get stats() {
			return this[kStats];
		}
		async [kClose]() {
			if (this[kQueue].isEmpty()) return Promise.all(this[kClients].map((c) => c.close()));
			else return new Promise((resolve) => {
				this[kClosedResolve] = resolve;
			});
		}
		async [kDestroy](err) {
			while (true) {
				const item = this[kQueue].shift();
				if (!item) break;
				item.handler.onError(err);
			}
			return Promise.all(this[kClients].map((c) => c.destroy(err)));
		}
		[kDispatch](opts, handler) {
			const dispatcher = this[kGetDispatcher]();
			if (!dispatcher) {
				this[kNeedDrain] = true;
				this[kQueue].push({
					opts,
					handler
				});
				this[kQueued]++;
			} else if (!dispatcher.dispatch(opts, handler)) {
				dispatcher[kNeedDrain] = true;
				this[kNeedDrain] = !this[kGetDispatcher]();
			}
			return !this[kNeedDrain];
		}
		[kAddClient](client) {
			client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
			this[kClients].push(client);
			if (this[kNeedDrain]) process.nextTick(() => {
				if (this[kNeedDrain]) this[kOnDrain](client[kUrl], [this, client]);
			});
			return this;
		}
		[kRemoveClient](client) {
			client.close(() => {
				const idx = this[kClients].indexOf(client);
				if (idx !== -1) this[kClients].splice(idx, 1);
			});
			this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
		}
	};
	module.exports = {
		PoolBase,
		kClients,
		kNeedDrain,
		kAddClient,
		kRemoveClient,
		kGetDispatcher
	};
}));
var require_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = require_pool_base();
	var Client = require_client();
	var { InvalidArgumentError } = require_errors();
	var util = require_util$6();
	var { kUrl, kInterceptors } = require_symbols$4();
	var buildConnector = require_connect();
	var kOptions = Symbol("options");
	var kConnections = Symbol("connections");
	var kFactory = Symbol("factory");
	function defaultFactory(origin, opts) {
		return new Client(origin, opts);
	}
	var Pool = class extends PoolBase {
		constructor(origin, { connections, factory = defaultFactory, connect, connectTimeout, tls: tls$1, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}) {
			super();
			if (connections != null && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError("invalid connections");
			if (typeof factory !== "function") throw new InvalidArgumentError("factory must be a function.");
			if (connect != null && typeof connect !== "function" && typeof connect !== "object") throw new InvalidArgumentError("connect must be a function or an object");
			if (typeof connect !== "function") connect = buildConnector({
				...tls$1,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect
			});
			this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
			this[kConnections] = connections || null;
			this[kUrl] = util.parseOrigin(origin);
			this[kOptions] = {
				...util.deepClone(options),
				connect,
				allowH2
			};
			this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kFactory] = factory;
			this.on("connectionError", (origin$1, targets, error) => {
				for (const target of targets) {
					const idx = this[kClients].indexOf(target);
					if (idx !== -1) this[kClients].splice(idx, 1);
				}
			});
		}
		[kGetDispatcher]() {
			let dispatcher = this[kClients].find((dispatcher$1) => !dispatcher$1[kNeedDrain]);
			if (dispatcher) return dispatcher;
			if (!this[kConnections] || this[kClients].length < this[kConnections]) {
				dispatcher = this[kFactory](this[kUrl], this[kOptions]);
				this[kAddClient](dispatcher);
			}
			return dispatcher;
		}
	};
	module.exports = Pool;
}));
var require_balanced_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { BalancedPoolMissingUpstreamError, InvalidArgumentError } = require_errors();
	var { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = require_pool_base();
	var Pool = require_pool();
	var { kUrl, kInterceptors } = require_symbols$4();
	var { parseOrigin } = require_util$6();
	var kFactory = Symbol("factory");
	var kOptions = Symbol("options");
	var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
	var kCurrentWeight = Symbol("kCurrentWeight");
	var kIndex = Symbol("kIndex");
	var kWeight = Symbol("kWeight");
	var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
	var kErrorPenalty = Symbol("kErrorPenalty");
	function getGreatestCommonDivisor(a, b) {
		if (b === 0) return a;
		return getGreatestCommonDivisor(b, a % b);
	}
	function defaultFactory(origin, opts) {
		return new Pool(origin, opts);
	}
	var BalancedPool = class extends PoolBase {
		constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
			super();
			this[kOptions] = opts;
			this[kIndex] = -1;
			this[kCurrentWeight] = 0;
			this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
			this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
			if (!Array.isArray(upstreams)) upstreams = [upstreams];
			if (typeof factory !== "function") throw new InvalidArgumentError("factory must be a function.");
			this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
			this[kFactory] = factory;
			for (const upstream of upstreams) this.addUpstream(upstream);
			this._updateBalancedPoolStats();
		}
		addUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			if (this[kClients].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true)) return this;
			const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
			this[kAddClient](pool);
			pool.on("connect", () => {
				pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
			});
			pool.on("connectionError", () => {
				pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
				this._updateBalancedPoolStats();
			});
			pool.on("disconnect", (...args$1) => {
				const err = args$1[2];
				if (err && err.code === "UND_ERR_SOCKET") {
					pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
					this._updateBalancedPoolStats();
				}
			});
			for (const client of this[kClients]) client[kWeight] = this[kMaxWeightPerServer];
			this._updateBalancedPoolStats();
			return this;
		}
		_updateBalancedPoolStats() {
			this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
		}
		removeUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			const pool = this[kClients].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true);
			if (pool) this[kRemoveClient](pool);
			return this;
		}
		get upstreams() {
			return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
		}
		[kGetDispatcher]() {
			if (this[kClients].length === 0) throw new BalancedPoolMissingUpstreamError();
			if (!this[kClients].find((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true)) return;
			if (this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true)) return;
			let counter$5 = 0;
			let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
			while (counter$5++ < this[kClients].length) {
				this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
				const pool = this[kClients][this[kIndex]];
				if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) maxWeightIndex = this[kIndex];
				if (this[kIndex] === 0) {
					this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
					if (this[kCurrentWeight] <= 0) this[kCurrentWeight] = this[kMaxWeightPerServer];
				}
				if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) return pool;
			}
			this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
			this[kIndex] = maxWeightIndex;
			return this[kClients][maxWeightIndex];
		}
	};
	module.exports = BalancedPool;
}));
var require_dispatcher_weakref = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/* istanbul ignore file: only for Node 12 */
	var { kConnected, kSize } = require_symbols$4();
	var CompatWeakRef = class {
		constructor(value$2) {
			this.value = value$2;
		}
		deref() {
			return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
		}
	};
	var CompatFinalizer = class {
		constructor(finalizer) {
			this.finalizer = finalizer;
		}
		register(dispatcher, key) {
			if (dispatcher.on) dispatcher.on("disconnect", () => {
				if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) this.finalizer(key);
			});
		}
	};
	module.exports = function() {
		if (process.env.NODE_V8_COVERAGE) return {
			WeakRef: CompatWeakRef,
			FinalizationRegistry: CompatFinalizer
		};
		return {
			WeakRef: global.WeakRef || CompatWeakRef,
			FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
		};
	};
}));
var require_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { InvalidArgumentError } = require_errors();
	var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols$4();
	var DispatcherBase = require_dispatcher_base();
	var Pool = require_pool();
	var Client = require_client();
	var util = require_util$6();
	var createRedirectInterceptor = require_redirectInterceptor();
	var { WeakRef, FinalizationRegistry } = require_dispatcher_weakref()();
	var kOnConnect = Symbol("onConnect");
	var kOnDisconnect = Symbol("onDisconnect");
	var kOnConnectionError = Symbol("onConnectionError");
	var kMaxRedirections = Symbol("maxRedirections");
	var kOnDrain = Symbol("onDrain");
	var kFactory = Symbol("factory");
	var kFinalizer = Symbol("finalizer");
	var kOptions = Symbol("options");
	function defaultFactory(origin, opts) {
		return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
	}
	var Agent = class extends DispatcherBase {
		constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
			super();
			if (typeof factory !== "function") throw new InvalidArgumentError("factory must be a function.");
			if (connect != null && typeof connect !== "function" && typeof connect !== "object") throw new InvalidArgumentError("connect must be a function or an object");
			if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError("maxRedirections must be a positive number");
			if (connect && typeof connect !== "function") connect = { ...connect };
			this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
			this[kOptions] = {
				...util.deepClone(options),
				connect
			};
			this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kMaxRedirections] = maxRedirections;
			this[kFactory] = factory;
			this[kClients] = /* @__PURE__ */ new Map();
			this[kFinalizer] = new FinalizationRegistry(
				/* istanbul ignore next: gc is undeterministic */
				(key) => {
					const ref = this[kClients].get(key);
					if (ref !== void 0 && ref.deref() === void 0) this[kClients].delete(key);
				}
			);
			const agent = this;
			this[kOnDrain] = (origin, targets) => {
				agent.emit("drain", origin, [agent, ...targets]);
			};
			this[kOnConnect] = (origin, targets) => {
				agent.emit("connect", origin, [agent, ...targets]);
			};
			this[kOnDisconnect] = (origin, targets, err) => {
				agent.emit("disconnect", origin, [agent, ...targets], err);
			};
			this[kOnConnectionError] = (origin, targets, err) => {
				agent.emit("connectionError", origin, [agent, ...targets], err);
			};
		}
		get [kRunning]() {
			let ret = 0;
			for (const ref of this[kClients].values()) {
				const client = ref.deref();
				/* istanbul ignore next: gc is undeterministic */
				if (client) ret += client[kRunning];
			}
			return ret;
		}
		[kDispatch](opts, handler) {
			let key;
			if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) key = String(opts.origin);
			else throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
			const ref = this[kClients].get(key);
			let dispatcher = ref ? ref.deref() : null;
			if (!dispatcher) {
				dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
				this[kClients].set(key, new WeakRef(dispatcher));
				this[kFinalizer].register(dispatcher, key);
			}
			return dispatcher.dispatch(opts, handler);
		}
		async [kClose]() {
			const closePromises = [];
			for (const ref of this[kClients].values()) {
				const client = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client) closePromises.push(client.close());
			}
			await Promise.all(closePromises);
		}
		async [kDestroy](err) {
			const destroyPromises = [];
			for (const ref of this[kClients].values()) {
				const client = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client) destroyPromises.push(client.destroy(err));
			}
			await Promise.all(destroyPromises);
		}
	};
	module.exports = Agent;
}));
var require_readable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert$11 = __require("assert");
	var { Readable: Readable$2 } = __require("stream");
	var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
	var util = require_util$6();
	var { ReadableStreamFrom, toUSVString } = require_util$6();
	var Blob;
	var kConsume = Symbol("kConsume");
	var kReading = Symbol("kReading");
	var kBody = Symbol("kBody");
	var kAbort = Symbol("abort");
	var kContentType = Symbol("kContentType");
	var noop = () => {};
	module.exports = class BodyReadable extends Readable$2 {
		constructor({ resume: resume$1, abort, contentType = "", highWaterMark = 64 * 1024 }) {
			super({
				autoDestroy: true,
				read: resume$1,
				highWaterMark
			});
			this._readableState.dataEmitted = false;
			this[kAbort] = abort;
			this[kConsume] = null;
			this[kBody] = null;
			this[kContentType] = contentType;
			this[kReading] = false;
		}
		destroy(err) {
			if (this.destroyed) return this;
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError();
			if (err) this[kAbort]();
			return super.destroy(err);
		}
		emit(ev, ...args$1) {
			if (ev === "data") this._readableState.dataEmitted = true;
			else if (ev === "error") this._readableState.errorEmitted = true;
			return super.emit(ev, ...args$1);
		}
		on(ev, ...args$1) {
			if (ev === "data" || ev === "readable") this[kReading] = true;
			return super.on(ev, ...args$1);
		}
		addListener(ev, ...args$1) {
			return this.on(ev, ...args$1);
		}
		off(ev, ...args$1) {
			const ret = super.off(ev, ...args$1);
			if (ev === "data" || ev === "readable") this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
			return ret;
		}
		removeListener(ev, ...args$1) {
			return this.off(ev, ...args$1);
		}
		push(chunk$4) {
			if (this[kConsume] && chunk$4 !== null && this.readableLength === 0) {
				consumePush(this[kConsume], chunk$4);
				return this[kReading] ? super.push(chunk$4) : true;
			}
			return super.push(chunk$4);
		}
		async text() {
			return consume(this, "text");
		}
		async json() {
			return consume(this, "json");
		}
		async blob() {
			return consume(this, "blob");
		}
		async arrayBuffer() {
			return consume(this, "arrayBuffer");
		}
		async formData() {
			throw new NotSupportedError();
		}
		get bodyUsed() {
			return util.isDisturbed(this);
		}
		get body() {
			if (!this[kBody]) {
				this[kBody] = ReadableStreamFrom(this);
				if (this[kConsume]) {
					this[kBody].getReader();
					assert$11(this[kBody].locked);
				}
			}
			return this[kBody];
		}
		dump(opts) {
			let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
			const signal = opts && opts.signal;
			if (signal) try {
				if (typeof signal !== "object" || !("aborted" in signal)) throw new InvalidArgumentError("signal must be an AbortSignal");
				util.throwIfAborted(signal);
			} catch (err) {
				return Promise.reject(err);
			}
			if (this.closed) return Promise.resolve(null);
			return new Promise((resolve, reject) => {
				const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
					this.destroy();
				}) : noop;
				this.on("close", function() {
					signalListenerCleanup();
					if (signal && signal.aborted) reject(signal.reason || Object.assign(/* @__PURE__ */ new Error("The operation was aborted"), { name: "AbortError" }));
					else resolve(null);
				}).on("error", noop).on("data", function(chunk$4) {
					limit -= chunk$4.length;
					if (limit <= 0) this.destroy();
				}).resume();
			});
		}
	};
	function isLocked(self) {
		return self[kBody] && self[kBody].locked === true || self[kConsume];
	}
	function isUnusable(self) {
		return util.isDisturbed(self) || isLocked(self);
	}
	async function consume(stream$1, type) {
		if (isUnusable(stream$1)) throw new TypeError("unusable");
		assert$11(!stream$1[kConsume]);
		return new Promise((resolve, reject) => {
			stream$1[kConsume] = {
				type,
				stream: stream$1,
				resolve,
				reject,
				length: 0,
				body: []
			};
			stream$1.on("error", function(err) {
				consumeFinish(this[kConsume], err);
			}).on("close", function() {
				if (this[kConsume].body !== null) consumeFinish(this[kConsume], new RequestAbortedError());
			});
			process.nextTick(consumeStart, stream$1[kConsume]);
		});
	}
	function consumeStart(consume) {
		if (consume.body === null) return;
		const { _readableState: state } = consume.stream;
		for (const chunk$4 of state.buffer) consumePush(consume, chunk$4);
		if (state.endEmitted) consumeEnd(this[kConsume]);
		else consume.stream.on("end", function() {
			consumeEnd(this[kConsume]);
		});
		consume.stream.resume();
		while (consume.stream.read() != null);
	}
	function consumeEnd(consume) {
		const { type, body, resolve, stream: stream$1, length: length$1 } = consume;
		try {
			if (type === "text") resolve(toUSVString(Buffer.concat(body)));
			else if (type === "json") resolve(JSON.parse(Buffer.concat(body)));
			else if (type === "arrayBuffer") {
				const dst = new Uint8Array(length$1);
				let pos = 0;
				for (const buf of body) {
					dst.set(buf, pos);
					pos += buf.byteLength;
				}
				resolve(dst.buffer);
			} else if (type === "blob") {
				if (!Blob) Blob = __require("buffer").Blob;
				resolve(new Blob(body, { type: stream$1[kContentType] }));
			}
			consumeFinish(consume);
		} catch (err) {
			stream$1.destroy(err);
		}
	}
	function consumePush(consume, chunk$4) {
		consume.length += chunk$4.length;
		consume.body.push(chunk$4);
	}
	function consumeFinish(consume, err) {
		if (consume.body === null) return;
		if (err) consume.reject(err);
		else consume.resolve();
		consume.type = null;
		consume.stream = null;
		consume.resolve = null;
		consume.reject = null;
		consume.length = 0;
		consume.body = null;
	}
}));
var require_util$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert$10 = __require("assert");
	var { ResponseStatusCodeError } = require_errors();
	var { toUSVString } = require_util$6();
	async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
		assert$10(body);
		let chunks = [];
		let limit = 0;
		for await (const chunk$4 of body) {
			chunks.push(chunk$4);
			limit += chunk$4.length;
			if (limit > 128 * 1024) {
				chunks = null;
				break;
			}
		}
		if (statusCode === 204 || !contentType || !chunks) {
			process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
			return;
		}
		try {
			if (contentType.startsWith("application/json")) {
				const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
				return;
			}
			if (contentType.startsWith("text/")) {
				const payload = toUSVString(Buffer.concat(chunks));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
				return;
			}
		} catch (err) {}
		process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
	}
	module.exports = { getResolveErrorBodyCallback };
}));
var require_abort_signal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { addAbortListener } = require_util$6();
	var { RequestAbortedError } = require_errors();
	var kListener = Symbol("kListener");
	var kSignal = Symbol("kSignal");
	function abort(self) {
		if (self.abort) self.abort();
		else self.onError(new RequestAbortedError());
	}
	function addSignal(self, signal) {
		self[kSignal] = null;
		self[kListener] = null;
		if (!signal) return;
		if (signal.aborted) {
			abort(self);
			return;
		}
		self[kSignal] = signal;
		self[kListener] = () => {
			abort(self);
		};
		addAbortListener(self[kSignal], self[kListener]);
	}
	function removeSignal(self) {
		if (!self[kSignal]) return;
		if ("removeEventListener" in self[kSignal]) self[kSignal].removeEventListener("abort", self[kListener]);
		else self[kSignal].removeListener("abort", self[kListener]);
		self[kSignal] = null;
		self[kListener] = null;
	}
	module.exports = {
		addSignal,
		removeSignal
	};
}));
var require_api_request = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Readable = require_readable();
	var { InvalidArgumentError, RequestAbortedError } = require_errors();
	var util = require_util$6();
	var { getResolveErrorBodyCallback } = require_util$4();
	var { AsyncResource: AsyncResource$4 } = __require("async_hooks");
	var { addSignal, removeSignal } = require_abort_signal();
	var RequestHandler = class extends AsyncResource$4 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError("invalid callback");
				if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) throw new InvalidArgumentError("invalid highWaterMark");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError("invalid onInfo callback");
				super("UNDICI_REQUEST");
			} catch (err) {
				if (util.isStream(body)) util.destroy(body.on("error", util.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.body = body;
			this.trailers = {};
			this.context = null;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError;
			this.highWaterMark = highWaterMark;
			if (util.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal(this, signal);
		}
		onConnect(abort, context$3) {
			if (!this.callback) throw new RequestAbortedError();
			this.abort = abort;
			this.context = context$3;
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const { callback, opaque, abort, context: context$3, responseHeaders, highWaterMark } = this;
			const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			const contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"];
			const body = new Readable({
				resume: resume$1,
				abort,
				contentType,
				highWaterMark
			});
			this.callback = null;
			this.res = body;
			if (callback !== null) if (this.throwOnError && statusCode >= 400) this.runInAsyncScope(getResolveErrorBodyCallback, null, {
				callback,
				body,
				contentType,
				statusCode,
				statusMessage,
				headers
			});
			else this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				trailers: this.trailers,
				opaque,
				body,
				context: context$3
			});
		}
		onData(chunk$4) {
			const { res } = this;
			return res.push(chunk$4);
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal(this);
			util.parseHeaders(trailers, this.trailers);
			res.push(null);
		}
		onError(err) {
			const { res, callback, body, opaque } = this;
			removeSignal(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (res) {
				this.res = null;
				queueMicrotask(() => {
					util.destroy(res, err);
				});
			}
			if (body) {
				this.body = null;
				util.destroy(body, err);
			}
		}
	};
	function request(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			request.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			this.dispatch(opts, new RequestHandler(opts, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = request;
	module.exports.RequestHandler = RequestHandler;
}));
var require_api_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { finished, PassThrough: PassThrough$1 } = __require("stream");
	var { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = require_errors();
	var util = require_util$6();
	var { getResolveErrorBodyCallback } = require_util$4();
	var { AsyncResource: AsyncResource$3 } = __require("async_hooks");
	var { addSignal, removeSignal } = require_abort_signal();
	var StreamHandler = class extends AsyncResource$3 {
		constructor(opts, factory, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError("invalid callback");
				if (typeof factory !== "function") throw new InvalidArgumentError("invalid factory");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError("invalid onInfo callback");
				super("UNDICI_STREAM");
			} catch (err) {
				if (util.isStream(body)) util.destroy(body.on("error", util.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.factory = factory;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.context = null;
			this.trailers = null;
			this.body = body;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError || false;
			if (util.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal(this, signal);
		}
		onConnect(abort, context$3) {
			if (!this.callback) throw new RequestAbortedError();
			this.abort = abort;
			this.context = context$3;
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const { factory, opaque, context: context$3, callback, responseHeaders } = this;
			const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			this.factory = null;
			let res;
			if (this.throwOnError && statusCode >= 400) {
				const contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"];
				res = new PassThrough$1();
				this.callback = null;
				this.runInAsyncScope(getResolveErrorBodyCallback, null, {
					callback,
					body: res,
					contentType,
					statusCode,
					statusMessage,
					headers
				});
			} else {
				if (factory === null) return;
				res = this.runInAsyncScope(factory, null, {
					statusCode,
					headers,
					opaque,
					context: context$3
				});
				if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") throw new InvalidReturnValueError("expected Writable");
				finished(res, { readable: false }, (err) => {
					const { callback: callback$1, res: res$1, opaque: opaque$1, trailers, abort } = this;
					this.res = null;
					if (err || !res$1.readable) util.destroy(res$1, err);
					this.callback = null;
					this.runInAsyncScope(callback$1, null, err || null, {
						opaque: opaque$1,
						trailers
					});
					if (err) abort();
				});
			}
			res.on("drain", resume$1);
			this.res = res;
			return (res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain) !== true;
		}
		onData(chunk$4) {
			const { res } = this;
			return res ? res.write(chunk$4) : true;
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal(this);
			if (!res) return;
			this.trailers = util.parseHeaders(trailers);
			res.end();
		}
		onError(err) {
			const { res, callback, opaque, body } = this;
			removeSignal(this);
			this.factory = null;
			if (res) {
				this.res = null;
				util.destroy(res, err);
			} else if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (body) {
				this.body = null;
				util.destroy(body, err);
			}
		}
	};
	function stream(opts, factory, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			stream.call(this, opts, factory, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			this.dispatch(opts, new StreamHandler(opts, factory, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = stream;
}));
var require_api_pipeline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Readable: Readable$1, Duplex, PassThrough } = __require("stream");
	var { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = require_errors();
	var util = require_util$6();
	var { AsyncResource: AsyncResource$2 } = __require("async_hooks");
	var { addSignal, removeSignal } = require_abort_signal();
	var assert$9 = __require("assert");
	var kResume = Symbol("resume");
	var PipelineRequest = class extends Readable$1 {
		constructor() {
			super({ autoDestroy: true });
			this[kResume] = null;
		}
		_read() {
			const { [kResume]: resume$1 } = this;
			if (resume$1) {
				this[kResume] = null;
				resume$1();
			}
		}
		_destroy(err, callback) {
			this._read();
			callback(err);
		}
	};
	var PipelineResponse = class extends Readable$1 {
		constructor(resume$1) {
			super({ autoDestroy: true });
			this[kResume] = resume$1;
		}
		_read() {
			this[kResume]();
		}
		_destroy(err, callback) {
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError();
			callback(err);
		}
	};
	var PipelineHandler = class extends AsyncResource$2 {
		constructor(opts, handler) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			if (typeof handler !== "function") throw new InvalidArgumentError("invalid handler");
			const { signal, method, opaque, onInfo, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
			if (method === "CONNECT") throw new InvalidArgumentError("invalid method");
			if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError("invalid onInfo callback");
			super("UNDICI_PIPELINE");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.handler = handler;
			this.abort = null;
			this.context = null;
			this.onInfo = onInfo || null;
			this.req = new PipelineRequest().on("error", util.nop);
			this.ret = new Duplex({
				readableObjectMode: opts.objectMode,
				autoDestroy: true,
				read: () => {
					const { body } = this;
					if (body && body.resume) body.resume();
				},
				write: (chunk$4, encoding, callback) => {
					const { req } = this;
					if (req.push(chunk$4, encoding) || req._readableState.destroyed) callback();
					else req[kResume] = callback;
				},
				destroy: (err, callback) => {
					const { body, req, res, ret, abort } = this;
					if (!err && !ret._readableState.endEmitted) err = new RequestAbortedError();
					if (abort && err) abort();
					util.destroy(body, err);
					util.destroy(req, err);
					util.destroy(res, err);
					removeSignal(this);
					callback(err);
				}
			}).on("prefinish", () => {
				const { req } = this;
				req.push(null);
			});
			this.res = null;
			addSignal(this, signal);
		}
		onConnect(abort, context$3) {
			const { ret, res } = this;
			assert$9(!res, "pipeline cannot be retried");
			if (ret.destroyed) throw new RequestAbortedError();
			this.abort = abort;
			this.context = context$3;
		}
		onHeaders(statusCode, rawHeaders, resume$1) {
			const { opaque, handler, context: context$3 } = this;
			if (statusCode < 200) {
				if (this.onInfo) {
					const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
					this.onInfo({
						statusCode,
						headers
					});
				}
				return;
			}
			this.res = new PipelineResponse(resume$1);
			let body;
			try {
				this.handler = null;
				const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
				body = this.runInAsyncScope(handler, null, {
					statusCode,
					headers,
					opaque,
					body: this.res,
					context: context$3
				});
			} catch (err) {
				this.res.on("error", util.nop);
				throw err;
			}
			if (!body || typeof body.on !== "function") throw new InvalidReturnValueError("expected Readable");
			body.on("data", (chunk$4) => {
				const { ret, body: body$1 } = this;
				if (!ret.push(chunk$4) && body$1.pause) body$1.pause();
			}).on("error", (err) => {
				const { ret } = this;
				util.destroy(ret, err);
			}).on("end", () => {
				const { ret } = this;
				ret.push(null);
			}).on("close", () => {
				const { ret } = this;
				if (!ret._readableState.ended) util.destroy(ret, new RequestAbortedError());
			});
			this.body = body;
		}
		onData(chunk$4) {
			const { res } = this;
			return res.push(chunk$4);
		}
		onComplete(trailers) {
			const { res } = this;
			res.push(null);
		}
		onError(err) {
			const { ret } = this;
			this.handler = null;
			util.destroy(ret, err);
		}
	};
	function pipeline(opts, handler) {
		try {
			const pipelineHandler = new PipelineHandler(opts, handler);
			this.dispatch({
				...opts,
				body: pipelineHandler.req
			}, pipelineHandler);
			return pipelineHandler.ret;
		} catch (err) {
			return new PassThrough().destroy(err);
		}
	}
	module.exports = pipeline;
}));
var require_api_upgrade = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
	var { AsyncResource: AsyncResource$1 } = __require("async_hooks");
	var util = require_util$6();
	var { addSignal, removeSignal } = require_abort_signal();
	var assert$8 = __require("assert");
	var UpgradeHandler = class extends AsyncResource$1 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
			super("UNDICI_UPGRADE");
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.abort = null;
			this.context = null;
			addSignal(this, signal);
		}
		onConnect(abort, context$3) {
			if (!this.callback) throw new RequestAbortedError();
			this.abort = abort;
			this.context = null;
		}
		onHeaders() {
			throw new SocketError("bad upgrade", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context: context$3 } = this;
			assert$8.strictEqual(statusCode, 101);
			removeSignal(this);
			this.callback = null;
			const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				headers,
				socket,
				opaque,
				context: context$3
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function upgrade(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			upgrade.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			const upgradeHandler = new UpgradeHandler(opts, callback);
			this.dispatch({
				...opts,
				method: opts.method || "GET",
				upgrade: opts.protocol || "Websocket"
			}, upgradeHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = upgrade;
}));
var require_api_connect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { AsyncResource } = __require("async_hooks");
	var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
	var util = require_util$6();
	var { addSignal, removeSignal } = require_abort_signal();
	var ConnectHandler = class extends AsyncResource {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
			super("UNDICI_CONNECT");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.callback = callback;
			this.abort = null;
			addSignal(this, signal);
		}
		onConnect(abort, context$3) {
			if (!this.callback) throw new RequestAbortedError();
			this.abort = abort;
			this.context = context$3;
		}
		onHeaders() {
			throw new SocketError("bad connect", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context: context$3 } = this;
			removeSignal(this);
			this.callback = null;
			let headers = rawHeaders;
			if (headers != null) headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				socket,
				opaque,
				context: context$3
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function connect(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			connect.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			const connectHandler = new ConnectHandler(opts, callback);
			this.dispatch({
				...opts,
				method: "CONNECT"
			}, connectHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = connect;
}));
var require_api = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports.request = require_api_request();
	module.exports.stream = require_api_stream();
	module.exports.pipeline = require_api_pipeline();
	module.exports.upgrade = require_api_upgrade();
	module.exports.connect = require_api_connect();
}));
var require_mock_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { UndiciError } = require_errors();
	module.exports = { MockNotMatchedError: class MockNotMatchedError extends UndiciError {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, MockNotMatchedError);
			this.name = "MockNotMatchedError";
			this.message = message || "The request does not match any registered mock dispatches";
			this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
		}
	} };
}));
var require_mock_symbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kAgent: Symbol("agent"),
		kOptions: Symbol("options"),
		kFactory: Symbol("factory"),
		kDispatches: Symbol("dispatches"),
		kDispatchKey: Symbol("dispatch key"),
		kDefaultHeaders: Symbol("default headers"),
		kDefaultTrailers: Symbol("default trailers"),
		kContentLength: Symbol("content length"),
		kMockAgent: Symbol("mock agent"),
		kMockAgentSet: Symbol("mock agent set"),
		kMockAgentGet: Symbol("mock agent get"),
		kMockDispatch: Symbol("mock dispatch"),
		kClose: Symbol("close"),
		kOriginalClose: Symbol("original agent close"),
		kOrigin: Symbol("origin"),
		kIsMockActive: Symbol("is mock active"),
		kNetConnect: Symbol("net connect"),
		kGetNetConnect: Symbol("get net connect"),
		kConnected: Symbol("connected")
	};
}));
var require_mock_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { MockNotMatchedError } = require_mock_errors();
	var { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = require_mock_symbols();
	var { buildURL, nop } = require_util$6();
	var { STATUS_CODES: STATUS_CODES$1 } = __require("http");
	var { types: { isPromise } } = __require("util");
	function matchValue(match$15, value$2) {
		if (typeof match$15 === "string") return match$15 === value$2;
		if (match$15 instanceof RegExp) return match$15.test(value$2);
		if (typeof match$15 === "function") return match$15(value$2) === true;
		return false;
	}
	function lowerCaseEntries(headers) {
		return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
			return [headerName.toLocaleLowerCase(), headerValue];
		}));
	}
	function getHeaderByName(headers, key) {
		if (Array.isArray(headers)) {
			for (let i = 0; i < headers.length; i += 2) if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i + 1];
			return;
		} else if (typeof headers.get === "function") return headers.get(key);
		else return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
	}
	function buildHeadersFromArray(headers) {
		const clone$1 = headers.slice();
		const entries$2 = [];
		for (let index = 0; index < clone$1.length; index += 2) entries$2.push([clone$1[index], clone$1[index + 1]]);
		return Object.fromEntries(entries$2);
	}
	function matchHeaders(mockDispatch, headers) {
		if (typeof mockDispatch.headers === "function") {
			if (Array.isArray(headers)) headers = buildHeadersFromArray(headers);
			return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});
		}
		if (typeof mockDispatch.headers === "undefined") return true;
		if (typeof headers !== "object" || typeof mockDispatch.headers !== "object") return false;
		for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) if (!matchValue(matchHeaderValue, getHeaderByName(headers, matchHeaderName))) return false;
		return true;
	}
	function safeUrl(path$5) {
		if (typeof path$5 !== "string") return path$5;
		const pathSegments = path$5.split("?");
		if (pathSegments.length !== 2) return path$5;
		const qp = new URLSearchParams(pathSegments.pop());
		qp.sort();
		return [...pathSegments, qp.toString()].join("?");
	}
	function matchKey(mockDispatch, { path: path$5, method, body, headers }) {
		const pathMatch = matchValue(mockDispatch.path, path$5);
		const methodMatch = matchValue(mockDispatch.method, method);
		const bodyMatch = typeof mockDispatch.body !== "undefined" ? matchValue(mockDispatch.body, body) : true;
		const headersMatch = matchHeaders(mockDispatch, headers);
		return pathMatch && methodMatch && bodyMatch && headersMatch;
	}
	function getResponseData(data) {
		if (Buffer.isBuffer(data)) return data;
		else if (typeof data === "object") return JSON.stringify(data);
		else return data.toString();
	}
	function getMockDispatch(mockDispatches, key) {
		const basePath = key.query ? buildURL(key.path, key.query) : key.path;
		const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
		let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path$5 }) => matchValue(safeUrl(path$5), resolvedPath));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
		matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
		return matchedMockDispatches[0];
	}
	function addMockDispatch(mockDispatches, key, data) {
		const baseData = {
			timesInvoked: 0,
			times: 1,
			persist: false,
			consumed: false
		};
		const replyData = typeof data === "function" ? { callback: data } : { ...data };
		const newMockDispatch = {
			...baseData,
			...key,
			pending: true,
			data: {
				error: null,
				...replyData
			}
		};
		mockDispatches.push(newMockDispatch);
		return newMockDispatch;
	}
	function deleteMockDispatch(mockDispatches, key) {
		const index = mockDispatches.findIndex((dispatch) => {
			if (!dispatch.consumed) return false;
			return matchKey(dispatch, key);
		});
		if (index !== -1) mockDispatches.splice(index, 1);
	}
	function buildKey(opts) {
		const { path: path$5, method, body, headers, query } = opts;
		return {
			path: path$5,
			method,
			body,
			headers,
			query
		};
	}
	function generateKeyValues(data) {
		return Object.entries(data).reduce((keyValuePairs, [key, value$2]) => [
			...keyValuePairs,
			Buffer.from(`${key}`),
			Array.isArray(value$2) ? value$2.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value$2}`)
		], []);
	}
	function getStatusText(statusCode) {
		return STATUS_CODES$1[statusCode] || "unknown";
	}
	async function getResponse(body) {
		const buffers = [];
		for await (const data of body) buffers.push(data);
		return Buffer.concat(buffers).toString("utf8");
	}
	function mockDispatch(opts, handler) {
		const key = buildKey(opts);
		const mockDispatch = getMockDispatch(this[kDispatches], key);
		mockDispatch.timesInvoked++;
		if (mockDispatch.data.callback) mockDispatch.data = {
			...mockDispatch.data,
			...mockDispatch.data.callback(opts)
		};
		const { data: { statusCode, data, headers, trailers, error }, delay: delay$2, persist } = mockDispatch;
		const { timesInvoked, times } = mockDispatch;
		mockDispatch.consumed = !persist && timesInvoked >= times;
		mockDispatch.pending = timesInvoked < times;
		if (error !== null) {
			deleteMockDispatch(this[kDispatches], key);
			handler.onError(error);
			return true;
		}
		if (typeof delay$2 === "number" && delay$2 > 0) setTimeout(() => {
			handleReply(this[kDispatches]);
		}, delay$2);
		else handleReply(this[kDispatches]);
		function handleReply(mockDispatches, _data = data) {
			const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
			const body = typeof _data === "function" ? _data({
				...opts,
				headers: optsHeaders
			}) : _data;
			if (isPromise(body)) {
				body.then((newData) => handleReply(mockDispatches, newData));
				return;
			}
			const responseData = getResponseData(body);
			const responseHeaders = generateKeyValues(headers);
			const responseTrailers = generateKeyValues(trailers);
			handler.abort = nop;
			handler.onHeaders(statusCode, responseHeaders, resume$1, getStatusText(statusCode));
			handler.onData(Buffer.from(responseData));
			handler.onComplete(responseTrailers);
			deleteMockDispatch(mockDispatches, key);
		}
		function resume$1() {}
		return true;
	}
	function buildMockDispatch() {
		const agent = this[kMockAgent];
		const origin = this[kOrigin];
		const originalDispatch = this[kOriginalDispatch];
		return function dispatch(opts, handler) {
			if (agent.isMockActive) try {
				mockDispatch.call(this, opts, handler);
			} catch (error) {
				if (error instanceof MockNotMatchedError) {
					const netConnect = agent[kGetNetConnect]();
					if (netConnect === false) throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
					if (checkNetConnect(netConnect, origin)) originalDispatch.call(this, opts, handler);
					else throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
				} else throw error;
			}
			else originalDispatch.call(this, opts, handler);
		};
	}
	function checkNetConnect(netConnect, origin) {
		const url$2 = new URL(origin);
		if (netConnect === true) return true;
		else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url$2.host))) return true;
		return false;
	}
	function buildMockOptions(opts) {
		if (opts) {
			const { agent, ...mockOptions } = opts;
			return mockOptions;
		}
	}
	module.exports = {
		getResponseData,
		getMockDispatch,
		addMockDispatch,
		deleteMockDispatch,
		buildKey,
		generateKeyValues,
		matchValue,
		getResponse,
		getStatusText,
		mockDispatch,
		buildMockDispatch,
		checkNetConnect,
		buildMockOptions,
		getHeaderByName
	};
}));
var require_mock_interceptor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
	var { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = require_mock_symbols();
	var { InvalidArgumentError } = require_errors();
	var { buildURL } = require_util$6();
	var MockScope = class {
		constructor(mockDispatch) {
			this[kMockDispatch] = mockDispatch;
		}
		delay(waitInMs) {
			if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
			this[kMockDispatch].delay = waitInMs;
			return this;
		}
		persist() {
			this[kMockDispatch].persist = true;
			return this;
		}
		times(repeatTimes) {
			if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
			this[kMockDispatch].times = repeatTimes;
			return this;
		}
	};
	var MockInterceptor = class {
		constructor(opts, mockDispatches) {
			if (typeof opts !== "object") throw new InvalidArgumentError("opts must be an object");
			if (typeof opts.path === "undefined") throw new InvalidArgumentError("opts.path must be defined");
			if (typeof opts.method === "undefined") opts.method = "GET";
			if (typeof opts.path === "string") if (opts.query) opts.path = buildURL(opts.path, opts.query);
			else {
				const parsedURL = new URL(opts.path, "data://");
				opts.path = parsedURL.pathname + parsedURL.search;
			}
			if (typeof opts.method === "string") opts.method = opts.method.toUpperCase();
			this[kDispatchKey] = buildKey(opts);
			this[kDispatches] = mockDispatches;
			this[kDefaultHeaders] = {};
			this[kDefaultTrailers] = {};
			this[kContentLength] = false;
		}
		createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
			const responseData = getResponseData(data);
			const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
			return {
				statusCode,
				data,
				headers: {
					...this[kDefaultHeaders],
					...contentLength,
					...responseOptions.headers
				},
				trailers: {
					...this[kDefaultTrailers],
					...responseOptions.trailers
				}
			};
		}
		validateReplyParameters(statusCode, data, responseOptions) {
			if (typeof statusCode === "undefined") throw new InvalidArgumentError("statusCode must be defined");
			if (typeof data === "undefined") throw new InvalidArgumentError("data must be defined");
			if (typeof responseOptions !== "object") throw new InvalidArgumentError("responseOptions must be an object");
		}
		reply(replyData) {
			if (typeof replyData === "function") {
				const wrappedDefaultsCallback = (opts) => {
					const resolvedData = replyData(opts);
					if (typeof resolvedData !== "object") throw new InvalidArgumentError("reply options callback must return an object");
					const { statusCode: statusCode$1, data: data$1 = "", responseOptions: responseOptions$1 = {} } = resolvedData;
					this.validateReplyParameters(statusCode$1, data$1, responseOptions$1);
					return { ...this.createMockScopeDispatchData(statusCode$1, data$1, responseOptions$1) };
				};
				return new MockScope(addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback));
			}
			const [statusCode, data = "", responseOptions = {}] = [...arguments];
			this.validateReplyParameters(statusCode, data, responseOptions);
			const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
			return new MockScope(addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData));
		}
		replyWithError(error) {
			if (typeof error === "undefined") throw new InvalidArgumentError("error must be defined");
			return new MockScope(addMockDispatch(this[kDispatches], this[kDispatchKey], { error }));
		}
		defaultReplyHeaders(headers) {
			if (typeof headers === "undefined") throw new InvalidArgumentError("headers must be defined");
			this[kDefaultHeaders] = headers;
			return this;
		}
		defaultReplyTrailers(trailers) {
			if (typeof trailers === "undefined") throw new InvalidArgumentError("trailers must be defined");
			this[kDefaultTrailers] = trailers;
			return this;
		}
		replyContentLength() {
			this[kContentLength] = true;
			return this;
		}
	};
	module.exports.MockInterceptor = MockInterceptor;
	module.exports.MockScope = MockScope;
}));
var require_mock_client = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { promisify: promisify$1 } = __require("util");
	var Client = require_client();
	var { buildMockDispatch } = require_mock_utils();
	var { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = require_mock_symbols();
	var { MockInterceptor } = require_mock_interceptor();
	var Symbols = require_symbols$4();
	var { InvalidArgumentError } = require_errors();
	var MockClient = class extends Client {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError("Argument opts.agent must implement Agent");
			this[kMockAgent] = opts.agent;
			this[kOrigin] = origin;
			this[kDispatches] = [];
			this[kConnected] = 1;
			this[kOriginalDispatch] = this.dispatch;
			this[kOriginalClose] = this.close.bind(this);
			this.dispatch = buildMockDispatch.call(this);
			this.close = this[kClose];
		}
		get [Symbols.kConnected]() {
			return this[kConnected];
		}
		intercept(opts) {
			return new MockInterceptor(opts, this[kDispatches]);
		}
		async [kClose]() {
			await promisify$1(this[kOriginalClose])();
			this[kConnected] = 0;
			this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
		}
	};
	module.exports = MockClient;
}));
var require_mock_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { promisify } = __require("util");
	var Pool = require_pool();
	var { buildMockDispatch } = require_mock_utils();
	var { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = require_mock_symbols();
	var { MockInterceptor } = require_mock_interceptor();
	var Symbols = require_symbols$4();
	var { InvalidArgumentError } = require_errors();
	var MockPool = class extends Pool {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError("Argument opts.agent must implement Agent");
			this[kMockAgent] = opts.agent;
			this[kOrigin] = origin;
			this[kDispatches] = [];
			this[kConnected] = 1;
			this[kOriginalDispatch] = this.dispatch;
			this[kOriginalClose] = this.close.bind(this);
			this.dispatch = buildMockDispatch.call(this);
			this.close = this[kClose];
		}
		get [Symbols.kConnected]() {
			return this[kConnected];
		}
		intercept(opts) {
			return new MockInterceptor(opts, this[kDispatches]);
		}
		async [kClose]() {
			await promisify(this[kOriginalClose])();
			this[kConnected] = 0;
			this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
		}
	};
	module.exports = MockPool;
}));
var require_pluralizer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var singulars = {
		pronoun: "it",
		is: "is",
		was: "was",
		this: "this"
	};
	var plurals = {
		pronoun: "they",
		is: "are",
		was: "were",
		this: "these"
	};
	module.exports = class Pluralizer {
		constructor(singular, plural) {
			this.singular = singular;
			this.plural = plural;
		}
		pluralize(count) {
			const one = count === 1;
			const keys$5 = one ? singulars : plurals;
			const noun = one ? this.singular : this.plural;
			return {
				...keys$5,
				count,
				noun
			};
		}
	};
}));
var require_pending_interceptors_formatter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Transform } = __require("stream");
	var { Console } = __require("console");
	module.exports = class PendingInterceptorsFormatter {
		constructor({ disableColors } = {}) {
			this.transform = new Transform({ transform(chunk$4, _enc, cb) {
				cb(null, chunk$4);
			} });
			this.logger = new Console({
				stdout: this.transform,
				inspectOptions: { colors: !disableColors && !process.env.CI }
			});
		}
		format(pendingInterceptors) {
			const withPrettyHeaders = pendingInterceptors.map(({ method, path: path$5, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
				Method: method,
				Origin: origin,
				Path: path$5,
				"Status code": statusCode,
				Persistent: persist ? "" : "",
				Invocations: timesInvoked,
				Remaining: persist ? Infinity : times - timesInvoked
			}));
			this.logger.table(withPrettyHeaders);
			return this.transform.read().toString();
		}
	};
}));
var require_mock_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { kClients } = require_symbols$4();
	var Agent = require_agent();
	var { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = require_mock_symbols();
	var MockClient = require_mock_client();
	var MockPool = require_mock_pool();
	var { matchValue, buildMockOptions } = require_mock_utils();
	var { InvalidArgumentError, UndiciError } = require_errors();
	var Dispatcher = require_dispatcher();
	var Pluralizer = require_pluralizer();
	var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
	var FakeWeakRef = class {
		constructor(value$2) {
			this.value = value$2;
		}
		deref() {
			return this.value;
		}
	};
	var MockAgent = class extends Dispatcher {
		constructor(opts) {
			super(opts);
			this[kNetConnect] = true;
			this[kIsMockActive] = true;
			if (opts && opts.agent && typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError("Argument opts.agent must implement Agent");
			const agent = opts && opts.agent ? opts.agent : new Agent(opts);
			this[kAgent] = agent;
			this[kClients] = agent[kClients];
			this[kOptions] = buildMockOptions(opts);
		}
		get(origin) {
			let dispatcher = this[kMockAgentGet](origin);
			if (!dispatcher) {
				dispatcher = this[kFactory](origin);
				this[kMockAgentSet](origin, dispatcher);
			}
			return dispatcher;
		}
		dispatch(opts, handler) {
			this.get(opts.origin);
			return this[kAgent].dispatch(opts, handler);
		}
		async close() {
			await this[kAgent].close();
			this[kClients].clear();
		}
		deactivate() {
			this[kIsMockActive] = false;
		}
		activate() {
			this[kIsMockActive] = true;
		}
		enableNetConnect(matcher) {
			if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) if (Array.isArray(this[kNetConnect])) this[kNetConnect].push(matcher);
			else this[kNetConnect] = [matcher];
			else if (typeof matcher === "undefined") this[kNetConnect] = true;
			else throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
		}
		disableNetConnect() {
			this[kNetConnect] = false;
		}
		get isMockActive() {
			return this[kIsMockActive];
		}
		[kMockAgentSet](origin, dispatcher) {
			this[kClients].set(origin, new FakeWeakRef(dispatcher));
		}
		[kFactory](origin) {
			const mockOptions = Object.assign({ agent: this }, this[kOptions]);
			return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
		}
		[kMockAgentGet](origin) {
			const ref = this[kClients].get(origin);
			if (ref) return ref.deref();
			if (typeof origin !== "string") {
				const dispatcher = this[kFactory]("http://localhost:9999");
				this[kMockAgentSet](origin, dispatcher);
				return dispatcher;
			}
			for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
				const nonExplicitDispatcher = nonExplicitRef.deref();
				if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
					const dispatcher = this[kFactory](origin);
					this[kMockAgentSet](origin, dispatcher);
					dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
					return dispatcher;
				}
			}
		}
		[kGetNetConnect]() {
			return this[kNetConnect];
		}
		pendingInterceptors() {
			const mockAgentClients = this[kClients];
			return Array.from(mockAgentClients.entries()).flatMap(([origin, scope$3]) => scope$3.deref()[kDispatches].map((dispatch) => ({
				...dispatch,
				origin
			}))).filter(({ pending: pending$2 }) => pending$2);
		}
		assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
			const pending$2 = this.pendingInterceptors();
			if (pending$2.length === 0) return;
			const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending$2.length);
			throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending$2)}
`.trim());
		}
	};
	module.exports = MockAgent;
}));
var require_proxy_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols$4();
	var { URL: URL$1 } = __require("url");
	var Agent = require_agent();
	var Pool = require_pool();
	var DispatcherBase = require_dispatcher_base();
	var { InvalidArgumentError, RequestAbortedError } = require_errors();
	var buildConnector = require_connect();
	var kAgent = Symbol("proxy agent");
	var kClient = Symbol("proxy client");
	var kProxyHeaders = Symbol("proxy headers");
	var kRequestTls = Symbol("request tls settings");
	var kProxyTls = Symbol("proxy tls settings");
	var kConnectEndpoint = Symbol("connect endpoint function");
	function defaultProtocolPort(protocol) {
		return protocol === "https:" ? 443 : 80;
	}
	function buildProxyOptions(opts) {
		if (typeof opts === "string") opts = { uri: opts };
		if (!opts || !opts.uri) throw new InvalidArgumentError("Proxy opts.uri is mandatory");
		return {
			uri: opts.uri,
			protocol: opts.protocol || "https"
		};
	}
	function defaultFactory(origin, opts) {
		return new Pool(origin, opts);
	}
	var ProxyAgent = class extends DispatcherBase {
		constructor(opts) {
			super(opts);
			this[kProxy] = buildProxyOptions(opts);
			this[kAgent] = new Agent(opts);
			this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
			if (typeof opts === "string") opts = { uri: opts };
			if (!opts || !opts.uri) throw new InvalidArgumentError("Proxy opts.uri is mandatory");
			const { clientFactory = defaultFactory } = opts;
			if (typeof clientFactory !== "function") throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
			this[kRequestTls] = opts.requestTls;
			this[kProxyTls] = opts.proxyTls;
			this[kProxyHeaders] = opts.headers || {};
			const resolvedUrl = new URL$1(opts.uri);
			const { origin, port: port$2, host, username, password } = resolvedUrl;
			if (opts.auth && opts.token) throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
			else if (opts.auth) this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
			else if (opts.token) this[kProxyHeaders]["proxy-authorization"] = opts.token;
			else if (username && password) this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
			const connect = buildConnector({ ...opts.proxyTls });
			this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
			this[kClient] = clientFactory(resolvedUrl, { connect });
			this[kAgent] = new Agent({
				...opts,
				connect: async (opts$1, callback) => {
					let requestedHost = opts$1.host;
					if (!opts$1.port) requestedHost += `:${defaultProtocolPort(opts$1.protocol)}`;
					try {
						const { socket, statusCode } = await this[kClient].connect({
							origin,
							port: port$2,
							path: requestedHost,
							signal: opts$1.signal,
							headers: {
								...this[kProxyHeaders],
								host
							}
						});
						if (statusCode !== 200) {
							socket.on("error", () => {}).destroy();
							callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
						}
						if (opts$1.protocol !== "https:") {
							callback(null, socket);
							return;
						}
						let servername;
						if (this[kRequestTls]) servername = this[kRequestTls].servername;
						else servername = opts$1.servername;
						this[kConnectEndpoint]({
							...opts$1,
							servername,
							httpSocket: socket
						}, callback);
					} catch (err) {
						callback(err);
					}
				}
			});
		}
		dispatch(opts, handler) {
			const { host } = new URL$1(opts.origin);
			const headers = buildHeaders(opts.headers);
			throwIfProxyAuthIsSent(headers);
			return this[kAgent].dispatch({
				...opts,
				headers: {
					...headers,
					host
				}
			}, handler);
		}
		async [kClose]() {
			await this[kAgent].close();
			await this[kClient].close();
		}
		async [kDestroy]() {
			await this[kAgent].destroy();
			await this[kClient].destroy();
		}
	};
	function buildHeaders(headers) {
		if (Array.isArray(headers)) {
			const headersPair = {};
			for (let i = 0; i < headers.length; i += 2) headersPair[headers[i]] = headers[i + 1];
			return headersPair;
		}
		return headers;
	}
	function throwIfProxyAuthIsSent(headers) {
		if (headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization")) throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
	}
	module.exports = ProxyAgent;
}));
var require_RetryHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert$7 = __require("assert");
	var { kRetryHandlerDefaultRetry } = require_symbols$4();
	var { RequestRetryError } = require_errors();
	var { isDisturbed, parseHeaders, parseRangeHeader } = require_util$6();
	function calculateRetryAfterHeader(retryAfter) {
		const current = Date.now();
		return new Date(retryAfter).getTime() - current;
	}
	module.exports = class RetryHandler {
		constructor(opts, handlers) {
			const { retryOptions, ...dispatchOpts } = opts;
			const { retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};
			this.dispatch = handlers.dispatch;
			this.handler = handlers.handler;
			this.opts = dispatchOpts;
			this.abort = null;
			this.aborted = false;
			this.retryOpts = {
				retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
				retryAfter: retryAfter ?? true,
				maxTimeout: maxTimeout ?? 30 * 1e3,
				timeout: minTimeout ?? 500,
				timeoutFactor: timeoutFactor ?? 2,
				maxRetries: maxRetries ?? 5,
				methods: methods ?? [
					"GET",
					"HEAD",
					"OPTIONS",
					"PUT",
					"DELETE",
					"TRACE"
				],
				statusCodes: statusCodes ?? [
					500,
					502,
					503,
					504,
					429
				],
				errorCodes: errorCodes ?? [
					"ECONNRESET",
					"ECONNREFUSED",
					"ENOTFOUND",
					"ENETDOWN",
					"ENETUNREACH",
					"EHOSTDOWN",
					"EHOSTUNREACH",
					"EPIPE"
				]
			};
			this.retryCount = 0;
			this.start = 0;
			this.end = null;
			this.etag = null;
			this.resume = null;
			this.handler.onConnect((reason) => {
				this.aborted = true;
				if (this.abort) this.abort(reason);
				else this.reason = reason;
			});
		}
		onRequestSent() {
			if (this.handler.onRequestSent) this.handler.onRequestSent();
		}
		onUpgrade(statusCode, headers, socket) {
			if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers, socket);
		}
		onConnect(abort) {
			if (this.aborted) abort(this.reason);
			else this.abort = abort;
		}
		onBodySent(chunk$4) {
			if (this.handler.onBodySent) return this.handler.onBodySent(chunk$4);
		}
		static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
			const { statusCode, code, headers } = err;
			const { method, retryOptions } = opts;
			const { maxRetries, timeout: timeout$2, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;
			let { counter: counter$5, currentTimeout } = state;
			currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout$2;
			if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
				cb(err);
				return;
			}
			if (Array.isArray(methods) && !methods.includes(method)) {
				cb(err);
				return;
			}
			if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
				cb(err);
				return;
			}
			if (counter$5 > maxRetries) {
				cb(err);
				return;
			}
			let retryAfterHeader = headers != null && headers["retry-after"];
			if (retryAfterHeader) {
				retryAfterHeader = Number(retryAfterHeader);
				retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
			}
			const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter$5, maxTimeout);
			state.currentTimeout = retryTimeout;
			setTimeout(() => cb(null), retryTimeout);
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const headers = parseHeaders(rawHeaders);
			this.retryCount += 1;
			if (statusCode >= 300) {
				this.abort(new RequestRetryError("Request failed", statusCode, {
					headers,
					count: this.retryCount
				}));
				return false;
			}
			if (this.resume != null) {
				this.resume = null;
				if (statusCode !== 206) return true;
				const contentRange = parseRangeHeader(headers["content-range"]);
				if (!contentRange) {
					this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				if (this.etag != null && this.etag !== headers.etag) {
					this.abort(new RequestRetryError("ETag mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				const { start: start$2, size: size$11, end: end$2 = size$11 } = contentRange;
				assert$7(this.start === start$2, "content-range mismatch");
				assert$7(this.end == null || this.end === end$2, "content-range mismatch");
				this.resume = resume$1;
				return true;
			}
			if (this.end == null) {
				if (statusCode === 206) {
					const range = parseRangeHeader(headers["content-range"]);
					if (range == null) return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
					const { start: start$2, size: size$11, end: end$2 = size$11 } = range;
					assert$7(start$2 != null && Number.isFinite(start$2) && this.start !== start$2, "content-range mismatch");
					assert$7(Number.isFinite(start$2));
					assert$7(end$2 != null && Number.isFinite(end$2) && this.end !== end$2, "invalid content-length");
					this.start = start$2;
					this.end = end$2;
				}
				if (this.end == null) {
					const contentLength = headers["content-length"];
					this.end = contentLength != null ? Number(contentLength) : null;
				}
				assert$7(Number.isFinite(this.start));
				assert$7(this.end == null || Number.isFinite(this.end), "invalid content-length");
				this.resume = resume$1;
				this.etag = headers.etag != null ? headers.etag : null;
				return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
			}
			const err = new RequestRetryError("Request failed", statusCode, {
				headers,
				count: this.retryCount
			});
			this.abort(err);
			return false;
		}
		onData(chunk$4) {
			this.start += chunk$4.length;
			return this.handler.onData(chunk$4);
		}
		onComplete(rawTrailers) {
			this.retryCount = 0;
			return this.handler.onComplete(rawTrailers);
		}
		onError(err) {
			if (this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err);
			this.retryOpts.retry(err, {
				state: {
					counter: this.retryCount++,
					currentTimeout: this.retryAfter
				},
				opts: {
					retryOptions: this.retryOpts,
					...this.opts
				}
			}, onRetry.bind(this));
			function onRetry(err$1) {
				if (err$1 != null || this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err$1);
				if (this.start !== 0) this.opts = {
					...this.opts,
					headers: {
						...this.opts.headers,
						range: `bytes=${this.start}-${this.end ?? ""}`
					}
				};
				try {
					this.dispatch(this.opts, this);
				} catch (err$2) {
					this.handler.onError(err$2);
				}
			}
		}
	};
}));
var require_global = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
	var { InvalidArgumentError } = require_errors();
	var Agent = require_agent();
	if (getGlobalDispatcher() === void 0) setGlobalDispatcher(new Agent());
	function setGlobalDispatcher(agent) {
		if (!agent || typeof agent.dispatch !== "function") throw new InvalidArgumentError("Argument agent must implement Agent");
		Object.defineProperty(globalThis, globalDispatcher, {
			value: agent,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	function getGlobalDispatcher() {
		return globalThis[globalDispatcher];
	}
	module.exports = {
		setGlobalDispatcher,
		getGlobalDispatcher
	};
}));
var require_DecoratorHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = class DecoratorHandler {
		constructor(handler) {
			this.handler = handler;
		}
		onConnect(...args$1) {
			return this.handler.onConnect(...args$1);
		}
		onError(...args$1) {
			return this.handler.onError(...args$1);
		}
		onUpgrade(...args$1) {
			return this.handler.onUpgrade(...args$1);
		}
		onHeaders(...args$1) {
			return this.handler.onHeaders(...args$1);
		}
		onData(...args$1) {
			return this.handler.onData(...args$1);
		}
		onComplete(...args$1) {
			return this.handler.onComplete(...args$1);
		}
		onBodySent(...args$1) {
			return this.handler.onBodySent(...args$1);
		}
	};
}));
var require_headers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { kHeadersList, kConstruct } = require_symbols$4();
	var { kGuard } = require_symbols$3();
	var { kEnumerableProperty } = require_util$6();
	var { makeIterator, isValidHeaderName, isValidHeaderValue } = require_util$5();
	var util = __require("util");
	var { webidl } = require_webidl();
	var assert$6 = __require("assert");
	var kHeadersMap = Symbol("headers map");
	var kHeadersSortedMap = Symbol("headers map sorted");
	function isHTTPWhiteSpaceCharCode(code) {
		return code === 10 || code === 13 || code === 9 || code === 32;
	}
	function headerValueNormalize(potentialValue) {
		let i = 0;
		let j = potentialValue.length;
		while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
		while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
		return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
	}
	function fill(headers, object) {
		if (Array.isArray(object)) for (let i = 0; i < object.length; ++i) {
			const header = object[i];
			if (header.length !== 2) throw webidl.errors.exception({
				header: "Headers constructor",
				message: `expected name/value pair to be length 2, found ${header.length}.`
			});
			appendHeader(headers, header[0], header[1]);
		}
		else if (typeof object === "object" && object !== null) {
			const keys$5 = Object.keys(object);
			for (let i = 0; i < keys$5.length; ++i) appendHeader(headers, keys$5[i], object[keys$5[i]]);
		} else throw webidl.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	}
	function appendHeader(headers, name, value$2) {
		value$2 = headerValueNormalize(value$2);
		if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
			prefix: "Headers.append",
			value: name,
			type: "header name"
		});
		else if (!isValidHeaderValue(value$2)) throw webidl.errors.invalidArgument({
			prefix: "Headers.append",
			value: value$2,
			type: "header value"
		});
		if (headers[kGuard] === "immutable") throw new TypeError("immutable");
		else if (headers[kGuard] === "request-no-cors") {}
		return headers[kHeadersList].append(name, value$2);
	}
	var HeadersList = class HeadersList {
		cookies = null;
		constructor(init) {
			if (init instanceof HeadersList) {
				this[kHeadersMap] = new Map(init[kHeadersMap]);
				this[kHeadersSortedMap] = init[kHeadersSortedMap];
				this.cookies = init.cookies === null ? null : [...init.cookies];
			} else {
				this[kHeadersMap] = new Map(init);
				this[kHeadersSortedMap] = null;
			}
		}
		contains(name) {
			name = name.toLowerCase();
			return this[kHeadersMap].has(name);
		}
		clear() {
			this[kHeadersMap].clear();
			this[kHeadersSortedMap] = null;
			this.cookies = null;
		}
		append(name, value$2) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			const exists$4 = this[kHeadersMap].get(lowercaseName);
			if (exists$4) {
				const delimiter = lowercaseName === "cookie" ? "; " : ", ";
				this[kHeadersMap].set(lowercaseName, {
					name: exists$4.name,
					value: `${exists$4.value}${delimiter}${value$2}`
				});
			} else this[kHeadersMap].set(lowercaseName, {
				name,
				value: value$2
			});
			if (lowercaseName === "set-cookie") {
				this.cookies ??= [];
				this.cookies.push(value$2);
			}
		}
		set(name, value$2) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			if (lowercaseName === "set-cookie") this.cookies = [value$2];
			this[kHeadersMap].set(lowercaseName, {
				name,
				value: value$2
			});
		}
		delete(name) {
			this[kHeadersSortedMap] = null;
			name = name.toLowerCase();
			if (name === "set-cookie") this.cookies = null;
			this[kHeadersMap].delete(name);
		}
		get(name) {
			const value$2 = this[kHeadersMap].get(name.toLowerCase());
			return value$2 === void 0 ? null : value$2.value;
		}
		*[Symbol.iterator]() {
			for (const [name, { value: value$2 }] of this[kHeadersMap]) yield [name, value$2];
		}
		get entries() {
			const headers = {};
			if (this[kHeadersMap].size) for (const { name, value: value$2 } of this[kHeadersMap].values()) headers[name] = value$2;
			return headers;
		}
	};
	var Headers = class Headers {
		constructor(init = void 0) {
			if (init === kConstruct) return;
			this[kHeadersList] = new HeadersList();
			this[kGuard] = "none";
			if (init !== void 0) {
				init = webidl.converters.HeadersInit(init);
				fill(this, init);
			}
		}
		append(name, value$2) {
			webidl.brandCheck(this, Headers);
			webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
			name = webidl.converters.ByteString(name);
			value$2 = webidl.converters.ByteString(value$2);
			return appendHeader(this, name, value$2);
		}
		delete(name) {
			webidl.brandCheck(this, Headers);
			webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
			name = webidl.converters.ByteString(name);
			if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
				prefix: "Headers.delete",
				value: name,
				type: "header name"
			});
			if (this[kGuard] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard] === "request-no-cors") {}
			if (!this[kHeadersList].contains(name)) return;
			this[kHeadersList].delete(name);
		}
		get(name) {
			webidl.brandCheck(this, Headers);
			webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
			name = webidl.converters.ByteString(name);
			if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
				prefix: "Headers.get",
				value: name,
				type: "header name"
			});
			return this[kHeadersList].get(name);
		}
		has(name) {
			webidl.brandCheck(this, Headers);
			webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
			name = webidl.converters.ByteString(name);
			if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
				prefix: "Headers.has",
				value: name,
				type: "header name"
			});
			return this[kHeadersList].contains(name);
		}
		set(name, value$2) {
			webidl.brandCheck(this, Headers);
			webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
			name = webidl.converters.ByteString(name);
			value$2 = webidl.converters.ByteString(value$2);
			value$2 = headerValueNormalize(value$2);
			if (!isValidHeaderName(name)) throw webidl.errors.invalidArgument({
				prefix: "Headers.set",
				value: name,
				type: "header name"
			});
			else if (!isValidHeaderValue(value$2)) throw webidl.errors.invalidArgument({
				prefix: "Headers.set",
				value: value$2,
				type: "header value"
			});
			if (this[kGuard] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard] === "request-no-cors") {}
			this[kHeadersList].set(name, value$2);
		}
		getSetCookie() {
			webidl.brandCheck(this, Headers);
			const list = this[kHeadersList].cookies;
			if (list) return [...list];
			return [];
		}
		get [kHeadersSortedMap]() {
			if (this[kHeadersList][kHeadersSortedMap]) return this[kHeadersList][kHeadersSortedMap];
			const headers = [];
			const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
			const cookies = this[kHeadersList].cookies;
			for (let i = 0; i < names.length; ++i) {
				const [name, value$2] = names[i];
				if (name === "set-cookie") for (let j = 0; j < cookies.length; ++j) headers.push([name, cookies[j]]);
				else {
					assert$6(value$2 !== null);
					headers.push([name, value$2]);
				}
			}
			this[kHeadersList][kHeadersSortedMap] = headers;
			return headers;
		}
		keys() {
			webidl.brandCheck(this, Headers);
			if (this[kGuard] === "immutable") {
				const value$2 = this[kHeadersSortedMap];
				return makeIterator(() => value$2, "Headers", "key");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
		}
		values() {
			webidl.brandCheck(this, Headers);
			if (this[kGuard] === "immutable") {
				const value$2 = this[kHeadersSortedMap];
				return makeIterator(() => value$2, "Headers", "value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
		}
		entries() {
			webidl.brandCheck(this, Headers);
			if (this[kGuard] === "immutable") {
				const value$2 = this[kHeadersSortedMap];
				return makeIterator(() => value$2, "Headers", "key+value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
		}
		forEach(callbackFn, thisArg = globalThis) {
			webidl.brandCheck(this, Headers);
			webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
			for (const [key, value$2] of this) callbackFn.apply(thisArg, [
				value$2,
				key,
				this
			]);
		}
		[Symbol.for("nodejs.util.inspect.custom")]() {
			webidl.brandCheck(this, Headers);
			return this[kHeadersList];
		}
	};
	Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	Object.defineProperties(Headers.prototype, {
		append: kEnumerableProperty,
		delete: kEnumerableProperty,
		get: kEnumerableProperty,
		has: kEnumerableProperty,
		set: kEnumerableProperty,
		getSetCookie: kEnumerableProperty,
		keys: kEnumerableProperty,
		values: kEnumerableProperty,
		entries: kEnumerableProperty,
		forEach: kEnumerableProperty,
		[Symbol.iterator]: { enumerable: false },
		[Symbol.toStringTag]: {
			value: "Headers",
			configurable: true
		},
		[util.inspect.custom]: { enumerable: false }
	});
	webidl.converters.HeadersInit = function(V) {
		if (webidl.util.Type(V) === "Object") {
			if (V[Symbol.iterator]) return webidl.converters["sequence<sequence<ByteString>>"](V);
			return webidl.converters["record<ByteString, ByteString>"](V);
		}
		throw webidl.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	};
	module.exports = {
		fill,
		Headers,
		HeadersList
	};
}));
var require_response = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Headers, HeadersList, fill } = require_headers();
	var { extractBody, cloneBody, mixinBody } = require_body();
	var util = require_util$6();
	var { kEnumerableProperty } = util;
	var { isValidReasonPhrase, isCancelled, isAborted, isBlobLike, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode } = require_util$5();
	var { redirectStatusSet, nullBodyStatus, DOMException } = require_constants$3();
	var { kState, kHeaders, kGuard, kRealm } = require_symbols$3();
	var { webidl } = require_webidl();
	var { FormData } = require_formdata();
	var { getGlobalOrigin } = require_global$1();
	var { URLSerializer } = require_dataURL();
	var { kHeadersList, kConstruct } = require_symbols$4();
	var assert$5 = __require("assert");
	var { types: types$2 } = __require("util");
	var ReadableStream = globalThis.ReadableStream || __require("stream/web").ReadableStream;
	var textEncoder = new TextEncoder("utf-8");
	var Response = class Response {
		static error() {
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response();
			responseObject[kState] = makeNetworkError();
			responseObject[kRealm] = relevantRealm;
			responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
			responseObject[kHeaders][kGuard] = "immutable";
			responseObject[kHeaders][kRealm] = relevantRealm;
			return responseObject;
		}
		static json(data, init = {}) {
			webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
			if (init !== null) init = webidl.converters.ResponseInit(init);
			const body = extractBody(textEncoder.encode(serializeJavascriptValueToJSONString(data)));
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response();
			responseObject[kRealm] = relevantRealm;
			responseObject[kHeaders][kGuard] = "response";
			responseObject[kHeaders][kRealm] = relevantRealm;
			initializeResponse(responseObject, init, {
				body: body[0],
				type: "application/json"
			});
			return responseObject;
		}
		static redirect(url$2, status$2 = 302) {
			const relevantRealm = { settingsObject: {} };
			webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
			url$2 = webidl.converters.USVString(url$2);
			status$2 = webidl.converters["unsigned short"](status$2);
			let parsedURL;
			try {
				parsedURL = new URL(url$2, getGlobalOrigin());
			} catch (err) {
				throw Object.assign(/* @__PURE__ */ new TypeError("Failed to parse URL from " + url$2), { cause: err });
			}
			if (!redirectStatusSet.has(status$2)) throw new RangeError("Invalid status code " + status$2);
			const responseObject = new Response();
			responseObject[kRealm] = relevantRealm;
			responseObject[kHeaders][kGuard] = "immutable";
			responseObject[kHeaders][kRealm] = relevantRealm;
			responseObject[kState].status = status$2;
			const value$2 = isomorphicEncode(URLSerializer(parsedURL));
			responseObject[kState].headersList.append("location", value$2);
			return responseObject;
		}
		constructor(body = null, init = {}) {
			if (body !== null) body = webidl.converters.BodyInit(body);
			init = webidl.converters.ResponseInit(init);
			this[kRealm] = { settingsObject: {} };
			this[kState] = makeResponse({});
			this[kHeaders] = new Headers(kConstruct);
			this[kHeaders][kGuard] = "response";
			this[kHeaders][kHeadersList] = this[kState].headersList;
			this[kHeaders][kRealm] = this[kRealm];
			let bodyWithType = null;
			if (body != null) {
				const [extractedBody, type] = extractBody(body);
				bodyWithType = {
					body: extractedBody,
					type
				};
			}
			initializeResponse(this, init, bodyWithType);
		}
		get type() {
			webidl.brandCheck(this, Response);
			return this[kState].type;
		}
		get url() {
			webidl.brandCheck(this, Response);
			const urlList = this[kState].urlList;
			const url$2 = urlList[urlList.length - 1] ?? null;
			if (url$2 === null) return "";
			return URLSerializer(url$2, true);
		}
		get redirected() {
			webidl.brandCheck(this, Response);
			return this[kState].urlList.length > 1;
		}
		get status() {
			webidl.brandCheck(this, Response);
			return this[kState].status;
		}
		get ok() {
			webidl.brandCheck(this, Response);
			return this[kState].status >= 200 && this[kState].status <= 299;
		}
		get statusText() {
			webidl.brandCheck(this, Response);
			return this[kState].statusText;
		}
		get headers() {
			webidl.brandCheck(this, Response);
			return this[kHeaders];
		}
		get body() {
			webidl.brandCheck(this, Response);
			return this[kState].body ? this[kState].body.stream : null;
		}
		get bodyUsed() {
			webidl.brandCheck(this, Response);
			return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
		}
		clone() {
			webidl.brandCheck(this, Response);
			if (this.bodyUsed || this.body && this.body.locked) throw webidl.errors.exception({
				header: "Response.clone",
				message: "Body has already been consumed."
			});
			const clonedResponse = cloneResponse(this[kState]);
			const clonedResponseObject = new Response();
			clonedResponseObject[kState] = clonedResponse;
			clonedResponseObject[kRealm] = this[kRealm];
			clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
			clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
			clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
			return clonedResponseObject;
		}
	};
	mixinBody(Response);
	Object.defineProperties(Response.prototype, {
		type: kEnumerableProperty,
		url: kEnumerableProperty,
		status: kEnumerableProperty,
		ok: kEnumerableProperty,
		redirected: kEnumerableProperty,
		statusText: kEnumerableProperty,
		headers: kEnumerableProperty,
		clone: kEnumerableProperty,
		body: kEnumerableProperty,
		bodyUsed: kEnumerableProperty,
		[Symbol.toStringTag]: {
			value: "Response",
			configurable: true
		}
	});
	Object.defineProperties(Response, {
		json: kEnumerableProperty,
		redirect: kEnumerableProperty,
		error: kEnumerableProperty
	});
	function cloneResponse(response) {
		if (response.internalResponse) return filterResponse(cloneResponse(response.internalResponse), response.type);
		const newResponse = makeResponse({
			...response,
			body: null
		});
		if (response.body != null) newResponse.body = cloneBody(response.body);
		return newResponse;
	}
	function makeResponse(init) {
		return {
			aborted: false,
			rangeRequested: false,
			timingAllowPassed: false,
			requestIncludesCredentials: false,
			type: "default",
			status: 200,
			timingInfo: null,
			cacheState: "",
			statusText: "",
			...init,
			headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
			urlList: init.urlList ? [...init.urlList] : []
		};
	}
	function makeNetworkError(reason) {
		return makeResponse({
			type: "error",
			status: 0,
			error: isErrorLike(reason) ? reason : new Error(reason ? String(reason) : reason),
			aborted: reason && reason.name === "AbortError"
		});
	}
	function makeFilteredResponse(response, state) {
		state = {
			internalResponse: response,
			...state
		};
		return new Proxy(response, {
			get(target, p) {
				return p in state ? state[p] : target[p];
			},
			set(target, p, value$2) {
				assert$5(!(p in state));
				target[p] = value$2;
				return true;
			}
		});
	}
	function filterResponse(response, type) {
		if (type === "basic") return makeFilteredResponse(response, {
			type: "basic",
			headersList: response.headersList
		});
		else if (type === "cors") return makeFilteredResponse(response, {
			type: "cors",
			headersList: response.headersList
		});
		else if (type === "opaque") return makeFilteredResponse(response, {
			type: "opaque",
			urlList: Object.freeze([]),
			status: 0,
			statusText: "",
			body: null
		});
		else if (type === "opaqueredirect") return makeFilteredResponse(response, {
			type: "opaqueredirect",
			status: 0,
			statusText: "",
			headersList: [],
			body: null
		});
		else assert$5(false);
	}
	function makeAppropriateNetworkError(fetchParams, err = null) {
		assert$5(isCancelled(fetchParams));
		return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
	}
	function initializeResponse(response, init, body) {
		if (init.status !== null && (init.status < 200 || init.status > 599)) throw new RangeError("init[\"status\"] must be in the range of 200 to 599, inclusive.");
		if ("statusText" in init && init.statusText != null) {
			if (!isValidReasonPhrase(String(init.statusText))) throw new TypeError("Invalid statusText");
		}
		if ("status" in init && init.status != null) response[kState].status = init.status;
		if ("statusText" in init && init.statusText != null) response[kState].statusText = init.statusText;
		if ("headers" in init && init.headers != null) fill(response[kHeaders], init.headers);
		if (body) {
			if (nullBodyStatus.includes(response.status)) throw webidl.errors.exception({
				header: "Response constructor",
				message: "Invalid response status code " + response.status
			});
			response[kState].body = body.body;
			if (body.type != null && !response[kState].headersList.contains("Content-Type")) response[kState].headersList.append("content-type", body.type);
		}
	}
	webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
	webidl.converters.FormData = webidl.interfaceConverter(FormData);
	webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
	webidl.converters.XMLHttpRequestBodyInit = function(V) {
		if (typeof V === "string") return webidl.converters.USVString(V);
		if (isBlobLike(V)) return webidl.converters.Blob(V, { strict: false });
		if (types$2.isArrayBuffer(V) || types$2.isTypedArray(V) || types$2.isDataView(V)) return webidl.converters.BufferSource(V);
		if (util.isFormDataLike(V)) return webidl.converters.FormData(V, { strict: false });
		if (V instanceof URLSearchParams) return webidl.converters.URLSearchParams(V);
		return webidl.converters.DOMString(V);
	};
	webidl.converters.BodyInit = function(V) {
		if (V instanceof ReadableStream) return webidl.converters.ReadableStream(V);
		if (V?.[Symbol.asyncIterator]) return V;
		return webidl.converters.XMLHttpRequestBodyInit(V);
	};
	webidl.converters.ResponseInit = webidl.dictionaryConverter([
		{
			key: "status",
			converter: webidl.converters["unsigned short"],
			defaultValue: 200
		},
		{
			key: "statusText",
			converter: webidl.converters.ByteString,
			defaultValue: ""
		},
		{
			key: "headers",
			converter: webidl.converters.HeadersInit
		}
	]);
	module.exports = {
		makeNetworkError,
		makeResponse,
		makeAppropriateNetworkError,
		filterResponse,
		Response,
		cloneResponse
	};
}));
var require_request = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { extractBody, mixinBody, cloneBody } = require_body();
	var { Headers, fill: fillHeaders, HeadersList } = require_headers();
	var { FinalizationRegistry } = require_dispatcher_weakref()();
	var util = require_util$6();
	var { isValidHTTPToken, sameOrigin, normalizeMethod, makePolicyContainer, normalizeMethodRecord } = require_util$5();
	var { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = require_constants$3();
	var { kEnumerableProperty } = util;
	var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols$3();
	var { webidl } = require_webidl();
	var { getGlobalOrigin } = require_global$1();
	var { URLSerializer } = require_dataURL();
	var { kHeadersList, kConstruct } = require_symbols$4();
	var assert$4 = __require("assert");
	var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
	var TransformStream = globalThis.TransformStream;
	var kAbortController = Symbol("abortController");
	var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
		signal.removeEventListener("abort", abort);
	});
	var Request = class Request {
		constructor(input, init = {}) {
			if (input === kConstruct) return;
			webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
			input = webidl.converters.RequestInfo(input);
			init = webidl.converters.RequestInit(init);
			this[kRealm] = { settingsObject: {
				baseUrl: getGlobalOrigin(),
				get origin() {
					return this.baseUrl?.origin;
				},
				policyContainer: makePolicyContainer()
			} };
			let request$1 = null;
			let fallbackMode = null;
			const baseUrl = this[kRealm].settingsObject.baseUrl;
			let signal = null;
			if (typeof input === "string") {
				let parsedURL;
				try {
					parsedURL = new URL(input, baseUrl);
				} catch (err) {
					throw new TypeError("Failed to parse URL from " + input, { cause: err });
				}
				if (parsedURL.username || parsedURL.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
				request$1 = makeRequest({ urlList: [parsedURL] });
				fallbackMode = "cors";
			} else {
				assert$4(input instanceof Request);
				request$1 = input[kState];
				signal = input[kSignal];
			}
			const origin = this[kRealm].settingsObject.origin;
			let window = "client";
			if (request$1.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request$1.window, origin)) window = request$1.window;
			if (init.window != null) throw new TypeError(`'window' option '${window}' must be null`);
			if ("window" in init) window = "no-window";
			request$1 = makeRequest({
				method: request$1.method,
				headersList: request$1.headersList,
				unsafeRequest: request$1.unsafeRequest,
				client: this[kRealm].settingsObject,
				window,
				priority: request$1.priority,
				origin: request$1.origin,
				referrer: request$1.referrer,
				referrerPolicy: request$1.referrerPolicy,
				mode: request$1.mode,
				credentials: request$1.credentials,
				cache: request$1.cache,
				redirect: request$1.redirect,
				integrity: request$1.integrity,
				keepalive: request$1.keepalive,
				reloadNavigation: request$1.reloadNavigation,
				historyNavigation: request$1.historyNavigation,
				urlList: [...request$1.urlList]
			});
			const initHasKey = Object.keys(init).length !== 0;
			if (initHasKey) {
				if (request$1.mode === "navigate") request$1.mode = "same-origin";
				request$1.reloadNavigation = false;
				request$1.historyNavigation = false;
				request$1.origin = "client";
				request$1.referrer = "client";
				request$1.referrerPolicy = "";
				request$1.url = request$1.urlList[request$1.urlList.length - 1];
				request$1.urlList = [request$1.url];
			}
			if (init.referrer !== void 0) {
				const referrer = init.referrer;
				if (referrer === "") request$1.referrer = "no-referrer";
				else {
					let parsedReferrer;
					try {
						parsedReferrer = new URL(referrer, baseUrl);
					} catch (err) {
						throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
					}
					if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) request$1.referrer = "client";
					else request$1.referrer = parsedReferrer;
				}
			}
			if (init.referrerPolicy !== void 0) request$1.referrerPolicy = init.referrerPolicy;
			let mode;
			if (init.mode !== void 0) mode = init.mode;
			else mode = fallbackMode;
			if (mode === "navigate") throw webidl.errors.exception({
				header: "Request constructor",
				message: "invalid request mode navigate."
			});
			if (mode != null) request$1.mode = mode;
			if (init.credentials !== void 0) request$1.credentials = init.credentials;
			if (init.cache !== void 0) request$1.cache = init.cache;
			if (request$1.cache === "only-if-cached" && request$1.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
			if (init.redirect !== void 0) request$1.redirect = init.redirect;
			if (init.integrity != null) request$1.integrity = String(init.integrity);
			if (init.keepalive !== void 0) request$1.keepalive = Boolean(init.keepalive);
			if (init.method !== void 0) {
				let method = init.method;
				if (!isValidHTTPToken(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
				if (forbiddenMethodsSet.has(method.toUpperCase())) throw new TypeError(`'${method}' HTTP method is unsupported.`);
				method = normalizeMethodRecord[method] ?? normalizeMethod(method);
				request$1.method = method;
			}
			if (init.signal !== void 0) signal = init.signal;
			this[kState] = request$1;
			const ac = new AbortController();
			this[kSignal] = ac.signal;
			this[kSignal][kRealm] = this[kRealm];
			if (signal != null) {
				if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
				if (signal.aborted) ac.abort(signal.reason);
				else {
					this[kAbortController] = ac;
					const acRef = new WeakRef(ac);
					const abort = function() {
						const ac$1 = acRef.deref();
						if (ac$1 !== void 0) ac$1.abort(this.reason);
					};
					try {
						if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) setMaxListeners(100, signal);
						else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) setMaxListeners(100, signal);
					} catch {}
					util.addAbortListener(signal, abort);
					requestFinalizer.register(ac, {
						signal,
						abort
					});
				}
			}
			this[kHeaders] = new Headers(kConstruct);
			this[kHeaders][kHeadersList] = request$1.headersList;
			this[kHeaders][kGuard] = "request";
			this[kHeaders][kRealm] = this[kRealm];
			if (mode === "no-cors") {
				if (!corsSafeListedMethodsSet.has(request$1.method)) throw new TypeError(`'${request$1.method} is unsupported in no-cors mode.`);
				this[kHeaders][kGuard] = "request-no-cors";
			}
			if (initHasKey) {
				const headersList = this[kHeaders][kHeadersList];
				const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
				headersList.clear();
				if (headers instanceof HeadersList) {
					for (const [key, val] of headers) headersList.append(key, val);
					headersList.cookies = headers.cookies;
				} else fillHeaders(this[kHeaders], headers);
			}
			const inputBody = input instanceof Request ? input[kState].body : null;
			if ((init.body != null || inputBody != null) && (request$1.method === "GET" || request$1.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
			let initBody = null;
			if (init.body != null) {
				const [extractedBody, contentType] = extractBody(init.body, request$1.keepalive);
				initBody = extractedBody;
				if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) this[kHeaders].append("content-type", contentType);
			}
			const inputOrInitBody = initBody ?? inputBody;
			if (inputOrInitBody != null && inputOrInitBody.source == null) {
				if (initBody != null && init.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
				if (request$1.mode !== "same-origin" && request$1.mode !== "cors") throw new TypeError("If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"");
				request$1.useCORSPreflightFlag = true;
			}
			let finalBody = inputOrInitBody;
			if (initBody == null && inputBody != null) {
				if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
				if (!TransformStream) TransformStream = __require("stream/web").TransformStream;
				const identityTransform = new TransformStream();
				inputBody.stream.pipeThrough(identityTransform);
				finalBody = {
					source: inputBody.source,
					length: inputBody.length,
					stream: identityTransform.readable
				};
			}
			this[kState].body = finalBody;
		}
		get method() {
			webidl.brandCheck(this, Request);
			return this[kState].method;
		}
		get url() {
			webidl.brandCheck(this, Request);
			return URLSerializer(this[kState].url);
		}
		get headers() {
			webidl.brandCheck(this, Request);
			return this[kHeaders];
		}
		get destination() {
			webidl.brandCheck(this, Request);
			return this[kState].destination;
		}
		get referrer() {
			webidl.brandCheck(this, Request);
			if (this[kState].referrer === "no-referrer") return "";
			if (this[kState].referrer === "client") return "about:client";
			return this[kState].referrer.toString();
		}
		get referrerPolicy() {
			webidl.brandCheck(this, Request);
			return this[kState].referrerPolicy;
		}
		get mode() {
			webidl.brandCheck(this, Request);
			return this[kState].mode;
		}
		get credentials() {
			return this[kState].credentials;
		}
		get cache() {
			webidl.brandCheck(this, Request);
			return this[kState].cache;
		}
		get redirect() {
			webidl.brandCheck(this, Request);
			return this[kState].redirect;
		}
		get integrity() {
			webidl.brandCheck(this, Request);
			return this[kState].integrity;
		}
		get keepalive() {
			webidl.brandCheck(this, Request);
			return this[kState].keepalive;
		}
		get isReloadNavigation() {
			webidl.brandCheck(this, Request);
			return this[kState].reloadNavigation;
		}
		get isHistoryNavigation() {
			webidl.brandCheck(this, Request);
			return this[kState].historyNavigation;
		}
		get signal() {
			webidl.brandCheck(this, Request);
			return this[kSignal];
		}
		get body() {
			webidl.brandCheck(this, Request);
			return this[kState].body ? this[kState].body.stream : null;
		}
		get bodyUsed() {
			webidl.brandCheck(this, Request);
			return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
		}
		get duplex() {
			webidl.brandCheck(this, Request);
			return "half";
		}
		clone() {
			webidl.brandCheck(this, Request);
			if (this.bodyUsed || this.body?.locked) throw new TypeError("unusable");
			const clonedRequest = cloneRequest(this[kState]);
			const clonedRequestObject = new Request(kConstruct);
			clonedRequestObject[kState] = clonedRequest;
			clonedRequestObject[kRealm] = this[kRealm];
			clonedRequestObject[kHeaders] = new Headers(kConstruct);
			clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
			clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
			clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
			const ac = new AbortController();
			if (this.signal.aborted) ac.abort(this.signal.reason);
			else util.addAbortListener(this.signal, () => {
				ac.abort(this.signal.reason);
			});
			clonedRequestObject[kSignal] = ac.signal;
			return clonedRequestObject;
		}
	};
	mixinBody(Request);
	function makeRequest(init) {
		const request$1 = {
			method: "GET",
			localURLsOnly: false,
			unsafeRequest: false,
			body: null,
			client: null,
			reservedClient: null,
			replacesClientId: "",
			window: "client",
			keepalive: false,
			serviceWorkers: "all",
			initiator: "",
			destination: "",
			priority: null,
			origin: "client",
			policyContainer: "client",
			referrer: "client",
			referrerPolicy: "",
			mode: "no-cors",
			useCORSPreflightFlag: false,
			credentials: "same-origin",
			useCredentials: false,
			cache: "default",
			redirect: "follow",
			integrity: "",
			cryptoGraphicsNonceMetadata: "",
			parserMetadata: "",
			reloadNavigation: false,
			historyNavigation: false,
			userActivation: false,
			taintedOrigin: false,
			redirectCount: 0,
			responseTainting: "basic",
			preventNoCacheCacheControlHeaderModification: false,
			done: false,
			timingAllowFailed: false,
			...init,
			headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
		};
		request$1.url = request$1.urlList[0];
		return request$1;
	}
	function cloneRequest(request$1) {
		const newRequest = makeRequest({
			...request$1,
			body: null
		});
		if (request$1.body != null) newRequest.body = cloneBody(request$1.body);
		return newRequest;
	}
	Object.defineProperties(Request.prototype, {
		method: kEnumerableProperty,
		url: kEnumerableProperty,
		headers: kEnumerableProperty,
		redirect: kEnumerableProperty,
		clone: kEnumerableProperty,
		signal: kEnumerableProperty,
		duplex: kEnumerableProperty,
		destination: kEnumerableProperty,
		body: kEnumerableProperty,
		bodyUsed: kEnumerableProperty,
		isHistoryNavigation: kEnumerableProperty,
		isReloadNavigation: kEnumerableProperty,
		keepalive: kEnumerableProperty,
		integrity: kEnumerableProperty,
		cache: kEnumerableProperty,
		credentials: kEnumerableProperty,
		attribute: kEnumerableProperty,
		referrerPolicy: kEnumerableProperty,
		referrer: kEnumerableProperty,
		mode: kEnumerableProperty,
		[Symbol.toStringTag]: {
			value: "Request",
			configurable: true
		}
	});
	webidl.converters.Request = webidl.interfaceConverter(Request);
	webidl.converters.RequestInfo = function(V) {
		if (typeof V === "string") return webidl.converters.USVString(V);
		if (V instanceof Request) return webidl.converters.Request(V);
		return webidl.converters.USVString(V);
	};
	webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
	webidl.converters.RequestInit = webidl.dictionaryConverter([
		{
			key: "method",
			converter: webidl.converters.ByteString
		},
		{
			key: "headers",
			converter: webidl.converters.HeadersInit
		},
		{
			key: "body",
			converter: webidl.nullableConverter(webidl.converters.BodyInit)
		},
		{
			key: "referrer",
			converter: webidl.converters.USVString
		},
		{
			key: "referrerPolicy",
			converter: webidl.converters.DOMString,
			allowedValues: referrerPolicy
		},
		{
			key: "mode",
			converter: webidl.converters.DOMString,
			allowedValues: requestMode
		},
		{
			key: "credentials",
			converter: webidl.converters.DOMString,
			allowedValues: requestCredentials
		},
		{
			key: "cache",
			converter: webidl.converters.DOMString,
			allowedValues: requestCache
		},
		{
			key: "redirect",
			converter: webidl.converters.DOMString,
			allowedValues: requestRedirect
		},
		{
			key: "integrity",
			converter: webidl.converters.DOMString
		},
		{
			key: "keepalive",
			converter: webidl.converters.boolean
		},
		{
			key: "signal",
			converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, { strict: false }))
		},
		{
			key: "window",
			converter: webidl.converters.any
		},
		{
			key: "duplex",
			converter: webidl.converters.DOMString,
			allowedValues: requestDuplex
		}
	]);
	module.exports = {
		Request,
		makeRequest
	};
}));
var require_fetch = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Response, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = require_response();
	var { Headers } = require_headers();
	var { Request, makeRequest } = require_request();
	var zlib = __require("zlib");
	var { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme } = require_util$5();
	var { kState, kHeaders, kGuard, kRealm } = require_symbols$3();
	var assert$3 = __require("assert");
	var { safelyExtractBody } = require_body();
	var { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet, DOMException } = require_constants$3();
	var { kHeadersList } = require_symbols$4();
	var EE = __require("events");
	var { Readable, pipeline } = __require("stream");
	var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util$6();
	var { dataURLProcessor, serializeAMimeType } = require_dataURL();
	var { TransformStream } = __require("stream/web");
	var { getGlobalDispatcher } = require_global();
	var { webidl } = require_webidl();
	var { STATUS_CODES } = __require("http");
	var GET_OR_HEAD = ["GET", "HEAD"];
	var resolveObjectURL;
	var ReadableStream = globalThis.ReadableStream;
	var Fetch = class extends EE {
		constructor(dispatcher) {
			super();
			this.dispatcher = dispatcher;
			this.connection = null;
			this.dump = false;
			this.state = "ongoing";
			this.setMaxListeners(21);
		}
		terminate(reason) {
			if (this.state !== "ongoing") return;
			this.state = "terminated";
			this.connection?.destroy(reason);
			this.emit("terminated", reason);
		}
		abort(error) {
			if (this.state !== "ongoing") return;
			this.state = "aborted";
			if (!error) error = new DOMException("The operation was aborted.", "AbortError");
			this.serializedAbortReason = error;
			this.connection?.destroy(error);
			this.emit("terminated", error);
		}
	};
	function fetch(input, init = {}) {
		webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
		const p = createDeferredPromise();
		let requestObject;
		try {
			requestObject = new Request(input, init);
		} catch (e) {
			p.reject(e);
			return p.promise;
		}
		const request$1 = requestObject[kState];
		if (requestObject.signal.aborted) {
			abortFetch(p, request$1, null, requestObject.signal.reason);
			return p.promise;
		}
		if (request$1.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope") request$1.serviceWorkers = "none";
		let responseObject = null;
		const relevantRealm = null;
		let locallyAborted = false;
		let controller = null;
		addAbortListener(requestObject.signal, () => {
			locallyAborted = true;
			assert$3(controller != null);
			controller.abort(requestObject.signal.reason);
			abortFetch(p, request$1, responseObject, requestObject.signal.reason);
		});
		const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
		const processResponse = (response) => {
			if (locallyAborted) return Promise.resolve();
			if (response.aborted) {
				abortFetch(p, request$1, responseObject, controller.serializedAbortReason);
				return Promise.resolve();
			}
			if (response.type === "error") {
				p.reject(Object.assign(/* @__PURE__ */ new TypeError("fetch failed"), { cause: response.error }));
				return Promise.resolve();
			}
			responseObject = new Response();
			responseObject[kState] = response;
			responseObject[kRealm] = relevantRealm;
			responseObject[kHeaders][kHeadersList] = response.headersList;
			responseObject[kHeaders][kGuard] = "immutable";
			responseObject[kHeaders][kRealm] = relevantRealm;
			p.resolve(responseObject);
		};
		controller = fetching({
			request: request$1,
			processResponseEndOfBody: handleFetchDone,
			processResponse,
			dispatcher: init.dispatcher ?? getGlobalDispatcher()
		});
		return p.promise;
	}
	function finalizeAndReportTiming(response, initiatorType = "other") {
		if (response.type === "error" && response.aborted) return;
		if (!response.urlList?.length) return;
		const originalURL = response.urlList[0];
		let timingInfo = response.timingInfo;
		let cacheState = response.cacheState;
		if (!urlIsHttpHttpsScheme(originalURL)) return;
		if (timingInfo === null) return;
		if (!response.timingAllowPassed) {
			timingInfo = createOpaqueTimingInfo({ startTime: timingInfo.startTime });
			cacheState = "";
		}
		timingInfo.endTime = coarsenedSharedCurrentTime();
		response.timingInfo = timingInfo;
		markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
	}
	function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis$1, cacheState) {
		if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis$1, cacheState);
	}
	function abortFetch(p, request$1, responseObject, error) {
		if (!error) error = new DOMException("The operation was aborted.", "AbortError");
		p.reject(error);
		if (request$1.body != null && isReadable(request$1.body?.stream)) request$1.body.stream.cancel(error).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
		if (responseObject == null) return;
		const response = responseObject[kState];
		if (response.body != null && isReadable(response.body?.stream)) response.body.stream.cancel(error).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
	}
	function fetching({ request: request$1, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher }) {
		let taskDestination = null;
		let crossOriginIsolatedCapability = false;
		if (request$1.client != null) {
			taskDestination = request$1.client.globalObject;
			crossOriginIsolatedCapability = request$1.client.crossOriginIsolatedCapability;
		}
		const timingInfo = createOpaqueTimingInfo({ startTime: coarsenedSharedCurrentTime(crossOriginIsolatedCapability) });
		const fetchParams = {
			controller: new Fetch(dispatcher),
			request: request$1,
			timingInfo,
			processRequestBodyChunkLength,
			processRequestEndOfBody,
			processResponse,
			processResponseConsumeBody,
			processResponseEndOfBody,
			taskDestination,
			crossOriginIsolatedCapability
		};
		assert$3(!request$1.body || request$1.body.stream);
		if (request$1.window === "client") request$1.window = request$1.client?.globalObject?.constructor?.name === "Window" ? request$1.client : "no-window";
		if (request$1.origin === "client") request$1.origin = request$1.client?.origin;
		if (request$1.policyContainer === "client") if (request$1.client != null) request$1.policyContainer = clonePolicyContainer(request$1.client.policyContainer);
		else request$1.policyContainer = makePolicyContainer();
		if (!request$1.headersList.contains("accept")) request$1.headersList.append("accept", "*/*");
		if (!request$1.headersList.contains("accept-language")) request$1.headersList.append("accept-language", "*");
		if (request$1.priority === null) {}
		if (subresourceSet.has(request$1.destination)) {}
		mainFetch(fetchParams).catch((err) => {
			fetchParams.controller.terminate(err);
		});
		return fetchParams.controller;
	}
	async function mainFetch(fetchParams, recursive = false) {
		const request$1 = fetchParams.request;
		let response = null;
		if (request$1.localURLsOnly && !urlIsLocal(requestCurrentURL(request$1))) response = makeNetworkError("local URLs only");
		tryUpgradeRequestToAPotentiallyTrustworthyURL(request$1);
		if (requestBadPort(request$1) === "blocked") response = makeNetworkError("bad port");
		if (request$1.referrerPolicy === "") request$1.referrerPolicy = request$1.policyContainer.referrerPolicy;
		if (request$1.referrer !== "no-referrer") request$1.referrer = determineRequestsReferrer(request$1);
		if (response === null) response = await (async () => {
			const currentURL = requestCurrentURL(request$1);
			if (sameOrigin(currentURL, request$1.url) && request$1.responseTainting === "basic" || currentURL.protocol === "data:" || request$1.mode === "navigate" || request$1.mode === "websocket") {
				request$1.responseTainting = "basic";
				return await schemeFetch(fetchParams);
			}
			if (request$1.mode === "same-origin") return makeNetworkError("request mode cannot be \"same-origin\"");
			if (request$1.mode === "no-cors") {
				if (request$1.redirect !== "follow") return makeNetworkError("redirect mode cannot be \"follow\" for \"no-cors\" request");
				request$1.responseTainting = "opaque";
				return await schemeFetch(fetchParams);
			}
			if (!urlIsHttpHttpsScheme(requestCurrentURL(request$1))) return makeNetworkError("URL scheme must be a HTTP(S) scheme");
			request$1.responseTainting = "cors";
			return await httpFetch(fetchParams);
		})();
		if (recursive) return response;
		if (response.status !== 0 && !response.internalResponse) {
			if (request$1.responseTainting === "cors") {}
			if (request$1.responseTainting === "basic") response = filterResponse(response, "basic");
			else if (request$1.responseTainting === "cors") response = filterResponse(response, "cors");
			else if (request$1.responseTainting === "opaque") response = filterResponse(response, "opaque");
			else assert$3(false);
		}
		let internalResponse = response.status === 0 ? response : response.internalResponse;
		if (internalResponse.urlList.length === 0) internalResponse.urlList.push(...request$1.urlList);
		if (!request$1.timingAllowFailed) response.timingAllowPassed = true;
		if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request$1.headers.contains("range")) response = internalResponse = makeNetworkError();
		if (response.status !== 0 && (request$1.method === "HEAD" || request$1.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
			internalResponse.body = null;
			fetchParams.controller.dump = true;
		}
		if (request$1.integrity) {
			const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
			if (request$1.responseTainting === "opaque" || response.body == null) {
				processBodyError(response.error);
				return;
			}
			const processBody = (bytes) => {
				if (!bytesMatch(bytes, request$1.integrity)) {
					processBodyError("integrity mismatch");
					return;
				}
				response.body = safelyExtractBody(bytes)[0];
				fetchFinale(fetchParams, response);
			};
			await fullyReadBody(response.body, processBody, processBodyError);
		} else fetchFinale(fetchParams, response);
	}
	function schemeFetch(fetchParams) {
		if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
		const { request: request$1 } = fetchParams;
		const { protocol: scheme } = requestCurrentURL(request$1);
		switch (scheme) {
			case "about:": return Promise.resolve(makeNetworkError("about scheme is not supported"));
			case "blob:": {
				if (!resolveObjectURL) resolveObjectURL = __require("buffer").resolveObjectURL;
				const blobURLEntry = requestCurrentURL(request$1);
				if (blobURLEntry.search.length !== 0) return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
				const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
				if (request$1.method !== "GET" || !isBlobLike(blobURLEntryObject)) return Promise.resolve(makeNetworkError("invalid method"));
				const bodyWithType = safelyExtractBody(blobURLEntryObject);
				const body = bodyWithType[0];
				const length$1 = isomorphicEncode(`${body.length}`);
				const type = bodyWithType[1] ?? "";
				const response = makeResponse({
					statusText: "OK",
					headersList: [["content-length", {
						name: "Content-Length",
						value: length$1
					}], ["content-type", {
						name: "Content-Type",
						value: type
					}]]
				});
				response.body = body;
				return Promise.resolve(response);
			}
			case "data:": {
				const dataURLStruct = dataURLProcessor(requestCurrentURL(request$1));
				if (dataURLStruct === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
				const mimeType = serializeAMimeType(dataURLStruct.mimeType);
				return Promise.resolve(makeResponse({
					statusText: "OK",
					headersList: [["content-type", {
						name: "Content-Type",
						value: mimeType
					}]],
					body: safelyExtractBody(dataURLStruct.body)[0]
				}));
			}
			case "file:": return Promise.resolve(makeNetworkError("not implemented... yet..."));
			case "http:":
			case "https:": return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
			default: return Promise.resolve(makeNetworkError("unknown scheme"));
		}
	}
	function finalizeResponse(fetchParams, response) {
		fetchParams.request.done = true;
		if (fetchParams.processResponseDone != null) queueMicrotask(() => fetchParams.processResponseDone(response));
	}
	function fetchFinale(fetchParams, response) {
		if (response.type === "error") {
			response.urlList = [fetchParams.request.urlList[0]];
			response.timingInfo = createOpaqueTimingInfo({ startTime: fetchParams.timingInfo.startTime });
		}
		const processResponseEndOfBody = () => {
			fetchParams.request.done = true;
			if (fetchParams.processResponseEndOfBody != null) queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
		};
		if (fetchParams.processResponse != null) queueMicrotask(() => fetchParams.processResponse(response));
		if (response.body == null) processResponseEndOfBody();
		else {
			const identityTransformAlgorithm = (chunk$4, controller) => {
				controller.enqueue(chunk$4);
			};
			const transformStream = new TransformStream({
				start() {},
				transform: identityTransformAlgorithm,
				flush: processResponseEndOfBody
			}, { size() {
				return 1;
			} }, { size() {
				return 1;
			} });
			response.body = { stream: response.body.stream.pipeThrough(transformStream) };
		}
		if (fetchParams.processResponseConsumeBody != null) {
			const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
			const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
			if (response.body == null) queueMicrotask(() => processBody(null));
			else return fullyReadBody(response.body, processBody, processBodyError);
			return Promise.resolve();
		}
	}
	async function httpFetch(fetchParams) {
		const request$1 = fetchParams.request;
		let response = null;
		let actualResponse = null;
		const timingInfo = fetchParams.timingInfo;
		if (request$1.serviceWorkers === "all") {}
		if (response === null) {
			if (request$1.redirect === "follow") request$1.serviceWorkers = "none";
			actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
			if (request$1.responseTainting === "cors" && corsCheck(request$1, response) === "failure") return makeNetworkError("cors failure");
			if (TAOCheck(request$1, response) === "failure") request$1.timingAllowFailed = true;
		}
		if ((request$1.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request$1.origin, request$1.client, request$1.destination, actualResponse) === "blocked") return makeNetworkError("blocked");
		if (redirectStatusSet.has(actualResponse.status)) {
			if (request$1.redirect !== "manual") fetchParams.controller.connection.destroy();
			if (request$1.redirect === "error") response = makeNetworkError("unexpected redirect");
			else if (request$1.redirect === "manual") response = actualResponse;
			else if (request$1.redirect === "follow") response = await httpRedirectFetch(fetchParams, response);
			else assert$3(false);
		}
		response.timingInfo = timingInfo;
		return response;
	}
	function httpRedirectFetch(fetchParams, response) {
		const request$1 = fetchParams.request;
		const actualResponse = response.internalResponse ? response.internalResponse : response;
		let locationURL;
		try {
			locationURL = responseLocationURL(actualResponse, requestCurrentURL(request$1).hash);
			if (locationURL == null) return response;
		} catch (err) {
			return Promise.resolve(makeNetworkError(err));
		}
		if (!urlIsHttpHttpsScheme(locationURL)) return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
		if (request$1.redirectCount === 20) return Promise.resolve(makeNetworkError("redirect count exceeded"));
		request$1.redirectCount += 1;
		if (request$1.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request$1, locationURL)) return Promise.resolve(makeNetworkError("cross origin not allowed for request mode \"cors\""));
		if (request$1.responseTainting === "cors" && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError("URL cannot contain credentials for request mode \"cors\""));
		if (actualResponse.status !== 303 && request$1.body != null && request$1.body.source == null) return Promise.resolve(makeNetworkError());
		if ([301, 302].includes(actualResponse.status) && request$1.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request$1.method)) {
			request$1.method = "GET";
			request$1.body = null;
			for (const headerName of requestBodyHeader) request$1.headersList.delete(headerName);
		}
		if (!sameOrigin(requestCurrentURL(request$1), locationURL)) {
			request$1.headersList.delete("authorization");
			request$1.headersList.delete("proxy-authorization", true);
			request$1.headersList.delete("cookie");
			request$1.headersList.delete("host");
		}
		if (request$1.body != null) {
			assert$3(request$1.body.source != null);
			request$1.body = safelyExtractBody(request$1.body.source)[0];
		}
		const timingInfo = fetchParams.timingInfo;
		timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
		if (timingInfo.redirectStartTime === 0) timingInfo.redirectStartTime = timingInfo.startTime;
		request$1.urlList.push(locationURL);
		setRequestReferrerPolicyOnRedirect(request$1, actualResponse);
		return mainFetch(fetchParams, true);
	}
	async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
		const request$1 = fetchParams.request;
		let httpFetchParams = null;
		let httpRequest = null;
		let response = null;
		const httpCache = null;
		if (request$1.window === "no-window" && request$1.redirect === "error") {
			httpFetchParams = fetchParams;
			httpRequest = request$1;
		} else {
			httpRequest = makeRequest(request$1);
			httpFetchParams = { ...fetchParams };
			httpFetchParams.request = httpRequest;
		}
		const includeCredentials = request$1.credentials === "include" || request$1.credentials === "same-origin" && request$1.responseTainting === "basic";
		const contentLength = httpRequest.body ? httpRequest.body.length : null;
		let contentLengthHeaderValue = null;
		if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) contentLengthHeaderValue = "0";
		if (contentLength != null) contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
		if (contentLengthHeaderValue != null) httpRequest.headersList.append("content-length", contentLengthHeaderValue);
		if (contentLength != null && httpRequest.keepalive) {}
		if (httpRequest.referrer instanceof URL) httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
		appendRequestOriginHeader(httpRequest);
		appendFetchMetadata(httpRequest);
		if (!httpRequest.headersList.contains("user-agent")) httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
		if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) httpRequest.cache = "no-store";
		if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) httpRequest.headersList.append("cache-control", "max-age=0");
		if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
			if (!httpRequest.headersList.contains("pragma")) httpRequest.headersList.append("pragma", "no-cache");
			if (!httpRequest.headersList.contains("cache-control")) httpRequest.headersList.append("cache-control", "no-cache");
		}
		if (httpRequest.headersList.contains("range")) httpRequest.headersList.append("accept-encoding", "identity");
		if (!httpRequest.headersList.contains("accept-encoding")) if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
		else httpRequest.headersList.append("accept-encoding", "gzip, deflate");
		httpRequest.headersList.delete("host");
		if (includeCredentials) {}
		if (httpCache == null) httpRequest.cache = "no-store";
		if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {}
		if (response == null) {
			if (httpRequest.mode === "only-if-cached") return makeNetworkError("only if cached");
			const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
			if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {}
			if (response == null) response = forwardResponse;
		}
		response.urlList = [...httpRequest.urlList];
		if (httpRequest.headersList.contains("range")) response.rangeRequested = true;
		response.requestIncludesCredentials = includeCredentials;
		if (response.status === 407) {
			if (request$1.window === "no-window") return makeNetworkError();
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			return makeNetworkError("proxy authentication required");
		}
		if (response.status === 421 && !isNewConnectionFetch && (request$1.body == null || request$1.body.source != null)) {
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			fetchParams.controller.connection.destroy();
			response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
		}
		if (isAuthenticationFetch) {}
		return response;
	}
	async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
		assert$3(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
		fetchParams.controller.connection = {
			abort: null,
			destroyed: false,
			destroy(err) {
				if (!this.destroyed) {
					this.destroyed = true;
					this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
				}
			}
		};
		const request$1 = fetchParams.request;
		let response = null;
		const timingInfo = fetchParams.timingInfo;
		request$1.cache = "no-store";
		if (request$1.mode === "websocket") {}
		let requestBody = null;
		if (request$1.body == null && fetchParams.processRequestEndOfBody) queueMicrotask(() => fetchParams.processRequestEndOfBody());
		else if (request$1.body != null) {
			const processBodyChunk = async function* (bytes) {
				if (isCancelled(fetchParams)) return;
				yield bytes;
				fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
			};
			const processEndOfBody = () => {
				if (isCancelled(fetchParams)) return;
				if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();
			};
			const processBodyError = (e) => {
				if (isCancelled(fetchParams)) return;
				if (e.name === "AbortError") fetchParams.controller.abort();
				else fetchParams.controller.terminate(e);
			};
			requestBody = (async function* () {
				try {
					for await (const bytes of request$1.body.stream) yield* processBodyChunk(bytes);
					processEndOfBody();
				} catch (err) {
					processBodyError(err);
				}
			})();
		}
		try {
			const { body, status: status$2, statusText, headersList, socket } = await dispatch({ body: requestBody });
			if (socket) response = makeResponse({
				status: status$2,
				statusText,
				headersList,
				socket
			});
			else {
				const iterator = body[Symbol.asyncIterator]();
				fetchParams.controller.next = () => iterator.next();
				response = makeResponse({
					status: status$2,
					statusText,
					headersList
				});
			}
		} catch (err) {
			if (err.name === "AbortError") {
				fetchParams.controller.connection.destroy();
				return makeAppropriateNetworkError(fetchParams, err);
			}
			return makeNetworkError(err);
		}
		const pullAlgorithm = () => {
			fetchParams.controller.resume();
		};
		const cancelAlgorithm = (reason) => {
			fetchParams.controller.abort(reason);
		};
		if (!ReadableStream) ReadableStream = __require("stream/web").ReadableStream;
		const stream$1 = new ReadableStream({
			async start(controller) {
				fetchParams.controller.controller = controller;
			},
			async pull(controller) {
				await pullAlgorithm(controller);
			},
			async cancel(reason) {
				await cancelAlgorithm(reason);
			}
		}, {
			highWaterMark: 0,
			size() {
				return 1;
			}
		});
		response.body = { stream: stream$1 };
		fetchParams.controller.on("terminated", onAborted);
		fetchParams.controller.resume = async () => {
			while (true) {
				let bytes;
				let isFailure$5;
				try {
					const { done: done$8, value: value$2 } = await fetchParams.controller.next();
					if (isAborted(fetchParams)) break;
					bytes = done$8 ? void 0 : value$2;
				} catch (err) {
					if (fetchParams.controller.ended && !timingInfo.encodedBodySize) bytes = void 0;
					else {
						bytes = err;
						isFailure$5 = true;
					}
				}
				if (bytes === void 0) {
					readableStreamClose(fetchParams.controller.controller);
					finalizeResponse(fetchParams, response);
					return;
				}
				timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
				if (isFailure$5) {
					fetchParams.controller.terminate(bytes);
					return;
				}
				fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
				if (isErrored(stream$1)) {
					fetchParams.controller.terminate();
					return;
				}
				if (!fetchParams.controller.controller.desiredSize) return;
			}
		};
		function onAborted(reason) {
			if (isAborted(fetchParams)) {
				response.aborted = true;
				if (isReadable(stream$1)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
			} else if (isReadable(stream$1)) fetchParams.controller.controller.error(new TypeError("terminated", { cause: isErrorLike(reason) ? reason : void 0 }));
			fetchParams.controller.connection.destroy();
		}
		return response;
		async function dispatch({ body }) {
			const url$2 = requestCurrentURL(request$1);
			const agent = fetchParams.controller.dispatcher;
			return new Promise((resolve, reject) => agent.dispatch({
				path: url$2.pathname + url$2.search,
				origin: url$2.origin,
				method: request$1.method,
				body: fetchParams.controller.dispatcher.isMockActive ? request$1.body && (request$1.body.source || request$1.body.stream) : body,
				headers: request$1.headersList.entries,
				maxRedirections: 0,
				upgrade: request$1.mode === "websocket" ? "websocket" : void 0
			}, {
				body: null,
				abort: null,
				onConnect(abort) {
					const { connection } = fetchParams.controller;
					if (connection.destroyed) abort(new DOMException("The operation was aborted.", "AbortError"));
					else {
						fetchParams.controller.on("terminated", abort);
						this.abort = connection.abort = abort;
					}
				},
				onHeaders(status$2, headersList, resume$1, statusText) {
					if (status$2 < 200) return;
					let codings = [];
					let location = "";
					const headers = new Headers();
					if (Array.isArray(headersList)) for (let n = 0; n < headersList.length; n += 2) {
						const key = headersList[n + 0].toString("latin1");
						const val = headersList[n + 1].toString("latin1");
						if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x) => x.trim());
						else if (key.toLowerCase() === "location") location = val;
						headers[kHeadersList].append(key, val);
					}
					else {
						const keys$5 = Object.keys(headersList);
						for (const key of keys$5) {
							const val = headersList[key];
							if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
							else if (key.toLowerCase() === "location") location = val;
							headers[kHeadersList].append(key, val);
						}
					}
					this.body = new Readable({ read: resume$1 });
					const decoders = [];
					const willFollow = request$1.redirect === "follow" && location && redirectStatusSet.has(status$2);
					if (request$1.method !== "HEAD" && request$1.method !== "CONNECT" && !nullBodyStatus.includes(status$2) && !willFollow) for (const coding of codings) if (coding === "x-gzip" || coding === "gzip") decoders.push(zlib.createGunzip({
						flush: zlib.constants.Z_SYNC_FLUSH,
						finishFlush: zlib.constants.Z_SYNC_FLUSH
					}));
					else if (coding === "deflate") decoders.push(zlib.createInflate());
					else if (coding === "br") decoders.push(zlib.createBrotliDecompress());
					else {
						decoders.length = 0;
						break;
					}
					resolve({
						status: status$2,
						statusText,
						headersList: headers[kHeadersList],
						body: decoders.length ? pipeline(this.body, ...decoders, () => {}) : this.body.on("error", () => {})
					});
					return true;
				},
				onData(chunk$4) {
					if (fetchParams.controller.dump) return;
					const bytes = chunk$4;
					timingInfo.encodedBodySize += bytes.byteLength;
					return this.body.push(bytes);
				},
				onComplete() {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					fetchParams.controller.ended = true;
					this.body.push(null);
				},
				onError(error) {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					this.body?.destroy(error);
					fetchParams.controller.terminate(error);
					reject(error);
				},
				onUpgrade(status$2, headersList, socket) {
					if (status$2 !== 101) return;
					const headers = new Headers();
					for (let n = 0; n < headersList.length; n += 2) {
						const key = headersList[n + 0].toString("latin1");
						const val = headersList[n + 1].toString("latin1");
						headers[kHeadersList].append(key, val);
					}
					resolve({
						status: status$2,
						statusText: STATUS_CODES[status$2],
						headersList: headers[kHeadersList],
						socket
					});
					return true;
				}
			}));
		}
	}
	module.exports = {
		fetch,
		Fetch,
		fetching,
		finalizeAndReportTiming
	};
}));
var require_symbols$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kState: Symbol("FileReader state"),
		kResult: Symbol("FileReader result"),
		kError: Symbol("FileReader error"),
		kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
		kEvents: Symbol("FileReader events"),
		kAborted: Symbol("FileReader aborted")
	};
}));
var require_progressevent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { webidl } = require_webidl();
	var kState = Symbol("ProgressEvent state");
	var ProgressEvent = class ProgressEvent extends Event {
		constructor(type, eventInitDict = {}) {
			type = webidl.converters.DOMString(type);
			eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
			super(type, eventInitDict);
			this[kState] = {
				lengthComputable: eventInitDict.lengthComputable,
				loaded: eventInitDict.loaded,
				total: eventInitDict.total
			};
		}
		get lengthComputable() {
			webidl.brandCheck(this, ProgressEvent);
			return this[kState].lengthComputable;
		}
		get loaded() {
			webidl.brandCheck(this, ProgressEvent);
			return this[kState].loaded;
		}
		get total() {
			webidl.brandCheck(this, ProgressEvent);
			return this[kState].total;
		}
	};
	webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
		{
			key: "lengthComputable",
			converter: webidl.converters.boolean,
			defaultValue: false
		},
		{
			key: "loaded",
			converter: webidl.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "total",
			converter: webidl.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "bubbles",
			converter: webidl.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl.converters.boolean,
			defaultValue: false
		}
	]);
	module.exports = { ProgressEvent };
}));
var require_encoding = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function getEncoding(label) {
		if (!label) return "failure";
		switch (label.trim().toLowerCase()) {
			case "unicode-1-1-utf-8":
			case "unicode11utf8":
			case "unicode20utf8":
			case "utf-8":
			case "utf8":
			case "x-unicode20utf8": return "UTF-8";
			case "866":
			case "cp866":
			case "csibm866":
			case "ibm866": return "IBM866";
			case "csisolatin2":
			case "iso-8859-2":
			case "iso-ir-101":
			case "iso8859-2":
			case "iso88592":
			case "iso_8859-2":
			case "iso_8859-2:1987":
			case "l2":
			case "latin2": return "ISO-8859-2";
			case "csisolatin3":
			case "iso-8859-3":
			case "iso-ir-109":
			case "iso8859-3":
			case "iso88593":
			case "iso_8859-3":
			case "iso_8859-3:1988":
			case "l3":
			case "latin3": return "ISO-8859-3";
			case "csisolatin4":
			case "iso-8859-4":
			case "iso-ir-110":
			case "iso8859-4":
			case "iso88594":
			case "iso_8859-4":
			case "iso_8859-4:1988":
			case "l4":
			case "latin4": return "ISO-8859-4";
			case "csisolatincyrillic":
			case "cyrillic":
			case "iso-8859-5":
			case "iso-ir-144":
			case "iso8859-5":
			case "iso88595":
			case "iso_8859-5":
			case "iso_8859-5:1988": return "ISO-8859-5";
			case "arabic":
			case "asmo-708":
			case "csiso88596e":
			case "csiso88596i":
			case "csisolatinarabic":
			case "ecma-114":
			case "iso-8859-6":
			case "iso-8859-6-e":
			case "iso-8859-6-i":
			case "iso-ir-127":
			case "iso8859-6":
			case "iso88596":
			case "iso_8859-6":
			case "iso_8859-6:1987": return "ISO-8859-6";
			case "csisolatingreek":
			case "ecma-118":
			case "elot_928":
			case "greek":
			case "greek8":
			case "iso-8859-7":
			case "iso-ir-126":
			case "iso8859-7":
			case "iso88597":
			case "iso_8859-7":
			case "iso_8859-7:1987":
			case "sun_eu_greek": return "ISO-8859-7";
			case "csiso88598e":
			case "csisolatinhebrew":
			case "hebrew":
			case "iso-8859-8":
			case "iso-8859-8-e":
			case "iso-ir-138":
			case "iso8859-8":
			case "iso88598":
			case "iso_8859-8":
			case "iso_8859-8:1988":
			case "visual": return "ISO-8859-8";
			case "csiso88598i":
			case "iso-8859-8-i":
			case "logical": return "ISO-8859-8-I";
			case "csisolatin6":
			case "iso-8859-10":
			case "iso-ir-157":
			case "iso8859-10":
			case "iso885910":
			case "l6":
			case "latin6": return "ISO-8859-10";
			case "iso-8859-13":
			case "iso8859-13":
			case "iso885913": return "ISO-8859-13";
			case "iso-8859-14":
			case "iso8859-14":
			case "iso885914": return "ISO-8859-14";
			case "csisolatin9":
			case "iso-8859-15":
			case "iso8859-15":
			case "iso885915":
			case "iso_8859-15":
			case "l9": return "ISO-8859-15";
			case "iso-8859-16": return "ISO-8859-16";
			case "cskoi8r":
			case "koi":
			case "koi8":
			case "koi8-r":
			case "koi8_r": return "KOI8-R";
			case "koi8-ru":
			case "koi8-u": return "KOI8-U";
			case "csmacintosh":
			case "mac":
			case "macintosh":
			case "x-mac-roman": return "macintosh";
			case "iso-8859-11":
			case "iso8859-11":
			case "iso885911":
			case "tis-620":
			case "windows-874": return "windows-874";
			case "cp1250":
			case "windows-1250":
			case "x-cp1250": return "windows-1250";
			case "cp1251":
			case "windows-1251":
			case "x-cp1251": return "windows-1251";
			case "ansi_x3.4-1968":
			case "ascii":
			case "cp1252":
			case "cp819":
			case "csisolatin1":
			case "ibm819":
			case "iso-8859-1":
			case "iso-ir-100":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "iso_8859-1:1987":
			case "l1":
			case "latin1":
			case "us-ascii":
			case "windows-1252":
			case "x-cp1252": return "windows-1252";
			case "cp1253":
			case "windows-1253":
			case "x-cp1253": return "windows-1253";
			case "cp1254":
			case "csisolatin5":
			case "iso-8859-9":
			case "iso-ir-148":
			case "iso8859-9":
			case "iso88599":
			case "iso_8859-9":
			case "iso_8859-9:1989":
			case "l5":
			case "latin5":
			case "windows-1254":
			case "x-cp1254": return "windows-1254";
			case "cp1255":
			case "windows-1255":
			case "x-cp1255": return "windows-1255";
			case "cp1256":
			case "windows-1256":
			case "x-cp1256": return "windows-1256";
			case "cp1257":
			case "windows-1257":
			case "x-cp1257": return "windows-1257";
			case "cp1258":
			case "windows-1258":
			case "x-cp1258": return "windows-1258";
			case "x-mac-cyrillic":
			case "x-mac-ukrainian": return "x-mac-cyrillic";
			case "chinese":
			case "csgb2312":
			case "csiso58gb231280":
			case "gb2312":
			case "gb_2312":
			case "gb_2312-80":
			case "gbk":
			case "iso-ir-58":
			case "x-gbk": return "GBK";
			case "gb18030": return "gb18030";
			case "big5":
			case "big5-hkscs":
			case "cn-big5":
			case "csbig5":
			case "x-x-big5": return "Big5";
			case "cseucpkdfmtjapanese":
			case "euc-jp":
			case "x-euc-jp": return "EUC-JP";
			case "csiso2022jp":
			case "iso-2022-jp": return "ISO-2022-JP";
			case "csshiftjis":
			case "ms932":
			case "ms_kanji":
			case "shift-jis":
			case "shift_jis":
			case "sjis":
			case "windows-31j":
			case "x-sjis": return "Shift_JIS";
			case "cseuckr":
			case "csksc56011987":
			case "euc-kr":
			case "iso-ir-149":
			case "korean":
			case "ks_c_5601-1987":
			case "ks_c_5601-1989":
			case "ksc5601":
			case "ksc_5601":
			case "windows-949": return "EUC-KR";
			case "csiso2022kr":
			case "hz-gb-2312":
			case "iso-2022-cn":
			case "iso-2022-cn-ext":
			case "iso-2022-kr":
			case "replacement": return "replacement";
			case "unicodefffe":
			case "utf-16be": return "UTF-16BE";
			case "csunicode":
			case "iso-10646-ucs-2":
			case "ucs-2":
			case "unicode":
			case "unicodefeff":
			case "utf-16":
			case "utf-16le": return "UTF-16LE";
			case "x-user-defined": return "x-user-defined";
			default: return "failure";
		}
	}
	module.exports = { getEncoding };
}));
var require_util$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { kState, kError, kResult, kAborted, kLastProgressEventFired } = require_symbols$2();
	var { ProgressEvent } = require_progressevent();
	var { getEncoding } = require_encoding();
	var { DOMException } = require_constants$3();
	var { serializeAMimeType, parseMIMEType } = require_dataURL();
	var { types: types$1 } = __require("util");
	var { StringDecoder } = __require("string_decoder");
	var { btoa } = __require("buffer");
	var staticPropertyDescriptors = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	function readOperation(fr, blob, type, encodingName) {
		if (fr[kState] === "loading") throw new DOMException("Invalid state", "InvalidStateError");
		fr[kState] = "loading";
		fr[kResult] = null;
		fr[kError] = null;
		const reader = blob.stream().getReader();
		const bytes = [];
		let chunkPromise = reader.read();
		let isFirstChunk = true;
		(async () => {
			while (!fr[kAborted]) try {
				const { done: done$8, value: value$2 } = await chunkPromise;
				if (isFirstChunk && !fr[kAborted]) queueMicrotask(() => {
					fireAProgressEvent("loadstart", fr);
				});
				isFirstChunk = false;
				if (!done$8 && types$1.isUint8Array(value$2)) {
					bytes.push(value$2);
					if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
						fr[kLastProgressEventFired] = Date.now();
						queueMicrotask(() => {
							fireAProgressEvent("progress", fr);
						});
					}
					chunkPromise = reader.read();
				} else if (done$8) {
					queueMicrotask(() => {
						fr[kState] = "done";
						try {
							const result = packageData(bytes, type, blob.type, encodingName);
							if (fr[kAborted]) return;
							fr[kResult] = result;
							fireAProgressEvent("load", fr);
						} catch (error) {
							fr[kError] = error;
							fireAProgressEvent("error", fr);
						}
						if (fr[kState] !== "loading") fireAProgressEvent("loadend", fr);
					});
					break;
				}
			} catch (error) {
				if (fr[kAborted]) return;
				queueMicrotask(() => {
					fr[kState] = "done";
					fr[kError] = error;
					fireAProgressEvent("error", fr);
					if (fr[kState] !== "loading") fireAProgressEvent("loadend", fr);
				});
				break;
			}
		})();
	}
	function fireAProgressEvent(e, reader) {
		const event = new ProgressEvent(e, {
			bubbles: false,
			cancelable: false
		});
		reader.dispatchEvent(event);
	}
	function packageData(bytes, type, mimeType, encodingName) {
		switch (type) {
			case "DataURL": {
				let dataURL = "data:";
				const parsed = parseMIMEType(mimeType || "application/octet-stream");
				if (parsed !== "failure") dataURL += serializeAMimeType(parsed);
				dataURL += ";base64,";
				const decoder$1 = new StringDecoder("latin1");
				for (const chunk$4 of bytes) dataURL += btoa(decoder$1.write(chunk$4));
				dataURL += btoa(decoder$1.end());
				return dataURL;
			}
			case "Text": {
				let encoding = "failure";
				if (encodingName) encoding = getEncoding(encodingName);
				if (encoding === "failure" && mimeType) {
					const type$1 = parseMIMEType(mimeType);
					if (type$1 !== "failure") encoding = getEncoding(type$1.parameters.get("charset"));
				}
				if (encoding === "failure") encoding = "UTF-8";
				return decode(bytes, encoding);
			}
			case "ArrayBuffer": return combineByteSequences(bytes).buffer;
			case "BinaryString": {
				let binaryString = "";
				const decoder$1 = new StringDecoder("latin1");
				for (const chunk$4 of bytes) binaryString += decoder$1.write(chunk$4);
				binaryString += decoder$1.end();
				return binaryString;
			}
		}
	}
	function decode(ioQueue, encoding) {
		const bytes = combineByteSequences(ioQueue);
		const BOMEncoding = BOMSniffing(bytes);
		let slice = 0;
		if (BOMEncoding !== null) {
			encoding = BOMEncoding;
			slice = BOMEncoding === "UTF-8" ? 3 : 2;
		}
		const sliced = bytes.slice(slice);
		return new TextDecoder(encoding).decode(sliced);
	}
	function BOMSniffing(ioQueue) {
		const [a, b, c] = ioQueue;
		if (a === 239 && b === 187 && c === 191) return "UTF-8";
		else if (a === 254 && b === 255) return "UTF-16BE";
		else if (a === 255 && b === 254) return "UTF-16LE";
		return null;
	}
	function combineByteSequences(sequences) {
		const size$11 = sequences.reduce((a, b) => {
			return a + b.byteLength;
		}, 0);
		let offset = 0;
		return sequences.reduce((a, b) => {
			a.set(b, offset);
			offset += b.byteLength;
			return a;
		}, new Uint8Array(size$11));
	}
	module.exports = {
		staticPropertyDescriptors,
		readOperation,
		fireAProgressEvent
	};
}));
var require_filereader = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { staticPropertyDescriptors, readOperation, fireAProgressEvent } = require_util$3();
	var { kState, kError, kResult, kEvents, kAborted } = require_symbols$2();
	var { webidl } = require_webidl();
	var { kEnumerableProperty } = require_util$6();
	var FileReader = class FileReader extends EventTarget {
		constructor() {
			super();
			this[kState] = "empty";
			this[kResult] = null;
			this[kError] = null;
			this[kEvents] = {
				loadend: null,
				error: null,
				abort: null,
				load: null,
				progress: null,
				loadstart: null
			};
		}
		readAsArrayBuffer(blob) {
			webidl.brandCheck(this, FileReader);
			webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
			blob = webidl.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "ArrayBuffer");
		}
		readAsBinaryString(blob) {
			webidl.brandCheck(this, FileReader);
			webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
			blob = webidl.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "BinaryString");
		}
		readAsText(blob, encoding = void 0) {
			webidl.brandCheck(this, FileReader);
			webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
			blob = webidl.converters.Blob(blob, { strict: false });
			if (encoding !== void 0) encoding = webidl.converters.DOMString(encoding);
			readOperation(this, blob, "Text", encoding);
		}
		readAsDataURL(blob) {
			webidl.brandCheck(this, FileReader);
			webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
			blob = webidl.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "DataURL");
		}
		abort() {
			if (this[kState] === "empty" || this[kState] === "done") {
				this[kResult] = null;
				return;
			}
			if (this[kState] === "loading") {
				this[kState] = "done";
				this[kResult] = null;
			}
			this[kAborted] = true;
			fireAProgressEvent("abort", this);
			if (this[kState] !== "loading") fireAProgressEvent("loadend", this);
		}
		get readyState() {
			webidl.brandCheck(this, FileReader);
			switch (this[kState]) {
				case "empty": return this.EMPTY;
				case "loading": return this.LOADING;
				case "done": return this.DONE;
			}
		}
		get result() {
			webidl.brandCheck(this, FileReader);
			return this[kResult];
		}
		get error() {
			webidl.brandCheck(this, FileReader);
			return this[kError];
		}
		get onloadend() {
			webidl.brandCheck(this, FileReader);
			return this[kEvents].loadend;
		}
		set onloadend(fn) {
			webidl.brandCheck(this, FileReader);
			if (this[kEvents].loadend) this.removeEventListener("loadend", this[kEvents].loadend);
			if (typeof fn === "function") {
				this[kEvents].loadend = fn;
				this.addEventListener("loadend", fn);
			} else this[kEvents].loadend = null;
		}
		get onerror() {
			webidl.brandCheck(this, FileReader);
			return this[kEvents].error;
		}
		set onerror(fn) {
			webidl.brandCheck(this, FileReader);
			if (this[kEvents].error) this.removeEventListener("error", this[kEvents].error);
			if (typeof fn === "function") {
				this[kEvents].error = fn;
				this.addEventListener("error", fn);
			} else this[kEvents].error = null;
		}
		get onloadstart() {
			webidl.brandCheck(this, FileReader);
			return this[kEvents].loadstart;
		}
		set onloadstart(fn) {
			webidl.brandCheck(this, FileReader);
			if (this[kEvents].loadstart) this.removeEventListener("loadstart", this[kEvents].loadstart);
			if (typeof fn === "function") {
				this[kEvents].loadstart = fn;
				this.addEventListener("loadstart", fn);
			} else this[kEvents].loadstart = null;
		}
		get onprogress() {
			webidl.brandCheck(this, FileReader);
			return this[kEvents].progress;
		}
		set onprogress(fn) {
			webidl.brandCheck(this, FileReader);
			if (this[kEvents].progress) this.removeEventListener("progress", this[kEvents].progress);
			if (typeof fn === "function") {
				this[kEvents].progress = fn;
				this.addEventListener("progress", fn);
			} else this[kEvents].progress = null;
		}
		get onload() {
			webidl.brandCheck(this, FileReader);
			return this[kEvents].load;
		}
		set onload(fn) {
			webidl.brandCheck(this, FileReader);
			if (this[kEvents].load) this.removeEventListener("load", this[kEvents].load);
			if (typeof fn === "function") {
				this[kEvents].load = fn;
				this.addEventListener("load", fn);
			} else this[kEvents].load = null;
		}
		get onabort() {
			webidl.brandCheck(this, FileReader);
			return this[kEvents].abort;
		}
		set onabort(fn) {
			webidl.brandCheck(this, FileReader);
			if (this[kEvents].abort) this.removeEventListener("abort", this[kEvents].abort);
			if (typeof fn === "function") {
				this[kEvents].abort = fn;
				this.addEventListener("abort", fn);
			} else this[kEvents].abort = null;
		}
	};
	FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
	FileReader.LOADING = FileReader.prototype.LOADING = 1;
	FileReader.DONE = FileReader.prototype.DONE = 2;
	Object.defineProperties(FileReader.prototype, {
		EMPTY: staticPropertyDescriptors,
		LOADING: staticPropertyDescriptors,
		DONE: staticPropertyDescriptors,
		readAsArrayBuffer: kEnumerableProperty,
		readAsBinaryString: kEnumerableProperty,
		readAsText: kEnumerableProperty,
		readAsDataURL: kEnumerableProperty,
		abort: kEnumerableProperty,
		readyState: kEnumerableProperty,
		result: kEnumerableProperty,
		error: kEnumerableProperty,
		onloadstart: kEnumerableProperty,
		onprogress: kEnumerableProperty,
		onload: kEnumerableProperty,
		onabort: kEnumerableProperty,
		onerror: kEnumerableProperty,
		onloadend: kEnumerableProperty,
		[Symbol.toStringTag]: {
			value: "FileReader",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(FileReader, {
		EMPTY: staticPropertyDescriptors,
		LOADING: staticPropertyDescriptors,
		DONE: staticPropertyDescriptors
	});
	module.exports = { FileReader };
}));
var require_symbols$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = { kConstruct: require_symbols$4().kConstruct };
}));
var require_util$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assert$2 = __require("assert");
	var { URLSerializer } = require_dataURL();
	var { isValidHeaderName } = require_util$5();
	function urlEquals(A, B, excludeFragment = false) {
		return URLSerializer(A, excludeFragment) === URLSerializer(B, excludeFragment);
	}
	function fieldValues(header) {
		assert$2(header !== null);
		const values$6 = [];
		for (let value$2 of header.split(",")) {
			value$2 = value$2.trim();
			if (!value$2.length) continue;
			else if (!isValidHeaderName(value$2)) continue;
			values$6.push(value$2);
		}
		return values$6;
	}
	module.exports = {
		urlEquals,
		fieldValues
	};
}));
var require_cache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { kConstruct } = require_symbols$1();
	var { urlEquals, fieldValues: getFieldValues } = require_util$2();
	var { kEnumerableProperty, isDisturbed } = require_util$6();
	var { kHeadersList } = require_symbols$4();
	var { webidl } = require_webidl();
	var { Response, cloneResponse } = require_response();
	var { Request } = require_request();
	var { kState, kHeaders, kGuard, kRealm } = require_symbols$3();
	var { fetching } = require_fetch();
	var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util$5();
	var assert$1 = __require("assert");
	var { getGlobalDispatcher } = require_global();
	var Cache = class Cache {
		#relevantRequestResponseList;
		constructor() {
			if (arguments[0] !== kConstruct) webidl.illegalConstructor();
			this.#relevantRequestResponseList = arguments[1];
		}
		async match(request$1, options = {}) {
			webidl.brandCheck(this, Cache);
			webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
			request$1 = webidl.converters.RequestInfo(request$1);
			options = webidl.converters.CacheQueryOptions(options);
			const p = await this.matchAll(request$1, options);
			if (p.length === 0) return;
			return p[0];
		}
		async matchAll(request$1 = void 0, options = {}) {
			webidl.brandCheck(this, Cache);
			if (request$1 !== void 0) request$1 = webidl.converters.RequestInfo(request$1);
			options = webidl.converters.CacheQueryOptions(options);
			let r = null;
			if (request$1 !== void 0) {
				if (request$1 instanceof Request) {
					r = request$1[kState];
					if (r.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$1 === "string") r = new Request(request$1)[kState];
			}
			const responses = [];
			if (request$1 === void 0) for (const requestResponse of this.#relevantRequestResponseList) responses.push(requestResponse[1]);
			else {
				const requestResponses = this.#queryCache(r, options);
				for (const requestResponse of requestResponses) responses.push(requestResponse[1]);
			}
			const responseList = [];
			for (const response of responses) {
				const responseObject = new Response(response.body?.source ?? null);
				const body = responseObject[kState].body;
				responseObject[kState] = response;
				responseObject[kState].body = body;
				responseObject[kHeaders][kHeadersList] = response.headersList;
				responseObject[kHeaders][kGuard] = "immutable";
				responseList.push(responseObject);
			}
			return Object.freeze(responseList);
		}
		async add(request$1) {
			webidl.brandCheck(this, Cache);
			webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
			request$1 = webidl.converters.RequestInfo(request$1);
			const requests = [request$1];
			return await this.addAll(requests);
		}
		async addAll(requests) {
			webidl.brandCheck(this, Cache);
			webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
			requests = webidl.converters["sequence<RequestInfo>"](requests);
			const responsePromises = [];
			const requestList = [];
			for (const request$1 of requests) {
				if (typeof request$1 === "string") continue;
				const r = request$1[kState];
				if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") throw webidl.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme when method is not GET."
				});
			}
			const fetchControllers = [];
			for (const request$1 of requests) {
				const r = new Request(request$1)[kState];
				if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme."
				});
				r.initiator = "fetch";
				r.destination = "subresource";
				requestList.push(r);
				const responsePromise = createDeferredPromise();
				fetchControllers.push(fetching({
					request: r,
					dispatcher: getGlobalDispatcher(),
					processResponse(response) {
						if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) responsePromise.reject(webidl.errors.exception({
							header: "Cache.addAll",
							message: "Received an invalid status code or the request failed."
						}));
						else if (response.headersList.contains("vary")) {
							const fieldValues = getFieldValues(response.headersList.get("vary"));
							for (const fieldValue of fieldValues) if (fieldValue === "*") {
								responsePromise.reject(webidl.errors.exception({
									header: "Cache.addAll",
									message: "invalid vary field value"
								}));
								for (const controller of fetchControllers) controller.abort();
								return;
							}
						}
					},
					processResponseEndOfBody(response) {
						if (response.aborted) {
							responsePromise.reject(new DOMException("aborted", "AbortError"));
							return;
						}
						responsePromise.resolve(response);
					}
				}));
				responsePromises.push(responsePromise.promise);
			}
			const responses = await Promise.all(responsePromises);
			const operations = [];
			let index = 0;
			for (const response of responses) {
				const operation = {
					type: "put",
					request: requestList[index],
					response
				};
				operations.push(operation);
				index++;
			}
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(void 0);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async put(request$1, response) {
			webidl.brandCheck(this, Cache);
			webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
			request$1 = webidl.converters.RequestInfo(request$1);
			response = webidl.converters.Response(response);
			let innerRequest = null;
			if (request$1 instanceof Request) innerRequest = request$1[kState];
			else innerRequest = new Request(request$1)[kState];
			if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") throw webidl.errors.exception({
				header: "Cache.put",
				message: "Expected an http/s scheme when method is not GET"
			});
			const innerResponse = response[kState];
			if (innerResponse.status === 206) throw webidl.errors.exception({
				header: "Cache.put",
				message: "Got 206 status"
			});
			if (innerResponse.headersList.contains("vary")) {
				const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
				for (const fieldValue of fieldValues) if (fieldValue === "*") throw webidl.errors.exception({
					header: "Cache.put",
					message: "Got * vary field value"
				});
			}
			if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl.errors.exception({
				header: "Cache.put",
				message: "Response body is locked or disturbed"
			});
			const clonedResponse = cloneResponse(innerResponse);
			const bodyReadPromise = createDeferredPromise();
			if (innerResponse.body != null) readAllBytes(innerResponse.body.stream.getReader()).then(bodyReadPromise.resolve, bodyReadPromise.reject);
			else bodyReadPromise.resolve(void 0);
			const operations = [];
			const operation = {
				type: "put",
				request: innerRequest,
				response: clonedResponse
			};
			operations.push(operation);
			const bytes = await bodyReadPromise.promise;
			if (clonedResponse.body != null) clonedResponse.body.source = bytes;
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve();
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async delete(request$1, options = {}) {
			webidl.brandCheck(this, Cache);
			webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
			request$1 = webidl.converters.RequestInfo(request$1);
			options = webidl.converters.CacheQueryOptions(options);
			let r = null;
			if (request$1 instanceof Request) {
				r = request$1[kState];
				if (r.method !== "GET" && !options.ignoreMethod) return false;
			} else {
				assert$1(typeof request$1 === "string");
				r = new Request(request$1)[kState];
			}
			const operations = [];
			const operation = {
				type: "delete",
				request: r,
				options
			};
			operations.push(operation);
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			let requestResponses;
			try {
				requestResponses = this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(!!requestResponses?.length);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async keys(request$1 = void 0, options = {}) {
			webidl.brandCheck(this, Cache);
			if (request$1 !== void 0) request$1 = webidl.converters.RequestInfo(request$1);
			options = webidl.converters.CacheQueryOptions(options);
			let r = null;
			if (request$1 !== void 0) {
				if (request$1 instanceof Request) {
					r = request$1[kState];
					if (r.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$1 === "string") r = new Request(request$1)[kState];
			}
			const promise$2 = createDeferredPromise();
			const requests = [];
			if (request$1 === void 0) for (const requestResponse of this.#relevantRequestResponseList) requests.push(requestResponse[0]);
			else {
				const requestResponses = this.#queryCache(r, options);
				for (const requestResponse of requestResponses) requests.push(requestResponse[0]);
			}
			queueMicrotask(() => {
				const requestList = [];
				for (const request$2 of requests) {
					const requestObject = new Request("https://a");
					requestObject[kState] = request$2;
					requestObject[kHeaders][kHeadersList] = request$2.headersList;
					requestObject[kHeaders][kGuard] = "immutable";
					requestObject[kRealm] = request$2.client;
					requestList.push(requestObject);
				}
				promise$2.resolve(Object.freeze(requestList));
			});
			return promise$2.promise;
		}
		#batchCacheOperations(operations) {
			const cache = this.#relevantRequestResponseList;
			const backupCache = [...cache];
			const addedItems = [];
			const resultList = [];
			try {
				for (const operation of operations) {
					if (operation.type !== "delete" && operation.type !== "put") throw webidl.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "operation type does not match \"delete\" or \"put\""
					});
					if (operation.type === "delete" && operation.response != null) throw webidl.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "delete operation should not have an associated response"
					});
					if (this.#queryCache(operation.request, operation.options, addedItems).length) throw new DOMException("???", "InvalidStateError");
					let requestResponses;
					if (operation.type === "delete") {
						requestResponses = this.#queryCache(operation.request, operation.options);
						if (requestResponses.length === 0) return [];
						for (const requestResponse of requestResponses) {
							const idx = cache.indexOf(requestResponse);
							assert$1(idx !== -1);
							cache.splice(idx, 1);
						}
					} else if (operation.type === "put") {
						if (operation.response == null) throw webidl.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "put operation should have an associated response"
						});
						const r = operation.request;
						if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "expected http or https scheme"
						});
						if (r.method !== "GET") throw webidl.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "not get method"
						});
						if (operation.options != null) throw webidl.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "options must not be defined"
						});
						requestResponses = this.#queryCache(operation.request);
						for (const requestResponse of requestResponses) {
							const idx = cache.indexOf(requestResponse);
							assert$1(idx !== -1);
							cache.splice(idx, 1);
						}
						cache.push([operation.request, operation.response]);
						addedItems.push([operation.request, operation.response]);
					}
					resultList.push([operation.request, operation.response]);
				}
				return resultList;
			} catch (e) {
				this.#relevantRequestResponseList.length = 0;
				this.#relevantRequestResponseList = backupCache;
				throw e;
			}
		}
		#queryCache(requestQuery, options, targetStorage) {
			const resultList = [];
			const storage = targetStorage ?? this.#relevantRequestResponseList;
			for (const requestResponse of storage) {
				const [cachedRequest, cachedResponse] = requestResponse;
				if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);
			}
			return resultList;
		}
		#requestMatchesCachedItem(requestQuery, request$1, response = null, options) {
			const queryURL = new URL(requestQuery.url);
			const cachedURL = new URL(request$1.url);
			if (options?.ignoreSearch) {
				cachedURL.search = "";
				queryURL.search = "";
			}
			if (!urlEquals(queryURL, cachedURL, true)) return false;
			if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) return true;
			const fieldValues = getFieldValues(response.headersList.get("vary"));
			for (const fieldValue of fieldValues) {
				if (fieldValue === "*") return false;
				if (request$1.headersList.get(fieldValue) !== requestQuery.headersList.get(fieldValue)) return false;
			}
			return true;
		}
	};
	Object.defineProperties(Cache.prototype, {
		[Symbol.toStringTag]: {
			value: "Cache",
			configurable: true
		},
		match: kEnumerableProperty,
		matchAll: kEnumerableProperty,
		add: kEnumerableProperty,
		addAll: kEnumerableProperty,
		put: kEnumerableProperty,
		delete: kEnumerableProperty,
		keys: kEnumerableProperty
	});
	var cacheQueryOptionConverters = [
		{
			key: "ignoreSearch",
			converter: webidl.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreMethod",
			converter: webidl.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreVary",
			converter: webidl.converters.boolean,
			defaultValue: false
		}
	];
	webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
	webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([...cacheQueryOptionConverters, {
		key: "cacheName",
		converter: webidl.converters.DOMString
	}]);
	webidl.converters.Response = webidl.interfaceConverter(Response);
	webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
	module.exports = { Cache };
}));
var require_cachestorage = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { kConstruct } = require_symbols$1();
	var { Cache } = require_cache();
	var { webidl } = require_webidl();
	var { kEnumerableProperty } = require_util$6();
	var CacheStorage = class CacheStorage {
		#caches = /* @__PURE__ */ new Map();
		constructor() {
			if (arguments[0] !== kConstruct) webidl.illegalConstructor();
		}
		async match(request$1, options = {}) {
			webidl.brandCheck(this, CacheStorage);
			webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
			request$1 = webidl.converters.RequestInfo(request$1);
			options = webidl.converters.MultiCacheQueryOptions(options);
			if (options.cacheName != null) {
				if (this.#caches.has(options.cacheName)) return await new Cache(kConstruct, this.#caches.get(options.cacheName)).match(request$1, options);
			} else for (const cacheList of this.#caches.values()) {
				const response = await new Cache(kConstruct, cacheList).match(request$1, options);
				if (response !== void 0) return response;
			}
		}
		async has(cacheName) {
			webidl.brandCheck(this, CacheStorage);
			webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
			cacheName = webidl.converters.DOMString(cacheName);
			return this.#caches.has(cacheName);
		}
		async open(cacheName) {
			webidl.brandCheck(this, CacheStorage);
			webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
			cacheName = webidl.converters.DOMString(cacheName);
			if (this.#caches.has(cacheName)) return new Cache(kConstruct, this.#caches.get(cacheName));
			const cache = [];
			this.#caches.set(cacheName, cache);
			return new Cache(kConstruct, cache);
		}
		async delete(cacheName) {
			webidl.brandCheck(this, CacheStorage);
			webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
			cacheName = webidl.converters.DOMString(cacheName);
			return this.#caches.delete(cacheName);
		}
		async keys() {
			webidl.brandCheck(this, CacheStorage);
			return [...this.#caches.keys()];
		}
	};
	Object.defineProperties(CacheStorage.prototype, {
		[Symbol.toStringTag]: {
			value: "CacheStorage",
			configurable: true
		},
		match: kEnumerableProperty,
		has: kEnumerableProperty,
		open: kEnumerableProperty,
		delete: kEnumerableProperty,
		keys: kEnumerableProperty
	});
	module.exports = { CacheStorage };
}));
var require_constants$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		maxAttributeValueSize: 1024,
		maxNameValuePairSize: 4096
	};
}));
var require_util$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isCTLExcludingHtab(value$2) {
		if (value$2.length === 0) return false;
		for (const char of value$2) {
			const code = char.charCodeAt(0);
			if (code >= 0 || code <= 8 || code >= 10 || code <= 31 || code === 127) return false;
		}
	}
	function validateCookieName(name) {
		for (const char of name) {
			const code = char.charCodeAt(0);
			if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") throw new Error("Invalid cookie name");
		}
	}
	function validateCookieValue(value$2) {
		for (const char of value$2) {
			const code = char.charCodeAt(0);
			if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126) throw new Error("Invalid header value");
		}
	}
	function validateCookiePath(path$5) {
		for (const char of path$5) if (char.charCodeAt(0) < 33 || char === ";") throw new Error("Invalid cookie path");
	}
	function validateCookieDomain(domain) {
		if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) throw new Error("Invalid cookie domain");
	}
	function toIMFDate(date$2) {
		if (typeof date$2 === "number") date$2 = new Date(date$2);
		return `${[
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		][date$2.getUTCDay()]}, ${date$2.getUTCDate().toString().padStart(2, "0")} ${[
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		][date$2.getUTCMonth()]} ${date$2.getUTCFullYear()} ${date$2.getUTCHours().toString().padStart(2, "0")}:${date$2.getUTCMinutes().toString().padStart(2, "0")}:${date$2.getUTCSeconds().toString().padStart(2, "0")} GMT`;
	}
	function validateCookieMaxAge(maxAge) {
		if (maxAge < 0) throw new Error("Invalid cookie max-age");
	}
	function stringify(cookie) {
		if (cookie.name.length === 0) return null;
		validateCookieName(cookie.name);
		validateCookieValue(cookie.value);
		const out = [`${cookie.name}=${cookie.value}`];
		if (cookie.name.startsWith("__Secure-")) cookie.secure = true;
		if (cookie.name.startsWith("__Host-")) {
			cookie.secure = true;
			cookie.domain = null;
			cookie.path = "/";
		}
		if (cookie.secure) out.push("Secure");
		if (cookie.httpOnly) out.push("HttpOnly");
		if (typeof cookie.maxAge === "number") {
			validateCookieMaxAge(cookie.maxAge);
			out.push(`Max-Age=${cookie.maxAge}`);
		}
		if (cookie.domain) {
			validateCookieDomain(cookie.domain);
			out.push(`Domain=${cookie.domain}`);
		}
		if (cookie.path) {
			validateCookiePath(cookie.path);
			out.push(`Path=${cookie.path}`);
		}
		if (cookie.expires && cookie.expires.toString() !== "Invalid Date") out.push(`Expires=${toIMFDate(cookie.expires)}`);
		if (cookie.sameSite) out.push(`SameSite=${cookie.sameSite}`);
		for (const part of cookie.unparsed) {
			if (!part.includes("=")) throw new Error("Invalid unparsed");
			const [key, ...value$2] = part.split("=");
			out.push(`${key.trim()}=${value$2.join("=")}`);
		}
		return out.join("; ");
	}
	module.exports = {
		isCTLExcludingHtab,
		validateCookieName,
		validateCookiePath,
		validateCookieValue,
		toIMFDate,
		stringify
	};
}));
var require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { maxNameValuePairSize, maxAttributeValueSize } = require_constants$1();
	var { isCTLExcludingHtab } = require_util$1();
	var { collectASequenceOfCodePointsFast } = require_dataURL();
	var assert = __require("assert");
	function parseSetCookie(header) {
		if (isCTLExcludingHtab(header)) return null;
		let nameValuePair = "";
		let unparsedAttributes = "";
		let name = "";
		let value$2 = "";
		if (header.includes(";")) {
			const position = { position: 0 };
			nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
			unparsedAttributes = header.slice(position.position);
		} else nameValuePair = header;
		if (!nameValuePair.includes("=")) value$2 = nameValuePair;
		else {
			const position = { position: 0 };
			name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
			value$2 = nameValuePair.slice(position.position + 1);
		}
		name = name.trim();
		value$2 = value$2.trim();
		if (name.length + value$2.length > maxNameValuePairSize) return null;
		return {
			name,
			value: value$2,
			...parseUnparsedAttributes(unparsedAttributes)
		};
	}
	function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
		if (unparsedAttributes.length === 0) return cookieAttributeList;
		assert(unparsedAttributes[0] === ";");
		unparsedAttributes = unparsedAttributes.slice(1);
		let cookieAv = "";
		if (unparsedAttributes.includes(";")) {
			cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
			unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
		} else {
			cookieAv = unparsedAttributes;
			unparsedAttributes = "";
		}
		let attributeName = "";
		let attributeValue = "";
		if (cookieAv.includes("=")) {
			const position = { position: 0 };
			attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
			attributeValue = cookieAv.slice(position.position + 1);
		} else attributeName = cookieAv;
		attributeName = attributeName.trim();
		attributeValue = attributeValue.trim();
		if (attributeValue.length > maxAttributeValueSize) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
		const attributeNameLowercase = attributeName.toLowerCase();
		if (attributeNameLowercase === "expires") cookieAttributeList.expires = new Date(attributeValue);
		else if (attributeNameLowercase === "max-age") {
			const charCode = attributeValue.charCodeAt(0);
			if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			if (!/^\d+$/.test(attributeValue)) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			cookieAttributeList.maxAge = Number(attributeValue);
		} else if (attributeNameLowercase === "domain") {
			let cookieDomain = attributeValue;
			if (cookieDomain[0] === ".") cookieDomain = cookieDomain.slice(1);
			cookieDomain = cookieDomain.toLowerCase();
			cookieAttributeList.domain = cookieDomain;
		} else if (attributeNameLowercase === "path") {
			let cookiePath = "";
			if (attributeValue.length === 0 || attributeValue[0] !== "/") cookiePath = "/";
			else cookiePath = attributeValue;
			cookieAttributeList.path = cookiePath;
		} else if (attributeNameLowercase === "secure") cookieAttributeList.secure = true;
		else if (attributeNameLowercase === "httponly") cookieAttributeList.httpOnly = true;
		else if (attributeNameLowercase === "samesite") {
			let enforcement = "Default";
			const attributeValueLowercase = attributeValue.toLowerCase();
			if (attributeValueLowercase.includes("none")) enforcement = "None";
			if (attributeValueLowercase.includes("strict")) enforcement = "Strict";
			if (attributeValueLowercase.includes("lax")) enforcement = "Lax";
			cookieAttributeList.sameSite = enforcement;
		} else {
			cookieAttributeList.unparsed ??= [];
			cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
		}
		return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
	}
	module.exports = {
		parseSetCookie,
		parseUnparsedAttributes
	};
}));
var require_cookies = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { parseSetCookie } = require_parse();
	var { stringify } = require_util$1();
	var { webidl } = require_webidl();
	var { Headers } = require_headers();
	function getCookies(headers) {
		webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
		webidl.brandCheck(headers, Headers, { strict: false });
		const cookie = headers.get("cookie");
		const out = {};
		if (!cookie) return out;
		for (const piece of cookie.split(";")) {
			const [name, ...value$2] = piece.split("=");
			out[name.trim()] = value$2.join("=");
		}
		return out;
	}
	function deleteCookie(headers, name, attributes) {
		webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
		webidl.brandCheck(headers, Headers, { strict: false });
		name = webidl.converters.DOMString(name);
		attributes = webidl.converters.DeleteCookieAttributes(attributes);
		setCookie(headers, {
			name,
			value: "",
			expires: /* @__PURE__ */ new Date(0),
			...attributes
		});
	}
	function getSetCookies(headers) {
		webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
		webidl.brandCheck(headers, Headers, { strict: false });
		const cookies = headers.getSetCookie();
		if (!cookies) return [];
		return cookies.map((pair) => parseSetCookie(pair));
	}
	function setCookie(headers, cookie) {
		webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
		webidl.brandCheck(headers, Headers, { strict: false });
		cookie = webidl.converters.Cookie(cookie);
		if (stringify(cookie)) headers.append("Set-Cookie", stringify(cookie));
	}
	webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([{
		converter: webidl.nullableConverter(webidl.converters.DOMString),
		key: "path",
		defaultValue: null
	}, {
		converter: webidl.nullableConverter(webidl.converters.DOMString),
		key: "domain",
		defaultValue: null
	}]);
	webidl.converters.Cookie = webidl.dictionaryConverter([
		{
			converter: webidl.converters.DOMString,
			key: "name"
		},
		{
			converter: webidl.converters.DOMString,
			key: "value"
		},
		{
			converter: webidl.nullableConverter((value$2) => {
				if (typeof value$2 === "number") return webidl.converters["unsigned long long"](value$2);
				return new Date(value$2);
			}),
			key: "expires",
			defaultValue: null
		},
		{
			converter: webidl.nullableConverter(webidl.converters["long long"]),
			key: "maxAge",
			defaultValue: null
		},
		{
			converter: webidl.nullableConverter(webidl.converters.DOMString),
			key: "domain",
			defaultValue: null
		},
		{
			converter: webidl.nullableConverter(webidl.converters.DOMString),
			key: "path",
			defaultValue: null
		},
		{
			converter: webidl.nullableConverter(webidl.converters.boolean),
			key: "secure",
			defaultValue: null
		},
		{
			converter: webidl.nullableConverter(webidl.converters.boolean),
			key: "httpOnly",
			defaultValue: null
		},
		{
			converter: webidl.converters.USVString,
			key: "sameSite",
			allowedValues: [
				"Strict",
				"Lax",
				"None"
			]
		},
		{
			converter: webidl.sequenceConverter(webidl.converters.DOMString),
			key: "unparsed",
			defaultValue: []
		}
	]);
	module.exports = {
		getCookies,
		deleteCookie,
		getSetCookies,
		setCookie
	};
}));
var require_constants = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		uid: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		staticPropertyDescriptors: {
			enumerable: true,
			writable: false,
			configurable: false
		},
		states: {
			CONNECTING: 0,
			OPEN: 1,
			CLOSING: 2,
			CLOSED: 3
		},
		opcodes: {
			CONTINUATION: 0,
			TEXT: 1,
			BINARY: 2,
			CLOSE: 8,
			PING: 9,
			PONG: 10
		},
		maxUnsigned16Bit: 2 ** 16 - 1,
		parserStates: {
			INFO: 0,
			PAYLOADLENGTH_16: 2,
			PAYLOADLENGTH_64: 3,
			READ_DATA: 4
		},
		emptyBuffer: Buffer.allocUnsafe(0)
	};
}));
var require_symbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kWebSocketURL: Symbol("url"),
		kReadyState: Symbol("ready state"),
		kController: Symbol("controller"),
		kResponse: Symbol("response"),
		kBinaryType: Symbol("binary type"),
		kSentClose: Symbol("sent close"),
		kReceivedClose: Symbol("received close"),
		kByteParser: Symbol("byte parser")
	};
}));
var require_events = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { webidl } = require_webidl();
	var { kEnumerableProperty } = require_util$6();
	var { MessagePort } = __require("worker_threads");
	var MessageEvent = class MessageEvent extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
			type = webidl.converters.DOMString(type);
			eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get data() {
			webidl.brandCheck(this, MessageEvent);
			return this.#eventInit.data;
		}
		get origin() {
			webidl.brandCheck(this, MessageEvent);
			return this.#eventInit.origin;
		}
		get lastEventId() {
			webidl.brandCheck(this, MessageEvent);
			return this.#eventInit.lastEventId;
		}
		get source() {
			webidl.brandCheck(this, MessageEvent);
			return this.#eventInit.source;
		}
		get ports() {
			webidl.brandCheck(this, MessageEvent);
			if (!Object.isFrozen(this.#eventInit.ports)) Object.freeze(this.#eventInit.ports);
			return this.#eventInit.ports;
		}
		initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
			webidl.brandCheck(this, MessageEvent);
			webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
			return new MessageEvent(type, {
				bubbles,
				cancelable,
				data,
				origin,
				lastEventId,
				source,
				ports
			});
		}
	};
	var CloseEvent = class CloseEvent extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
			type = webidl.converters.DOMString(type);
			eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get wasClean() {
			webidl.brandCheck(this, CloseEvent);
			return this.#eventInit.wasClean;
		}
		get code() {
			webidl.brandCheck(this, CloseEvent);
			return this.#eventInit.code;
		}
		get reason() {
			webidl.brandCheck(this, CloseEvent);
			return this.#eventInit.reason;
		}
	};
	var ErrorEvent = class ErrorEvent extends Event {
		#eventInit;
		constructor(type, eventInitDict) {
			webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
			super(type, eventInitDict);
			type = webidl.converters.DOMString(type);
			eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
			this.#eventInit = eventInitDict;
		}
		get message() {
			webidl.brandCheck(this, ErrorEvent);
			return this.#eventInit.message;
		}
		get filename() {
			webidl.brandCheck(this, ErrorEvent);
			return this.#eventInit.filename;
		}
		get lineno() {
			webidl.brandCheck(this, ErrorEvent);
			return this.#eventInit.lineno;
		}
		get colno() {
			webidl.brandCheck(this, ErrorEvent);
			return this.#eventInit.colno;
		}
		get error() {
			webidl.brandCheck(this, ErrorEvent);
			return this.#eventInit.error;
		}
	};
	Object.defineProperties(MessageEvent.prototype, {
		[Symbol.toStringTag]: {
			value: "MessageEvent",
			configurable: true
		},
		data: kEnumerableProperty,
		origin: kEnumerableProperty,
		lastEventId: kEnumerableProperty,
		source: kEnumerableProperty,
		ports: kEnumerableProperty,
		initMessageEvent: kEnumerableProperty
	});
	Object.defineProperties(CloseEvent.prototype, {
		[Symbol.toStringTag]: {
			value: "CloseEvent",
			configurable: true
		},
		reason: kEnumerableProperty,
		code: kEnumerableProperty,
		wasClean: kEnumerableProperty
	});
	Object.defineProperties(ErrorEvent.prototype, {
		[Symbol.toStringTag]: {
			value: "ErrorEvent",
			configurable: true
		},
		message: kEnumerableProperty,
		filename: kEnumerableProperty,
		lineno: kEnumerableProperty,
		colno: kEnumerableProperty,
		error: kEnumerableProperty
	});
	webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
	webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
	var eventInit = [
		{
			key: "bubbles",
			converter: webidl.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl.converters.boolean,
			defaultValue: false
		}
	];
	webidl.converters.MessageEventInit = webidl.dictionaryConverter([
		...eventInit,
		{
			key: "data",
			converter: webidl.converters.any,
			defaultValue: null
		},
		{
			key: "origin",
			converter: webidl.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lastEventId",
			converter: webidl.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "source",
			converter: webidl.nullableConverter(webidl.converters.MessagePort),
			defaultValue: null
		},
		{
			key: "ports",
			converter: webidl.converters["sequence<MessagePort>"],
			get defaultValue() {
				return [];
			}
		}
	]);
	webidl.converters.CloseEventInit = webidl.dictionaryConverter([
		...eventInit,
		{
			key: "wasClean",
			converter: webidl.converters.boolean,
			defaultValue: false
		},
		{
			key: "code",
			converter: webidl.converters["unsigned short"],
			defaultValue: 0
		},
		{
			key: "reason",
			converter: webidl.converters.USVString,
			defaultValue: ""
		}
	]);
	webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
		...eventInit,
		{
			key: "message",
			converter: webidl.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "filename",
			converter: webidl.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lineno",
			converter: webidl.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "colno",
			converter: webidl.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "error",
			converter: webidl.converters.any
		}
	]);
	module.exports = {
		MessageEvent,
		CloseEvent,
		ErrorEvent
	};
}));
var require_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols();
	var { states, opcodes } = require_constants();
	var { MessageEvent, ErrorEvent } = require_events();
	function isEstablished(ws) {
		return ws[kReadyState] === states.OPEN;
	}
	function isClosing(ws) {
		return ws[kReadyState] === states.CLOSING;
	}
	function isClosed(ws) {
		return ws[kReadyState] === states.CLOSED;
	}
	function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
		const event = new eventConstructor(e, eventInitDict);
		target.dispatchEvent(event);
	}
	function websocketMessageReceived(ws, type, data) {
		if (ws[kReadyState] !== states.OPEN) return;
		let dataForEvent;
		if (type === opcodes.TEXT) try {
			dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
		} catch {
			failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
			return;
		}
		else if (type === opcodes.BINARY) if (ws[kBinaryType] === "blob") dataForEvent = new Blob([data]);
		else dataForEvent = new Uint8Array(data).buffer;
		fireEvent("message", ws, MessageEvent, {
			origin: ws[kWebSocketURL].origin,
			data: dataForEvent
		});
	}
	function isValidSubprotocol(protocol) {
		if (protocol.length === 0) return false;
		for (const char of protocol) {
			const code = char.charCodeAt(0);
			if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9) return false;
		}
		return true;
	}
	function isValidStatusCode(code) {
		if (code >= 1e3 && code < 1015) return code !== 1004 && code !== 1005 && code !== 1006;
		return code >= 3e3 && code <= 4999;
	}
	function failWebsocketConnection(ws, reason) {
		const { [kController]: controller, [kResponse]: response } = ws;
		controller.abort();
		if (response?.socket && !response.socket.destroyed) response.socket.destroy();
		if (reason) fireEvent("error", ws, ErrorEvent, { error: new Error(reason) });
	}
	module.exports = {
		isEstablished,
		isClosing,
		isClosed,
		fireEvent,
		isValidSubprotocol,
		isValidStatusCode,
		failWebsocketConnection,
		websocketMessageReceived
	};
}));
var require_connection = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var diagnosticsChannel$1 = __require("diagnostics_channel");
	var { uid, states } = require_constants();
	var { kReadyState, kSentClose, kByteParser, kReceivedClose } = require_symbols();
	var { fireEvent, failWebsocketConnection } = require_util();
	var { CloseEvent } = require_events();
	var { makeRequest } = require_request();
	var { fetching } = require_fetch();
	var { Headers } = require_headers();
	var { getGlobalDispatcher } = require_global();
	var { kHeadersList } = require_symbols$4();
	var channels = {};
	channels.open = diagnosticsChannel$1.channel("undici:websocket:open");
	channels.close = diagnosticsChannel$1.channel("undici:websocket:close");
	channels.socketError = diagnosticsChannel$1.channel("undici:websocket:socket_error");
	var crypto;
	try {
		crypto = __require("crypto");
	} catch {}
	function establishWebSocketConnection(url$2, protocols, ws, onEstablish, options) {
		const requestURL = url$2;
		requestURL.protocol = url$2.protocol === "ws:" ? "http:" : "https:";
		const request$1 = makeRequest({
			urlList: [requestURL],
			serviceWorkers: "none",
			referrer: "no-referrer",
			mode: "websocket",
			credentials: "include",
			cache: "no-store",
			redirect: "error"
		});
		if (options.headers) request$1.headersList = new Headers(options.headers)[kHeadersList];
		const keyValue = crypto.randomBytes(16).toString("base64");
		request$1.headersList.append("sec-websocket-key", keyValue);
		request$1.headersList.append("sec-websocket-version", "13");
		for (const protocol of protocols) request$1.headersList.append("sec-websocket-protocol", protocol);
		const permessageDeflate = "";
		return fetching({
			request: request$1,
			useParallelQueue: true,
			dispatcher: options.dispatcher ?? getGlobalDispatcher(),
			processResponse(response) {
				if (response.type === "error" || response.status !== 101) {
					failWebsocketConnection(ws, "Received network error or non-101 status code.");
					return;
				}
				if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection(ws, "Server did not respond with sent protocols.");
					return;
				}
				if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
					failWebsocketConnection(ws, "Server did not set Upgrade header to \"websocket\".");
					return;
				}
				if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
					failWebsocketConnection(ws, "Server did not set Connection header to \"upgrade\".");
					return;
				}
				if (response.headersList.get("Sec-WebSocket-Accept") !== crypto.createHash("sha1").update(keyValue + uid).digest("base64")) {
					failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
					return;
				}
				const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
				if (secExtension !== null && secExtension !== permessageDeflate) {
					failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
					return;
				}
				const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
				if (secProtocol !== null && secProtocol !== request$1.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
					return;
				}
				response.socket.on("data", onSocketData);
				response.socket.on("close", onSocketClose);
				response.socket.on("error", onSocketError);
				if (channels.open.hasSubscribers) channels.open.publish({
					address: response.socket.address(),
					protocol: secProtocol,
					extensions: secExtension
				});
				onEstablish(response);
			}
		});
	}
	function onSocketData(chunk$4) {
		if (!this.ws[kByteParser].write(chunk$4)) this.pause();
	}
	function onSocketClose() {
		const { ws } = this;
		const wasClean = ws[kSentClose] && ws[kReceivedClose];
		let code = 1005;
		let reason = "";
		const result = ws[kByteParser].closingInfo;
		if (result) {
			code = result.code ?? 1005;
			reason = result.reason;
		} else if (!ws[kSentClose]) code = 1006;
		ws[kReadyState] = states.CLOSED;
		fireEvent("close", ws, CloseEvent, {
			wasClean,
			code,
			reason
		});
		if (channels.close.hasSubscribers) channels.close.publish({
			websocket: ws,
			code,
			reason
		});
	}
	function onSocketError(error) {
		const { ws } = this;
		ws[kReadyState] = states.CLOSING;
		if (channels.socketError.hasSubscribers) channels.socketError.publish(error);
		this.destroy();
	}
	module.exports = { establishWebSocketConnection };
}));
var require_frame = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { maxUnsigned16Bit } = require_constants();
	var crypto;
	try {
		crypto = __require("crypto");
	} catch {}
	var WebsocketFrameSend = class {
		constructor(data) {
			this.frameData = data;
			this.maskKey = crypto.randomBytes(4);
		}
		createFrame(opcode) {
			const bodyLength = this.frameData?.byteLength ?? 0;
			let payloadLength = bodyLength;
			let offset = 6;
			if (bodyLength > maxUnsigned16Bit) {
				offset += 8;
				payloadLength = 127;
			} else if (bodyLength > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const buffer = Buffer.allocUnsafe(bodyLength + offset);
			buffer[0] = buffer[1] = 0;
			buffer[0] |= 128;
			buffer[0] = (buffer[0] & 240) + opcode;
			buffer[offset - 4] = this.maskKey[0];
			buffer[offset - 3] = this.maskKey[1];
			buffer[offset - 2] = this.maskKey[2];
			buffer[offset - 1] = this.maskKey[3];
			buffer[1] = payloadLength;
			if (payloadLength === 126) buffer.writeUInt16BE(bodyLength, 2);
			else if (payloadLength === 127) {
				buffer[2] = buffer[3] = 0;
				buffer.writeUIntBE(bodyLength, 4, 6);
			}
			buffer[1] |= 128;
			for (let i = 0; i < bodyLength; i++) buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
			return buffer;
		}
	};
	module.exports = { WebsocketFrameSend };
}));
var require_receiver = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Writable } = __require("stream");
	var diagnosticsChannel = __require("diagnostics_channel");
	var { parserStates, opcodes, states, emptyBuffer } = require_constants();
	var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols();
	var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util();
	var { WebsocketFrameSend } = require_frame();
	var channels = {};
	channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
	channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
	var ByteParser = class extends Writable {
		#buffers = [];
		#byteOffset = 0;
		#state = parserStates.INFO;
		#info = {};
		#fragments = [];
		constructor(ws) {
			super();
			this.ws = ws;
		}
		_write(chunk$4, _, callback) {
			this.#buffers.push(chunk$4);
			this.#byteOffset += chunk$4.length;
			this.run(callback);
		}
		run(callback) {
			while (true) {
				if (this.#state === parserStates.INFO) {
					if (this.#byteOffset < 2) return callback();
					const buffer = this.consume(2);
					this.#info.fin = (buffer[0] & 128) !== 0;
					this.#info.opcode = buffer[0] & 15;
					this.#info.originalOpcode ??= this.#info.opcode;
					this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
					if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
						failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
						return;
					}
					const payloadLength = buffer[1] & 127;
					if (payloadLength <= 125) {
						this.#info.payloadLength = payloadLength;
						this.#state = parserStates.READ_DATA;
					} else if (payloadLength === 126) this.#state = parserStates.PAYLOADLENGTH_16;
					else if (payloadLength === 127) this.#state = parserStates.PAYLOADLENGTH_64;
					if (this.#info.fragmented && payloadLength > 125) {
						failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
						return;
					} else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
						failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
						return;
					} else if (this.#info.opcode === opcodes.CLOSE) {
						if (payloadLength === 1) {
							failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
							return;
						}
						const body = this.consume(payloadLength);
						this.#info.closeInfo = this.parseCloseBody(false, body);
						if (!this.ws[kSentClose]) {
							const body$1 = Buffer.allocUnsafe(2);
							body$1.writeUInt16BE(this.#info.closeInfo.code, 0);
							const closeFrame = new WebsocketFrameSend(body$1);
							this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
								if (!err) this.ws[kSentClose] = true;
							});
						}
						this.ws[kReadyState] = states.CLOSING;
						this.ws[kReceivedClose] = true;
						this.end();
						return;
					} else if (this.#info.opcode === opcodes.PING) {
						const body = this.consume(payloadLength);
						if (!this.ws[kReceivedClose]) {
							const frame = new WebsocketFrameSend(body);
							this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
							if (channels.ping.hasSubscribers) channels.ping.publish({ payload: body });
						}
						this.#state = parserStates.INFO;
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					} else if (this.#info.opcode === opcodes.PONG) {
						const body = this.consume(payloadLength);
						if (channels.pong.hasSubscribers) channels.pong.publish({ payload: body });
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					}
				} else if (this.#state === parserStates.PAYLOADLENGTH_16) {
					if (this.#byteOffset < 2) return callback();
					const buffer = this.consume(2);
					this.#info.payloadLength = buffer.readUInt16BE(0);
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.PAYLOADLENGTH_64) {
					if (this.#byteOffset < 8) return callback();
					const buffer = this.consume(8);
					const upper = buffer.readUInt32BE(0);
					if (upper > 2 ** 31 - 1) {
						failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
						return;
					}
					const lower = buffer.readUInt32BE(4);
					this.#info.payloadLength = (upper << 8) + lower;
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.READ_DATA) {
					if (this.#byteOffset < this.#info.payloadLength) return callback();
					else if (this.#byteOffset >= this.#info.payloadLength) {
						const body = this.consume(this.#info.payloadLength);
						this.#fragments.push(body);
						if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
							const fullMessage = Buffer.concat(this.#fragments);
							websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
							this.#info = {};
							this.#fragments.length = 0;
						}
						this.#state = parserStates.INFO;
					}
				}
				if (this.#byteOffset > 0) continue;
				else {
					callback();
					break;
				}
			}
		}
		consume(n) {
			if (n > this.#byteOffset) return null;
			else if (n === 0) return emptyBuffer;
			if (this.#buffers[0].length === n) {
				this.#byteOffset -= this.#buffers[0].length;
				return this.#buffers.shift();
			}
			const buffer = Buffer.allocUnsafe(n);
			let offset = 0;
			while (offset !== n) {
				const next = this.#buffers[0];
				const { length: length$1 } = next;
				if (length$1 + offset === n) {
					buffer.set(this.#buffers.shift(), offset);
					break;
				} else if (length$1 + offset > n) {
					buffer.set(next.subarray(0, n - offset), offset);
					this.#buffers[0] = next.subarray(n - offset);
					break;
				} else {
					buffer.set(this.#buffers.shift(), offset);
					offset += next.length;
				}
			}
			this.#byteOffset -= n;
			return buffer;
		}
		parseCloseBody(onlyCode, data) {
			let code;
			if (data.length >= 2) code = data.readUInt16BE(0);
			if (onlyCode) {
				if (!isValidStatusCode(code)) return null;
				return { code };
			}
			let reason = data.subarray(2);
			if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) reason = reason.subarray(3);
			if (code !== void 0 && !isValidStatusCode(code)) return null;
			try {
				reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
			} catch {
				return null;
			}
			return {
				code,
				reason
			};
		}
		get closingInfo() {
			return this.#info.closeInfo;
		}
	};
	module.exports = { ByteParser };
}));
var require_websocket = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { webidl } = require_webidl();
	var { DOMException } = require_constants$3();
	var { URLSerializer } = require_dataURL();
	var { getGlobalOrigin } = require_global$1();
	var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants();
	var { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = require_symbols();
	var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util();
	var { establishWebSocketConnection } = require_connection();
	var { WebsocketFrameSend } = require_frame();
	var { ByteParser } = require_receiver();
	var { kEnumerableProperty, isBlobLike } = require_util$6();
	var { getGlobalDispatcher } = require_global();
	var { types } = __require("util");
	var experimentalWarned = false;
	var WebSocket = class WebSocket extends EventTarget {
		#events = {
			open: null,
			error: null,
			close: null,
			message: null
		};
		#bufferedAmount = 0;
		#protocol = "";
		#extensions = "";
		constructor(url$2, protocols = []) {
			super();
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
			if (!experimentalWarned) {
				experimentalWarned = true;
				process.emitWarning("WebSockets are experimental, expect them to change at any time.", { code: "UNDICI-WS" });
			}
			const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
			url$2 = webidl.converters.USVString(url$2);
			protocols = options.protocols;
			const baseURL = getGlobalOrigin();
			let urlRecord;
			try {
				urlRecord = new URL(url$2, baseURL);
			} catch (e) {
				throw new DOMException(e, "SyntaxError");
			}
			if (urlRecord.protocol === "http:") urlRecord.protocol = "ws:";
			else if (urlRecord.protocol === "https:") urlRecord.protocol = "wss:";
			if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
			if (urlRecord.hash || urlRecord.href.endsWith("#")) throw new DOMException("Got fragment", "SyntaxError");
			if (typeof protocols === "string") protocols = [protocols];
			if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			this[kWebSocketURL] = new URL(urlRecord.href);
			this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options);
			this[kReadyState] = WebSocket.CONNECTING;
			this[kBinaryType] = "blob";
		}
		close(code = void 0, reason = void 0) {
			webidl.brandCheck(this, WebSocket);
			if (code !== void 0) code = webidl.converters["unsigned short"](code, { clamp: true });
			if (reason !== void 0) reason = webidl.converters.USVString(reason);
			if (code !== void 0) {
				if (code !== 1e3 && (code < 3e3 || code > 4999)) throw new DOMException("invalid code", "InvalidAccessError");
			}
			let reasonByteLength = 0;
			if (reason !== void 0) {
				reasonByteLength = Buffer.byteLength(reason);
				if (reasonByteLength > 123) throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
			}
			if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {} else if (!isEstablished(this)) {
				failWebsocketConnection(this, "Connection was closed before it was established.");
				this[kReadyState] = WebSocket.CLOSING;
			} else if (!isClosing(this)) {
				const frame = new WebsocketFrameSend();
				if (code !== void 0 && reason === void 0) {
					frame.frameData = Buffer.allocUnsafe(2);
					frame.frameData.writeUInt16BE(code, 0);
				} else if (code !== void 0 && reason !== void 0) {
					frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
					frame.frameData.writeUInt16BE(code, 0);
					frame.frameData.write(reason, 2, "utf-8");
				} else frame.frameData = emptyBuffer;
				this[kResponse].socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
					if (!err) this[kSentClose] = true;
				});
				this[kReadyState] = states.CLOSING;
			} else this[kReadyState] = WebSocket.CLOSING;
		}
		send(data) {
			webidl.brandCheck(this, WebSocket);
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
			data = webidl.converters.WebSocketSendData(data);
			if (this[kReadyState] === WebSocket.CONNECTING) throw new DOMException("Sent before connected.", "InvalidStateError");
			if (!isEstablished(this) || isClosing(this)) return;
			const socket = this[kResponse].socket;
			if (typeof data === "string") {
				const value$2 = Buffer.from(data);
				const buffer = new WebsocketFrameSend(value$2).createFrame(opcodes.TEXT);
				this.#bufferedAmount += value$2.byteLength;
				socket.write(buffer, () => {
					this.#bufferedAmount -= value$2.byteLength;
				});
			} else if (types.isArrayBuffer(data)) {
				const value$2 = Buffer.from(data);
				const buffer = new WebsocketFrameSend(value$2).createFrame(opcodes.BINARY);
				this.#bufferedAmount += value$2.byteLength;
				socket.write(buffer, () => {
					this.#bufferedAmount -= value$2.byteLength;
				});
			} else if (ArrayBuffer.isView(data)) {
				const ab = Buffer.from(data, data.byteOffset, data.byteLength);
				const buffer = new WebsocketFrameSend(ab).createFrame(opcodes.BINARY);
				this.#bufferedAmount += ab.byteLength;
				socket.write(buffer, () => {
					this.#bufferedAmount -= ab.byteLength;
				});
			} else if (isBlobLike(data)) {
				const frame = new WebsocketFrameSend();
				data.arrayBuffer().then((ab) => {
					const value$2 = Buffer.from(ab);
					frame.frameData = value$2;
					const buffer = frame.createFrame(opcodes.BINARY);
					this.#bufferedAmount += value$2.byteLength;
					socket.write(buffer, () => {
						this.#bufferedAmount -= value$2.byteLength;
					});
				});
			}
		}
		get readyState() {
			webidl.brandCheck(this, WebSocket);
			return this[kReadyState];
		}
		get bufferedAmount() {
			webidl.brandCheck(this, WebSocket);
			return this.#bufferedAmount;
		}
		get url() {
			webidl.brandCheck(this, WebSocket);
			return URLSerializer(this[kWebSocketURL]);
		}
		get extensions() {
			webidl.brandCheck(this, WebSocket);
			return this.#extensions;
		}
		get protocol() {
			webidl.brandCheck(this, WebSocket);
			return this.#protocol;
		}
		get onopen() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.open;
		}
		set onopen(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.open) this.removeEventListener("open", this.#events.open);
			if (typeof fn === "function") {
				this.#events.open = fn;
				this.addEventListener("open", fn);
			} else this.#events.open = null;
		}
		get onerror() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.error;
		}
		set onerror(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.error) this.removeEventListener("error", this.#events.error);
			if (typeof fn === "function") {
				this.#events.error = fn;
				this.addEventListener("error", fn);
			} else this.#events.error = null;
		}
		get onclose() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.close;
		}
		set onclose(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.close) this.removeEventListener("close", this.#events.close);
			if (typeof fn === "function") {
				this.#events.close = fn;
				this.addEventListener("close", fn);
			} else this.#events.close = null;
		}
		get onmessage() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.message;
		}
		set onmessage(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.message) this.removeEventListener("message", this.#events.message);
			if (typeof fn === "function") {
				this.#events.message = fn;
				this.addEventListener("message", fn);
			} else this.#events.message = null;
		}
		get binaryType() {
			webidl.brandCheck(this, WebSocket);
			return this[kBinaryType];
		}
		set binaryType(type) {
			webidl.brandCheck(this, WebSocket);
			if (type !== "blob" && type !== "arraybuffer") this[kBinaryType] = "blob";
			else this[kBinaryType] = type;
		}
		#onConnectionEstablished(response) {
			this[kResponse] = response;
			const parser = new ByteParser(this);
			parser.on("drain", function onParserDrain() {
				this.ws[kResponse].socket.resume();
			});
			response.socket.ws = this;
			this[kByteParser] = parser;
			this[kReadyState] = states.OPEN;
			const extensions = response.headersList.get("sec-websocket-extensions");
			if (extensions !== null) this.#extensions = extensions;
			const protocol = response.headersList.get("sec-websocket-protocol");
			if (protocol !== null) this.#protocol = protocol;
			fireEvent("open", this);
		}
	};
	WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
	WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
	WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
	WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
	Object.defineProperties(WebSocket.prototype, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors,
		url: kEnumerableProperty,
		readyState: kEnumerableProperty,
		bufferedAmount: kEnumerableProperty,
		onopen: kEnumerableProperty,
		onerror: kEnumerableProperty,
		onclose: kEnumerableProperty,
		close: kEnumerableProperty,
		onmessage: kEnumerableProperty,
		binaryType: kEnumerableProperty,
		send: kEnumerableProperty,
		extensions: kEnumerableProperty,
		protocol: kEnumerableProperty,
		[Symbol.toStringTag]: {
			value: "WebSocket",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(WebSocket, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors
	});
	webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
	webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
		if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) return webidl.converters["sequence<DOMString>"](V);
		return webidl.converters.DOMString(V);
	};
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
		{
			key: "protocols",
			converter: webidl.converters["DOMString or sequence<DOMString>"],
			get defaultValue() {
				return [];
			}
		},
		{
			key: "dispatcher",
			converter: (V) => V,
			get defaultValue() {
				return getGlobalDispatcher();
			}
		},
		{
			key: "headers",
			converter: webidl.nullableConverter(webidl.converters.HeadersInit)
		}
	]);
	webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
		if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) return webidl.converters.WebSocketInit(V);
		return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
	};
	webidl.converters.WebSocketSendData = function(V) {
		if (webidl.util.Type(V) === "Object") {
			if (isBlobLike(V)) return webidl.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) return webidl.converters.BufferSource(V);
		}
		return webidl.converters.USVString(V);
	};
	module.exports = { WebSocket };
}));
var require_undici = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Client = require_client();
	var Dispatcher = require_dispatcher();
	var errors = require_errors();
	var Pool = require_pool();
	var BalancedPool = require_balanced_pool();
	var Agent = require_agent();
	var util = require_util$6();
	var { InvalidArgumentError } = errors;
	var api = require_api();
	var buildConnector = require_connect();
	var MockClient = require_mock_client();
	var MockAgent = require_mock_agent();
	var MockPool = require_mock_pool();
	var mockErrors = require_mock_errors();
	var ProxyAgent = require_proxy_agent();
	var RetryHandler = require_RetryHandler();
	var { getGlobalDispatcher, setGlobalDispatcher } = require_global();
	var DecoratorHandler = require_DecoratorHandler();
	var RedirectHandler = require_RedirectHandler();
	var createRedirectInterceptor = require_redirectInterceptor();
	var hasCrypto;
	try {
		__require("crypto");
		hasCrypto = true;
	} catch {
		hasCrypto = false;
	}
	Object.assign(Dispatcher.prototype, api);
	module.exports.Dispatcher = Dispatcher;
	module.exports.Client = Client;
	module.exports.Pool = Pool;
	module.exports.BalancedPool = BalancedPool;
	module.exports.Agent = Agent;
	module.exports.ProxyAgent = ProxyAgent;
	module.exports.RetryHandler = RetryHandler;
	module.exports.DecoratorHandler = DecoratorHandler;
	module.exports.RedirectHandler = RedirectHandler;
	module.exports.createRedirectInterceptor = createRedirectInterceptor;
	module.exports.buildConnector = buildConnector;
	module.exports.errors = errors;
	function makeDispatcher(fn) {
		return (url$2, opts, handler) => {
			if (typeof opts === "function") {
				handler = opts;
				opts = null;
			}
			if (!url$2 || typeof url$2 !== "string" && typeof url$2 !== "object" && !(url$2 instanceof URL)) throw new InvalidArgumentError("invalid url");
			if (opts != null && typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			if (opts && opts.path != null) {
				if (typeof opts.path !== "string") throw new InvalidArgumentError("invalid opts.path");
				let path$5 = opts.path;
				if (!opts.path.startsWith("/")) path$5 = `/${path$5}`;
				url$2 = new URL(util.parseOrigin(url$2).origin + path$5);
			} else {
				if (!opts) opts = typeof url$2 === "object" ? url$2 : {};
				url$2 = util.parseURL(url$2);
			}
			const { agent, dispatcher = getGlobalDispatcher() } = opts;
			if (agent) throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
			return fn.call(dispatcher, {
				...opts,
				origin: url$2.origin,
				path: url$2.search ? `${url$2.pathname}${url$2.search}` : url$2.pathname,
				method: opts.method || (opts.body ? "PUT" : "GET")
			}, handler);
		};
	}
	module.exports.setGlobalDispatcher = setGlobalDispatcher;
	module.exports.getGlobalDispatcher = getGlobalDispatcher;
	if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
		let fetchImpl = null;
		module.exports.fetch = async function fetch(resource) {
			if (!fetchImpl) fetchImpl = require_fetch().fetch;
			try {
				return await fetchImpl(...arguments);
			} catch (err) {
				if (typeof err === "object") Error.captureStackTrace(err, this);
				throw err;
			}
		};
		module.exports.Headers = require_headers().Headers;
		module.exports.Response = require_response().Response;
		module.exports.Request = require_request().Request;
		module.exports.FormData = require_formdata().FormData;
		module.exports.File = require_file().File;
		module.exports.FileReader = require_filereader().FileReader;
		const { setGlobalOrigin, getGlobalOrigin } = require_global$1();
		module.exports.setGlobalOrigin = setGlobalOrigin;
		module.exports.getGlobalOrigin = getGlobalOrigin;
		const { CacheStorage } = require_cachestorage();
		const { kConstruct } = require_symbols$1();
		module.exports.caches = new CacheStorage(kConstruct);
	}
	if (util.nodeMajor >= 16) {
		const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
		module.exports.deleteCookie = deleteCookie;
		module.exports.getCookies = getCookies;
		module.exports.getSetCookies = getSetCookies;
		module.exports.setCookie = setCookie;
		const { parseMIMEType, serializeAMimeType } = require_dataURL();
		module.exports.parseMIMEType = parseMIMEType;
		module.exports.serializeAMimeType = serializeAMimeType;
	}
	if (util.nodeMajor >= 18 && hasCrypto) {
		const { WebSocket } = require_websocket();
		module.exports.WebSocket = WebSocket;
	}
	module.exports.request = makeDispatcher(api.request);
	module.exports.stream = makeDispatcher(api.stream);
	module.exports.pipeline = makeDispatcher(api.pipeline);
	module.exports.connect = makeDispatcher(api.connect);
	module.exports.upgrade = makeDispatcher(api.upgrade);
	module.exports.MockClient = MockClient;
	module.exports.MockPool = MockPool;
	module.exports.MockAgent = MockAgent;
	module.exports.mockErrors = mockErrors;
}));
var require_lib = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpClient = exports.HttpClientResponse = exports.HttpClientError = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
	exports.getProxyUrl = getProxyUrl;
	exports.isHttps = isHttps;
	var http = __importStar(__require("http"));
	var https = __importStar(__require("https"));
	var pm = __importStar(require_proxy());
	var tunnel = __importStar(require_tunnel());
	var undici_1 = require_undici();
	var HttpCodes;
	(function(HttpCodes) {
		HttpCodes[HttpCodes["OK"] = 200] = "OK";
		HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
		HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
		HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
		HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
		HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
		HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
		HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
		HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
		HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
		HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
		HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
		HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
		HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
		HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
		HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
		HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
		HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
		HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
		HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
		HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
		HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
		HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
		HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
		HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
		HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
		HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
	var Headers;
	(function(Headers) {
		Headers["Accept"] = "accept";
		Headers["ContentType"] = "content-type";
	})(Headers || (exports.Headers = Headers = {}));
	var MediaTypes;
	(function(MediaTypes) {
		MediaTypes["ApplicationJson"] = "application/json";
	})(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
	function getProxyUrl(serverUrl) {
		const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
		return proxyUrl ? proxyUrl.href : "";
	}
	var HttpRedirectCodes = [
		HttpCodes.MovedPermanently,
		HttpCodes.ResourceMoved,
		HttpCodes.SeeOther,
		HttpCodes.TemporaryRedirect,
		HttpCodes.PermanentRedirect
	];
	var HttpResponseRetryCodes = [
		HttpCodes.BadGateway,
		HttpCodes.ServiceUnavailable,
		HttpCodes.GatewayTimeout
	];
	var RetryableHttpVerbs = [
		"OPTIONS",
		"GET",
		"DELETE",
		"HEAD"
	];
	var ExponentialBackoffCeiling = 10;
	var ExponentialBackoffTimeSlice = 5;
	var HttpClientError = class HttpClientError extends Error {
		constructor(message, statusCode) {
			super(message);
			this.name = "HttpClientError";
			this.statusCode = statusCode;
			Object.setPrototypeOf(this, HttpClientError.prototype);
		}
	};
	exports.HttpClientError = HttpClientError;
	var HttpClientResponse = class {
		constructor(message) {
			this.message = message;
		}
		readBody() {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
					let output = Buffer.alloc(0);
					this.message.on("data", (chunk$4) => {
						output = Buffer.concat([output, chunk$4]);
					});
					this.message.on("end", () => {
						resolve(output.toString());
					});
				}));
			});
		}
		readBodyBuffer() {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
					const chunks = [];
					this.message.on("data", (chunk$4) => {
						chunks.push(chunk$4);
					});
					this.message.on("end", () => {
						resolve(Buffer.concat(chunks));
					});
				}));
			});
		}
	};
	exports.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
		return new URL(requestUrl).protocol === "https:";
	}
	var HttpClient = class {
		constructor(userAgent, handlers, requestOptions) {
			this._ignoreSslError = false;
			this._allowRedirects = true;
			this._allowRedirectDowngrade = false;
			this._maxRedirects = 50;
			this._allowRetries = false;
			this._maxRetries = 1;
			this._keepAlive = false;
			this._disposed = false;
			this.userAgent = userAgent;
			this.handlers = handlers || [];
			this.requestOptions = requestOptions;
			if (requestOptions) {
				if (requestOptions.ignoreSslError != null) this._ignoreSslError = requestOptions.ignoreSslError;
				this._socketTimeout = requestOptions.socketTimeout;
				if (requestOptions.allowRedirects != null) this._allowRedirects = requestOptions.allowRedirects;
				if (requestOptions.allowRedirectDowngrade != null) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
				if (requestOptions.maxRedirects != null) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
				if (requestOptions.keepAlive != null) this._keepAlive = requestOptions.keepAlive;
				if (requestOptions.allowRetries != null) this._allowRetries = requestOptions.allowRetries;
				if (requestOptions.maxRetries != null) this._maxRetries = requestOptions.maxRetries;
			}
		}
		options(requestUrl, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
			});
		}
		get(requestUrl, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("GET", requestUrl, null, additionalHeaders || {});
			});
		}
		del(requestUrl, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("DELETE", requestUrl, null, additionalHeaders || {});
			});
		}
		post(requestUrl, data, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("POST", requestUrl, data, additionalHeaders || {});
			});
		}
		patch(requestUrl, data, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("PATCH", requestUrl, data, additionalHeaders || {});
			});
		}
		put(requestUrl, data, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("PUT", requestUrl, data, additionalHeaders || {});
			});
		}
		head(requestUrl, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("HEAD", requestUrl, null, additionalHeaders || {});
			});
		}
		sendStream(verb, requestUrl, stream$1, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request(verb, requestUrl, stream$1, additionalHeaders);
			});
		}
		getJson(requestUrl_1) {
			return __awaiter(this, arguments, void 0, function* (requestUrl, additionalHeaders = {}) {
				additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
				const res = yield this.get(requestUrl, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		postJson(requestUrl_1, obj_1) {
			return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
				const res = yield this.post(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		putJson(requestUrl_1, obj_1) {
			return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
				const res = yield this.put(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		patchJson(requestUrl_1, obj_1) {
			return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
				const res = yield this.patch(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		request(verb, requestUrl, data, headers) {
			return __awaiter(this, void 0, void 0, function* () {
				if (this._disposed) throw new Error("Client has already been disposed.");
				const parsedUrl = new URL(requestUrl);
				let info = this._prepareRequest(verb, parsedUrl, headers);
				const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
				let numTries = 0;
				let response;
				do {
					response = yield this.requestRaw(info, data);
					if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
						let authenticationHandler;
						for (const handler of this.handlers) if (handler.canHandleAuthentication(response)) {
							authenticationHandler = handler;
							break;
						}
						if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info, data);
						else return response;
					}
					let redirectsRemaining = this._maxRedirects;
					while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
						const redirectUrl = response.message.headers["location"];
						if (!redirectUrl) break;
						const parsedRedirectUrl = new URL(redirectUrl);
						if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
						yield response.readBody();
						if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
							for (const header in headers) if (header.toLowerCase() === "authorization") delete headers[header];
						}
						info = this._prepareRequest(verb, parsedRedirectUrl, headers);
						response = yield this.requestRaw(info, data);
						redirectsRemaining--;
					}
					if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) return response;
					numTries += 1;
					if (numTries < maxTries) {
						yield response.readBody();
						yield this._performExponentialBackoff(numTries);
					}
				} while (numTries < maxTries);
				return response;
			});
		}
		dispose() {
			if (this._agent) this._agent.destroy();
			this._disposed = true;
		}
		requestRaw(info, data) {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => {
					function callbackForResult(err, res) {
						if (err) reject(err);
						else if (!res) reject(/* @__PURE__ */ new Error("Unknown error"));
						else resolve(res);
					}
					this.requestRawWithCallback(info, data, callbackForResult);
				});
			});
		}
		requestRawWithCallback(info, data, onResult) {
			if (typeof data === "string") {
				if (!info.options.headers) info.options.headers = {};
				info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
			}
			let callbackCalled = false;
			function handleResult(err, res) {
				if (!callbackCalled) {
					callbackCalled = true;
					onResult(err, res);
				}
			}
			const req = info.httpModule.request(info.options, (msg) => {
				handleResult(void 0, new HttpClientResponse(msg));
			});
			let socket;
			req.on("socket", (sock) => {
				socket = sock;
			});
			req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
				if (socket) socket.end();
				handleResult(/* @__PURE__ */ new Error(`Request timeout: ${info.options.path}`));
			});
			req.on("error", function(err) {
				handleResult(err);
			});
			if (data && typeof data === "string") req.write(data, "utf8");
			if (data && typeof data !== "string") {
				data.on("close", function() {
					req.end();
				});
				data.pipe(req);
			} else req.end();
		}
		getAgent(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			return this._getAgent(parsedUrl);
		}
		getAgentDispatcher(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			if (!(proxyUrl && proxyUrl.hostname)) return;
			return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
		}
		_prepareRequest(method, requestUrl, headers) {
			const info = {};
			info.parsedUrl = requestUrl;
			const usingSsl = info.parsedUrl.protocol === "https:";
			info.httpModule = usingSsl ? https : http;
			const defaultPort = usingSsl ? 443 : 80;
			info.options = {};
			info.options.host = info.parsedUrl.hostname;
			info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
			info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
			info.options.method = method;
			info.options.headers = this._mergeHeaders(headers);
			if (this.userAgent != null) info.options.headers["user-agent"] = this.userAgent;
			info.options.agent = this._getAgent(info.parsedUrl);
			if (this.handlers) for (const handler of this.handlers) handler.prepareRequest(info.options);
			return info;
		}
		_mergeHeaders(headers) {
			if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
			return lowercaseKeys(headers || {});
		}
		_getExistingOrDefaultHeader(additionalHeaders, header, _default) {
			let clientHeader;
			if (this.requestOptions && this.requestOptions.headers) {
				const headerValue = lowercaseKeys(this.requestOptions.headers)[header];
				if (headerValue) clientHeader = typeof headerValue === "number" ? headerValue.toString() : headerValue;
			}
			const additionalValue = additionalHeaders[header];
			if (additionalValue !== void 0) return typeof additionalValue === "number" ? additionalValue.toString() : additionalValue;
			if (clientHeader !== void 0) return clientHeader;
			return _default;
		}
		_getExistingOrDefaultContentTypeHeader(additionalHeaders, _default) {
			let clientHeader;
			if (this.requestOptions && this.requestOptions.headers) {
				const headerValue = lowercaseKeys(this.requestOptions.headers)[Headers.ContentType];
				if (headerValue) if (typeof headerValue === "number") clientHeader = String(headerValue);
				else if (Array.isArray(headerValue)) clientHeader = headerValue.join(", ");
				else clientHeader = headerValue;
			}
			const additionalValue = additionalHeaders[Headers.ContentType];
			if (additionalValue !== void 0) if (typeof additionalValue === "number") return String(additionalValue);
			else if (Array.isArray(additionalValue)) return additionalValue.join(", ");
			else return additionalValue;
			if (clientHeader !== void 0) return clientHeader;
			return _default;
		}
		_getAgent(parsedUrl) {
			let agent;
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			const useProxy = proxyUrl && proxyUrl.hostname;
			if (this._keepAlive && useProxy) agent = this._proxyAgent;
			if (!useProxy) agent = this._agent;
			if (agent) return agent;
			const usingSsl = parsedUrl.protocol === "https:";
			let maxSockets = 100;
			if (this.requestOptions) maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
			if (proxyUrl && proxyUrl.hostname) {
				const agentOptions = {
					maxSockets,
					keepAlive: this._keepAlive,
					proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && { proxyAuth: `${proxyUrl.username}:${proxyUrl.password}` }), {
						host: proxyUrl.hostname,
						port: proxyUrl.port
					})
				};
				let tunnelAgent;
				const overHttps = proxyUrl.protocol === "https:";
				if (usingSsl) tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
				else tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
				agent = tunnelAgent(agentOptions);
				this._proxyAgent = agent;
			}
			if (!agent) {
				const options = {
					keepAlive: this._keepAlive,
					maxSockets
				};
				agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
				this._agent = agent;
			}
			if (usingSsl && this._ignoreSslError) agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
			return agent;
		}
		_getProxyAgentDispatcher(parsedUrl, proxyUrl) {
			let proxyAgent;
			if (this._keepAlive) proxyAgent = this._proxyAgentDispatcher;
			if (proxyAgent) return proxyAgent;
			const usingSsl = parsedUrl.protocol === "https:";
			proxyAgent = new undici_1.ProxyAgent(Object.assign({
				uri: proxyUrl.href,
				pipelining: !this._keepAlive ? 0 : 1
			}, (proxyUrl.username || proxyUrl.password) && { token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}` }));
			this._proxyAgentDispatcher = proxyAgent;
			if (usingSsl && this._ignoreSslError) proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, { rejectUnauthorized: false });
			return proxyAgent;
		}
		_performExponentialBackoff(retryNumber) {
			return __awaiter(this, void 0, void 0, function* () {
				retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
				const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
				return new Promise((resolve) => setTimeout(() => resolve(), ms));
			});
		}
		_processResponse(res, options) {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
					const statusCode = res.message.statusCode || 0;
					const response = {
						statusCode,
						result: null,
						headers: {}
					};
					if (statusCode === HttpCodes.NotFound) resolve(response);
					function dateTimeDeserializer(key, value$2) {
						if (typeof value$2 === "string") {
							const a = new Date(value$2);
							if (!isNaN(a.valueOf())) return a;
						}
						return value$2;
					}
					let obj;
					let contents;
					try {
						contents = yield res.readBody();
						if (contents && contents.length > 0) {
							if (options && options.deserializeDates) obj = JSON.parse(contents, dateTimeDeserializer);
							else obj = JSON.parse(contents);
							response.result = obj;
						}
						response.headers = res.message.headers;
					} catch (err) {}
					if (statusCode > 299) {
						let msg;
						if (obj && obj.message) msg = obj.message;
						else if (contents && contents.length > 0) msg = contents;
						else msg = `Failed request: (${statusCode})`;
						const err = new HttpClientError(msg, statusCode);
						err.result = response.result;
						reject(err);
					} else resolve(response);
				}));
			});
		}
	};
	exports.HttpClient = HttpClient;
	var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
}));
var require_auth = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
	var BasicCredentialHandler = class {
		constructor(username, password) {
			this.username = username;
			this.password = password;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BasicCredentialHandler = BasicCredentialHandler;
	var BearerCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Bearer ${this.token}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BearerCredentialHandler = BearerCredentialHandler;
	var PersonalAccessTokenCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
}));
var require_oidc_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OidcClient = void 0;
	var http_client_1 = require_lib();
	var auth_1 = require_auth();
	var core_1 = require_core();
	exports.OidcClient = class OidcClient {
		static createHttpClient(allowRetry = true, maxRetry = 10) {
			const requestOptions = {
				allowRetries: allowRetry,
				maxRetries: maxRetry
			};
			return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
		}
		static getRequestToken() {
			const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
			if (!token) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
			return token;
		}
		static getIDTokenUrl() {
			const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
			if (!runtimeUrl) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
			return runtimeUrl;
		}
		static getCall(id_token_url) {
			return __awaiter(this, void 0, void 0, function* () {
				var _a;
				const id_token = (_a = (yield OidcClient.createHttpClient().getJson(id_token_url).catch((error) => {
					throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
				})).result) === null || _a === void 0 ? void 0 : _a.value;
				if (!id_token) throw new Error("Response json body do not have ID Token field");
				return id_token;
			});
		}
		static getIDToken(audience) {
			return __awaiter(this, void 0, void 0, function* () {
				try {
					let id_token_url = OidcClient.getIDTokenUrl();
					if (audience) id_token_url = `${id_token_url}&audience=${encodeURIComponent(audience)}`;
					(0, core_1.debug)(`ID token url is ${id_token_url}`);
					const id_token = yield OidcClient.getCall(id_token_url);
					(0, core_1.setSecret)(id_token);
					return id_token;
				} catch (error) {
					throw new Error(`Error message: ${error.message}`);
				}
			});
		}
	};
}));
var require_summary = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
	var os_1$1 = __require("os");
	var fs_1 = __require("fs");
	var { access, appendFile, writeFile } = fs_1.promises;
	exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
	exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
	var Summary = class {
		constructor() {
			this._buffer = "";
		}
		filePath() {
			return __awaiter(this, void 0, void 0, function* () {
				if (this._filePath) return this._filePath;
				const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
				if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
				try {
					yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
				} catch (_a) {
					throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
				}
				this._filePath = pathFromEnv;
				return this._filePath;
			});
		}
		wrap(tag, content, attrs = {}) {
			const htmlAttrs = Object.entries(attrs).map(([key, value$2]) => ` ${key}="${value$2}"`).join("");
			if (!content) return `<${tag}${htmlAttrs}>`;
			return `<${tag}${htmlAttrs}>${content}</${tag}>`;
		}
		write(options) {
			return __awaiter(this, void 0, void 0, function* () {
				const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
				const filePath = yield this.filePath();
				yield (overwrite ? writeFile : appendFile)(filePath, this._buffer, { encoding: "utf8" });
				return this.emptyBuffer();
			});
		}
		clear() {
			return __awaiter(this, void 0, void 0, function* () {
				return this.emptyBuffer().write({ overwrite: true });
			});
		}
		stringify() {
			return this._buffer;
		}
		isEmptyBuffer() {
			return this._buffer.length === 0;
		}
		emptyBuffer() {
			this._buffer = "";
			return this;
		}
		addRaw(text, addEOL = false) {
			this._buffer += text;
			return addEOL ? this.addEOL() : this;
		}
		addEOL() {
			return this.addRaw(os_1$1.EOL);
		}
		addCodeBlock(code, lang) {
			const attrs = Object.assign({}, lang && { lang });
			const element = this.wrap("pre", this.wrap("code", code), attrs);
			return this.addRaw(element).addEOL();
		}
		addList(items, ordered = false) {
			const tag = ordered ? "ol" : "ul";
			const listItems = items.map((item) => this.wrap("li", item)).join("");
			const element = this.wrap(tag, listItems);
			return this.addRaw(element).addEOL();
		}
		addTable(rows) {
			const tableBody = rows.map((row) => {
				const cells = row.map((cell) => {
					if (typeof cell === "string") return this.wrap("td", cell);
					const { header, data, colspan, rowspan } = cell;
					const tag = header ? "th" : "td";
					const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
					return this.wrap(tag, data, attrs);
				}).join("");
				return this.wrap("tr", cells);
			}).join("");
			const element = this.wrap("table", tableBody);
			return this.addRaw(element).addEOL();
		}
		addDetails(label, content) {
			const element = this.wrap("details", this.wrap("summary", label) + content);
			return this.addRaw(element).addEOL();
		}
		addImage(src, alt, options) {
			const { width, height } = options || {};
			const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
			const element = this.wrap("img", null, Object.assign({
				src,
				alt
			}, attrs));
			return this.addRaw(element).addEOL();
		}
		addHeading(text, level) {
			const tag = `h${level}`;
			const allowedTag = [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			].includes(tag) ? tag : "h1";
			const element = this.wrap(allowedTag, text);
			return this.addRaw(element).addEOL();
		}
		addSeparator() {
			const element = this.wrap("hr", null);
			return this.addRaw(element).addEOL();
		}
		addBreak() {
			const element = this.wrap("br", null);
			return this.addRaw(element).addEOL();
		}
		addQuote(text, cite) {
			const attrs = Object.assign({}, cite && { cite });
			const element = this.wrap("blockquote", text, attrs);
			return this.addRaw(element).addEOL();
		}
		addLink(text, href) {
			const element = this.wrap("a", text, { href });
			return this.addRaw(element).addEOL();
		}
	};
	var _summary = new Summary();
	exports.markdownSummary = _summary;
	exports.summary = _summary;
}));
var require_path_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toPosixPath = toPosixPath;
	exports.toWin32Path = toWin32Path;
	exports.toPlatformPath = toPlatformPath;
	var path$4 = __importStar(__require("path"));
	function toPosixPath(pth) {
		return pth.replace(/[\\]/g, "/");
	}
	function toWin32Path(pth) {
		return pth.replace(/[/]/g, "\\");
	}
	function toPlatformPath(pth) {
		return pth.replace(/[/\\]/g, path$4.sep);
	}
}));
var require_io_util = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var _a;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
	exports.readlink = readlink;
	exports.exists = exists;
	exports.isDirectory = isDirectory;
	exports.isRooted = isRooted;
	exports.tryGetExecutablePath = tryGetExecutablePath;
	exports.getCmdPath = getCmdPath;
	var fs$1 = __importStar(__require("fs"));
	var path$3 = __importStar(__require("path"));
	_a = fs$1.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
	exports.IS_WINDOWS = process.platform === "win32";
	function readlink(fsPath) {
		return __awaiter(this, void 0, void 0, function* () {
			const result = yield fs$1.promises.readlink(fsPath);
			if (exports.IS_WINDOWS && !result.endsWith("\\")) return `${result}\\`;
			return result;
		});
	}
	exports.UV_FS_O_EXLOCK = 268435456;
	exports.READONLY = fs$1.constants.O_RDONLY;
	function exists(fsPath) {
		return __awaiter(this, void 0, void 0, function* () {
			try {
				yield (0, exports.stat)(fsPath);
			} catch (err) {
				if (err.code === "ENOENT") return false;
				throw err;
			}
			return true;
		});
	}
	function isDirectory(fsPath_1) {
		return __awaiter(this, arguments, void 0, function* (fsPath, useStat = false) {
			return (useStat ? yield (0, exports.stat)(fsPath) : yield (0, exports.lstat)(fsPath)).isDirectory();
		});
	}
	function isRooted(p) {
		p = normalizeSeparators(p);
		if (!p) throw new Error("isRooted() parameter \"p\" cannot be empty");
		if (exports.IS_WINDOWS) return p.startsWith("\\") || /^[A-Z]:/i.test(p);
		return p.startsWith("/");
	}
	function tryGetExecutablePath(filePath, extensions) {
		return __awaiter(this, void 0, void 0, function* () {
			let stats = void 0;
			try {
				stats = yield (0, exports.stat)(filePath);
			} catch (err) {
				if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
			}
			if (stats && stats.isFile()) {
				if (exports.IS_WINDOWS) {
					const upperExt = path$3.extname(filePath).toUpperCase();
					if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) return filePath;
				} else if (isUnixExecutable(stats)) return filePath;
			}
			const originalFilePath = filePath;
			for (const extension of extensions) {
				filePath = originalFilePath + extension;
				stats = void 0;
				try {
					stats = yield (0, exports.stat)(filePath);
				} catch (err) {
					if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
				}
				if (stats && stats.isFile()) {
					if (exports.IS_WINDOWS) {
						try {
							const directory = path$3.dirname(filePath);
							const upperName = path$3.basename(filePath).toUpperCase();
							for (const actualName of yield (0, exports.readdir)(directory)) if (upperName === actualName.toUpperCase()) {
								filePath = path$3.join(directory, actualName);
								break;
							}
						} catch (err) {
							console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
						}
						return filePath;
					} else if (isUnixExecutable(stats)) return filePath;
				}
			}
			return "";
		});
	}
	function normalizeSeparators(p) {
		p = p || "";
		if (exports.IS_WINDOWS) {
			p = p.replace(/\//g, "\\");
			return p.replace(/\\\\+/g, "\\");
		}
		return p.replace(/\/\/+/g, "/");
	}
	function isUnixExecutable(stats) {
		return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && process.getgid !== void 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && process.getuid !== void 0 && stats.uid === process.getuid();
	}
	function getCmdPath() {
		var _a;
		return (_a = process.env["COMSPEC"]) !== null && _a !== void 0 ? _a : `cmd.exe`;
	}
}));
var require_io = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cp = cp;
	exports.mv = mv;
	exports.rmRF = rmRF;
	exports.mkdirP = mkdirP;
	exports.which = which;
	exports.findInPath = findInPath;
	var assert_1 = __require("assert");
	var path$2 = __importStar(__require("path"));
	var ioUtil = __importStar(require_io_util());
	function cp(source_1, dest_1) {
		return __awaiter(this, arguments, void 0, function* (source, dest, options = {}) {
			const { force, recursive, copySourceDirectory } = readCopyOptions(options);
			const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
			if (destStat && destStat.isFile() && !force) return;
			const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path$2.join(dest, path$2.basename(source)) : dest;
			if (!(yield ioUtil.exists(source))) throw new Error(`no such file or directory: ${source}`);
			if ((yield ioUtil.stat(source)).isDirectory()) if (!recursive) throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
			else yield cpDirRecursive(source, newDest, 0, force);
			else {
				if (path$2.relative(source, newDest) === "") throw new Error(`'${newDest}' and '${source}' are the same file`);
				yield copyFile(source, newDest, force);
			}
		});
	}
	function mv(source_1, dest_1) {
		return __awaiter(this, arguments, void 0, function* (source, dest, options = {}) {
			if (yield ioUtil.exists(dest)) {
				let destExists = true;
				if (yield ioUtil.isDirectory(dest)) {
					dest = path$2.join(dest, path$2.basename(source));
					destExists = yield ioUtil.exists(dest);
				}
				if (destExists) if (options.force == null || options.force) yield rmRF(dest);
				else throw new Error("Destination already exists");
			}
			yield mkdirP(path$2.dirname(dest));
			yield ioUtil.rename(source, dest);
		});
	}
	function rmRF(inputPath) {
		return __awaiter(this, void 0, void 0, function* () {
			if (ioUtil.IS_WINDOWS) {
				if (/[*"<>|]/.test(inputPath)) throw new Error("File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows");
			}
			try {
				yield ioUtil.rm(inputPath, {
					force: true,
					maxRetries: 3,
					recursive: true,
					retryDelay: 300
				});
			} catch (err) {
				throw new Error(`File was unable to be removed ${err}`);
			}
		});
	}
	function mkdirP(fsPath) {
		return __awaiter(this, void 0, void 0, function* () {
			(0, assert_1.ok)(fsPath, "a path argument must be provided");
			yield ioUtil.mkdir(fsPath, { recursive: true });
		});
	}
	function which(tool, check$1) {
		return __awaiter(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			if (check$1) {
				const result = yield which(tool, false);
				if (!result) if (ioUtil.IS_WINDOWS) throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
				else throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
				return result;
			}
			const matches = yield findInPath(tool);
			if (matches && matches.length > 0) return matches[0];
			return "";
		});
	}
	function findInPath(tool) {
		return __awaiter(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			const extensions = [];
			if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
				for (const extension of process.env["PATHEXT"].split(path$2.delimiter)) if (extension) extensions.push(extension);
			}
			if (ioUtil.isRooted(tool)) {
				const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
				if (filePath) return [filePath];
				return [];
			}
			if (tool.includes(path$2.sep)) return [];
			const directories = [];
			if (process.env.PATH) {
				for (const p of process.env.PATH.split(path$2.delimiter)) if (p) directories.push(p);
			}
			const matches = [];
			for (const directory of directories) {
				const filePath = yield ioUtil.tryGetExecutablePath(path$2.join(directory, tool), extensions);
				if (filePath) matches.push(filePath);
			}
			return matches;
		});
	}
	function readCopyOptions(options) {
		return {
			force: options.force == null ? true : options.force,
			recursive: Boolean(options.recursive),
			copySourceDirectory: options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory)
		};
	}
	function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
		return __awaiter(this, void 0, void 0, function* () {
			if (currentDepth >= 255) return;
			currentDepth++;
			yield mkdirP(destDir);
			const files = yield ioUtil.readdir(sourceDir);
			for (const fileName of files) {
				const srcFile = `${sourceDir}/${fileName}`;
				const destFile = `${destDir}/${fileName}`;
				if ((yield ioUtil.lstat(srcFile)).isDirectory()) yield cpDirRecursive(srcFile, destFile, currentDepth, force);
				else yield copyFile(srcFile, destFile, force);
			}
			yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
		});
	}
	function copyFile(srcFile, destFile, force) {
		return __awaiter(this, void 0, void 0, function* () {
			if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
				try {
					yield ioUtil.lstat(destFile);
					yield ioUtil.unlink(destFile);
				} catch (e) {
					if (e.code === "EPERM") {
						yield ioUtil.chmod(destFile, "0666");
						yield ioUtil.unlink(destFile);
					}
				}
				const symlinkFull = yield ioUtil.readlink(srcFile);
				yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
			} else if (!(yield ioUtil.exists(destFile)) || force) yield ioUtil.copyFile(srcFile, destFile);
		});
	}
}));
var require_toolrunner = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ToolRunner = void 0;
	exports.argStringToArray = argStringToArray;
	var os$2 = __importStar(__require("os"));
	var events = __importStar(__require("events"));
	var child = __importStar(__require("child_process"));
	var path$1 = __importStar(__require("path"));
	var io = __importStar(require_io());
	var ioUtil = __importStar(require_io_util());
	var timers_1 = __require("timers");
	var IS_WINDOWS = process.platform === "win32";
	var ToolRunner = class extends events.EventEmitter {
		constructor(toolPath, args$1, options) {
			super();
			if (!toolPath) throw new Error("Parameter 'toolPath' cannot be null or empty.");
			this.toolPath = toolPath;
			this.args = args$1 || [];
			this.options = options || {};
		}
		_debug(message) {
			if (this.options.listeners && this.options.listeners.debug) this.options.listeners.debug(message);
		}
		_getCommandString(options, noPrefix) {
			const toolPath = this._getSpawnFileName();
			const args$1 = this._getSpawnArgs(options);
			let cmd = noPrefix ? "" : "[command]";
			if (IS_WINDOWS) if (this._isCmdFile()) {
				cmd += toolPath;
				for (const a of args$1) cmd += ` ${a}`;
			} else if (options.windowsVerbatimArguments) {
				cmd += `"${toolPath}"`;
				for (const a of args$1) cmd += ` ${a}`;
			} else {
				cmd += this._windowsQuoteCmdArg(toolPath);
				for (const a of args$1) cmd += ` ${this._windowsQuoteCmdArg(a)}`;
			}
			else {
				cmd += toolPath;
				for (const a of args$1) cmd += ` ${a}`;
			}
			return cmd;
		}
		_processLineBuffer(data, strBuffer, onLine) {
			try {
				let s = strBuffer + data.toString();
				let n = s.indexOf(os$2.EOL);
				while (n > -1) {
					onLine(s.substring(0, n));
					s = s.substring(n + os$2.EOL.length);
					n = s.indexOf(os$2.EOL);
				}
				return s;
			} catch (err) {
				this._debug(`error processing line. Failed with error ${err}`);
				return "";
			}
		}
		_getSpawnFileName() {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) return process.env["COMSPEC"] || "cmd.exe";
			}
			return this.toolPath;
		}
		_getSpawnArgs(options) {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) {
					let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
					for (const a of this.args) {
						argline += " ";
						argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
					}
					argline += "\"";
					return [argline];
				}
			}
			return this.args;
		}
		_endsWith(str, end$2) {
			return str.endsWith(end$2);
		}
		_isCmdFile() {
			const upperToolPath = this.toolPath.toUpperCase();
			return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
		}
		_windowsQuoteCmdArg(arg) {
			if (!this._isCmdFile()) return this._uvQuoteCmdArg(arg);
			if (!arg) return "\"\"";
			const cmdSpecialChars = [
				" ",
				"	",
				"&",
				"(",
				")",
				"[",
				"]",
				"{",
				"}",
				"^",
				"=",
				";",
				"!",
				"'",
				"+",
				",",
				"`",
				"~",
				"|",
				"<",
				">",
				"\""
			];
			let needsQuotes = false;
			for (const char of arg) if (cmdSpecialChars.some((x) => x === char)) {
				needsQuotes = true;
				break;
			}
			if (!needsQuotes) return arg;
			let reverse$3 = "\"";
			let quoteHit = true;
			for (let i = arg.length; i > 0; i--) {
				reverse$3 += arg[i - 1];
				if (quoteHit && arg[i - 1] === "\\") reverse$3 += "\\";
				else if (arg[i - 1] === "\"") {
					quoteHit = true;
					reverse$3 += "\"";
				} else quoteHit = false;
			}
			reverse$3 += "\"";
			return reverse$3.split("").reverse().join("");
		}
		_uvQuoteCmdArg(arg) {
			if (!arg) return "\"\"";
			if (!arg.includes(" ") && !arg.includes("	") && !arg.includes("\"")) return arg;
			if (!arg.includes("\"") && !arg.includes("\\")) return `"${arg}"`;
			let reverse$3 = "\"";
			let quoteHit = true;
			for (let i = arg.length; i > 0; i--) {
				reverse$3 += arg[i - 1];
				if (quoteHit && arg[i - 1] === "\\") reverse$3 += "\\";
				else if (arg[i - 1] === "\"") {
					quoteHit = true;
					reverse$3 += "\\";
				} else quoteHit = false;
			}
			reverse$3 += "\"";
			return reverse$3.split("").reverse().join("");
		}
		_cloneExecOptions(options) {
			options = options || {};
			const result = {
				cwd: options.cwd || process.cwd(),
				env: options.env || process.env,
				silent: options.silent || false,
				windowsVerbatimArguments: options.windowsVerbatimArguments || false,
				failOnStdErr: options.failOnStdErr || false,
				ignoreReturnCode: options.ignoreReturnCode || false,
				delay: options.delay || 1e4
			};
			result.outStream = options.outStream || process.stdout;
			result.errStream = options.errStream || process.stderr;
			return result;
		}
		_getSpawnOptions(options, toolPath) {
			options = options || {};
			const result = {};
			result.cwd = options.cwd;
			result.env = options.env;
			result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
			if (options.windowsVerbatimArguments) result.argv0 = `"${toolPath}"`;
			return result;
		}
		exec() {
			return __awaiter(this, void 0, void 0, function* () {
				if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) this.toolPath = path$1.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
				this.toolPath = yield io.which(this.toolPath, true);
				return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
					this._debug(`exec tool: ${this.toolPath}`);
					this._debug("arguments:");
					for (const arg of this.args) this._debug(`   ${arg}`);
					const optionsNonNull = this._cloneExecOptions(this.options);
					if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os$2.EOL);
					const state = new ExecState(optionsNonNull, this.toolPath);
					state.on("debug", (message) => {
						this._debug(message);
					});
					if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) return reject(/* @__PURE__ */ new Error(`The cwd: ${this.options.cwd} does not exist!`));
					const fileName = this._getSpawnFileName();
					const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
					let stdbuffer = "";
					if (cp.stdout) cp.stdout.on("data", (data) => {
						if (this.options.listeners && this.options.listeners.stdout) this.options.listeners.stdout(data);
						if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(data);
						stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.stdline) this.options.listeners.stdline(line);
						});
					});
					let errbuffer = "";
					if (cp.stderr) cp.stderr.on("data", (data) => {
						state.processStderr = true;
						if (this.options.listeners && this.options.listeners.stderr) this.options.listeners.stderr(data);
						if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) (optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream).write(data);
						errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.errline) this.options.listeners.errline(line);
						});
					});
					cp.on("error", (err) => {
						state.processError = err.message;
						state.processExited = true;
						state.processClosed = true;
						state.CheckComplete();
					});
					cp.on("exit", (code) => {
						state.processExitCode = code;
						state.processExited = true;
						this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
						state.CheckComplete();
					});
					cp.on("close", (code) => {
						state.processExitCode = code;
						state.processExited = true;
						state.processClosed = true;
						this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
						state.CheckComplete();
					});
					state.on("done", (error, exitCode) => {
						if (stdbuffer.length > 0) this.emit("stdline", stdbuffer);
						if (errbuffer.length > 0) this.emit("errline", errbuffer);
						cp.removeAllListeners();
						if (error) reject(error);
						else resolve(exitCode);
					});
					if (this.options.input) {
						if (!cp.stdin) throw new Error("child process missing stdin");
						cp.stdin.end(this.options.input);
					}
				}));
			});
		}
	};
	exports.ToolRunner = ToolRunner;
	function argStringToArray(argString) {
		const args$1 = [];
		let inQuotes = false;
		let escaped = false;
		let arg = "";
		function append$3(c) {
			if (escaped && c !== "\"") arg += "\\";
			arg += c;
			escaped = false;
		}
		for (let i = 0; i < argString.length; i++) {
			const c = argString.charAt(i);
			if (c === "\"") {
				if (!escaped) inQuotes = !inQuotes;
				else append$3(c);
				continue;
			}
			if (c === "\\" && escaped) {
				append$3(c);
				continue;
			}
			if (c === "\\" && inQuotes) {
				escaped = true;
				continue;
			}
			if (c === " " && !inQuotes) {
				if (arg.length > 0) {
					args$1.push(arg);
					arg = "";
				}
				continue;
			}
			append$3(c);
		}
		if (arg.length > 0) args$1.push(arg.trim());
		return args$1;
	}
	var ExecState = class ExecState extends events.EventEmitter {
		constructor(options, toolPath) {
			super();
			this.processClosed = false;
			this.processError = "";
			this.processExitCode = 0;
			this.processExited = false;
			this.processStderr = false;
			this.delay = 1e4;
			this.done = false;
			this.timeout = null;
			if (!toolPath) throw new Error("toolPath must not be empty");
			this.options = options;
			this.toolPath = toolPath;
			if (options.delay) this.delay = options.delay;
		}
		CheckComplete() {
			if (this.done) return;
			if (this.processClosed) this._setResult();
			else if (this.processExited) this.timeout = (0, timers_1.setTimeout)(ExecState.HandleTimeout, this.delay, this);
		}
		_debug(message) {
			this.emit("debug", message);
		}
		_setResult() {
			let error;
			if (this.processExited) {
				if (this.processError) error = /* @__PURE__ */ new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
				else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) error = /* @__PURE__ */ new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
				else if (this.processStderr && this.options.failOnStdErr) error = /* @__PURE__ */ new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
			}
			if (this.timeout) {
				clearTimeout(this.timeout);
				this.timeout = null;
			}
			this.done = true;
			this.emit("done", error, this.processExitCode);
		}
		static HandleTimeout(state) {
			if (state.done) return;
			if (!state.processClosed && state.processExited) {
				const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
				state._debug(message);
			}
			state._setResult();
		}
	};
}));
var require_exec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.exec = exec;
	exports.getExecOutput = getExecOutput;
	var string_decoder_1 = __require("string_decoder");
	var tr = __importStar(require_toolrunner());
	function exec(commandLine, args$1, options) {
		return __awaiter(this, void 0, void 0, function* () {
			const commandArgs = tr.argStringToArray(commandLine);
			if (commandArgs.length === 0) throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
			const toolPath = commandArgs[0];
			args$1 = commandArgs.slice(1).concat(args$1 || []);
			return new tr.ToolRunner(toolPath, args$1, options).exec();
		});
	}
	function getExecOutput(commandLine, args$1, options) {
		return __awaiter(this, void 0, void 0, function* () {
			var _a, _b;
			let stdout = "";
			let stderr = "";
			const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
			const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
			const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
			const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
			const stdErrListener = (data) => {
				stderr += stderrDecoder.write(data);
				if (originalStdErrListener) originalStdErrListener(data);
			};
			const stdOutListener = (data) => {
				stdout += stdoutDecoder.write(data);
				if (originalStdoutListener) originalStdoutListener(data);
			};
			const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), {
				stdout: stdOutListener,
				stderr: stdErrListener
			});
			const exitCode = yield exec(commandLine, args$1, Object.assign(Object.assign({}, options), { listeners }));
			stdout += stdoutDecoder.end();
			stderr += stderrDecoder.end();
			return {
				exitCode,
				stdout,
				stderr
			};
		});
	}
}));
var require_platform = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
	exports.getDetails = getDetails;
	var os_1 = __importDefault(__require("os"));
	var exec = __importStar(require_exec());
	var getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		const { stdout: version } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Version\"", void 0, { silent: true });
		const { stdout: name } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Caption\"", void 0, { silent: true });
		return {
			name: name.trim(),
			version: version.trim()
		};
	});
	var getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		var _a, _b, _c, _d;
		const { stdout } = yield exec.getExecOutput("sw_vers", void 0, { silent: true });
		const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
		return {
			name: (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "",
			version
		};
	});
	var getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
		const { stdout } = yield exec.getExecOutput("lsb_release", [
			"-i",
			"-r",
			"-s"
		], { silent: true });
		const [name, version] = stdout.trim().split("\n");
		return {
			name,
			version
		};
	});
	exports.platform = os_1.default.platform();
	exports.arch = os_1.default.arch();
	exports.isWindows = exports.platform === "win32";
	exports.isMacOS = exports.platform === "darwin";
	exports.isLinux = exports.platform === "linux";
	function getDetails() {
		return __awaiter(this, void 0, void 0, function* () {
			return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
				platform: exports.platform,
				arch: exports.arch,
				isWindows: exports.isWindows,
				isMacOS: exports.isMacOS,
				isLinux: exports.isLinux
			});
		});
	}
}));
var require_core = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys = function(o) {
			ownKeys = Object.getOwnPropertyNames || function(o$1) {
				var ar = [];
				for (var k in o$1) if (Object.prototype.hasOwnProperty.call(o$1, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys(o);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$2) {
			return value$2 instanceof P ? value$2 : new P(function(resolve) {
				resolve(value$2);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value$2) {
				try {
					step$3(generator.next(value$2));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value$2) {
				try {
					step$3(generator["throw"](value$2));
				} catch (e) {
					reject(e);
				}
			}
			function step$3(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step$3((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.ExitCode = void 0;
	exports.exportVariable = exportVariable;
	exports.setSecret = setSecret;
	exports.addPath = addPath;
	exports.getInput = getInput;
	exports.getMultilineInput = getMultilineInput;
	exports.getBooleanInput = getBooleanInput;
	exports.setOutput = setOutput;
	exports.setCommandEcho = setCommandEcho;
	exports.setFailed = setFailed;
	exports.isDebug = isDebug;
	exports.debug = debug;
	exports.error = error;
	exports.warning = warning;
	exports.notice = notice;
	exports.info = info;
	exports.startGroup = startGroup;
	exports.endGroup = endGroup;
	exports.group = group;
	exports.saveState = saveState;
	exports.getState = getState;
	exports.getIDToken = getIDToken;
	var command_1 = require_command();
	var file_command_1 = require_file_command();
	var utils_1 = require_utils$1();
	var os$1 = __importStar(__require("os"));
	var path = __importStar(__require("path"));
	var oidc_utils_1 = require_oidc_utils();
	var ExitCode;
	(function(ExitCode) {
		ExitCode[ExitCode["Success"] = 0] = "Success";
		ExitCode[ExitCode["Failure"] = 1] = "Failure";
	})(ExitCode || (exports.ExitCode = ExitCode = {}));
	function exportVariable(name, val) {
		const convertedVal = (0, utils_1.toCommandValue)(val);
		process.env[name] = convertedVal;
		if (process.env["GITHUB_ENV"] || "") return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
		(0, command_1.issueCommand)("set-env", { name }, convertedVal);
	}
	function setSecret(secret$2) {
		(0, command_1.issueCommand)("add-mask", {}, secret$2);
	}
	function addPath(inputPath) {
		if (process.env["GITHUB_PATH"] || "") (0, file_command_1.issueFileCommand)("PATH", inputPath);
		else (0, command_1.issueCommand)("add-path", {}, inputPath);
		process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
	}
	function getInput(name, options) {
		const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
		if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);
		if (options && options.trimWhitespace === false) return val;
		return val.trim();
	}
	function getMultilineInput(name, options) {
		const inputs = getInput(name, options).split("\n").filter((x) => x !== "");
		if (options && options.trimWhitespace === false) return inputs;
		return inputs.map((input) => input.trim());
	}
	function getBooleanInput(name, options) {
		const trueValue = [
			"true",
			"True",
			"TRUE"
		];
		const falseValue = [
			"false",
			"False",
			"FALSE"
		];
		const val = getInput(name, options);
		if (trueValue.includes(val)) return true;
		if (falseValue.includes(val)) return false;
		throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\nSupport boolean input list: \`true | True | TRUE | false | False | FALSE\``);
	}
	function setOutput(name, value$2) {
		if (process.env["GITHUB_OUTPUT"] || "") return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value$2));
		process.stdout.write(os$1.EOL);
		(0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value$2));
	}
	function setCommandEcho(enabled$1) {
		(0, command_1.issue)("echo", enabled$1 ? "on" : "off");
	}
	function setFailed(message) {
		process.exitCode = ExitCode.Failure;
		error(message);
	}
	function isDebug() {
		return process.env["RUNNER_DEBUG"] === "1";
	}
	function debug(message) {
		(0, command_1.issueCommand)("debug", {}, message);
	}
	function error(message, properties = {}) {
		(0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	function warning(message, properties = {}) {
		(0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	function notice(message, properties = {}) {
		(0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	function info(message) {
		process.stdout.write(message + os$1.EOL);
	}
	function startGroup(name) {
		(0, command_1.issue)("group", name);
	}
	function endGroup() {
		(0, command_1.issue)("endgroup");
	}
	function group(name, fn) {
		return __awaiter(this, void 0, void 0, function* () {
			startGroup(name);
			let result;
			try {
				result = yield fn();
			} finally {
				endGroup();
			}
			return result;
		});
	}
	function saveState(name, value$2) {
		if (process.env["GITHUB_STATE"] || "") return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value$2));
		(0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value$2));
	}
	function getState(name) {
		return process.env[`STATE_${name}`] || "";
	}
	function getIDToken(aud) {
		return __awaiter(this, void 0, void 0, function* () {
			return yield oidc_utils_1.OidcClient.getIDToken(aud);
		});
	}
	var summary_1 = require_summary();
	Object.defineProperty(exports, "summary", {
		enumerable: true,
		get: function() {
			return summary_1.summary;
		}
	});
	var summary_2 = require_summary();
	Object.defineProperty(exports, "markdownSummary", {
		enumerable: true,
		get: function() {
			return summary_2.markdownSummary;
		}
	});
	var path_utils_1 = require_path_utils();
	Object.defineProperty(exports, "toPosixPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPosixPath;
		}
	});
	Object.defineProperty(exports, "toWin32Path", {
		enumerable: true,
		get: function() {
			return path_utils_1.toWin32Path;
		}
	});
	Object.defineProperty(exports, "toPlatformPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPlatformPath;
		}
	});
	exports.platform = __importStar(require_platform());
}));
const isFunction$1 = (input) => typeof input === "function";
const dual = function(arity, body) {
	if (typeof arity === "function") return function() {
		if (arity(arguments)) return body.apply(this, arguments);
		return (self) => body(self, ...arguments);
	};
	switch (arity) {
		case 0:
		case 1: throw new RangeError(`Invalid arity ${arity}`);
		case 2: return function(a, b) {
			if (arguments.length >= 2) return body(a, b);
			return function(self) {
				return body(self, a);
			};
		};
		case 3: return function(a, b, c) {
			if (arguments.length >= 3) return body(a, b, c);
			return function(self) {
				return body(self, a, b);
			};
		};
		case 4: return function(a, b, c, d) {
			if (arguments.length >= 4) return body(a, b, c, d);
			return function(self) {
				return body(self, a, b, c);
			};
		};
		case 5: return function(a, b, c, d, e) {
			if (arguments.length >= 5) return body(a, b, c, d, e);
			return function(self) {
				return body(self, a, b, c, d);
			};
		};
		default: return function() {
			if (arguments.length >= arity) return body.apply(this, arguments);
			const args$1 = arguments;
			return function(self) {
				return body(self, ...args$1);
			};
		};
	}
};
const identity = (a) => a;
const constant = (value$2) => () => value$2;
const constTrue = /* @__PURE__ */ constant(true);
const constFalse = /* @__PURE__ */ constant(false);
const constUndefined = /* @__PURE__ */ constant(void 0);
const constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
	switch (arguments.length) {
		case 1: return a;
		case 2: return ab(a);
		case 3: return bc(ab(a));
		case 4: return cd(bc(ab(a)));
		case 5: return de(cd(bc(ab(a))));
		case 6: return ef(de(cd(bc(ab(a)))));
		case 7: return fg(ef(de(cd(bc(ab(a))))));
		case 8: return gh(fg(ef(de(cd(bc(ab(a)))))));
		case 9: return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
		default: {
			let ret = arguments[0];
			for (let i = 1; i < arguments.length; i++) ret = arguments[i](ret);
			return ret;
		}
	}
}
const make$48 = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
const mapInput$1 = /* @__PURE__ */ dual(2, (self, f) => make$48((x, y) => self(f(x), f(y))));
const array$4 = (item) => make$48((self, that) => {
	if (self.length !== that.length) return false;
	for (let i = 0; i < self.length; i++) if (!item(self[i], that[i])) return false;
	return true;
});
var globalStoreId = `effect/GlobalValue`;
var globalStore;
const globalValue = (id$2, compute) => {
	if (!globalStore) {
		globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
		globalStore = globalThis[globalStoreId];
	}
	if (!globalStore.has(id$2)) globalStore.set(id$2, compute());
	return globalStore.get(id$2);
};
const isString = (input) => typeof input === "string";
const isNumber = (input) => typeof input === "number";
const isBoolean$1 = (input) => typeof input === "boolean";
const isBigInt = (input) => typeof input === "bigint";
const isSymbol = (input) => typeof input === "symbol";
const isFunction = isFunction$1;
const isUndefined = (input) => input === void 0;
const isNever = (_) => false;
const isRecordOrArray = (input) => typeof input === "object" && input !== null;
const isObject = (input) => isRecordOrArray(input) || isFunction(input);
const hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && property in self);
const isTagged = /* @__PURE__ */ dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
const isNullable = (input) => input === null || input === void 0;
const isNotNullable = (input) => input !== null && input !== void 0;
const isUint8Array = (input) => input instanceof Uint8Array;
const isDate = (input) => input instanceof Date;
const isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
const isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
const isPromiseLike = (input) => hasProperty(input, "then") && isFunction(input.then);
const getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;
Symbol.iterator;
var SingleShotGen = class SingleShotGen {
	self;
	called = false;
	constructor(self) {
		this.self = self;
	}
	next(a) {
		return this.called ? {
			value: a,
			done: true
		} : (this.called = true, {
			value: this.self,
			done: false
		});
	}
	return(a) {
		return {
			value: a,
			done: true
		};
	}
	throw(e) {
		throw e;
	}
	[Symbol.iterator]() {
		return new SingleShotGen(this.self);
	}
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933;
var MUL_LO = 1284865837;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
	_state;
	constructor(seedHi, seedLo, incHi, incLo) {
		if (isNullable(seedLo) && isNullable(seedHi)) {
			seedLo = Math.random() * 4294967295 >>> 0;
			seedHi = 0;
		} else if (isNullable(seedLo)) {
			seedLo = seedHi;
			seedHi = 0;
		}
		if (isNullable(incLo) && isNullable(incHi)) {
			incLo = this._state ? this._state[3] : defaultIncLo;
			incHi = this._state ? this._state[2] : defaultIncHi;
		} else if (isNullable(incLo)) {
			incLo = incHi;
			incHi = 0;
		}
		this._state = new Int32Array([
			0,
			0,
			incHi >>> 0,
			((incLo || 0) | 1) >>> 0
		]);
		this._next();
		add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
		this._next();
		return this;
	}
	getState() {
		return [
			this._state[0],
			this._state[1],
			this._state[2],
			this._state[3]
		];
	}
	setState(state) {
		this._state[0] = state[0];
		this._state[1] = state[1];
		this._state[2] = state[2];
		this._state[3] = state[3] | 1;
	}
	integer(max$4) {
		return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max$4;
	}
	number() {
		const hi = (this._next() & 67108863) * 1;
		const lo = (this._next() & 134217727) * 1;
		return (hi * BIT_27 + lo) / BIT_53;
	}
	_next() {
		const oldHi = this._state[0] >>> 0;
		const oldLo = this._state[1] >>> 0;
		mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
		add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
		let xsHi = oldHi >>> 18;
		let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
		xsHi = (xsHi ^ oldHi) >>> 0;
		xsLo = (xsLo ^ oldLo) >>> 0;
		const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
		const rot = oldHi >>> 27;
		const rot2 = (-rot >>> 0 & 31) >>> 0;
		return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
	}
};
function mul64(out, aHi, aLo, bHi, bLo) {
	let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
	let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
	let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
	let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
	c0 = c0 << 16 >>> 0;
	lo = lo + c0 >>> 0;
	if (lo >>> 0 < c0 >>> 0) hi = hi + 1 >>> 0;
	c1 = c1 << 16 >>> 0;
	lo = lo + c1 >>> 0;
	if (lo >>> 0 < c1 >>> 0) hi = hi + 1 >>> 0;
	hi = hi + Math.imul(aLo, bHi) >>> 0;
	hi = hi + Math.imul(aHi, bLo) >>> 0;
	out[0] = hi;
	out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
	let hi = aHi + bHi >>> 0;
	const lo = aLo + bLo >>> 0;
	if (lo >>> 0 < aLo >>> 0) hi = hi + 1 | 0;
	out[0] = hi;
	out[1] = lo;
}
const YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
	#value;
	constructor(value$2) {
		this.#value = value$2;
	}
	[YieldWrapTypeId]() {
		return this.#value;
	}
};
function yieldWrapGet(self) {
	if (typeof self === "object" && self !== null && YieldWrapTypeId in self) return self[YieldWrapTypeId]();
	throw new Error(getBugErrorMessage("yieldWrapGet"));
}
const structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
	enabled: false,
	tester: void 0
}));
var standard = { effect_internal_function: (body) => {
	return body();
} };
const internalCall = /* @__PURE__ */ standard.effect_internal_function(() => (/* @__PURE__ */ new Error()).stack)?.includes("effect_internal_function") === true ? standard.effect_internal_function : { effect_internal_function: (body) => {
	try {
		return body();
	} finally {}
} }.effect_internal_function;
(function* () {}).constructor;
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
const symbol$1 = /* @__PURE__ */ Symbol.for("effect/Hash");
const hash = (self) => {
	if (structuralRegionState.enabled === true) return 0;
	switch (typeof self) {
		case "number": return number$3(self);
		case "bigint": return string$2(self.toString(10));
		case "boolean": return string$2(String(self));
		case "symbol": return string$2(String(self));
		case "string": return string$2(self);
		case "undefined": return string$2("undefined");
		case "function":
		case "object": if (self === null) return string$2("null");
		else if (self instanceof Date) {
			if (Number.isNaN(self.getTime())) return string$2("Invalid Date");
			return hash(self.toISOString());
		} else if (self instanceof URL) return hash(self.href);
		else if (isHash(self)) return self[symbol$1]();
		else return random$2(self);
		default: throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
	}
};
const random$2 = (self) => {
	if (!randomHashCache.has(self)) randomHashCache.set(self, number$3(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
	return randomHashCache.get(self);
};
const combine$11 = (b) => (self) => self * 53 ^ b;
const optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
const isHash = (u) => hasProperty(u, symbol$1);
const number$3 = (n) => {
	if (n !== n || n === Infinity) return 0;
	let h = n | 0;
	if (h !== n) h ^= n * 4294967295;
	while (n > 4294967295) h ^= n /= 4294967295;
	return optimize(h);
};
const string$2 = (str) => {
	let h = 5381, i = str.length;
	while (i) h = h * 33 ^ str.charCodeAt(--i);
	return optimize(h);
};
const structureKeys = (o, keys$5) => {
	let h = 12289;
	for (let i = 0; i < keys$5.length; i++) h ^= pipe(string$2(keys$5[i]), combine$11(hash(o[keys$5[i]])));
	return optimize(h);
};
const structure = (o) => structureKeys(o, Object.keys(o));
const array$3 = (arr) => {
	let h = 6151;
	for (let i = 0; i < arr.length; i++) h = pipe(h, combine$11(hash(arr[i])));
	return optimize(h);
};
const cached$2 = function() {
	if (arguments.length === 1) {
		const self$1 = arguments[0];
		return function(hash$2) {
			Object.defineProperty(self$1, symbol$1, {
				value() {
					return hash$2;
				},
				enumerable: false
			});
			return hash$2;
		};
	}
	const self = arguments[0];
	const hash$1 = arguments[1];
	Object.defineProperty(self, symbol$1, {
		value() {
			return hash$1;
		},
		enumerable: false
	});
	return hash$1;
};
const symbol = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
	if (arguments.length === 1) return (self) => compareBoth(self, arguments[0]);
	return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
	if (self === that) return true;
	const selfType = typeof self;
	if (selfType !== typeof that) return false;
	if (selfType === "object" || selfType === "function") {
		if (self !== null && that !== null) {
			if (isEqual(self) && isEqual(that)) if (hash(self) === hash(that) && self[symbol](that)) return true;
			else return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
			else if (self instanceof Date && that instanceof Date) {
				const t1 = self.getTime();
				const t2 = that.getTime();
				return t1 === t2 || Number.isNaN(t1) && Number.isNaN(t2);
			} else if (self instanceof URL && that instanceof URL) return self.href === that.href;
		}
		if (structuralRegionState.enabled) {
			if (Array.isArray(self) && Array.isArray(that)) return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
			if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
				const keysSelf = Object.keys(self);
				const keysThat = Object.keys(that);
				if (keysSelf.length === keysThat.length) {
					for (const key of keysSelf) if (!(key in that && compareBoth(self[key], that[key]))) return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
					return true;
				}
			}
			return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
		}
	}
	return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
const isEqual = (u) => hasProperty(u, symbol);
const equivalence = () => equals;
const NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
const toJSON = (x) => {
	try {
		if (hasProperty(x, "toJSON") && isFunction(x["toJSON"]) && x["toJSON"].length === 0) return x.toJSON();
		else if (Array.isArray(x)) return x.map(toJSON);
	} catch {
		return {};
	}
	return redact(x);
};
var CIRCULAR = "[Circular]";
function formatDate(date$2) {
	try {
		return date$2.toISOString();
	} catch {
		return "Invalid Date";
	}
}
function safeToString(input) {
	try {
		const s = input.toString();
		return typeof s === "string" ? s : String(s);
	} catch {
		return "[toString threw]";
	}
}
function formatPropertyKey$1(name) {
	return isString(name) ? JSON.stringify(name) : String(name);
}
function formatUnknown(input, options) {
	const space = options?.space ?? 0;
	const seen = /* @__PURE__ */ new WeakSet();
	const gap = !space ? "" : isNumber(space) ? " ".repeat(space) : space;
	const ind = (d) => gap.repeat(d);
	const wrap = (v, body) => {
		const ctor = v?.constructor;
		return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
	};
	const ownKeys = (o) => {
		try {
			return Reflect.ownKeys(o);
		} catch {
			return ["[ownKeys threw]"];
		}
	};
	function go$1(v, d = 0) {
		if (Array.isArray(v)) {
			if (seen.has(v)) return CIRCULAR;
			seen.add(v);
			if (!gap || v.length <= 1) return `[${v.map((x) => go$1(x, d)).join(",")}]`;
			const inner = v.map((x) => go$1(x, d + 1)).join(",\n" + ind(d + 1));
			return `[\n${ind(d + 1)}${inner}\n${ind(d)}]`;
		}
		if (isDate(v)) return formatDate(v);
		if (!options?.ignoreToString && hasProperty(v, "toString") && isFunction(v["toString"]) && v["toString"] !== Object.prototype.toString && v["toString"] !== Array.prototype.toString) {
			const s = safeToString(v);
			if (v instanceof Error && v.cause) return `${s} (cause: ${go$1(v.cause, d)})`;
			return s;
		}
		if (isString(v)) return JSON.stringify(v);
		if (isNumber(v) || v == null || isBoolean$1(v) || isSymbol(v)) return String(v);
		if (isBigInt(v)) return String(v) + "n";
		if (v instanceof Set || v instanceof Map) {
			if (seen.has(v)) return CIRCULAR;
			seen.add(v);
			return `${v.constructor.name}(${go$1(Array.from(v), d)})`;
		}
		if (isObject(v)) {
			if (seen.has(v)) return CIRCULAR;
			seen.add(v);
			const keys$5 = ownKeys(v);
			if (!gap || keys$5.length <= 1) return wrap(v, `{${keys$5.map((k) => `${formatPropertyKey$1(k)}:${go$1(v[k], d)}`).join(",")}}`);
			return wrap(v, `{\n${keys$5.map((k) => `${ind(d + 1)}${formatPropertyKey$1(k)}: ${go$1(v[k], d + 1)}`).join(",\n")}\n${ind(d)}}`);
		}
		return String(v);
	}
	return go$1(input, 0);
}
const format = (x) => JSON.stringify(x, null, 2);
const toStringUnknown = (u, whitespace = 2) => {
	if (typeof u === "string") return u;
	try {
		return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
	} catch {
		return String(u);
	}
};
const stringifyCircular = (obj, whitespace) => {
	let cache = [];
	const retVal = JSON.stringify(obj, (_key, value$2) => typeof value$2 === "object" && value$2 !== null ? cache.includes(value$2) ? void 0 : cache.push(value$2) && (redactableState.fiberRefs !== void 0 && isRedactable(value$2) ? value$2[symbolRedactable](redactableState.fiberRefs) : value$2) : value$2, whitespace);
	cache = void 0;
	return retVal;
};
const symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
const isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({ fiberRefs: void 0 }));
const withRedactableContext = (context$3, f) => {
	const prev = redactableState.fiberRefs;
	redactableState.fiberRefs = context$3;
	try {
		return f();
	} finally {
		redactableState.fiberRefs = prev;
	}
};
const redact = (u) => {
	if (isRedactable(u) && redactableState.fiberRefs !== void 0) return u[symbolRedactable](redactableState.fiberRefs);
	return u;
};
const pipeArguments = (self, args$1) => {
	switch (args$1.length) {
		case 0: return self;
		case 1: return args$1[0](self);
		case 2: return args$1[1](args$1[0](self));
		case 3: return args$1[2](args$1[1](args$1[0](self)));
		case 4: return args$1[3](args$1[2](args$1[1](args$1[0](self))));
		case 5: return args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self)))));
		case 6: return args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self))))));
		case 7: return args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self)))))));
		case 8: return args$1[7](args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self))))))));
		case 9: return args$1[8](args$1[7](args$1[6](args$1[5](args$1[4](args$1[3](args$1[2](args$1[1](args$1[0](self)))))))));
		default: {
			let ret = self;
			for (let i = 0, len = args$1.length; i < len; i++) ret = args$1[i](ret);
			return ret;
		}
	}
};
const OP_ASYNC = "Async";
const OP_COMMIT = "Commit";
const OP_FAILURE = "Failure";
const OP_ON_FAILURE = "OnFailure";
const OP_ON_SUCCESS = "OnSuccess";
const OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
const OP_SUCCESS = "Success";
const OP_SYNC = "Sync";
const OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
const OP_WHILE = "While";
const OP_ITERATOR = "Iterator";
const OP_WITH_RUNTIME = "WithRuntime";
const OP_YIELD = "Yield";
const OP_REVERT_FLAGS = "RevertFlags";
var moduleVersion = "3.19.12";
const getCurrentVersion = () => moduleVersion;
const EffectTypeId$3 = /* @__PURE__ */ Symbol.for("effect/Effect");
const StreamTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Stream");
const SinkTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Sink");
const ChannelTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Channel");
const effectVariance = {
	_R: (_) => _,
	_E: (_) => _,
	_A: (_) => _,
	_V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
	_A: (_) => _,
	_In: (_) => _,
	_L: (_) => _,
	_E: (_) => _,
	_R: (_) => _
};
var channelVariance = {
	_Env: (_) => _,
	_InErr: (_) => _,
	_InElem: (_) => _,
	_InDone: (_) => _,
	_OutErr: (_) => _,
	_OutElem: (_) => _,
	_OutDone: (_) => _
};
const EffectPrototype$1 = {
	[EffectTypeId$3]: effectVariance,
	[StreamTypeId$1]: effectVariance,
	[SinkTypeId$1]: sinkVariance,
	[ChannelTypeId$1]: channelVariance,
	[symbol](that) {
		return this === that;
	},
	[symbol$1]() {
		return cached$2(this, random$2(this));
	},
	[Symbol.iterator]() {
		return new SingleShotGen(new YieldWrap(this));
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const StructuralPrototype = {
	[symbol$1]() {
		return cached$2(this, structure(this));
	},
	[symbol](that) {
		const selfKeys = Object.keys(this);
		const thatKeys = Object.keys(that);
		if (selfKeys.length !== thatKeys.length) return false;
		for (const key of selfKeys) if (!(key in that && equals(this[key], that[key]))) return false;
		return true;
	}
};
const CommitPrototype$1 = {
	...EffectPrototype$1,
	_op: OP_COMMIT
};
const StructuralCommitPrototype$1 = {
	...CommitPrototype$1,
	...StructuralPrototype
};
const Base$1 = /* @__PURE__ */ function() {
	function Base$2() {}
	Base$2.prototype = CommitPrototype$1;
	return Base$2;
}();
var TypeId$17 = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto$1 = {
	...EffectPrototype$1,
	[TypeId$17]: { _A: (_) => _ },
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	toString() {
		return format(this.toJSON());
	}
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto$1), {
	_tag: "Some",
	_op: "Some",
	[symbol](that) {
		return isOption$1(that) && isSome$1(that) && equals(this.value, that.value);
	},
	[symbol$1]() {
		return cached$2(this, combine$11(hash(this._tag))(hash(this.value)));
	},
	toJSON() {
		return {
			_id: "Option",
			_tag: this._tag,
			value: toJSON(this.value)
		};
	}
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto$1), {
	_tag: "None",
	_op: "None",
	[symbol](that) {
		return isOption$1(that) && isNone$3(that);
	},
	[symbol$1]() {
		return NoneHash;
	},
	toJSON() {
		return {
			_id: "Option",
			_tag: this._tag
		};
	}
});
const isOption$1 = (input) => hasProperty(input, TypeId$17);
const isNone$3 = (fa) => fa._tag === "None";
const isSome$1 = (fa) => fa._tag === "Some";
const none$8 = /* @__PURE__ */ Object.create(NoneProto);
const some$5 = (value$2) => {
	const a = Object.create(SomeProto);
	a.value = value$2;
	return a;
};
const TypeId$16 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto = {
	...EffectPrototype$1,
	[TypeId$16]: { _R: (_) => _ },
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	toString() {
		return format(this.toJSON());
	}
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
	_tag: "Right",
	_op: "Right",
	[symbol](that) {
		return isEither$2(that) && isRight$1(that) && equals(this.right, that.right);
	},
	[symbol$1]() {
		return combine$11(hash(this._tag))(hash(this.right));
	},
	toJSON() {
		return {
			_id: "Either",
			_tag: this._tag,
			right: toJSON(this.right)
		};
	}
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
	_tag: "Left",
	_op: "Left",
	[symbol](that) {
		return isEither$2(that) && isLeft$1(that) && equals(this.left, that.left);
	},
	[symbol$1]() {
		return combine$11(hash(this._tag))(hash(this.left));
	},
	toJSON() {
		return {
			_id: "Either",
			_tag: this._tag,
			left: toJSON(this.left)
		};
	}
});
const isEither$2 = (input) => hasProperty(input, TypeId$16);
const isLeft$1 = (ma) => ma._tag === "Left";
const isRight$1 = (ma) => ma._tag === "Right";
const left$1 = (left$2) => {
	const a = Object.create(LeftProto);
	a.left = left$2;
	return a;
};
const right$1 = (right$2) => {
	const a = Object.create(RightProto);
	a.right = right$2;
	return a;
};
const right = right$1;
const left = left$1;
const isEither$1 = isEither$2;
const isLeft = isLeft$1;
const isRight = isRight$1;
const mapLeft = /* @__PURE__ */ dual(2, (self, f) => isLeft(self) ? left(f(self.left)) : right(self.right));
const map$20 = /* @__PURE__ */ dual(2, (self, f) => isRight(self) ? right(f(self.right)) : left(self.left));
const match$14 = /* @__PURE__ */ dual(2, (self, { onLeft, onRight }) => isLeft(self) ? onLeft(self.left) : onRight(self.right));
const merge$6 = /* @__PURE__ */ match$14({
	onLeft: identity,
	onRight: identity
});
const getOrThrowWith$1 = /* @__PURE__ */ dual(2, (self, onLeft) => {
	if (isRight(self)) return self.right;
	throw onLeft(self.left);
});
const getOrThrow$1 = /* @__PURE__ */ getOrThrowWith$1(() => /* @__PURE__ */ new Error("getOrThrow called on a Left"));
const isNonEmptyArray$1 = (self) => self.length > 0;
const make$47 = (compare$1) => (self, that) => self === that ? 0 : compare$1(self, that);
const number$2 = /* @__PURE__ */ make$47((self, that) => self < that ? -1 : 1);
const mapInput = /* @__PURE__ */ dual(2, (self, f) => make$47((b1, b2) => self(f(b1), f(b2))));
const greaterThan$3 = (O) => dual(2, (self, that) => O(self, that) === 1);
const none$7 = () => none$8;
const some$4 = some$5;
const isNone$2 = isNone$3;
const isSome = isSome$1;
const match$13 = /* @__PURE__ */ dual(2, (self, { onNone, onSome }) => isNone$2(self) ? onNone() : onSome(self.value));
const getOrElse$5 = /* @__PURE__ */ dual(2, (self, onNone) => isNone$2(self) ? onNone() : self.value);
const orElse$9 = /* @__PURE__ */ dual(2, (self, that) => isNone$2(self) ? that() : self);
const orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone$2(self) ? some$4(onNone()) : self);
const fromNullable$2 = (nullableValue) => nullableValue == null ? none$7() : some$4(nullableValue);
const getOrUndefined = /* @__PURE__ */ getOrElse$5(constUndefined);
const liftThrowable = (f) => (...a) => {
	try {
		return some$4(f(...a));
	} catch {
		return none$7();
	}
};
const getOrThrow = /* @__PURE__ */ (/* @__PURE__ */ dual(2, (self, onNone) => {
	if (isSome(self)) return self.value;
	throw onNone();
}))(() => /* @__PURE__ */ new Error("getOrThrow called on a None"));
const map$19 = /* @__PURE__ */ dual(2, (self, f) => isNone$2(self) ? none$7() : some$4(f(self.value)));
const flatMap$13 = /* @__PURE__ */ dual(2, (self, f) => isNone$2(self) ? none$7() : f(self.value));
const flatMapNullable = /* @__PURE__ */ dual(2, (self, f) => isNone$2(self) ? none$7() : fromNullable$2(f(self.value)));
const all$6 = (input) => {
	if (Symbol.iterator in input) {
		const out$1 = [];
		for (const o of input) {
			if (isNone$2(o)) return none$7();
			out$1.push(o.value);
		}
		return some$4(out$1);
	}
	const out = {};
	for (const key of Object.keys(input)) {
		const o = input[key];
		if (isNone$2(o)) return none$7();
		out[key] = o.value;
	}
	return some$4(out);
};
const containsWith$2 = (isEquivalent) => dual(2, (self, a) => isNone$2(self) ? false : isEquivalent(self.value, a));
const contains$4 = /* @__PURE__ */ containsWith$2(/* @__PURE__ */ equivalence());
const exists$3 = /* @__PURE__ */ dual(2, (self, refinement) => isNone$2(self) ? false : refinement(self.value));
const mergeWith = (f) => (o1, o2) => {
	if (isNone$2(o1)) return o2;
	else if (isNone$2(o2)) return o1;
	return some$4(f(o1.value, o2.value));
};
const make$46 = (...elements) => elements;
const make$45 = (...elements) => elements;
const allocate = (n) => new Array(n);
const makeBy = /* @__PURE__ */ dual(2, (n, f) => {
	const max$4 = Math.max(1, Math.floor(n));
	const out = new Array(max$4);
	for (let i = 0; i < max$4; i++) out[i] = f(i);
	return out;
});
const fromIterable$10 = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
const ensure = (self) => Array.isArray(self) ? self : [self];
const match$12 = /* @__PURE__ */ dual(2, (self, { onEmpty, onNonEmpty }) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
const matchLeft = /* @__PURE__ */ dual(2, (self, { onEmpty, onNonEmpty }) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty$1(self), tailNonEmpty$1(self)) : onEmpty());
const prepend$2 = /* @__PURE__ */ dual(2, (self, head$4) => [head$4, ...self]);
const append$2 = /* @__PURE__ */ dual(2, (self, last$3) => [...self, last$3]);
const appendAll$2 = /* @__PURE__ */ dual(2, (self, that) => fromIterable$10(self).concat(fromIterable$10(that)));
const isArray = Array.isArray;
const isEmptyArray = (self) => self.length === 0;
const isEmptyReadonlyArray = isEmptyArray;
const isNonEmptyArray = isNonEmptyArray$1;
const isNonEmptyReadonlyArray = isNonEmptyArray$1;
var isOutOfBounds = (i, as$6) => i < 0 || i >= as$6.length;
var clamp = (i, as$6) => Math.floor(Math.min(Math.max(0, i), as$6.length));
const get$11 = /* @__PURE__ */ dual(2, (self, index) => {
	const i = Math.floor(index);
	return isOutOfBounds(i, self) ? none$7() : some$4(self[i]);
});
const unsafeGet$5 = /* @__PURE__ */ dual(2, (self, index) => {
	const i = Math.floor(index);
	if (isOutOfBounds(i, self)) throw new Error(`Index ${i} out of bounds`);
	return self[i];
});
const head$3 = /* @__PURE__ */ get$11(0);
const headNonEmpty$1 = /* @__PURE__ */ unsafeGet$5(0);
const last$2 = (self) => isNonEmptyReadonlyArray(self) ? some$4(lastNonEmpty(self)) : none$7();
const lastNonEmpty = (self) => self[self.length - 1];
const tailNonEmpty$1 = (self) => self.slice(1);
var spanIndex = (self, predicate) => {
	let i = 0;
	for (const a of self) {
		if (!predicate(a, i)) break;
		i++;
	}
	return i;
};
const span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
const drop$1 = /* @__PURE__ */ dual(2, (self, n) => {
	const input = fromIterable$10(self);
	return input.slice(clamp(n, input), input.length);
});
const reverse$2 = (self) => Array.from(self).reverse();
const sort = /* @__PURE__ */ dual(2, (self, O) => {
	const out = Array.from(self);
	out.sort(O);
	return out;
});
const zip$8 = /* @__PURE__ */ dual(2, (self, that) => zipWith$7(self, that, make$46));
const zipWith$7 = /* @__PURE__ */ dual(3, (self, that, f) => {
	const as$6 = fromIterable$10(self);
	const bs = fromIterable$10(that);
	if (isNonEmptyReadonlyArray(as$6) && isNonEmptyReadonlyArray(bs)) {
		const out = [f(headNonEmpty$1(as$6), headNonEmpty$1(bs))];
		const len = Math.min(as$6.length, bs.length);
		for (let i = 1; i < len; i++) out[i] = f(as$6[i], bs[i]);
		return out;
	}
	return [];
});
var _equivalence$2 = /* @__PURE__ */ equivalence();
const splitAt = /* @__PURE__ */ dual(2, (self, n) => {
	const input = Array.from(self);
	const _n = Math.floor(n);
	if (isNonEmptyReadonlyArray(input)) {
		if (_n >= 1) return splitNonEmptyAt(input, _n);
		return [[], input];
	}
	return [input, []];
});
const splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
	const _n = Math.max(1, Math.floor(n));
	return _n >= self.length ? [copy$1(self), []] : [prepend$2(self.slice(1, _n), headNonEmpty$1(self)), self.slice(_n)];
});
const copy$1 = (self) => self.slice();
const unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
	const a = fromIterable$10(self);
	const b = fromIterable$10(that);
	if (isNonEmptyReadonlyArray(a)) {
		if (isNonEmptyReadonlyArray(b)) return dedupeWith(isEquivalent)(appendAll$2(a, b));
		return a;
	}
	return b;
});
const union$8 = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence$2));
const empty$34 = () => [];
const of$4 = (a) => [a];
const map$18 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
const flatMap$12 = /* @__PURE__ */ dual(2, (self, f) => {
	if (isEmptyReadonlyArray(self)) return [];
	const out = [];
	for (let i = 0; i < self.length; i++) {
		const inner = f(self[i], i);
		for (let j = 0; j < inner.length; j++) out.push(inner[j]);
	}
	return out;
});
const flatten$8 = /* @__PURE__ */ flatMap$12(identity);
const filterMap$4 = /* @__PURE__ */ dual(2, (self, f) => {
	const as$6 = fromIterable$10(self);
	const out = [];
	for (let i = 0; i < as$6.length; i++) {
		const o = f(as$6[i], i);
		if (isSome(o)) out.push(o.value);
	}
	return out;
});
const reduce$12 = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable$10(self).reduce((b$1, a, i) => f(b$1, a, i), b));
const reduceRight$3 = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable$10(self).reduceRight((b$1, a, i) => f(b$1, a, i), b));
const unfold$1 = (b, f) => {
	const out = [];
	let next = b;
	let o;
	while (isSome(o = f(next))) {
		const [a, b$1] = o.value;
		out.push(a);
		next = b$1;
	}
	return out;
};
const getEquivalence$3 = array$4;
const dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
	const input = fromIterable$10(self);
	if (isNonEmptyReadonlyArray(input)) {
		const out = [headNonEmpty$1(input)];
		const rest = tailNonEmpty$1(input);
		for (const r of rest) if (out.every((a) => !isEquivalent(r, a))) out.push(r);
		return out;
	}
	return [];
});
const dedupe = (self) => dedupeWith(self, equivalence());
const join$3 = /* @__PURE__ */ dual(2, (self, sep) => fromIterable$10(self).join(sep));
const getKeysForIndexSignature = (input, parameter) => {
	switch (parameter._tag) {
		case "StringKeyword":
		case "TemplateLiteral": return Object.keys(input);
		case "SymbolKeyword": return Object.getOwnPropertySymbols(input);
		case "Refinement": return getKeysForIndexSignature(input, parameter.from);
	}
};
const memoizeThunk = (f) => {
	let done$8 = false;
	let a;
	return () => {
		if (done$8) return a;
		a = f();
		done$8 = true;
		return a;
	};
};
const isNonEmpty$5 = (x) => Array.isArray(x);
const isSingle = (x) => !Array.isArray(x);
const formatPathKey = (key) => `[${formatPropertyKey$1(key)}]`;
const formatPath = (path$5) => isNonEmpty$5(path$5) ? path$5.map(formatPathKey).join("") : formatPathKey(path$5);
var getErrorMessage = (reason, details, path$5, ast) => {
	let out = reason;
	if (path$5 && isNonEmptyReadonlyArray(path$5)) out += `\nat path: ${formatPath(path$5)}`;
	if (details !== void 0) out += `\ndetails: ${details}`;
	if (ast) out += `\nschema (${ast._tag}): ${ast}`;
	return out;
};
const getSchemaExtendErrorMessage = (x, y, path$5) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path$5);
const getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast);
const getASTUnsupportedLiteralErrorMessage = (literal$2) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal$2)}`);
const getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
const getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
const getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
const getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
const getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);
const MinLengthSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinLength");
const Order$4 = number$2;
const escape = (string$3) => string$3.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");
const BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
const SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
const MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
const MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
const IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
const TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
const AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
const DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
const ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
const DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
const JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
const ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
const PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
const EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
const DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
const ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
const BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
const ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
const ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
const DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
const SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
const StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
const getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some$4(annotated.annotations[key]) : none$7());
const getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
const getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
const getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
const getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
const getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
const getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
const getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
const getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
const getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
const getParseIssueTitleAnnotation$1 = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
const getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
const getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
const getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
const hasStableFilter = (annotated) => exists$3(getStableFilterAnnotation(annotated), (b) => b === true);
const JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
const getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
const getJSONIdentifier = (annotated) => orElse$9(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
var Declaration = class {
	typeParameters;
	decodeUnknown;
	encodeUnknown;
	annotations;
	_tag = "Declaration";
	constructor(typeParameters, decodeUnknown$3, encodeUnknown$1, annotations$1 = {}) {
		this.typeParameters = typeParameters;
		this.decodeUnknown = decodeUnknown$3;
		this.encodeUnknown = encodeUnknown$1;
		this.annotations = annotations$1;
	}
	toString() {
		return getOrElse$5(getExpected(this), () => "<declaration schema>");
	}
	toJSON() {
		return {
			_tag: this._tag,
			typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
var createASTGuard = (tag) => (ast) => ast._tag === tag;
var Literal$1 = class {
	literal;
	annotations;
	_tag = "Literal";
	constructor(literal$2, annotations$1 = {}) {
		this.literal = literal$2;
		this.annotations = annotations$1;
	}
	toString() {
		return getOrElse$5(getExpected(this), () => formatUnknown(this.literal));
	}
	toJSON() {
		return {
			_tag: this._tag,
			literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const isLiteral = /* @__PURE__ */ createASTGuard("Literal");
var UniqueSymbol = class {
	symbol;
	annotations;
	_tag = "UniqueSymbol";
	constructor(symbol$2, annotations$1 = {}) {
		this.symbol = symbol$2;
		this.annotations = annotations$1;
	}
	toString() {
		return getOrElse$5(getExpected(this), () => formatUnknown(this.symbol));
	}
	toJSON() {
		return {
			_tag: this._tag,
			symbol: String(this.symbol),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
var NeverKeyword = class {
	annotations;
	_tag = "NeverKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	toString() {
		return formatKeyword(this);
	}
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const neverKeyword = /* @__PURE__ */ new NeverKeyword({ [TitleAnnotationId]: "never" });
var UnknownKeyword = class {
	annotations;
	_tag = "UnknownKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	toString() {
		return formatKeyword(this);
	}
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const unknownKeyword = /* @__PURE__ */ new UnknownKeyword({ [TitleAnnotationId]: "unknown" });
var AnyKeyword = class {
	annotations;
	_tag = "AnyKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	toString() {
		return formatKeyword(this);
	}
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const anyKeyword = /* @__PURE__ */ new AnyKeyword({ [TitleAnnotationId]: "any" });
var StringKeyword = class {
	annotations;
	_tag = "StringKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	toString() {
		return formatKeyword(this);
	}
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const stringKeyword = /* @__PURE__ */ new StringKeyword({
	[TitleAnnotationId]: "string",
	[DescriptionAnnotationId]: "a string"
});
const isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
var NumberKeyword = class {
	annotations;
	_tag = "NumberKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	toString() {
		return formatKeyword(this);
	}
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const numberKeyword = /* @__PURE__ */ new NumberKeyword({
	[TitleAnnotationId]: "number",
	[DescriptionAnnotationId]: "a number"
});
const isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
var BooleanKeyword = class {
	annotations;
	_tag = "BooleanKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	toString() {
		return formatKeyword(this);
	}
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
	[TitleAnnotationId]: "boolean",
	[DescriptionAnnotationId]: "a boolean"
});
const isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");
const isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
var Type$1 = class {
	type;
	annotations;
	constructor(type, annotations$1 = {}) {
		this.type = type;
		this.annotations = annotations$1;
	}
	toJSON() {
		return {
			type: this.type.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
	toString() {
		return String(this.type);
	}
};
var OptionalType = class extends Type$1 {
	isOptional;
	constructor(type, isOptional, annotations$1 = {}) {
		super(type, annotations$1);
		this.isOptional = isOptional;
	}
	toJSON() {
		return {
			type: this.type.toJSON(),
			isOptional: this.isOptional,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
	toString() {
		return String(this.type) + (this.isOptional ? "?" : "");
	}
};
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
var TupleType = class {
	elements;
	rest;
	isReadonly;
	annotations;
	_tag = "TupleType";
	constructor(elements, rest, isReadonly, annotations$1 = {}) {
		this.elements = elements;
		this.rest = rest;
		this.isReadonly = isReadonly;
		this.annotations = annotations$1;
		let hasOptionalElement = false;
		let hasIllegalRequiredElement = false;
		for (const e of elements) if (e.isOptional) hasOptionalElement = true;
		else if (hasOptionalElement) {
			hasIllegalRequiredElement = true;
			break;
		}
		if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
	}
	toString() {
		return getOrElse$5(getExpected(this), () => formatTuple(this));
	}
	toJSON() {
		return {
			_tag: this._tag,
			elements: this.elements.map((e) => e.toJSON()),
			rest: this.rest.map((ast) => ast.toJSON()),
			isReadonly: this.isReadonly,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
var formatTuple = (ast) => {
	const formattedElements = ast.elements.map(String).join(", ");
	return matchLeft(ast.rest, {
		onEmpty: () => `readonly [${formattedElements}]`,
		onNonEmpty: (head$4, tail) => {
			const formattedHead = String(head$4);
			const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
			if (tail.length > 0) {
				const formattedTail = tail.map(String).join(", ");
				if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
				else return `readonly [...${wrappedHead}[], ${formattedTail}]`;
			} else if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
			else return `ReadonlyArray<${formattedHead}>`;
		}
	});
};
var PropertySignature = class extends OptionalType {
	name;
	isReadonly;
	constructor(name, type, isOptional, isReadonly, annotations$1) {
		super(type, isOptional, annotations$1);
		this.name = name;
		this.isReadonly = isReadonly;
	}
	toString() {
		return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
	}
	toJSON() {
		return {
			name: String(this.name),
			type: this.type.toJSON(),
			isOptional: this.isOptional,
			isReadonly: this.isReadonly,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const isParameter = (ast) => {
	switch (ast._tag) {
		case "StringKeyword":
		case "SymbolKeyword":
		case "TemplateLiteral": return true;
		case "Refinement": return isParameter(ast.from);
	}
	return false;
};
var IndexSignature = class {
	type;
	isReadonly;
	parameter;
	constructor(parameter, type, isReadonly) {
		this.type = type;
		this.isReadonly = isReadonly;
		if (isParameter(parameter)) this.parameter = parameter;
		else throw new Error(getASTIndexSignatureParameterErrorMessage);
	}
	toString() {
		return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
	}
	toJSON() {
		return {
			parameter: this.parameter.toJSON(),
			type: this.type.toJSON(),
			isReadonly: this.isReadonly
		};
	}
};
var TypeLiteral = class {
	annotations;
	_tag = "TypeLiteral";
	propertySignatures;
	indexSignatures;
	constructor(propertySignatures, indexSignatures, annotations$1 = {}) {
		this.annotations = annotations$1;
		const keys$5 = {};
		for (let i = 0; i < propertySignatures.length; i++) {
			const name = propertySignatures[i].name;
			if (Object.prototype.hasOwnProperty.call(keys$5, name)) throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
			keys$5[name] = null;
		}
		const parameters = {
			string: false,
			symbol: false
		};
		for (let i = 0; i < indexSignatures.length; i++) {
			const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
			if (isStringKeyword(encodedParameter)) {
				if (parameters.string) throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
				parameters.string = true;
			} else if (isSymbolKeyword(encodedParameter)) {
				if (parameters.symbol) throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
				parameters.symbol = true;
			}
		}
		this.propertySignatures = propertySignatures;
		this.indexSignatures = indexSignatures;
	}
	toString() {
		return getOrElse$5(getExpected(this), () => formatTypeLiteral(this));
	}
	toJSON() {
		return {
			_tag: this._tag,
			propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
			indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
	if (ast.propertySignatures.length > 0) {
		const pss = ast.propertySignatures.map(String).join("; ");
		if (ast.indexSignatures.length > 0) return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
		else return `{ ${pss} }`;
	} else if (ast.indexSignatures.length > 0) return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
	else return "{}";
};
const isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput(Order$4, (ast) => {
	switch (ast._tag) {
		case "AnyKeyword": return 0;
		case "UnknownKeyword": return 1;
		case "ObjectKeyword": return 2;
		case "StringKeyword":
		case "NumberKeyword":
		case "BooleanKeyword":
		case "BigIntKeyword":
		case "SymbolKeyword": return 3;
	}
	return 4;
}));
var literalMap = {
	string: "StringKeyword",
	number: "NumberKeyword",
	boolean: "BooleanKeyword",
	bigint: "BigIntKeyword"
};
const flatten$7 = (candidates) => flatMap$12(candidates, (ast) => isUnion(ast) ? flatten$7(ast.types) : [ast]);
const unify = (candidates) => {
	const cs = sortCandidates(candidates);
	const out = [];
	const uniques = {};
	const literals = [];
	for (const ast of cs) switch (ast._tag) {
		case "NeverKeyword": break;
		case "AnyKeyword": return [anyKeyword];
		case "UnknownKeyword": return [unknownKeyword];
		case "ObjectKeyword":
		case "UndefinedKeyword":
		case "VoidKeyword":
		case "StringKeyword":
		case "NumberKeyword":
		case "BooleanKeyword":
		case "BigIntKeyword":
		case "SymbolKeyword":
			if (!uniques[ast._tag]) {
				uniques[ast._tag] = ast;
				out.push(ast);
			}
			break;
		case "Literal": {
			const type = typeof ast.literal;
			switch (type) {
				case "string":
				case "number":
				case "bigint":
				case "boolean":
					if (!uniques[literalMap[type]] && !literals.includes(ast.literal)) {
						literals.push(ast.literal);
						out.push(ast);
					}
					break;
				case "object":
					if (!literals.includes(ast.literal)) {
						literals.push(ast.literal);
						out.push(ast);
					}
					break;
			}
			break;
		}
		case "UniqueSymbol":
			if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
				literals.push(ast.symbol);
				out.push(ast);
			}
			break;
		case "TupleType":
			if (!uniques["ObjectKeyword"]) out.push(ast);
			break;
		case "TypeLiteral":
			if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
				if (!uniques["{}"]) {
					uniques["{}"] = ast;
					out.push(ast);
				}
			} else if (!uniques["ObjectKeyword"]) out.push(ast);
			break;
		default: out.push(ast);
	}
	return out;
};
var Union = class Union {
	types;
	annotations;
	static make = (types$5, annotations$1) => {
		return isMembers(types$5) ? new Union(types$5, annotations$1) : types$5.length === 1 ? types$5[0] : neverKeyword;
	};
	static unify = (candidates, annotations$1) => {
		return Union.make(unify(flatten$7(candidates)), annotations$1);
	};
	_tag = "Union";
	constructor(types$5, annotations$1 = {}) {
		this.types = types$5;
		this.annotations = annotations$1;
	}
	toString() {
		return getOrElse$5(getExpected(this), () => this.types.map(String).join(" | "));
	}
	toJSON() {
		return {
			_tag: this._tag,
			types: this.types.map((ast) => ast.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const mapMembers = (members, f) => members.map(f);
const isMembers = (as$6) => as$6.length > 1;
const isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
	f;
	annotations;
	_tag = "Suspend";
	constructor(f, annotations$1 = {}) {
		this.f = f;
		this.annotations = annotations$1;
		this.f = memoizeThunk(f);
	}
	toString() {
		return getExpected(this).pipe(orElse$9(() => flatMap$13(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse$5(() => "<suspended schema>"));
	}
	toJSON() {
		const ast = this.f();
		let out = toJSONMemoMap.get(ast);
		if (out) return out;
		toJSONMemoMap.set(ast, { _tag: this._tag });
		out = {
			_tag: this._tag,
			ast: ast.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
		toJSONMemoMap.set(ast, out);
		return out;
	}
};
var Refinement$1 = class {
	from;
	filter;
	annotations;
	_tag = "Refinement";
	constructor(from, filter$9, annotations$1 = {}) {
		this.from = from;
		this.filter = filter$9;
		this.annotations = annotations$1;
	}
	toString() {
		return getIdentifierAnnotation(this).pipe(getOrElse$5(() => match$13(getOrElseExpected(this), {
			onNone: () => `{ ${this.from} | filter }`,
			onSome: (expected) => isRefinement$1(this.from) ? String(this.from) + " & " + expected : expected
		})));
	}
	toJSON() {
		return {
			_tag: this._tag,
			from: this.from.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const isRefinement$1 = /* @__PURE__ */ createASTGuard("Refinement");
const defaultParseOption = {};
var Transformation$1 = class {
	from;
	to;
	transformation;
	annotations;
	_tag = "Transformation";
	constructor(from, to, transformation, annotations$1 = {}) {
		this.from = from;
		this.to = to;
		this.transformation = transformation;
		this.annotations = annotations$1;
	}
	toString() {
		return getOrElse$5(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
	}
	toJSON() {
		return {
			_tag: this._tag,
			from: this.from.toJSON(),
			to: this.to.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const isTransformation$1 = /* @__PURE__ */ createASTGuard("Transformation");
var FinalTransformation = class {
	decode;
	encode;
	_tag = "FinalTransformation";
	constructor(decode$4, encode$3) {
		this.decode = decode$4;
		this.encode = encode$3;
	}
};
var createTransformationGuard = (tag) => (ast) => ast._tag === tag;
var ComposeTransformation = class {
	_tag = "ComposeTransformation";
};
const composeTransformation = /* @__PURE__ */ new ComposeTransformation();
var PropertySignatureTransformation$1 = class {
	from;
	to;
	decode;
	encode;
	constructor(from, to, decode$4, encode$3) {
		this.from = from;
		this.to = to;
		this.decode = decode$4;
		this.encode = encode$3;
	}
};
var TypeLiteralTransformation = class {
	propertySignatureTransformations;
	_tag = "TypeLiteralTransformation";
	constructor(propertySignatureTransformations) {
		this.propertySignatureTransformations = propertySignatureTransformations;
		const fromKeys = {};
		const toKeys = {};
		for (const pst of propertySignatureTransformations) {
			const from = pst.from;
			if (fromKeys[from]) throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
			fromKeys[from] = true;
			const to = pst.to;
			if (toKeys[to]) throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
			toKeys[to] = true;
		}
	}
};
const isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
const annotations = (ast, overrides) => {
	const d = Object.getOwnPropertyDescriptors(ast);
	const base = { ...ast.annotations };
	delete base[IdentifierAnnotationId];
	const value$2 = {
		...base,
		...overrides
	};
	const surrogate = getSurrogateAnnotation(ast);
	if (isSome(surrogate)) value$2[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
	d.annotations.value = value$2;
	return Object.create(Object.getPrototypeOf(ast), d);
};
var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type, capture$1) => {
	switch (type._tag) {
		case "Literal": return escape(String(type.literal));
		case "StringKeyword": return STRING_KEYWORD_PATTERN;
		case "NumberKeyword": return NUMBER_KEYWORD_PATTERN;
		case "TemplateLiteral": return getTemplateLiteralPattern(type, capture$1, false);
		case "Union": return type.types.map((type$1) => getTemplateLiteralSpanTypePattern(type$1, capture$1)).join("|");
	}
};
var handleTemplateLiteralSpanTypeParens = (type, s, capture$1, top) => {
	if (isUnion(type)) {
		if (capture$1 && !top) return `(?:${s})`;
	} else if (!capture$1 || !top) return s;
	return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture$1, top) => {
	let pattern$1 = ``;
	if (ast.head !== "") {
		const head$4 = escape(ast.head);
		pattern$1 += capture$1 && top ? `(${head$4})` : head$4;
	}
	for (const span$1 of ast.spans) {
		const spanPattern = getTemplateLiteralSpanTypePattern(span$1.type, capture$1);
		pattern$1 += handleTemplateLiteralSpanTypeParens(span$1.type, spanPattern, capture$1, top);
		if (span$1.literal !== "") {
			const literal$2 = escape(span$1.literal);
			pattern$1 += capture$1 && top ? `(${literal$2})` : literal$2;
		}
	}
	return pattern$1;
};
const getTemplateLiteralRegExp = (ast) => /* @__PURE__ */ new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
const record = (key, value$2) => {
	const propertySignatures = [];
	const indexSignatures = [];
	const go$1 = (key$1) => {
		switch (key$1._tag) {
			case "NeverKeyword": break;
			case "StringKeyword":
			case "SymbolKeyword":
			case "TemplateLiteral":
			case "Refinement":
				indexSignatures.push(new IndexSignature(key$1, value$2, true));
				break;
			case "Literal":
				if (isString(key$1.literal) || isNumber(key$1.literal)) propertySignatures.push(new PropertySignature(key$1.literal, value$2, false, true));
				else throw new Error(getASTUnsupportedLiteralErrorMessage(key$1.literal));
				break;
			case "Enums":
				for (const [_, name] of key$1.enums) propertySignatures.push(new PropertySignature(name, value$2, false, true));
				break;
			case "UniqueSymbol":
				propertySignatures.push(new PropertySignature(key$1.symbol, value$2, false, true));
				break;
			case "Union":
				key$1.types.forEach(go$1);
				break;
			default: throw new Error(getASTUnsupportedKeySchemaErrorMessage(key$1));
		}
	};
	go$1(key);
	return {
		propertySignatures,
		indexSignatures
	};
};
const pickAnnotations = (annotationIds) => (annotated) => {
	let out = void 0;
	for (const id$2 of annotationIds) if (Object.prototype.hasOwnProperty.call(annotated.annotations, id$2)) {
		if (out === void 0) out = {};
		out[id$2] = annotated.annotations[id$2];
	}
	return out;
};
const omitAnnotations = (annotationIds) => (annotated) => {
	const out = { ...annotated.annotations };
	for (const id$2 of annotationIds) delete out[id$2];
	return out;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([
	ExamplesAnnotationId,
	DefaultAnnotationId,
	JSONSchemaAnnotationId,
	ArbitraryAnnotationId,
	PrettyAnnotationId,
	EquivalenceAnnotationId
]);
const typeAST = (ast) => {
	switch (ast._tag) {
		case "Declaration": {
			const typeParameters = changeMap(ast.typeParameters, typeAST);
			return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
		}
		case "TupleType": {
			const elements = changeMap(ast.elements, (e) => {
				const type = typeAST(e.type);
				return type === e.type ? e : new OptionalType(type, e.isOptional);
			});
			const restASTs = getRestASTs(ast.rest);
			const rest = changeMap(restASTs, typeAST);
			return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type$1(type)), ast.isReadonly, ast.annotations);
		}
		case "TypeLiteral": {
			const propertySignatures = changeMap(ast.propertySignatures, (p) => {
				const type = typeAST(p.type);
				return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
			});
			const indexSignatures = changeMap(ast.indexSignatures, (is$1) => {
				const type = typeAST(is$1.type);
				return type === is$1.type ? is$1 : new IndexSignature(is$1.parameter, type, is$1.isReadonly);
			});
			return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
		}
		case "Union": {
			const types$5 = changeMap(ast.types, typeAST);
			return types$5 === ast.types ? ast : Union.make(types$5, ast.annotations);
		}
		case "Suspend": return new Suspend(() => typeAST(ast.f()), ast.annotations);
		case "Refinement": {
			const from = typeAST(ast.from);
			return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations);
		}
		case "Transformation": {
			const preserve = preserveTransformationAnnotations(ast);
			return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
		}
	}
	return ast;
};
function changeMap(as$6, f) {
	let changed = false;
	const out = allocate(as$6.length);
	for (let i = 0; i < as$6.length; i++) {
		const a = as$6[i];
		const fa = f(a);
		if (fa !== a) changed = true;
		out[i] = fa;
	}
	return changed ? out : as$6;
}
const getTransformationFrom = (ast) => {
	switch (ast._tag) {
		case "Transformation": return ast.from;
		case "Refinement": return getTransformationFrom(ast.from);
		case "Suspend": return getTransformationFrom(ast.f());
	}
};
var encodedAST_ = (ast, isBound) => {
	switch (ast._tag) {
		case "Declaration": {
			const typeParameters = changeMap(ast.typeParameters, (ast$1) => encodedAST_(ast$1, isBound));
			return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
		}
		case "TupleType": {
			const elements = changeMap(ast.elements, (e) => {
				const type = encodedAST_(e.type, isBound);
				return type === e.type ? e : new OptionalType(type, e.isOptional);
			});
			const restASTs = getRestASTs(ast.rest);
			const rest = changeMap(restASTs, (ast$1) => encodedAST_(ast$1, isBound));
			return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast$1) => new Type$1(ast$1)), ast.isReadonly);
		}
		case "TypeLiteral": {
			const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
				const type = encodedAST_(ps.type, isBound);
				return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
			});
			const indexSignatures = changeMap(ast.indexSignatures, (is$1) => {
				const type = encodedAST_(is$1.type, isBound);
				return type === is$1.type ? is$1 : new IndexSignature(is$1.parameter, type, is$1.isReadonly);
			});
			return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
		}
		case "Union": {
			const types$5 = changeMap(ast.types, (ast$1) => encodedAST_(ast$1, isBound));
			return types$5 === ast.types ? ast : Union.make(types$5);
		}
		case "Suspend": {
			let borrowedAnnotations = void 0;
			const identifier$1 = getJSONIdentifier(ast);
			if (isSome(identifier$1)) {
				const suffix = isBound ? "Bound" : "";
				borrowedAnnotations = { [JSONIdentifierAnnotationId]: `${identifier$1.value}Encoded${suffix}` };
			}
			return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
		}
		case "Refinement": {
			const from = encodedAST_(ast.from, isBound);
			if (isBound) {
				if (from === ast.from) return ast;
				if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) return new Refinement$1(from, ast.filter, ast.annotations);
				return from;
			} else return from;
		}
		case "Transformation": return encodedAST_(ast.from, isBound);
	}
	return ast;
};
const encodedAST = (ast) => encodedAST_(ast, false);
var toJSONAnnotations = (annotations$1) => {
	const out = {};
	for (const k of Object.getOwnPropertySymbols(annotations$1)) out[String(k)] = annotations$1[k];
	return out;
};
const getEncodedParameter = (ast) => {
	switch (ast._tag) {
		case "StringKeyword":
		case "SymbolKeyword":
		case "TemplateLiteral": return ast;
		case "Refinement": return getEncodedParameter(ast.from);
	}
};
var formatKeyword = (ast) => getOrElse$5(getExpected(ast), () => ast._tag);
function getBrands(ast) {
	return match$13(getBrandAnnotation(ast), {
		onNone: () => "",
		onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
	});
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse$9(() => getDescriptionAnnotation(ast)), orElse$9(() => getAutoTitleAnnotation(ast)), map$19((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse$9(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
const TagTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
const ReferenceTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
const STMTypeId = /* @__PURE__ */ Symbol.for("effect/STM");
const TagProto = {
	...EffectPrototype$1,
	_op: "Tag",
	[STMTypeId]: effectVariance,
	[TagTypeId$1]: {
		_Service: (_) => _,
		_Identifier: (_) => _
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Tag",
			key: this.key,
			stack: this.stack
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	of(self) {
		return self;
	},
	context(self) {
		return make$44(this, self);
	}
};
const ReferenceProto = {
	...TagProto,
	[ReferenceTypeId$1]: ReferenceTypeId$1
};
const makeGenericTag = (key) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 2;
	const creationError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	const tag = Object.create(TagProto);
	Object.defineProperty(tag, "stack", { get() {
		return creationError.stack;
	} });
	tag.key = key;
	return tag;
};
const Reference$1 = () => (id$2, options) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 2;
	const creationError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	function ReferenceClass() {}
	Object.setPrototypeOf(ReferenceClass, ReferenceProto);
	ReferenceClass.key = id$2;
	ReferenceClass.defaultValue = options.defaultValue;
	Object.defineProperty(ReferenceClass, "stack", { get() {
		return creationError.stack;
	} });
	return ReferenceClass;
};
const TypeId$14 = /* @__PURE__ */ Symbol.for("effect/Context");
const ContextProto = {
	[TypeId$14]: { _Services: (_) => _ },
	[symbol](that) {
		if (isContext$1(that)) {
			if (this.unsafeMap.size === that.unsafeMap.size) {
				for (const k of this.unsafeMap.keys()) if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) return false;
				return true;
			}
		}
		return false;
	},
	[symbol$1]() {
		return cached$2(this, number$3(this.unsafeMap.size));
	},
	pipe() {
		return pipeArguments(this, arguments);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Context",
			services: Array.from(this.unsafeMap).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
const makeContext = (unsafeMap) => {
	const context$3 = Object.create(ContextProto);
	context$3.unsafeMap = unsafeMap;
	return context$3;
};
var serviceNotFoundError = (tag) => {
	const error = /* @__PURE__ */ new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
	if (tag.stack) {
		const lines = tag.stack.split("\n");
		if (lines.length > 2) {
			const afterAt = lines[2].match(/at (.*)/);
			if (afterAt) error.message = error.message + ` (defined at ${afterAt[1]})`;
		}
	}
	if (error.stack) {
		const lines = error.stack.split("\n");
		lines.splice(1, 3);
		error.stack = lines.join("\n");
	}
	return error;
};
const isContext$1 = (u) => hasProperty(u, TypeId$14);
const isTag$1 = (u) => hasProperty(u, TagTypeId$1);
const isReference$1 = (u) => hasProperty(u, ReferenceTypeId$1);
var _empty$9 = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
const empty$33 = () => _empty$9;
const make$44 = (tag, service$1) => makeContext(new Map([[tag.key, service$1]]));
const add$4 = /* @__PURE__ */ dual(3, (self, tag, service$1) => {
	const map$21 = new Map(self.unsafeMap);
	map$21.set(tag.key, service$1);
	return makeContext(map$21);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = (tag) => {
	if (defaultValueCache.has(tag.key)) return defaultValueCache.get(tag.key);
	const value$2 = tag.defaultValue();
	defaultValueCache.set(tag.key, value$2);
	return value$2;
};
const unsafeGetReference = (self, tag) => {
	return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
const unsafeGet$4 = /* @__PURE__ */ dual(2, (self, tag) => {
	if (!self.unsafeMap.has(tag.key)) {
		if (ReferenceTypeId$1 in tag) return getDefaultValue(tag);
		throw serviceNotFoundError(tag);
	}
	return self.unsafeMap.get(tag.key);
});
const get$10 = unsafeGet$4;
const getOption$1 = /* @__PURE__ */ dual(2, (self, tag) => {
	if (!self.unsafeMap.has(tag.key)) return isReference$1(tag) ? some$5(getDefaultValue(tag)) : none$8;
	return some$5(self.unsafeMap.get(tag.key));
});
const merge$5 = /* @__PURE__ */ dual(2, (self, that) => {
	const map$21 = new Map(self.unsafeMap);
	for (const [tag, s] of that.unsafeMap) map$21.set(tag, s);
	return makeContext(map$21);
});
const mergeAll$4 = (...ctxs) => {
	const map$21 = /* @__PURE__ */ new Map();
	for (let i = 0; i < ctxs.length; i++) ctxs[i].unsafeMap.forEach((value$2, key) => {
		map$21.set(key, value$2);
	});
	return makeContext(map$21);
};
const GenericTag = makeGenericTag;
const isContext = isContext$1;
const isTag = isTag$1;
const empty$32 = empty$33;
const make$43 = make$44;
const add$3 = add$4;
const get$9 = get$10;
const unsafeGet$3 = unsafeGet$4;
const getOption = getOption$1;
const merge$4 = merge$5;
const mergeAll$3 = mergeAll$4;
const Reference = Reference$1;
var TypeId$13 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy(src, srcPos, dest, destPos, len) {
	for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) dest[destPos + i - srcPos] = src[i];
	return dest;
}
var emptyArray = [];
const getEquivalence$2 = (isEquivalent) => make$48((self, that) => self.length === that.length && toReadonlyArray(self).every((value$2, i) => isEquivalent(value$2, unsafeGet$2(that, i))));
var _equivalence$1 = /* @__PURE__ */ getEquivalence$2(equals);
var ChunkProto = {
	[TypeId$13]: { _A: (_) => _ },
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Chunk",
			values: toReadonlyArray(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol](that) {
		return isChunk(that) && _equivalence$1(this, that);
	},
	[symbol$1]() {
		return cached$2(this, array$3(toReadonlyArray(this)));
	},
	[Symbol.iterator]() {
		switch (this.backing._tag) {
			case "IArray": return this.backing.array[Symbol.iterator]();
			case "IEmpty": return emptyArray[Symbol.iterator]();
			default: return toReadonlyArray(this)[Symbol.iterator]();
		}
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var makeChunk = (backing) => {
	const chunk$4 = Object.create(ChunkProto);
	chunk$4.backing = backing;
	switch (backing._tag) {
		case "IEmpty":
			chunk$4.length = 0;
			chunk$4.depth = 0;
			chunk$4.left = chunk$4;
			chunk$4.right = chunk$4;
			break;
		case "IConcat":
			chunk$4.length = backing.left.length + backing.right.length;
			chunk$4.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
			chunk$4.left = backing.left;
			chunk$4.right = backing.right;
			break;
		case "IArray":
			chunk$4.length = backing.array.length;
			chunk$4.depth = 0;
			chunk$4.left = _empty$8;
			chunk$4.right = _empty$8;
			break;
		case "ISingleton":
			chunk$4.length = 1;
			chunk$4.depth = 0;
			chunk$4.left = _empty$8;
			chunk$4.right = _empty$8;
			break;
		case "ISlice":
			chunk$4.length = backing.length;
			chunk$4.depth = backing.chunk.depth + 1;
			chunk$4.left = _empty$8;
			chunk$4.right = _empty$8;
			break;
	}
	return chunk$4;
};
const isChunk = (u) => hasProperty(u, TypeId$13);
var _empty$8 = /* @__PURE__ */ makeChunk({ _tag: "IEmpty" });
const empty$31 = () => _empty$8;
const make$42 = (...as$6) => unsafeFromNonEmptyArray(as$6);
const of$3 = (a) => makeChunk({
	_tag: "ISingleton",
	a
});
const fromIterable$9 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable$10(self));
var copyToArray = (self, array$5, initial) => {
	switch (self.backing._tag) {
		case "IArray":
			copy(self.backing.array, 0, array$5, initial, self.length);
			break;
		case "IConcat":
			copyToArray(self.left, array$5, initial);
			copyToArray(self.right, array$5, initial + self.left.length);
			break;
		case "ISingleton":
			array$5[initial] = self.backing.a;
			break;
		case "ISlice": {
			let i = 0;
			let j = initial;
			while (i < self.length) {
				array$5[j] = unsafeGet$2(self, i);
				i += 1;
				j += 1;
			}
			break;
		}
	}
};
var toReadonlyArray_ = (self) => {
	switch (self.backing._tag) {
		case "IEmpty": return emptyArray;
		case "IArray": return self.backing.array;
		default: {
			const arr = new Array(self.length);
			copyToArray(self, arr, 0);
			self.backing = {
				_tag: "IArray",
				array: arr
			};
			self.left = _empty$8;
			self.right = _empty$8;
			self.depth = 0;
			return arr;
		}
	}
};
const toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
	switch (self.backing._tag) {
		case "IEmpty":
		case "ISingleton": return self;
		case "IArray": return makeChunk({
			_tag: "IArray",
			array: reverse$2(self.backing.array)
		});
		case "IConcat": return makeChunk({
			_tag: "IConcat",
			left: reverse$1(self.backing.right),
			right: reverse$1(self.backing.left)
		});
		case "ISlice": return unsafeFromArray(reverse$2(toReadonlyArray(self)));
	}
};
const reverse$1 = reverseChunk;
const get$8 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none$7() : some$4(unsafeGet$2(self, index)));
const unsafeFromArray = (self) => self.length === 0 ? empty$31() : self.length === 1 ? of$3(self[0]) : makeChunk({
	_tag: "IArray",
	array: self
});
const unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
const unsafeGet$2 = /* @__PURE__ */ dual(2, (self, index) => {
	switch (self.backing._tag) {
		case "IEmpty": throw new Error(`Index out of bounds`);
		case "ISingleton":
			if (index !== 0) throw new Error(`Index out of bounds`);
			return self.backing.a;
		case "IArray":
			if (index >= self.length || index < 0) throw new Error(`Index out of bounds`);
			return self.backing.array[index];
		case "IConcat": return index < self.left.length ? unsafeGet$2(self.left, index) : unsafeGet$2(self.right, index - self.left.length);
		case "ISlice": return unsafeGet$2(self.backing.chunk, index + self.backing.offset);
	}
});
const append$1 = /* @__PURE__ */ dual(2, (self, a) => appendAll$1(self, of$3(a)));
const prepend$1 = /* @__PURE__ */ dual(2, (self, elem) => appendAll$1(of$3(elem), self));
const drop = /* @__PURE__ */ dual(2, (self, n) => {
	if (n <= 0) return self;
	else if (n >= self.length) return _empty$8;
	else switch (self.backing._tag) {
		case "ISlice": return makeChunk({
			_tag: "ISlice",
			chunk: self.backing.chunk,
			offset: self.backing.offset + n,
			length: self.backing.length - n
		});
		case "IConcat":
			if (n > self.left.length) return drop(self.right, n - self.left.length);
			return makeChunk({
				_tag: "IConcat",
				left: drop(self.left, n),
				right: self.right
			});
		default: return makeChunk({
			_tag: "ISlice",
			chunk: self,
			offset: n,
			length: self.length - n
		});
	}
});
const appendAll$1 = /* @__PURE__ */ dual(2, (self, that) => {
	if (self.backing._tag === "IEmpty") return that;
	if (that.backing._tag === "IEmpty") return self;
	const diff$10 = that.depth - self.depth;
	if (Math.abs(diff$10) <= 1) return makeChunk({
		_tag: "IConcat",
		left: self,
		right: that
	});
	else if (diff$10 < -1) if (self.left.depth >= self.right.depth) {
		const nr = appendAll$1(self.right, that);
		return makeChunk({
			_tag: "IConcat",
			left: self.left,
			right: nr
		});
	} else {
		const nrr = appendAll$1(self.right.right, that);
		if (nrr.depth === self.depth - 3) {
			const nr = makeChunk({
				_tag: "IConcat",
				left: self.right.left,
				right: nrr
			});
			return makeChunk({
				_tag: "IConcat",
				left: self.left,
				right: nr
			});
		} else return makeChunk({
			_tag: "IConcat",
			left: makeChunk({
				_tag: "IConcat",
				left: self.left,
				right: self.right.left
			}),
			right: nrr
		});
	}
	else if (that.right.depth >= that.left.depth) return makeChunk({
		_tag: "IConcat",
		left: appendAll$1(self, that.left),
		right: that.right
	});
	else {
		const nll = appendAll$1(self, that.left.left);
		if (nll.depth === that.depth - 3) return makeChunk({
			_tag: "IConcat",
			left: makeChunk({
				_tag: "IConcat",
				left: nll,
				right: that.left.right
			}),
			right: that.right
		});
		else return makeChunk({
			_tag: "IConcat",
			left: nll,
			right: makeChunk({
				_tag: "IConcat",
				left: that.left.right,
				right: that.right
			})
		});
	}
});
const isEmpty$9 = (self) => self.length === 0;
const isNonEmpty$4 = (self) => self.length > 0;
const head$2 = /* @__PURE__ */ get$8(0);
const unsafeHead = (self) => unsafeGet$2(self, 0);
const headNonEmpty = unsafeHead;
const tailNonEmpty = (self) => drop(self, 1);
var TypeId$12 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0$2 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1e3);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
const decode$3 = (input) => {
	if (isDuration(input)) return input;
	else if (isNumber(input)) return millis(input);
	else if (isBigInt(input)) return nanos(input);
	else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
		if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) return zero;
		if (input[0] === Infinity || input[1] === Infinity) return infinity;
		return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
	} else if (isString(input)) {
		const match$15 = DURATION_REGEX.exec(input);
		if (match$15) {
			const [_, valueStr, unit] = match$15;
			const value$2 = Number(valueStr);
			switch (unit) {
				case "nano":
				case "nanos": return nanos(BigInt(valueStr));
				case "micro":
				case "micros": return micros(BigInt(valueStr));
				case "milli":
				case "millis": return millis(value$2);
				case "second":
				case "seconds": return seconds(value$2);
				case "minute":
				case "minutes": return minutes(value$2);
				case "hour":
				case "hours": return hours(value$2);
				case "day":
				case "days": return days(value$2);
				case "week":
				case "weeks": return weeks(value$2);
			}
		}
	}
	throw new Error("Invalid DurationInput");
};
var zeroValue = {
	_tag: "Millis",
	millis: 0
};
var infinityValue = { _tag: "Infinity" };
var DurationProto = {
	[TypeId$12]: TypeId$12,
	[symbol$1]() {
		return cached$2(this, structure(this.value));
	},
	[symbol](that) {
		return isDuration(that) && equals$1(this, that);
	},
	toString() {
		return `Duration(${format$2(this)})`;
	},
	toJSON() {
		switch (this.value._tag) {
			case "Millis": return {
				_id: "Duration",
				_tag: "Millis",
				millis: this.value.millis
			};
			case "Nanos": return {
				_id: "Duration",
				_tag: "Nanos",
				hrtime: toHrTime(this)
			};
			case "Infinity": return {
				_id: "Duration",
				_tag: "Infinity"
			};
		}
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var make$41 = (input) => {
	const duration$2 = Object.create(DurationProto);
	if (isNumber(input)) if (isNaN(input) || input <= 0) duration$2.value = zeroValue;
	else if (!Number.isFinite(input)) duration$2.value = infinityValue;
	else if (!Number.isInteger(input)) duration$2.value = {
		_tag: "Nanos",
		nanos: BigInt(Math.round(input * 1e6))
	};
	else duration$2.value = {
		_tag: "Millis",
		millis: input
	};
	else if (input <= bigint0$2) duration$2.value = zeroValue;
	else duration$2.value = {
		_tag: "Nanos",
		nanos: input
	};
	return duration$2;
};
const isDuration = (u) => hasProperty(u, TypeId$12);
const isZero = (self) => {
	switch (self.value._tag) {
		case "Millis": return self.value.millis === 0;
		case "Nanos": return self.value.nanos === bigint0$2;
		case "Infinity": return false;
	}
};
const zero = /* @__PURE__ */ make$41(0);
const infinity = /* @__PURE__ */ make$41(Infinity);
const nanos = (nanos$1) => make$41(nanos$1);
const micros = (micros$1) => make$41(micros$1 * bigint1e3);
const millis = (millis$1) => make$41(millis$1);
const seconds = (seconds$1) => make$41(seconds$1 * 1e3);
const minutes = (minutes$1) => make$41(minutes$1 * 6e4);
const hours = (hours$1) => make$41(hours$1 * 36e5);
const days = (days$1) => make$41(days$1 * 864e5);
const weeks = (weeks$1) => make$41(weeks$1 * 6048e5);
const toMillis = (self) => match$11(self, {
	onMillis: (millis$1) => millis$1,
	onNanos: (nanos$1) => Number(nanos$1) / 1e6
});
const unsafeToNanos = (self) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Infinity": throw new Error("Cannot convert infinite duration to nanos");
		case "Nanos": return _self.value.nanos;
		case "Millis": return BigInt(Math.round(_self.value.millis * 1e6));
	}
};
const toHrTime = (self) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Infinity": return [Infinity, 0];
		case "Nanos": return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
		case "Millis": return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
	}
};
const match$11 = /* @__PURE__ */ dual(2, (self, options) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Nanos": return options.onNanos(_self.value.nanos);
		case "Infinity": return options.onMillis(Infinity);
		case "Millis": return options.onMillis(_self.value.millis);
	}
});
const matchWith = /* @__PURE__ */ dual(3, (self, that, options) => {
	const _self = decode$3(self);
	const _that = decode$3(that);
	if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") return options.onMillis(toMillis(_self), toMillis(_that));
	else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
		const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
		const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
		return options.onNanos(selfNanos, thatNanos);
	}
	return options.onMillis(_self.value.millis, _that.value.millis);
});
const Equivalence = (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 === that$1,
	onNanos: (self$1, that$1) => self$1 === that$1
});
const lessThanOrEqualTo = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 <= that$1,
	onNanos: (self$1, that$1) => self$1 <= that$1
}));
const greaterThanOrEqualTo = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 >= that$1,
	onNanos: (self$1, that$1) => self$1 >= that$1
}));
const equals$1 = /* @__PURE__ */ dual(2, (self, that) => Equivalence(decode$3(self), decode$3(that)));
const parts = (self) => {
	const duration$2 = decode$3(self);
	if (duration$2.value._tag === "Infinity") return {
		days: Infinity,
		hours: Infinity,
		minutes: Infinity,
		seconds: Infinity,
		millis: Infinity,
		nanos: Infinity
	};
	const nanos$1 = unsafeToNanos(duration$2);
	const ms = nanos$1 / bigint1e6;
	const sec = ms / bigint1e3;
	const min$2 = sec / bigint60;
	const hr = min$2 / bigint60;
	const days$1 = hr / bigint24;
	return {
		days: Number(days$1),
		hours: Number(hr % bigint24),
		minutes: Number(min$2 % bigint60),
		seconds: Number(sec % bigint60),
		millis: Number(ms % bigint1e3),
		nanos: Number(nanos$1 % bigint1e6)
	};
};
const format$2 = (self) => {
	const duration$2 = decode$3(self);
	if (duration$2.value._tag === "Infinity") return "Infinity";
	if (isZero(duration$2)) return "0";
	const fragments = parts(duration$2);
	const pieces = [];
	if (fragments.days !== 0) pieces.push(`${fragments.days}d`);
	if (fragments.hours !== 0) pieces.push(`${fragments.hours}h`);
	if (fragments.minutes !== 0) pieces.push(`${fragments.minutes}m`);
	if (fragments.seconds !== 0) pieces.push(`${fragments.seconds}s`);
	if (fragments.millis !== 0) pieces.push(`${fragments.millis}ms`);
	if (fragments.nanos !== 0) pieces.push(`${fragments.nanos}ns`);
	return pieces.join(" ");
};
const BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, 5);
const MASK = BUCKET_SIZE - 1;
const MAX_INDEX_NODE = BUCKET_SIZE / 2;
const MIN_ARRAY_NODE = BUCKET_SIZE / 4;
function popcount(x) {
	x -= x >> 1 & 1431655765;
	x = (x & 858993459) + (x >> 2 & 858993459);
	x = x + (x >> 4) & 252645135;
	x += x >> 8;
	x += x >> 16;
	return x & 127;
}
function hashFragment(shift$1, h) {
	return h >>> shift$1 & MASK;
}
function toBitmap(x) {
	return 1 << x;
}
function fromBitmap(bitmap, bit) {
	return popcount(bitmap & bit - 1);
}
const make$40 = (value$2, previous) => ({
	value: value$2,
	previous
});
function arrayUpdate(mutate$4, at$2, v, arr) {
	let out = arr;
	if (!mutate$4) {
		const len = arr.length;
		out = new Array(len);
		for (let i = 0; i < len; ++i) out[i] = arr[i];
	}
	out[at$2] = v;
	return out;
}
function arraySpliceOut(mutate$4, at$2, arr) {
	const newLen = arr.length - 1;
	let i = 0;
	let g = 0;
	let out = arr;
	if (mutate$4) i = g = at$2;
	else {
		out = new Array(newLen);
		while (i < at$2) out[g++] = arr[i++];
	}
	++i;
	while (i <= newLen) out[g++] = arr[i++];
	if (mutate$4) out.length = newLen;
	return out;
}
function arraySpliceIn(mutate$4, at$2, v, arr) {
	const len = arr.length;
	if (mutate$4) {
		let i$1 = len;
		while (i$1 >= at$2) arr[i$1--] = arr[i$1];
		arr[at$2] = v;
		return arr;
	}
	let i = 0, g = 0;
	const out = new Array(len + 1);
	while (i < at$2) out[g++] = arr[i++];
	out[at$2] = v;
	while (i < len) out[++g] = arr[i++];
	return out;
}
var EmptyNode = class EmptyNode {
	_tag = "EmptyNode";
	modify(edit, _shift, f, hash$1, key, size$11) {
		const v = f(none$7());
		if (isNone$2(v)) return new EmptyNode();
		++size$11.value;
		return new LeafNode(edit, hash$1, key, v);
	}
};
function isEmptyNode(a) {
	return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
	return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
	return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class LeafNode {
	edit;
	hash;
	key;
	value;
	_tag = "LeafNode";
	constructor(edit, hash$1, key, value$2) {
		this.edit = edit;
		this.hash = hash$1;
		this.key = key;
		this.value = value$2;
	}
	modify(edit, shift$1, f, hash$1, key, size$11) {
		if (equals(key, this.key)) {
			const v$1 = f(this.value);
			if (v$1 === this.value) return this;
			else if (isNone$2(v$1)) {
				--size$11.value;
				return new EmptyNode();
			}
			if (canEditNode(this, edit)) {
				this.value = v$1;
				return this;
			}
			return new LeafNode(edit, hash$1, key, v$1);
		}
		const v = f(none$7());
		if (isNone$2(v)) return this;
		++size$11.value;
		return mergeLeaves(edit, shift$1, this.hash, this, hash$1, new LeafNode(edit, hash$1, key, v));
	}
};
var CollisionNode = class CollisionNode {
	edit;
	hash;
	children;
	_tag = "CollisionNode";
	constructor(edit, hash$1, children$2) {
		this.edit = edit;
		this.hash = hash$1;
		this.children = children$2;
	}
	modify(edit, shift$1, f, hash$1, key, size$11) {
		if (hash$1 === this.hash) {
			const canEdit = canEditNode(this, edit);
			const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size$11);
			if (list === this.children) return this;
			return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
		}
		const v = f(none$7());
		if (isNone$2(v)) return this;
		++size$11.value;
		return mergeLeaves(edit, shift$1, this.hash, this, hash$1, new LeafNode(edit, hash$1, key, v));
	}
	updateCollisionList(mutate$4, edit, hash$1, list, f, key, size$11) {
		const len = list.length;
		for (let i = 0; i < len; ++i) {
			const child$1 = list[i];
			if ("key" in child$1 && equals(key, child$1.key)) {
				const value$2 = child$1.value;
				const newValue$1 = f(value$2);
				if (newValue$1 === value$2) return list;
				if (isNone$2(newValue$1)) {
					--size$11.value;
					return arraySpliceOut(mutate$4, i, list);
				}
				return arrayUpdate(mutate$4, i, new LeafNode(edit, hash$1, key, newValue$1), list);
			}
		}
		const newValue = f(none$7());
		if (isNone$2(newValue)) return list;
		++size$11.value;
		return arrayUpdate(mutate$4, len, new LeafNode(edit, hash$1, key, newValue), list);
	}
};
var IndexedNode = class IndexedNode {
	edit;
	mask;
	children;
	_tag = "IndexedNode";
	constructor(edit, mask, children$2) {
		this.edit = edit;
		this.mask = mask;
		this.children = children$2;
	}
	modify(edit, shift$1, f, hash$1, key, size$11) {
		const mask = this.mask;
		const children$2 = this.children;
		const frag = hashFragment(shift$1, hash$1);
		const bit = toBitmap(frag);
		const indx = fromBitmap(mask, bit);
		const exists$4 = mask & bit;
		const canEdit = canEditNode(this, edit);
		if (!exists$4) {
			const _newChild = new EmptyNode().modify(edit, shift$1 + 5, f, hash$1, key, size$11);
			if (!_newChild) return this;
			return children$2.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children$2) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children$2));
		}
		const current = children$2[indx];
		const child$1 = current.modify(edit, shift$1 + 5, f, hash$1, key, size$11);
		if (current === child$1) return this;
		let bitmap = mask;
		let newChildren;
		if (isEmptyNode(child$1)) {
			bitmap &= ~bit;
			if (!bitmap) return new EmptyNode();
			if (children$2.length <= 2 && isLeafNode(children$2[indx ^ 1])) return children$2[indx ^ 1];
			newChildren = arraySpliceOut(canEdit, indx, children$2);
		} else newChildren = arrayUpdate(canEdit, indx, child$1, children$2);
		if (canEdit) {
			this.mask = bitmap;
			this.children = newChildren;
			return this;
		}
		return new IndexedNode(edit, bitmap, newChildren);
	}
};
var ArrayNode = class ArrayNode {
	edit;
	size;
	children;
	_tag = "ArrayNode";
	constructor(edit, size$11, children$2) {
		this.edit = edit;
		this.size = size$11;
		this.children = children$2;
	}
	modify(edit, shift$1, f, hash$1, key, size$11) {
		let count = this.size;
		const children$2 = this.children;
		const frag = hashFragment(shift$1, hash$1);
		const child$1 = children$2[frag];
		const newChild = (child$1 || new EmptyNode()).modify(edit, shift$1 + 5, f, hash$1, key, size$11);
		if (child$1 === newChild) return this;
		const canEdit = canEditNode(this, edit);
		let newChildren;
		if (isEmptyNode(child$1) && !isEmptyNode(newChild)) {
			++count;
			newChildren = arrayUpdate(canEdit, frag, newChild, children$2);
		} else if (!isEmptyNode(child$1) && isEmptyNode(newChild)) {
			--count;
			if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children$2);
			newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children$2);
		} else newChildren = arrayUpdate(canEdit, frag, newChild, children$2);
		if (canEdit) {
			this.size = count;
			this.children = newChildren;
			return this;
		}
		return new ArrayNode(edit, count, newChildren);
	}
};
function pack(edit, count, removed, elements) {
	const children$2 = new Array(count - 1);
	let g = 0;
	let bitmap = 0;
	for (let i = 0, len = elements.length; i < len; ++i) if (i !== removed) {
		const elem = elements[i];
		if (elem && !isEmptyNode(elem)) {
			children$2[g++] = elem;
			bitmap |= 1 << i;
		}
	}
	return new IndexedNode(edit, bitmap, children$2);
}
function expand(edit, frag, child$1, bitmap, subNodes) {
	const arr = [];
	let bit = bitmap;
	let count = 0;
	for (let i = 0; bit; ++i) {
		if (bit & 1) arr[i] = subNodes[count++];
		bit >>>= 1;
	}
	arr[frag] = child$1;
	return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift$1, h1, n1, h2, n2) {
	if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
	const subH1 = hashFragment(shift$1, h1);
	const subH2 = hashFragment(shift$1, h2);
	if (subH1 === subH2) return (child$1) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child$1]);
	else {
		const children$2 = subH1 < subH2 ? [n1, n2] : [n2, n1];
		return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children$2);
	}
}
function mergeLeaves(edit, shift$1, h1, n1, h2, n2) {
	let stack = void 0;
	let currentShift = shift$1;
	while (true) {
		const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
		if (typeof res === "function") {
			stack = make$40(res, stack);
			currentShift = currentShift + 5;
		} else {
			let final = res;
			while (stack != null) {
				final = stack.value(final);
				stack = stack.previous;
			}
			return final;
		}
	}
}
var HashMapSymbolKey = "effect/HashMap";
const HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
	[HashMapTypeId]: HashMapTypeId,
	[Symbol.iterator]() {
		return new HashMapIterator(this, (k, v) => [k, v]);
	},
	[symbol$1]() {
		let hash$1 = hash(HashMapSymbolKey);
		for (const item of this) hash$1 ^= pipe(hash(item[0]), combine$11(hash(item[1])));
		return cached$2(this, hash$1);
	},
	[symbol](that) {
		if (isHashMap$1(that)) {
			if (that._size !== this._size) return false;
			for (const item of this) {
				const elem = pipe(that, getHash$1(item[0], hash(item[0])));
				if (isNone$2(elem)) return false;
				else if (!equals(item[1], elem.value)) return false;
			}
			return true;
		}
		return false;
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "HashMap",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var makeImpl$2 = (editable, edit, root, size$11) => {
	const map$21 = Object.create(HashMapProto);
	map$21._editable = editable;
	map$21._edit = edit;
	map$21._root = root;
	map$21._size = size$11;
	return map$21;
};
var HashMapIterator = class HashMapIterator {
	map;
	f;
	v;
	constructor(map$21, f) {
		this.map = map$21;
		this.f = f;
		this.v = visitLazy(this.map._root, this.f, void 0);
	}
	next() {
		if (isNone$2(this.v)) return {
			done: true,
			value: void 0
		};
		const v0 = this.v.value;
		this.v = applyCont(v0.cont);
		return {
			done: false,
			value: v0.value
		};
	}
	[Symbol.iterator]() {
		return new HashMapIterator(this.map, this.f);
	}
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none$7();
var visitLazy = (node, f, cont = void 0) => {
	switch (node._tag) {
		case "LeafNode":
			if (isSome(node.value)) return some$4({
				value: f(node.key, node.value.value),
				cont
			});
			return applyCont(cont);
		case "CollisionNode":
		case "ArrayNode":
		case "IndexedNode": {
			const children$2 = node.children;
			return visitLazyChildren(children$2.length, children$2, 0, f, cont);
		}
		default: return applyCont(cont);
	}
};
var visitLazyChildren = (len, children$2, i, f, cont) => {
	while (i < len) {
		const child$1 = children$2[i++];
		if (child$1 && !isEmptyNode(child$1)) return visitLazy(child$1, f, [
			len,
			children$2,
			i,
			f,
			cont
		]);
	}
	return applyCont(cont);
};
var _empty$7 = /* @__PURE__ */ makeImpl$2(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
const empty$30 = () => _empty$7;
const fromIterable$8 = (entries$2) => {
	const map$21 = beginMutation$3(empty$30());
	for (const entry of entries$2) set$5(map$21, entry[0], entry[1]);
	return endMutation$3(map$21);
};
const isHashMap$1 = (u) => hasProperty(u, HashMapTypeId);
const isEmpty$8 = (self) => self && isEmptyNode(self._root);
const get$7 = /* @__PURE__ */ dual(2, (self, key) => getHash$1(self, key, hash(key)));
const getHash$1 = /* @__PURE__ */ dual(3, (self, key, hash$1) => {
	let node = self._root;
	let shift$1 = 0;
	while (true) switch (node._tag) {
		case "LeafNode": return equals(key, node.key) ? node.value : none$7();
		case "CollisionNode":
			if (hash$1 === node.hash) {
				const children$2 = node.children;
				for (let i = 0, len = children$2.length; i < len; ++i) {
					const child$1 = children$2[i];
					if ("key" in child$1 && equals(key, child$1.key)) return child$1.value;
				}
			}
			return none$7();
		case "IndexedNode": {
			const bit = toBitmap(hashFragment(shift$1, hash$1));
			if (node.mask & bit) {
				node = node.children[fromBitmap(node.mask, bit)];
				shift$1 += 5;
				break;
			}
			return none$7();
		}
		case "ArrayNode":
			node = node.children[hashFragment(shift$1, hash$1)];
			if (node) {
				shift$1 += 5;
				break;
			}
			return none$7();
		default: return none$7();
	}
});
const has$6 = /* @__PURE__ */ dual(2, (self, key) => isSome(getHash$1(self, key, hash(key))));
const set$5 = /* @__PURE__ */ dual(3, (self, key, value$2) => modifyAt$1(self, key, () => some$4(value$2)));
const setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
	if (self._editable) {
		self._root = newRoot;
		self._size = newSize;
		return self;
	}
	return newRoot === self._root ? self : makeImpl$2(self._editable, self._edit, newRoot, newSize);
});
const keys$3 = (self) => new HashMapIterator(self, (key) => key);
const size$10 = (self) => self._size;
const beginMutation$3 = (self) => makeImpl$2(true, self._edit + 1, self._root, self._size);
const endMutation$3 = (self) => {
	self._editable = false;
	return self;
};
const modifyAt$1 = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash$1(self, key, hash(key), f));
const modifyHash$1 = /* @__PURE__ */ dual(4, (self, key, hash$1, f) => {
	const size$11 = { value: self._size };
	return pipe(self, setTree(self._root.modify(self._editable ? self._edit : NaN, 0, f, hash$1, key, size$11), size$11.value));
});
const remove$6 = /* @__PURE__ */ dual(2, (self, key) => modifyAt$1(self, key, none$7));
const map$17 = /* @__PURE__ */ dual(2, (self, f) => reduce$10(self, empty$30(), (map$21, value$2, key) => set$5(map$21, key, f(value$2, key))));
const forEach$8 = /* @__PURE__ */ dual(2, (self, f) => reduce$10(self, void 0, (_, value$2, key) => f(value$2, key)));
const reduce$10 = /* @__PURE__ */ dual(3, (self, zero$1, f) => {
	const root = self._root;
	if (root._tag === "LeafNode") return isSome(root.value) ? f(zero$1, root.value.value, root.key) : zero$1;
	if (root._tag === "EmptyNode") return zero$1;
	const toVisit = [root.children];
	let children$2;
	while (children$2 = toVisit.pop()) for (let i = 0, len = children$2.length; i < len;) {
		const child$1 = children$2[i++];
		if (child$1 && !isEmptyNode(child$1)) if (child$1._tag === "LeafNode") {
			if (isSome(child$1.value)) zero$1 = f(zero$1, child$1.value.value, child$1.key);
		} else toVisit.push(child$1.children);
	}
	return zero$1;
});
var HashSetSymbolKey = "effect/HashSet";
const HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
	[HashSetTypeId]: HashSetTypeId,
	[Symbol.iterator]() {
		return keys$3(this._keyMap);
	},
	[symbol$1]() {
		return cached$2(this, combine$11(hash(this._keyMap))(hash(HashSetSymbolKey)));
	},
	[symbol](that) {
		if (isHashSet$1(that)) return size$10(this._keyMap) === size$10(that._keyMap) && equals(this._keyMap, that._keyMap);
		return false;
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "HashSet",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeImpl$1 = (keyMap) => {
	const set$6 = Object.create(HashSetProto);
	set$6._keyMap = keyMap;
	return set$6;
};
const isHashSet$1 = (u) => hasProperty(u, HashSetTypeId);
var _empty$6 = /* @__PURE__ */ makeImpl$1(/* @__PURE__ */ empty$30());
const empty$29 = () => _empty$6;
const fromIterable$7 = (elements) => {
	const set$6 = beginMutation$2(empty$29());
	for (const value$2 of elements) add$2(set$6, value$2);
	return endMutation$2(set$6);
};
const make$38 = (...elements) => {
	const set$6 = beginMutation$2(empty$29());
	for (const value$2 of elements) add$2(set$6, value$2);
	return endMutation$2(set$6);
};
const has$5 = /* @__PURE__ */ dual(2, (self, value$2) => has$6(self._keyMap, value$2));
const some$2 = /* @__PURE__ */ dual(2, (self, f) => {
	let found = false;
	for (const value$2 of self) {
		found = f(value$2);
		if (found) break;
	}
	return found;
});
const every$4 = /* @__PURE__ */ dual(2, (self, refinement) => !some$2(self, (a) => !refinement(a)));
const size$9 = (self) => size$10(self._keyMap);
const beginMutation$2 = (self) => makeImpl$1(beginMutation$3(self._keyMap));
const endMutation$2 = (self) => {
	self._keyMap._editable = false;
	return self;
};
const mutate$2 = /* @__PURE__ */ dual(2, (self, f) => {
	const transient = beginMutation$2(self);
	f(transient);
	return endMutation$2(transient);
});
const add$2 = /* @__PURE__ */ dual(2, (self, value$2) => self._keyMap._editable ? (set$5(value$2, true)(self._keyMap), self) : makeImpl$1(set$5(value$2, true)(self._keyMap)));
const remove$5 = /* @__PURE__ */ dual(2, (self, value$2) => self._keyMap._editable ? (remove$6(value$2)(self._keyMap), self) : makeImpl$1(remove$6(value$2)(self._keyMap)));
const difference$1 = /* @__PURE__ */ dual(2, (self, that) => mutate$2(self, (set$6) => {
	for (const value$2 of that) remove$5(set$6, value$2);
}));
const union$6 = /* @__PURE__ */ dual(2, (self, that) => mutate$2(empty$29(), (set$6) => {
	forEach$7(self, (value$2) => add$2(set$6, value$2));
	for (const value$2 of that) add$2(set$6, value$2);
}));
const forEach$7 = /* @__PURE__ */ dual(2, (self, f) => forEach$8(self._keyMap, (_, k) => f(k)));
const reduce$9 = /* @__PURE__ */ dual(3, (self, zero$1, f) => reduce$10(self._keyMap, zero$1, (z, _, a) => f(z, a)));
const empty$28 = empty$29;
const fromIterable$6 = fromIterable$7;
const make$37 = make$38;
const has$4 = has$5;
const every$3 = every$4;
const size$8 = size$9;
const add$1 = add$2;
const remove$4 = remove$5;
const difference = difference$1;
const union$5 = union$6;
const reduce$8 = reduce$9;
var TypeId$11 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
	[TypeId$11]: TypeId$11,
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableRef",
			current: toJSON(this.current)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const make$36 = (value$2) => {
	const ref = Object.create(MutableRefProto);
	ref.current = value$2;
	return ref;
};
const get$6 = (self) => self.current;
const set$4 = /* @__PURE__ */ dual(2, (self, value$2) => {
	self.current = value$2;
	return self;
});
var FiberIdSymbolKey = "effect/FiberId";
const FiberIdTypeId$1 = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string$2(`${FiberIdSymbolKey}-${OP_NONE}`);
var None$2 = class {
	[FiberIdTypeId$1] = FiberIdTypeId$1;
	_tag = OP_NONE;
	id = -1;
	startTimeMillis = -1;
	[symbol$1]() {
		return emptyHash;
	}
	[symbol](that) {
		return isFiberId$1(that) && that._tag === OP_NONE;
	}
	toString() {
		return format(this.toJSON());
	}
	toJSON() {
		return {
			_id: "FiberId",
			_tag: this._tag
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
var Runtime = class {
	id;
	startTimeMillis;
	[FiberIdTypeId$1] = FiberIdTypeId$1;
	_tag = OP_RUNTIME;
	constructor(id$2, startTimeMillis) {
		this.id = id$2;
		this.startTimeMillis = startTimeMillis;
	}
	[symbol$1]() {
		return cached$2(this, string$2(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
	}
	[symbol](that) {
		return isFiberId$1(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
	}
	toString() {
		return format(this.toJSON());
	}
	toJSON() {
		return {
			_id: "FiberId",
			_tag: this._tag,
			id: this.id,
			startTimeMillis: this.startTimeMillis
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
const none$1 = /* @__PURE__ */ new None$2();
const isFiberId$1 = (self) => hasProperty(self, FiberIdTypeId$1);
const isNone$1 = (self) => {
	return self._tag === OP_NONE || pipe(toSet$3(self), every$3((id$2) => isNone$1(id$2)));
};
const ids$1 = (self) => {
	switch (self._tag) {
		case OP_NONE: return empty$28();
		case OP_RUNTIME: return make$37(self.id);
		case OP_COMPOSITE: return pipe(ids$1(self.left), union$5(ids$1(self.right)));
	}
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make$36(0));
const threadName$1 = (self) => {
	return Array.from(ids$1(self)).map((n) => `#${n}`).join(",");
};
const toSet$3 = (self) => {
	switch (self._tag) {
		case OP_NONE: return empty$28();
		case OP_RUNTIME: return make$37(self);
		case OP_COMPOSITE: return pipe(toSet$3(self.left), union$5(toSet$3(self.right)));
	}
};
const unsafeMake$8 = () => {
	const id$2 = get$6(_fiberCounter);
	pipe(_fiberCounter, set$4(id$2 + 1));
	return new Runtime(id$2, Date.now());
};
const none$6 = none$1;
const threadName = threadName$1;
const unsafeMake$7 = unsafeMake$8;
const empty$27 = empty$30;
const fromIterable$5 = fromIterable$8;
const isEmpty$7 = isEmpty$8;
const get$5 = get$7;
const set$3 = set$5;
const keys$2 = keys$3;
const modifyAt = modifyAt$1;
const map$14 = map$17;
const forEach$5 = forEach$8;
const reduce$7 = reduce$10;
const TypeId$10 = /* @__PURE__ */ Symbol.for("effect/List");
const toArray = (self) => fromIterable$10(self);
const getEquivalence$1 = (isEquivalent) => mapInput$1(getEquivalence$3(isEquivalent), toArray);
var _equivalence = /* @__PURE__ */ getEquivalence$1(equals);
var ConsProto = {
	[TypeId$10]: TypeId$10,
	_tag: "Cons",
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "List",
			_tag: "Cons",
			values: toArray(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol](that) {
		return isList(that) && this._tag === that._tag && _equivalence(this, that);
	},
	[symbol$1]() {
		return cached$2(this, array$3(toArray(this)));
	},
	[Symbol.iterator]() {
		let done$8 = false;
		let self = this;
		return {
			next() {
				if (done$8) return this.return();
				if (self._tag === "Nil") {
					done$8 = true;
					return this.return();
				}
				const value$2 = self.head;
				self = self.tail;
				return {
					done: done$8,
					value: value$2
				};
			},
			return(value$2) {
				if (!done$8) done$8 = true;
				return {
					done: true,
					value: value$2
				};
			}
		};
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var makeCons = (head$4, tail) => {
	const cons$1 = Object.create(ConsProto);
	cons$1.head = head$4;
	cons$1.tail = tail;
	return cons$1;
};
var NilHash = /* @__PURE__ */ string$2("Nil");
var NilProto = {
	[TypeId$10]: TypeId$10,
	_tag: "Nil",
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "List",
			_tag: "Nil"
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol$1]() {
		return NilHash;
	},
	[symbol](that) {
		return isList(that) && this._tag === that._tag;
	},
	[Symbol.iterator]() {
		return { next() {
			return {
				done: true,
				value: void 0
			};
		} };
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
const isList = (u) => hasProperty(u, TypeId$10);
const isNil = (self) => self._tag === "Nil";
const isCons = (self) => self._tag === "Cons";
const nil = () => _Nil;
const cons = (head$4, tail) => makeCons(head$4, tail);
const empty$26 = nil;
const of$2 = (value$2) => makeCons(value$2, _Nil);
const appendAll = /* @__PURE__ */ dual(2, (self, that) => prependAll(that, self));
const prepend = /* @__PURE__ */ dual(2, (self, element) => cons(element, self));
const prependAll = /* @__PURE__ */ dual(2, (self, prefix) => {
	if (isNil(self)) return prefix;
	else if (isNil(prefix)) return self;
	else {
		const result = makeCons(prefix.head, self);
		let curr = result;
		let that = prefix.tail;
		while (!isNil(that)) {
			const temp = makeCons(that.head, self);
			curr.tail = temp;
			curr = temp;
			that = that.tail;
		}
		return result;
	}
});
const reduce$6 = /* @__PURE__ */ dual(3, (self, zero$1, f) => {
	let acc = zero$1;
	let these = self;
	while (!isNil(these)) {
		acc = f(acc, these.head);
		these = these.tail;
	}
	return acc;
});
const reverse = (self) => {
	let result = empty$26();
	let these = self;
	while (!isNil(these)) {
		result = prepend(result, these.head);
		these = these.tail;
	}
	return result;
};
Array.prototype;
const Structural$1 = /* @__PURE__ */ function() {
	function Structural$2(args$1) {
		if (args$1) Object.assign(this, args$1);
	}
	Structural$2.prototype = StructuralPrototype;
	return Structural$2;
}();
({ ...Structural$1.prototype });
const ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance$6(a) {
	return a;
}
var PatchProto$4 = {
	...Structural$1.prototype,
	[ContextPatchTypeId]: {
		_Value: variance$6,
		_Patch: variance$6
	}
};
var EmptyProto$4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "Empty" });
var _empty$4 = /* @__PURE__ */ Object.create(EmptyProto$4);
const empty$24 = () => _empty$4;
var AndThenProto$4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "AndThen" });
var makeAndThen$4 = (first$2, second) => {
	const o = Object.create(AndThenProto$4);
	o.first = first$2;
	o.second = second;
	return o;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "AddService" });
var makeAddService = (key, service$1) => {
	const o = Object.create(AddServiceProto);
	o.key = key;
	o.service = service$1;
	return o;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "RemoveService" });
var makeRemoveService = (key) => {
	const o = Object.create(RemoveServiceProto);
	o.key = key;
	return o;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "UpdateService" });
var makeUpdateService = (key, update$5) => {
	const o = Object.create(UpdateServiceProto);
	o.key = key;
	o.update = update$5;
	return o;
};
const diff$8 = (oldValue, newValue) => {
	const missingServices = new Map(oldValue.unsafeMap);
	let patch$11 = empty$24();
	for (const [tag, newService] of newValue.unsafeMap.entries()) if (missingServices.has(tag)) {
		const old = missingServices.get(tag);
		missingServices.delete(tag);
		if (!equals(old, newService)) patch$11 = combine$7(makeUpdateService(tag, () => newService))(patch$11);
	} else {
		missingServices.delete(tag);
		patch$11 = combine$7(makeAddService(tag, newService))(patch$11);
	}
	for (const [tag] of missingServices.entries()) patch$11 = combine$7(makeRemoveService(tag))(patch$11);
	return patch$11;
};
const combine$7 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen$4(self, that));
const patch$9 = /* @__PURE__ */ dual(2, (self, context$3) => {
	if (self._tag === "Empty") return context$3;
	let wasServiceUpdated = false;
	let patches = of$3(self);
	const updatedContext = new Map(context$3.unsafeMap);
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AddService":
				updatedContext.set(head$4.key, head$4.service);
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(prepend$1(tail, head$4.second), head$4.first);
				break;
			case "RemoveService":
				updatedContext.delete(head$4.key);
				patches = tail;
				break;
			case "UpdateService":
				updatedContext.set(head$4.key, head$4.update(updatedContext.get(head$4.key)));
				wasServiceUpdated = true;
				patches = tail;
				break;
		}
	}
	if (!wasServiceUpdated) return makeContext(updatedContext);
	const map$21 = /* @__PURE__ */ new Map();
	for (const [tag] of context$3.unsafeMap) if (updatedContext.has(tag)) {
		map$21.set(tag, updatedContext.get(tag));
		updatedContext.delete(tag);
	}
	for (const [tag, s] of updatedContext) map$21.set(tag, s);
	return makeContext(map$21);
});
({ ...Structural$1.prototype });
const HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance$4(a) {
	return a;
}
var PatchProto$2 = {
	...Structural$1.prototype,
	[HashSetPatchTypeId]: {
		_Value: variance$4,
		_Key: variance$4,
		_Patch: variance$4
	}
};
var EmptyProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Empty" });
var _empty$2 = /* @__PURE__ */ Object.create(EmptyProto$2);
const empty$22 = () => _empty$2;
var AndThenProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "AndThen" });
const makeAndThen$2 = (first$2, second) => {
	const o = Object.create(AndThenProto$2);
	o.first = first$2;
	o.second = second;
	return o;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Add" });
const makeAdd = (value$2) => {
	const o = Object.create(AddProto);
	o.value = value$2;
	return o;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Remove" });
const makeRemove = (value$2) => {
	const o = Object.create(RemoveProto);
	o.value = value$2;
	return o;
};
const diff$6 = (oldValue, newValue) => {
	const [removed, patch$11] = reduce$8([oldValue, empty$22()], ([set$6, patch$12], value$2) => {
		if (has$4(value$2)(set$6)) return [remove$4(value$2)(set$6), patch$12];
		return [set$6, combine$5(makeAdd(value$2))(patch$12)];
	})(newValue);
	return reduce$8(patch$11, (patch$12, value$2) => combine$5(makeRemove(value$2))(patch$12))(removed);
};
const combine$5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen$2(self, that));
const patch$7 = /* @__PURE__ */ dual(2, (self, oldValue) => {
	if (self._tag === "Empty") return oldValue;
	let set$6 = oldValue;
	let patches = of$3(self);
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "Add":
				set$6 = add$1(head$4.value)(set$6);
				patches = tail;
				break;
			case "Remove":
				set$6 = remove$4(head$4.value)(set$6);
				patches = tail;
		}
	}
	return set$6;
});
({ ...Structural$1.prototype });
const ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance$2(a) {
	return a;
}
var PatchProto = {
	...Structural$1.prototype,
	[ReadonlyArrayPatchTypeId]: {
		_Value: variance$2,
		_Patch: variance$2
	}
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Empty" });
var _empty = /* @__PURE__ */ Object.create(EmptyProto);
const empty$20 = () => _empty;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "AndThen" });
var makeAndThen = (first$2, second) => {
	const o = Object.create(AndThenProto);
	o.first = first$2;
	o.second = second;
	return o;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Append" });
var makeAppend = (values$6) => {
	const o = Object.create(AppendProto);
	o.values = values$6;
	return o;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Slice" });
var makeSlice = (from, until) => {
	const o = Object.create(SliceProto);
	o.from = from;
	o.until = until;
	return o;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Update" });
var makeUpdate = (index, patch$11) => {
	const o = Object.create(UpdateProto);
	o.index = index;
	o.patch = patch$11;
	return o;
};
const diff$4 = (options) => {
	let i = 0;
	let patch$11 = empty$20();
	while (i < options.oldValue.length && i < options.newValue.length) {
		const oldElement = options.oldValue[i];
		const newElement = options.newValue[i];
		const valuePatch = options.differ.diff(oldElement, newElement);
		if (!equals(valuePatch, options.differ.empty)) patch$11 = combine$3(patch$11, makeUpdate(i, valuePatch));
		i = i + 1;
	}
	if (i < options.oldValue.length) patch$11 = combine$3(patch$11, makeSlice(0, i));
	if (i < options.newValue.length) patch$11 = combine$3(patch$11, makeAppend(drop$1(i)(options.newValue)));
	return patch$11;
};
const combine$3 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
const patch$5 = /* @__PURE__ */ dual(3, (self, oldValue, differ$2) => {
	if (self._tag === "Empty") return oldValue;
	let readonlyArray$2 = oldValue.slice();
	let patches = of$4(self);
	while (isNonEmptyArray(patches)) {
		const head$4 = headNonEmpty$1(patches);
		const tail = tailNonEmpty$1(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				tail.unshift(head$4.first, head$4.second);
				patches = tail;
				break;
			case "Append":
				for (const value$2 of head$4.values) readonlyArray$2.push(value$2);
				patches = tail;
				break;
			case "Slice":
				readonlyArray$2 = readonlyArray$2.slice(head$4.from, head$4.until);
				patches = tail;
				break;
			case "Update":
				readonlyArray$2[head$4.index] = differ$2.patch(head$4.patch, readonlyArray$2[head$4.index]);
				patches = tail;
				break;
		}
	}
	return readonlyArray$2;
});
const DifferProto = {
	[/* @__PURE__ */ Symbol.for("effect/Differ")]: {
		_P: identity,
		_V: identity
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const make$32 = (params) => {
	const differ$2 = Object.create(DifferProto);
	differ$2.empty = params.empty;
	differ$2.diff = params.diff;
	differ$2.combine = params.combine;
	differ$2.patch = params.patch;
	return differ$2;
};
const environment$1 = () => make$32({
	empty: empty$24(),
	combine: (first$2, second) => combine$7(second)(first$2),
	diff: (oldValue, newValue) => diff$8(oldValue, newValue),
	patch: (patch$11, oldValue) => patch$9(oldValue)(patch$11)
});
const hashSet$3 = () => make$32({
	empty: empty$22(),
	combine: (first$2, second) => combine$5(second)(first$2),
	diff: (oldValue, newValue) => diff$6(oldValue, newValue),
	patch: (patch$11, oldValue) => patch$7(oldValue)(patch$11)
});
const readonlyArray$1 = (differ$2) => make$32({
	empty: empty$20(),
	combine: (first$2, second) => combine$3(first$2, second),
	diff: (oldValue, newValue) => diff$4({
		oldValue,
		newValue,
		differ: differ$2
	}),
	patch: (patch$11, oldValue) => patch$5(patch$11, oldValue, differ$2)
});
const update$4 = () => updateWith$1((_, a) => a);
const updateWith$1 = (f) => make$32({
	empty: identity,
	combine: (first$2, second) => {
		if (first$2 === identity) return second;
		if (second === identity) return first$2;
		return (a) => second(first$2(a));
	},
	diff: (oldValue, newValue) => {
		if (equals(oldValue, newValue)) return identity;
		return constant(newValue);
	},
	patch: (patch$11, oldValue) => f(oldValue, patch$11(oldValue))
});
var BIT_MASK = 255;
var BIT_SHIFT = 8;
const active = (patch$11) => patch$11 & BIT_MASK;
const enabled = (patch$11) => patch$11 >> BIT_SHIFT & BIT_MASK;
const make$31 = (active$1, enabled$1) => (active$1 & BIT_MASK) + ((enabled$1 & active$1 & BIT_MASK) << BIT_SHIFT);
const empty$19 = /* @__PURE__ */ make$31(0, 0);
const enable$2 = (flag) => make$31(flag, flag);
const disable$2 = (flag) => make$31(flag, 0);
const exclude$1 = /* @__PURE__ */ dual(2, (self, flag) => make$31(active(self) & ~flag, enabled(self)));
const andThen$6 = /* @__PURE__ */ dual(2, (self, that) => self | that);
const invert = (n) => ~n >>> 0 & BIT_MASK;
const Interruption = 1;
const OpSupervision = 2;
const RuntimeMetrics = 4;
const WindDown = 16;
const CooperativeYielding = 32;
const cooperativeYielding = (self) => isEnabled$1(self, 32);
const disable$1 = /* @__PURE__ */ dual(2, (self, flag) => self & ~flag);
const enable$1 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
const interruptible$3 = (self) => interruption(self) && !windDown(self);
const interruption = (self) => isEnabled$1(self, 1);
const isEnabled$1 = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
const make$30 = (...flags) => flags.reduce((a, b) => a | b, 0);
const none$5 = /* @__PURE__ */ make$30(0);
const runtimeMetrics = (self) => isEnabled$1(self, 4);
const windDown = (self) => isEnabled$1(self, 16);
const diff$3 = /* @__PURE__ */ dual(2, (self, that) => make$31(self ^ that, that));
const patch$4 = /* @__PURE__ */ dual(2, (self, patch$11) => self & (invert(active(patch$11)) | enabled(patch$11)) | active(patch$11) & enabled(patch$11));
const differ$1 = /* @__PURE__ */ make$32({
	empty: empty$19,
	diff: (oldValue, newValue) => diff$3(oldValue, newValue),
	combine: (first$2, second) => andThen$6(second)(first$2),
	patch: (_patch, oldValue) => patch$4(oldValue, _patch)
});
const empty$18 = empty$19;
const enable = enable$2;
const disable = disable$2;
const exclude = exclude$1;
const par = (self, that) => ({
	_tag: "Par",
	left: self,
	right: that
});
const seq = (self, that) => ({
	_tag: "Seq",
	left: self,
	right: that
});
const flatten$6 = (self) => {
	let current = of$2(self);
	let updated = empty$26();
	while (1) {
		const [parallel$4, sequential$4] = reduce$6(current, [parallelCollectionEmpty(), empty$26()], ([parallel$5, sequential$5], blockedRequest) => {
			const [par$1, seq$1] = step$2(blockedRequest);
			return [parallelCollectionCombine(parallel$5, par$1), appendAll(sequential$5, seq$1)];
		});
		updated = merge$3(updated, parallel$4);
		if (isNil(sequential$4)) return reverse(updated);
		current = sequential$4;
	}
	throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step$2 = (requests) => {
	let current = requests;
	let parallel$4 = parallelCollectionEmpty();
	let stack = empty$26();
	let sequential$4 = empty$26();
	while (1) switch (current._tag) {
		case "Empty":
			if (isNil(stack)) return [parallel$4, sequential$4];
			current = stack.head;
			stack = stack.tail;
			break;
		case "Par":
			stack = cons(current.right, stack);
			current = current.left;
			break;
		case "Seq": {
			const left$2 = current.left;
			const right$2 = current.right;
			switch (left$2._tag) {
				case "Empty":
					current = right$2;
					break;
				case "Par": {
					const l = left$2.left;
					const r = left$2.right;
					current = par(seq(l, right$2), seq(r, right$2));
					break;
				}
				case "Seq": {
					const l = left$2.left;
					const r = left$2.right;
					current = seq(l, seq(r, right$2));
					break;
				}
				case "Single":
					current = left$2;
					sequential$4 = cons(right$2, sequential$4);
					break;
			}
			break;
		}
		case "Single":
			parallel$4 = parallelCollectionAdd(parallel$4, current);
			if (isNil(stack)) return [parallel$4, sequential$4];
			current = stack.head;
			stack = stack.tail;
			break;
	}
	throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge$3 = (sequential$4, parallel$4) => {
	if (isNil(sequential$4)) return of$2(parallelCollectionToSequentialCollection(parallel$4));
	if (parallelCollectionIsEmpty(parallel$4)) return sequential$4;
	const seqHeadKeys = sequentialCollectionKeys(sequential$4.head);
	const parKeys = parallelCollectionKeys(parallel$4);
	if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) return cons(sequentialCollectionCombine(sequential$4.head, parallelCollectionToSequentialCollection(parallel$4)), sequential$4.tail);
	return cons(parallelCollectionToSequentialCollection(parallel$4), sequential$4);
};
const RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = { _R: (_) => _ };
var ParallelImpl = class {
	map;
	[RequestBlockParallelTypeId] = parallelVariance;
	constructor(map$21) {
		this.map = map$21;
	}
};
const parallelCollectionEmpty = () => new ParallelImpl(empty$27());
const parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt(self.map, blockedRequest.dataSource, (_) => orElseSome(map$19(_, append$1(blockedRequest.blockedRequest)), () => of$3(blockedRequest.blockedRequest))));
const parallelCollectionCombine = (self, that) => new ParallelImpl(reduce$7(self.map, that.map, (map$21, value$2, key) => set$3(map$21, key, match$13(get$5(map$21, key), {
	onNone: () => value$2,
	onSome: (other) => appendAll$1(value$2, other)
}))));
const parallelCollectionIsEmpty = (self) => isEmpty$7(self.map);
const parallelCollectionKeys = (self) => Array.from(keys$2(self.map));
const parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map$14(self.map, (x) => of$3(x)));
const SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = { _R: (_) => _ };
var SequentialImpl = class {
	map;
	[SequentialCollectionTypeId] = sequentialVariance;
	constructor(map$21) {
		this.map = map$21;
	}
};
const sequentialCollectionMake = (map$21) => new SequentialImpl(map$21);
const sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce$7(that.map, self.map, (map$21, value$2, key) => set$3(map$21, key, match$13(get$5(map$21, key), {
	onNone: () => empty$31(),
	onSome: (a) => appendAll$1(a, value$2)
}))));
const sequentialCollectionKeys = (self) => Array.from(keys$2(self.map));
const sequentialCollectionToChunk = (self) => Array.from(self.map);
const OP_EMPTY$2 = "Empty";
const OP_FAIL$1 = "Fail";
const OP_INTERRUPT = "Interrupt";
const OP_PARALLEL$1 = "Parallel";
const OP_SEQUENTIAL$1 = "Sequential";
var CauseSymbolKey = "effect/Cause";
const CauseTypeId$1 = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance$1 = { _E: (_) => _ };
var proto$4 = {
	[CauseTypeId$1]: variance$1,
	[symbol$1]() {
		return pipe(hash(CauseSymbolKey), combine$11(hash(flattenCause(this))), cached$2(this));
	},
	[symbol](that) {
		return isCause$1(that) && causeEquals(this, that);
	},
	pipe() {
		return pipeArguments(this, arguments);
	},
	toJSON() {
		switch (this._tag) {
			case "Empty": return {
				_id: "Cause",
				_tag: this._tag
			};
			case "Die": return {
				_id: "Cause",
				_tag: this._tag,
				defect: toJSON(this.defect)
			};
			case "Interrupt": return {
				_id: "Cause",
				_tag: this._tag,
				fiberId: this.fiberId.toJSON()
			};
			case "Fail": return {
				_id: "Cause",
				_tag: this._tag,
				failure: toJSON(this.error)
			};
			case "Sequential":
			case "Parallel": return {
				_id: "Cause",
				_tag: this._tag,
				left: toJSON(this.left),
				right: toJSON(this.right)
			};
		}
	},
	toString() {
		return pretty$3(this);
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
const empty$16 = /* @__PURE__ */ (() => {
	const o = /* @__PURE__ */ Object.create(proto$4);
	o._tag = OP_EMPTY$2;
	return o;
})();
const fail$13 = (error) => {
	const o = Object.create(proto$4);
	o._tag = OP_FAIL$1;
	o.error = error;
	return o;
};
const die$6 = (defect) => {
	const o = Object.create(proto$4);
	o._tag = "Die";
	o.defect = defect;
	return o;
};
const interrupt$6 = (fiberId$2) => {
	const o = Object.create(proto$4);
	o._tag = OP_INTERRUPT;
	o.fiberId = fiberId$2;
	return o;
};
const parallel$3 = (left$2, right$2) => {
	const o = Object.create(proto$4);
	o._tag = OP_PARALLEL$1;
	o.left = left$2;
	o.right = right$2;
	return o;
};
const sequential$3 = (left$2, right$2) => {
	const o = Object.create(proto$4);
	o._tag = OP_SEQUENTIAL$1;
	o.left = left$2;
	o.right = right$2;
	return o;
};
const isCause$1 = (u) => hasProperty(u, CauseTypeId$1);
const isEmptyType$1 = (self) => self._tag === OP_EMPTY$2;
const isFailType$1 = (self) => self._tag === OP_FAIL$1;
const isEmpty$4 = (self) => {
	if (self._tag === "Empty") return true;
	return reduce$5(self, true, (acc, cause$2) => {
		switch (cause$2._tag) {
			case OP_EMPTY$2: return some$4(acc);
			case "Die":
			case OP_FAIL$1:
			case OP_INTERRUPT: return some$4(false);
			default: return none$7();
		}
	});
};
const isInterrupted$2 = (self) => isSome(interruptOption$1(self));
const isInterruptedOnly$1 = (self) => reduceWithContext$3(void 0, IsInterruptedOnlyCauseReducer)(self);
const failures$1 = (self) => reverse$1(reduce$5(self, empty$31(), (list, cause$2) => cause$2._tag === "Fail" ? some$4(pipe(list, prepend$1(cause$2.error))) : none$7()));
const defects$1 = (self) => reverse$1(reduce$5(self, empty$31(), (list, cause$2) => cause$2._tag === "Die" ? some$4(pipe(list, prepend$1(cause$2.defect))) : none$7()));
const interruptors$1 = (self) => reduce$5(self, empty$28(), (set$6, cause$2) => cause$2._tag === "Interrupt" ? some$4(pipe(set$6, add$1(cause$2.fiberId))) : none$7());
const failureOption$1 = (self) => find$1(self, (cause$2) => cause$2._tag === "Fail" ? some$4(cause$2.error) : none$7());
const failureOrCause$1 = (self) => {
	const option$4 = failureOption$1(self);
	switch (option$4._tag) {
		case "None": return right(self);
		case "Some": return left(option$4.value);
	}
};
const interruptOption$1 = (self) => find$1(self, (cause$2) => cause$2._tag === "Interrupt" ? some$4(cause$2.fiberId) : none$7());
const keepDefectsAndElectFailures = (self) => match$10(self, {
	onEmpty: none$7(),
	onFail: (failure) => some$4(die$6(failure)),
	onDie: (defect) => some$4(die$6(defect)),
	onInterrupt: () => none$7(),
	onSequential: mergeWith(sequential$3),
	onParallel: mergeWith(parallel$3)
});
const stripFailures$1 = (self) => match$10(self, {
	onEmpty: empty$16,
	onFail: () => empty$16,
	onDie: die$6,
	onInterrupt: interrupt$6,
	onSequential: sequential$3,
	onParallel: parallel$3
});
const electFailures = (self) => match$10(self, {
	onEmpty: empty$16,
	onFail: die$6,
	onDie: die$6,
	onInterrupt: interrupt$6,
	onSequential: sequential$3,
	onParallel: parallel$3
});
var causeEquals = (left$2, right$2) => {
	let leftStack = of$3(left$2);
	let rightStack = of$3(right$2);
	while (isNonEmpty$4(leftStack) && isNonEmpty$4(rightStack)) {
		const [leftParallel, leftSequential] = pipe(headNonEmpty(leftStack), reduce$5([empty$28(), empty$31()], ([parallel$4, sequential$4], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return some$4([pipe(parallel$4, union$5(par$1)), pipe(sequential$4, appendAll$1(seq$1))]);
		}));
		const [rightParallel, rightSequential] = pipe(headNonEmpty(rightStack), reduce$5([empty$28(), empty$31()], ([parallel$4, sequential$4], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return some$4([pipe(parallel$4, union$5(par$1)), pipe(sequential$4, appendAll$1(seq$1))]);
		}));
		if (!equals(leftParallel, rightParallel)) return false;
		leftStack = leftSequential;
		rightStack = rightSequential;
	}
	return true;
};
var flattenCause = (cause$2) => {
	return flattenCauseLoop(of$3(cause$2), empty$31());
};
var flattenCauseLoop = (causes, flattened) => {
	while (1) {
		const [parallel$4, sequential$4] = pipe(causes, reduce$12([empty$28(), empty$31()], ([parallel$5, sequential$5], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return [pipe(parallel$5, union$5(par$1)), pipe(sequential$5, appendAll$1(seq$1))];
		}));
		const updated = size$8(parallel$4) > 0 ? pipe(flattened, prepend$1(parallel$4)) : flattened;
		if (isEmpty$9(sequential$4)) return reverse$1(updated);
		causes = sequential$4;
		flattened = updated;
	}
	throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
const find$1 = /* @__PURE__ */ dual(2, (self, pf) => {
	const stack = [self];
	while (stack.length > 0) {
		const item = stack.pop();
		const option$4 = pf(item);
		switch (option$4._tag) {
			case "None":
				switch (item._tag) {
					case OP_SEQUENTIAL$1:
					case OP_PARALLEL$1:
						stack.push(item.right);
						stack.push(item.left);
						break;
				}
				break;
			case "Some": return option$4;
		}
	}
	return none$7();
});
var evaluateCause = (self) => {
	let cause$2 = self;
	const stack = [];
	let _parallel = empty$28();
	let _sequential = empty$31();
	while (cause$2 !== void 0) switch (cause$2._tag) {
		case OP_EMPTY$2:
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_FAIL$1:
			_parallel = add$1(_parallel, make$42(cause$2._tag, cause$2.error));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case "Die":
			_parallel = add$1(_parallel, make$42(cause$2._tag, cause$2.defect));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_INTERRUPT:
			_parallel = add$1(_parallel, make$42(cause$2._tag, cause$2.fiberId));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_SEQUENTIAL$1:
			switch (cause$2.left._tag) {
				case OP_EMPTY$2:
					cause$2 = cause$2.right;
					break;
				case OP_SEQUENTIAL$1:
					cause$2 = sequential$3(cause$2.left.left, sequential$3(cause$2.left.right, cause$2.right));
					break;
				case OP_PARALLEL$1:
					cause$2 = parallel$3(sequential$3(cause$2.left.left, cause$2.right), sequential$3(cause$2.left.right, cause$2.right));
					break;
				default:
					_sequential = prepend$1(_sequential, cause$2.right);
					cause$2 = cause$2.left;
					break;
			}
			break;
		case OP_PARALLEL$1:
			stack.push(cause$2.right);
			cause$2 = cause$2.left;
			break;
	}
	throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
	emptyCase: constTrue,
	failCase: constFalse,
	dieCase: constFalse,
	interruptCase: constTrue,
	sequentialCase: (_, left$2, right$2) => left$2 && right$2,
	parallelCase: (_, left$2, right$2) => left$2 && right$2
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
const match$10 = /* @__PURE__ */ dual(2, (self, { onDie, onEmpty, onFail, onInterrupt: onInterrupt$2, onParallel, onSequential }) => {
	return reduceWithContext$3(self, void 0, {
		emptyCase: () => onEmpty,
		failCase: (_, error) => onFail(error),
		dieCase: (_, defect) => onDie(defect),
		interruptCase: (_, fiberId$2) => onInterrupt$2(fiberId$2),
		sequentialCase: (_, left$2, right$2) => onSequential(left$2, right$2),
		parallelCase: (_, left$2, right$2) => onParallel(left$2, right$2)
	});
});
const reduce$5 = /* @__PURE__ */ dual(3, (self, zero$1, pf) => {
	let accumulator = zero$1;
	let cause$2 = self;
	const causes = [];
	while (cause$2 !== void 0) {
		const option$4 = pf(accumulator, cause$2);
		accumulator = isSome(option$4) ? option$4.value : accumulator;
		switch (cause$2._tag) {
			case OP_SEQUENTIAL$1:
				causes.push(cause$2.right);
				cause$2 = cause$2.left;
				break;
			case OP_PARALLEL$1:
				causes.push(cause$2.right);
				cause$2 = cause$2.left;
				break;
			default:
				cause$2 = void 0;
				break;
		}
		if (cause$2 === void 0 && causes.length > 0) cause$2 = causes.pop();
	}
	return accumulator;
});
const reduceWithContext$3 = /* @__PURE__ */ dual(3, (self, context$3, reducer) => {
	const input = [self];
	const output = [];
	while (input.length > 0) {
		const cause$2 = input.pop();
		switch (cause$2._tag) {
			case OP_EMPTY$2:
				output.push(right(reducer.emptyCase(context$3)));
				break;
			case OP_FAIL$1:
				output.push(right(reducer.failCase(context$3, cause$2.error)));
				break;
			case "Die":
				output.push(right(reducer.dieCase(context$3, cause$2.defect)));
				break;
			case OP_INTERRUPT:
				output.push(right(reducer.interruptCase(context$3, cause$2.fiberId)));
				break;
			case OP_SEQUENTIAL$1:
				input.push(cause$2.right);
				input.push(cause$2.left);
				output.push(left({ _tag: OP_SEQUENTIAL_CASE }));
				break;
			case OP_PARALLEL$1:
				input.push(cause$2.right);
				input.push(cause$2.left);
				output.push(left({ _tag: OP_PARALLEL_CASE }));
				break;
		}
	}
	const accumulator = [];
	while (output.length > 0) {
		const either$4 = output.pop();
		switch (either$4._tag) {
			case "Left":
				switch (either$4.left._tag) {
					case OP_SEQUENTIAL_CASE: {
						const left$2 = accumulator.pop();
						const right$2 = accumulator.pop();
						const value$2 = reducer.sequentialCase(context$3, left$2, right$2);
						accumulator.push(value$2);
						break;
					}
					case OP_PARALLEL_CASE: {
						const left$2 = accumulator.pop();
						const right$2 = accumulator.pop();
						const value$2 = reducer.parallelCase(context$3, left$2, right$2);
						accumulator.push(value$2);
						break;
					}
				}
				break;
			case "Right":
				accumulator.push(either$4.right);
				break;
		}
	}
	if (accumulator.length === 0) throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
	return accumulator.pop();
});
const pretty$3 = (cause$2, options) => {
	if (isInterruptedOnly$1(cause$2)) return "All fibers interrupted without errors.";
	return prettyErrors$1(cause$2).map(function(e) {
		if (options?.renderErrorCause !== true || e.cause === void 0) return e.stack;
		return `${e.stack} {\n${renderErrorCause(e.cause, "  ")}\n}`;
	}).join("\n");
};
var renderErrorCause = (cause$2, prefix) => {
	const lines = cause$2.stack.split("\n");
	let stack = `${prefix}[cause]: ${lines[0]}`;
	for (let i = 1, len = lines.length; i < len; i++) stack += `\n${prefix}${lines[i]}`;
	if (cause$2.cause) stack += ` {\n${renderErrorCause(cause$2.cause, `${prefix}  `)}\n${prefix}}`;
	return stack;
};
var PrettyError = class PrettyError extends globalThis.Error {
	span = void 0;
	constructor(originalError$1) {
		const originalErrorIsObject = typeof originalError$1 === "object" && originalError$1 !== null;
		const prevLimit = Error.stackTraceLimit;
		Error.stackTraceLimit = 1;
		super(prettyErrorMessage(originalError$1), originalErrorIsObject && "cause" in originalError$1 && typeof originalError$1.cause !== "undefined" ? { cause: new PrettyError(originalError$1.cause) } : void 0);
		if (this.message === "") this.message = "An error has occurred";
		Error.stackTraceLimit = prevLimit;
		this.name = originalError$1 instanceof Error ? originalError$1.name : "Error";
		if (originalErrorIsObject) {
			if (spanSymbol in originalError$1) this.span = originalError$1[spanSymbol];
			Object.keys(originalError$1).forEach((key) => {
				if (!(key in this)) this[key] = originalError$1[key];
			});
		}
		this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError$1 instanceof Error && originalError$1.stack ? originalError$1.stack : "", this.span);
	}
};
const prettyErrorMessage = (u) => {
	if (typeof u === "string") return u;
	if (typeof u === "object" && u !== null && u instanceof Error) return u.message;
	try {
		if (hasProperty(u, "toString") && isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) return u["toString"]();
	} catch {}
	return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
const spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span$1) => {
	const out = [message];
	const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
	for (let i = 1; i < lines.length; i++) {
		if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
			i++;
			continue;
		}
		if (lines[i].includes("Generator.next")) break;
		if (lines[i].includes("effect_internal_function")) break;
		out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
	}
	if (span$1) {
		let current = span$1;
		let i = 0;
		while (current && current._tag === "Span" && i < 10) {
			const stackFn = spanToTrace.get(current);
			if (typeof stackFn === "function") {
				const stack$1 = stackFn();
				if (typeof stack$1 === "string") {
					const locationMatchAll = stack$1.matchAll(locationRegex);
					let match$15 = false;
					for (const [, location] of locationMatchAll) {
						match$15 = true;
						out.push(`    at ${current.name} (${location})`);
					}
					if (!match$15) out.push(`    at ${current.name} (${stack$1.replace(/^at /, "")})`);
				} else out.push(`    at ${current.name}`);
			} else out.push(`    at ${current.name}`);
			current = getOrUndefined(current.parent);
			i++;
		}
	}
	return out.join("\n");
};
const spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
const prettyErrors$1 = (cause$2) => reduceWithContext$3(cause$2, void 0, {
	emptyCase: () => [],
	dieCase: (_, unknownError) => {
		return [new PrettyError(unknownError)];
	},
	failCase: (_, error) => {
		return [new PrettyError(error)];
	},
	interruptCase: () => [],
	parallelCase: (_, l, r) => [...l, ...r],
	sequentialCase: (_, l, r) => [...l, ...r]
});
const OP_STATE_PENDING = "Pending";
const OP_STATE_DONE = "Done";
const DeferredTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Deferred");
const deferredVariance = {
	_E: (_) => _,
	_A: (_) => _
};
const pending$1 = (joiners) => {
	return {
		_tag: OP_STATE_PENDING,
		joiners
	};
};
const done$7 = (effect) => {
	return {
		_tag: OP_STATE_DONE,
		effect
	};
};
var SingleShotGen$1 = class SingleShotGen$1 {
	self;
	called = false;
	constructor(self) {
		this.self = self;
	}
	next(a) {
		return this.called ? {
			value: a,
			done: true
		} : (this.called = true, {
			value: this.self,
			done: false
		});
	}
	return(a) {
		return {
			value: a,
			done: true
		};
	}
	throw(e) {
		throw e;
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(this.self);
	}
};
const blocked$1 = (blockedRequests, _continue$2) => {
	const effect = new EffectPrimitive("Blocked");
	effect.effect_instruction_i0 = blockedRequests;
	effect.effect_instruction_i1 = _continue$2;
	return effect;
};
const runRequestBlock$1 = (blockedRequests) => {
	const effect = new EffectPrimitive("RunBlocked");
	effect.effect_instruction_i0 = blockedRequests;
	return effect;
};
const EffectTypeId$2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags = class {
	patch;
	op;
	_op = OP_REVERT_FLAGS;
	constructor(patch$11, op) {
		this.patch = patch$11;
		this.op = op;
	}
};
var EffectPrimitive = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
	}
	[symbol](that) {
		return this === that;
	}
	[symbol$1]() {
		return cached$2(this, random$2(this));
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Effect",
			_op: this._op,
			effect_instruction_i0: toJSON(this.effect_instruction_i0),
			effect_instruction_i1: toJSON(this.effect_instruction_i1),
			effect_instruction_i2: toJSON(this.effect_instruction_i2)
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
var EffectPrimitiveFailure = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
		this._tag = _op;
	}
	[symbol](that) {
		return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
	}
	[symbol$1]() {
		return pipe(string$2(this._tag), combine$11(hash(this.effect_instruction_i0)), cached$2(this));
	}
	get cause() {
		return this.effect_instruction_i0;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Exit",
			_tag: this._op,
			cause: this.cause.toJSON()
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
var EffectPrimitiveSuccess = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
		this._tag = _op;
	}
	[symbol](that) {
		return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
	}
	[symbol$1]() {
		return pipe(string$2(this._tag), combine$11(hash(this.effect_instruction_i0)), cached$2(this));
	}
	get value() {
		return this.effect_instruction_i0;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Exit",
			_tag: this._op,
			value: toJSON(this.value)
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
const isEffect$1 = (u) => hasProperty(u, EffectTypeId$2);
const withFiberRuntime$1 = (withRuntime) => {
	const effect = new EffectPrimitive(OP_WITH_RUNTIME);
	effect.effect_instruction_i0 = withRuntime;
	return effect;
};
const acquireUseRelease$1 = /* @__PURE__ */ dual(3, (acquire, use$1, release) => uninterruptibleMask$2((restore) => flatMap$6(acquire, (a) => flatMap$6(exit$2(suspend$5(() => restore(use$1(a)))), (exit$3) => {
	return suspend$5(() => release(a, exit$3)).pipe(matchCauseEffect$2({
		onFailure: (cause$2) => {
			switch (exit$3._tag) {
				case OP_FAILURE: return failCause$9(sequential$3(exit$3.effect_instruction_i0, cause$2));
				case OP_SUCCESS: return failCause$9(cause$2);
			}
		},
		onSuccess: () => exit$3
	}));
}))));
const as$4 = /* @__PURE__ */ dual(2, (self, value$2) => flatMap$6(self, () => succeed$12(value$2)));
const asVoid$3 = (self) => as$4(self, void 0);
const custom$1 = function() {
	const wrapper = new EffectPrimitive(OP_COMMIT);
	switch (arguments.length) {
		case 2:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.commit = arguments[1];
			break;
		case 3:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.effect_instruction_i1 = arguments[1];
			wrapper.commit = arguments[2];
			break;
		case 4:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.effect_instruction_i1 = arguments[1];
			wrapper.effect_instruction_i2 = arguments[2];
			wrapper.commit = arguments[3];
			break;
		default: throw new Error(getBugErrorMessage("you're not supposed to end up here"));
	}
	return wrapper;
};
const unsafeAsync = (register, blockingOn = none$6) => {
	const effect = new EffectPrimitive(OP_ASYNC);
	let cancelerRef = void 0;
	effect.effect_instruction_i0 = (resume$1) => {
		cancelerRef = register(resume$1);
	};
	effect.effect_instruction_i1 = blockingOn;
	return onInterrupt$1(effect, (_) => isEffect$1(cancelerRef) ? cancelerRef : void_$4);
};
const asyncInterrupt = (register, blockingOn = none$6) => suspend$5(() => unsafeAsync(register, blockingOn));
var async_ = (resume$1, blockingOn = none$6) => {
	return custom$1(resume$1, function() {
		let backingResume = void 0;
		let pendingEffect = void 0;
		function proxyResume(effect$1) {
			if (backingResume) backingResume(effect$1);
			else if (pendingEffect === void 0) pendingEffect = effect$1;
		}
		const effect = new EffectPrimitive(OP_ASYNC);
		effect.effect_instruction_i0 = (resume$2) => {
			backingResume = resume$2;
			if (pendingEffect) resume$2(pendingEffect);
		};
		effect.effect_instruction_i1 = blockingOn;
		let cancelerRef = void 0;
		let controllerRef = void 0;
		if (this.effect_instruction_i0.length !== 1) {
			controllerRef = new AbortController();
			cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
		} else cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
		return cancelerRef || controllerRef ? onInterrupt$1(effect, (_) => {
			if (controllerRef) controllerRef.abort();
			return cancelerRef ?? void_$4;
		}) : effect;
	});
};
const catchAllCause$2 = /* @__PURE__ */ dual(2, (self, f) => {
	const effect = new EffectPrimitive(OP_ON_FAILURE);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = f;
	return effect;
});
const catchAll$2 = /* @__PURE__ */ dual(2, (self, f) => matchEffect$2(self, {
	onFailure: f,
	onSuccess: succeed$12
}));
const catchIf$1 = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause$2(self, (cause$2) => {
	const either$4 = failureOrCause$1(cause$2);
	switch (either$4._tag) {
		case "Left": return predicate(either$4.left) ? f(either$4.left) : failCause$9(cause$2);
		case "Right": return failCause$9(either$4.right);
	}
}));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
const capture = (obj, span$1) => {
	if (isSome(span$1)) return new Proxy(obj, {
		has(target, p) {
			return p === spanSymbol || p === originalSymbol || p in target;
		},
		get(target, p) {
			if (p === spanSymbol) return span$1.value;
			if (p === originalSymbol) return obj;
			return target[p];
		}
	});
	return obj;
};
const die$5 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime$1((fiber) => failCause$9(die$6(capture(defect, currentSpanFromFiber(fiber))))) : failCause$9(die$6(defect));
const dieMessage$1 = (message) => failCauseSync$3(() => die$6(new RuntimeException$1(message)));
const either$1 = (self) => matchEffect$2(self, {
	onFailure: (e) => succeed$12(left(e)),
	onSuccess: (a) => succeed$12(right(a))
});
const exit$2 = (self) => matchCause$3(self, {
	onFailure: exitFailCause$1,
	onSuccess: exitSucceed$1
});
const fail$12 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime$1((fiber) => failCause$9(fail$13(capture(error, currentSpanFromFiber(fiber))))) : failCause$9(fail$13(error));
const failSync$3 = (evaluate$1) => flatMap$6(sync$6(evaluate$1), fail$12);
const failCause$9 = (cause$2) => {
	const effect = new EffectPrimitiveFailure(OP_FAILURE);
	effect.effect_instruction_i0 = cause$2;
	return effect;
};
const failCauseSync$3 = (evaluate$1) => flatMap$6(sync$6(evaluate$1), failCause$9);
const fiberId$1 = /* @__PURE__ */ withFiberRuntime$1((state) => succeed$12(state.id()));
const fiberIdWith$1 = (f) => withFiberRuntime$1((state) => f(state.id()));
const flatMap$6 = /* @__PURE__ */ dual(2, (self, f) => {
	const effect = new EffectPrimitive(OP_ON_SUCCESS);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = f;
	return effect;
});
const andThen$3 = /* @__PURE__ */ dual(2, (self, f) => flatMap$6(self, (a) => {
	const b = typeof f === "function" ? f(a) : f;
	if (isEffect$1(b)) return b;
	else if (isPromiseLike(b)) return unsafeAsync((resume$1) => {
		b.then((a$1) => resume$1(succeed$12(a$1)), (e) => resume$1(fail$12(new UnknownException$1(e, "An unknown error occurred in Effect.andThen"))));
	});
	return succeed$12(b);
}));
const step$1 = (self) => {
	const effect = new EffectPrimitive("OnStep");
	effect.effect_instruction_i0 = self;
	return effect;
};
const flatten$4 = (self) => flatMap$6(self, identity);
const matchCause$3 = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => succeed$12(options.onFailure(cause$2)),
	onSuccess: (a) => succeed$12(options.onSuccess(a))
}));
const matchCauseEffect$2 = /* @__PURE__ */ dual(2, (self, options) => {
	const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = options.onFailure;
	effect.effect_instruction_i2 = options.onSuccess;
	return effect;
});
const matchEffect$2 = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		if (defects$1(cause$2).length > 0) return failCause$9(electFailures(cause$2));
		const failures$2 = failures$1(cause$2);
		if (failures$2.length > 0) return options.onFailure(unsafeHead(failures$2));
		return failCause$9(cause$2);
	},
	onSuccess: options.onSuccess
}));
const forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend$5(() => {
	const arr = fromIterable$10(self);
	const ret = allocate(arr.length);
	let i = 0;
	return as$4(whileLoop$2({
		while: () => i < arr.length,
		body: () => f(arr[i], i),
		step: (b) => {
			ret[i++] = b;
		}
	}), ret);
}));
const forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend$5(() => {
	const arr = fromIterable$10(self);
	let i = 0;
	return whileLoop$2({
		while: () => i < arr.length,
		body: () => f(arr[i], i),
		step: () => {
			i++;
		}
	});
}));
const interruptible$2 = (self) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = enable(1);
	effect.effect_instruction_i1 = () => self;
	return effect;
};
const intoDeferred$1 = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask$2((restore) => flatMap$6(exit$2(restore(self)), (exit$3) => deferredDone(deferred, exit$3))));
const map$12 = /* @__PURE__ */ dual(2, (self, f) => flatMap$6(self, (a) => sync$6(() => f(a))));
const mapBoth$2 = /* @__PURE__ */ dual(2, (self, options) => matchEffect$2(self, {
	onFailure: (e) => failSync$3(() => options.onFailure(e)),
	onSuccess: (a) => sync$6(() => options.onSuccess(a))
}));
const mapError$4 = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const either$4 = failureOrCause$1(cause$2);
		switch (either$4._tag) {
			case "Left": return failSync$3(() => f(either$4.left));
			case "Right": return failCause$9(either$4.right);
		}
	},
	onSuccess: succeed$12
}));
const onExit$2 = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask$2((restore) => matchCauseEffect$2(restore(self), {
	onFailure: (cause1) => {
		const result = exitFailCause$1(cause1);
		return matchCauseEffect$2(cleanup(result), {
			onFailure: (cause2) => exitFailCause$1(sequential$3(cause1, cause2)),
			onSuccess: () => result
		});
	},
	onSuccess: (success) => {
		const result = exitSucceed$1(success);
		return zipRight$3(cleanup(result), result);
	}
})));
const onInterrupt$1 = /* @__PURE__ */ dual(2, (self, cleanup) => onExit$2(self, exitMatch({
	onFailure: (cause$2) => isInterruptedOnly$1(cause$2) ? asVoid$3(cleanup(interruptors$1(cause$2))) : void_$4,
	onSuccess: () => void_$4
})));
const orElse$8 = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed$12));
const orDie$2 = (self) => orDieWith$1(self, identity);
const orDieWith$1 = /* @__PURE__ */ dual(2, (self, f) => matchEffect$2(self, {
	onFailure: (e) => die$5(f(e)),
	onSuccess: succeed$12
}));
const runtimeFlags = /* @__PURE__ */ withFiberRuntime$1((_, status$2) => succeed$12(status$2.runtimeFlags));
const succeed$12 = (value$2) => {
	const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
	effect.effect_instruction_i0 = value$2;
	return effect;
};
const suspend$5 = (evaluate$1) => {
	const effect = new EffectPrimitive(OP_COMMIT);
	effect.commit = evaluate$1;
	return effect;
};
const sync$6 = (thunk) => {
	const effect = new EffectPrimitive(OP_SYNC);
	effect.effect_instruction_i0 = thunk;
	return effect;
};
const tap$2 = /* @__PURE__ */ dual((args$1) => args$1.length === 3 || args$1.length === 2 && !(isObject(args$1[1]) && "onlyEffect" in args$1[1]), (self, f) => flatMap$6(self, (a) => {
	const b = typeof f === "function" ? f(a) : f;
	if (isEffect$1(b)) return as$4(b, a);
	else if (isPromiseLike(b)) return unsafeAsync((resume$1) => {
		b.then((_) => resume$1(succeed$12(a)), (e) => resume$1(fail$12(new UnknownException$1(e, "An unknown error occurred in Effect.tap"))));
	});
	return succeed$12(a);
}));
const transplant$1 = (f) => withFiberRuntime$1((state) => {
	return f(fiberRefLocally$1(currentForkScopeOverride, some$4(pipe(state.getFiberRef(currentForkScopeOverride), getOrElse$5(() => state.scope())))));
});
const attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		if (defects$1(cause$2).length > 0) return failCause$9(getOrThrow(keepDefectsAndElectFailures(cause$2)));
		return that();
	},
	onSuccess
}));
const uninterruptible$1 = (self) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = disable(1);
	effect.effect_instruction_i1 = () => self;
	return effect;
};
const uninterruptibleMask$2 = (f) => custom$1(f, function() {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = disable(1);
	effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible$2)) : internalCall(() => this.effect_instruction_i0(uninterruptible$1));
	return effect;
});
var void_$4 = /* @__PURE__ */ succeed$12(void 0);
const updateRuntimeFlags = (patch$11) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = patch$11;
	effect.effect_instruction_i1 = void 0;
	return effect;
};
const whenEffect$1 = /* @__PURE__ */ dual(2, (self, condition) => flatMap$6(condition, (b) => {
	if (b) return pipe(self, map$12(some$4));
	return succeed$12(none$7());
}));
const whileLoop$2 = (options) => {
	const effect = new EffectPrimitive(OP_WHILE);
	effect.effect_instruction_i0 = options.while;
	effect.effect_instruction_i1 = options.body;
	effect.effect_instruction_i2 = options.step;
	return effect;
};
const fromIterator = (iterator) => suspend$5(() => {
	const effect = new EffectPrimitive(OP_ITERATOR);
	effect.effect_instruction_i0 = iterator();
	return effect;
});
const gen$1 = function() {
	const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
	return fromIterator(() => f(pipe));
};
const fnUntraced$1 = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args$1) {
	return fromIterator(() => body.apply(this, args$1));
} : function(...args$1) {
	let effect = fromIterator(() => body.apply(this, args$1));
	for (const x of pipeables) effect = x(effect, ...args$1);
	return effect;
}, "length", {
	value: body.length,
	configurable: true
});
const withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update$5) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = update$5;
	effect.effect_instruction_i1 = () => self;
	return effect;
});
const yieldNow$3 = (options) => {
	const effect = new EffectPrimitive(OP_YIELD);
	return typeof options?.priority !== "undefined" ? withSchedulingPriority$1(effect, options.priority) : effect;
};
const zip$6 = /* @__PURE__ */ dual(2, (self, that) => flatMap$6(self, (a) => map$12(that, (b) => [a, b])));
const zipLeft$3 = /* @__PURE__ */ dual(2, (self, that) => flatMap$6(self, (a) => as$4(that, a)));
const zipRight$3 = /* @__PURE__ */ dual(2, (self, that) => flatMap$6(self, () => that));
const zipWith$6 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap$6(self, (a) => map$12(that, (b) => f(a, b))));
const never$3 = /* @__PURE__ */ asyncInterrupt(() => {
	const interval = setInterval(() => {}, 2 ** 31 - 1);
	return sync$6(() => clearInterval(interval));
});
const interruptFiber = (self) => flatMap$6(fiberId$1, (fiberId$2) => pipe(self, interruptAsFiber(fiberId$2)));
const interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId$2) => flatMap$6(self.interruptAsFork(fiberId$2), () => self.await));
const logLevelAll = {
	_tag: "All",
	syslog: 0,
	label: "ALL",
	ordinal: Number.MIN_SAFE_INTEGER,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const logLevelFatal = {
	_tag: "Fatal",
	syslog: 2,
	label: "FATAL",
	ordinal: 5e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const logLevelError = {
	_tag: "Error",
	syslog: 3,
	label: "ERROR",
	ordinal: 4e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const logLevelWarning = {
	_tag: "Warning",
	syslog: 4,
	label: "WARN",
	ordinal: 3e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const logLevelInfo = {
	_tag: "Info",
	syslog: 6,
	label: "INFO",
	ordinal: 2e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const logLevelDebug = {
	_tag: "Debug",
	syslog: 7,
	label: "DEBUG",
	ordinal: 1e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const logLevelTrace = {
	_tag: "Trace",
	syslog: 7,
	label: "TRACE",
	ordinal: 0,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const logLevelNone = {
	_tag: "None",
	syslog: 7,
	label: "OFF",
	ordinal: Number.MAX_SAFE_INTEGER,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const FiberRefTypeId = /* @__PURE__ */ Symbol.for("effect/FiberRef");
var fiberRefVariance = { _A: (_) => _ };
const fiberRefGet = (self) => withFiberRuntime$1((fiber) => exitSucceed$1(fiber.getFiberRef(self)));
const fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap$6(fiberRefGet(self), f));
const fiberRefSet = /* @__PURE__ */ dual(2, (self, value$2) => fiberRefModify(self, () => [void 0, value$2]));
const fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime$1((state) => {
	const [b, a] = f(state.getFiberRef(self));
	state.setFiberRef(self, a);
	return succeed$12(b);
}));
const fiberRefLocally$1 = /* @__PURE__ */ dual(3, (use$1, self, value$2) => acquireUseRelease$1(zipLeft$3(fiberRefGet(self), fiberRefSet(self, value$2)), () => use$1, (oldValue) => fiberRefSet(self, oldValue)));
const fiberRefLocallyWith$1 = /* @__PURE__ */ dual(3, (use$1, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally$1(use$1, self, f(a))));
const fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
	differ: update$4(),
	fork: options?.fork ?? identity,
	join: options?.join
});
const fiberRefUnsafeMakeHashSet = (initial) => {
	const differ$2 = hashSet$3();
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
const fiberRefUnsafeMakeReadonlyArray = (initial) => {
	const differ$2 = readonlyArray$1(update$4());
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
const fiberRefUnsafeMakeContext = (initial) => {
	const differ$2 = environment$1();
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
const fiberRefUnsafeMakePatch = (initial, options) => {
	return {
		...CommitPrototype$1,
		[FiberRefTypeId]: fiberRefVariance,
		initial,
		commit() {
			return fiberRefGet(this);
		},
		diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
		combine: (first$2, second) => options.differ.combine(first$2, second),
		patch: (patch$11) => (oldValue) => options.differ.patch(patch$11, oldValue),
		fork: options.fork,
		join: options.join ?? ((_, n) => n)
	};
};
const fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
	differ: differ$1,
	fork: differ$1.empty
});
const currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty$32()));
const currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
const currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
const currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty$27()));
const currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
const currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty$26()));
const withSchedulingPriority$1 = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally$1(self, currentSchedulingPriority, scheduler));
const currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
const currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
const currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some$4(logLevelDebug)));
const currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some$4(logLevelWarning)));
const currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty$34()));
const currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none$7(), {
	fork: () => none$7(),
	join: (parent, _) => parent
}));
const currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty$16, {
	fork: () => empty$16,
	join: (parent, _) => parent
}));
const currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
const currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
const currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty$27()));
const currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty$31()));
const ScopeTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Scope");
const CloseableScopeTypeId$1 = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
const scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid$3(finalizer));
const scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);
const scopeClose = (self, exit$3) => self.close(exit$3);
const scopeFork = (self, strategy) => self.fork(strategy);
const YieldableError$1 = /* @__PURE__ */ function() {
	class YieldableError$2 extends globalThis.Error {
		commit() {
			return fail$12(this);
		}
		toJSON() {
			const obj = { ...this };
			if (this.message) obj.message = this.message;
			if (this.cause) obj.cause = this.cause;
			return obj;
		}
		[NodeInspectSymbol]() {
			if (this.toString !== globalThis.Error.prototype.toString) return this.stack ? `${this.toString()}\n${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
			else if ("Bun" in globalThis) return pretty$3(fail$13(this), { renderErrorCause: true });
			return this;
		}
	}
	Object.assign(YieldableError$2.prototype, StructuralCommitPrototype$1);
	return YieldableError$2;
}();
var makeException = (proto$5, tag) => {
	class Base$2 extends YieldableError$1 {
		_tag = tag;
	}
	Object.assign(Base$2.prototype, proto$5);
	Base$2.prototype.name = tag;
	return Base$2;
};
const RuntimeExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
const RuntimeException$1 = /* @__PURE__ */ makeException({ [RuntimeExceptionTypeId$1]: RuntimeExceptionTypeId$1 }, "RuntimeException");
const InterruptedExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
const isInterruptedException$1 = (u) => hasProperty(u, InterruptedExceptionTypeId$1);
const NoSuchElementExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
const NoSuchElementException$1 = /* @__PURE__ */ makeException({ [NoSuchElementExceptionTypeId$1]: NoSuchElementExceptionTypeId$1 }, "NoSuchElementException");
const UnknownExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
const UnknownException$1 = /* @__PURE__ */ function() {
	class UnknownException$2 extends YieldableError$1 {
		_tag = "UnknownException";
		error;
		constructor(cause$2, message) {
			super(message ?? "An unknown error occurred", { cause: cause$2 });
			this.error = cause$2;
		}
	}
	Object.assign(UnknownException$2.prototype, {
		[UnknownExceptionTypeId$1]: UnknownExceptionTypeId$1,
		name: "UnknownException"
	});
	return UnknownException$2;
}();
const exitIsExit = (u) => isEffect$1(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
const exitIsFailure = (self) => self._tag === "Failure";
const exitIsSuccess = (self) => self._tag === "Success";
const exitAs = /* @__PURE__ */ dual(2, (self, value$2) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return exitSucceed$1(value$2);
	}
});
const exitAsVoid = (self) => exitAs(self, void 0);
const exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel$3 : sequential$3);
const exitDie$1 = (defect) => exitFailCause$1(die$6(defect));
const exitFail = (error) => exitFailCause$1(fail$13(error));
const exitFailCause$1 = (cause$2) => {
	const effect = new EffectPrimitiveFailure(OP_FAILURE);
	effect.effect_instruction_i0 = cause$2;
	return effect;
};
const exitFlatMap = /* @__PURE__ */ dual(2, (self, f) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return f(self.effect_instruction_i0);
	}
});
const exitFlatten = (self) => pipe(self, exitFlatMap(identity));
const exitInterrupt$1 = (fiberId$2) => exitFailCause$1(interrupt$6(fiberId$2));
const exitMap = /* @__PURE__ */ dual(2, (self, f) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return exitSucceed$1(f(self.effect_instruction_i0));
	}
});
const exitMatch = /* @__PURE__ */ dual(2, (self, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: return onFailure(self.effect_instruction_i0);
		case OP_SUCCESS: return onSuccess(self.effect_instruction_i0);
	}
});
const exitMatchEffect = /* @__PURE__ */ dual(2, (self, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: return onFailure(self.effect_instruction_i0);
		case OP_SUCCESS: return onSuccess(self.effect_instruction_i0);
	}
});
const exitSucceed$1 = (value$2) => {
	const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
	effect.effect_instruction_i0 = value$2;
	return effect;
};
const exitVoid$1 = /* @__PURE__ */ exitSucceed$1(void 0);
const exitZipWith = /* @__PURE__ */ dual(3, (self, that, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: switch (that._tag) {
			case OP_SUCCESS: return exitFailCause$1(self.effect_instruction_i0);
			case OP_FAILURE: return exitFailCause$1(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
		}
		case OP_SUCCESS: switch (that._tag) {
			case OP_SUCCESS: return exitSucceed$1(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
			case OP_FAILURE: return exitFailCause$1(that.effect_instruction_i0);
		}
	}
});
var exitCollectAllInternal = (exits, combineCauses) => {
	const list = fromIterable$9(exits);
	if (!isNonEmpty$4(list)) return none$7();
	return pipe(tailNonEmpty(list), reduce$12(pipe(headNonEmpty(list), exitMap(of$3)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
		onSuccess: (list$1, value$2) => pipe(list$1, prepend$1(value$2)),
		onFailure: combineCauses
	}))), exitMap(reverse$1), exitMap((chunk$4) => toReadonlyArray(chunk$4)), some$4);
};
const deferredUnsafeMake = (fiberId$2) => {
	return {
		...CommitPrototype$1,
		[DeferredTypeId$1]: deferredVariance,
		state: make$36(pending$1([])),
		commit() {
			return deferredAwait(this);
		},
		blockingOn: fiberId$2
	};
};
const deferredMake = () => flatMap$6(fiberId$1, (id$2) => deferredMakeAs(id$2));
const deferredMakeAs = (fiberId$2) => sync$6(() => deferredUnsafeMake(fiberId$2));
const deferredAwait = (self) => asyncInterrupt((resume$1) => {
	const state = get$6(self.state);
	switch (state._tag) {
		case OP_STATE_DONE: return resume$1(state.effect);
		case OP_STATE_PENDING:
			state.joiners.push(resume$1);
			return deferredInterruptJoiner(self, resume$1);
	}
}, self.blockingOn);
const deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect) => sync$6(() => {
	const state = get$6(self.state);
	switch (state._tag) {
		case OP_STATE_DONE: return false;
		case OP_STATE_PENDING:
			set$4(self.state, done$7(effect));
			for (let i = 0, len = state.joiners.length; i < len; i++) state.joiners[i](effect);
			return true;
	}
}));
const deferredDone = /* @__PURE__ */ dual(2, (self, exit$3) => deferredCompleteWith(self, exit$3));
const deferredFailCause = /* @__PURE__ */ dual(2, (self, cause$2) => deferredCompleteWith(self, failCause$9(cause$2)));
const deferredSucceed = /* @__PURE__ */ dual(2, (self, value$2) => deferredCompleteWith(self, succeed$12(value$2)));
const deferredUnsafeDone = (self, effect) => {
	const state = get$6(self.state);
	if (state._tag === "Pending") {
		set$4(self.state, done$7(effect));
		for (let i = 0, len = state.joiners.length; i < len; i++) state.joiners[i](effect);
	}
};
var deferredInterruptJoiner = (self, joiner) => sync$6(() => {
	const state = get$6(self.state);
	if (state._tag === "Pending") {
		const index = state.joiners.indexOf(joiner);
		if (index >= 0) state.joiners.splice(index, 1);
	}
});
var constContext = /* @__PURE__ */ withFiberRuntime$1((fiber) => exitSucceed$1(fiber.currentContext));
const context$2 = () => constContext;
const contextWithEffect$1 = (f) => flatMap$6(context$2(), f);
const provideContext$1 = /* @__PURE__ */ dual(2, (self, context$3) => fiberRefLocally$1(currentContext, context$3)(self));
const provideSomeContext = /* @__PURE__ */ dual(2, (self, context$3) => fiberRefLocallyWith$1(currentContext, (parent) => merge$4(parent, context$3))(self));
const mapInputContext$1 = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect$1((context$3) => provideContext$1(self, f(context$3))));
const currentSpanFromFiber = (fiber) => {
	const span$1 = fiber.currentSpan;
	return span$1 !== void 0 && span$1._tag === "Span" ? some$4(span$1) : none$7();
};
var NoopSpanProto = {
	_tag: "Span",
	spanId: "noop",
	traceId: "noop",
	sampled: false,
	status: {
		_tag: "Ended",
		startTime: /* @__PURE__ */ BigInt(0),
		endTime: /* @__PURE__ */ BigInt(0),
		exit: exitVoid$1
	},
	attributes: /* @__PURE__ */ new Map(),
	links: [],
	kind: "internal",
	attribute() {},
	event() {},
	end() {},
	addLinks() {}
};
const noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);
const isSuccess$2 = exitIsSuccess;
const flatten$3 = exitFlatten;
var TypeId$9 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
	[TypeId$9]: TypeId$9,
	[Symbol.iterator]() {
		return new MutableHashMapIterator(this);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableHashMap",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var MutableHashMapIterator = class MutableHashMapIterator {
	self;
	referentialIterator;
	bucketIterator;
	constructor(self) {
		this.self = self;
		this.referentialIterator = self.referential[Symbol.iterator]();
	}
	next() {
		if (this.bucketIterator !== void 0) return this.bucketIterator.next();
		const result = this.referentialIterator.next();
		if (result.done) {
			this.bucketIterator = new BucketIterator(this.self.buckets.values());
			return this.next();
		}
		return result;
	}
	[Symbol.iterator]() {
		return new MutableHashMapIterator(this.self);
	}
};
var BucketIterator = class {
	backing;
	constructor(backing) {
		this.backing = backing;
	}
	currentBucket;
	next() {
		if (this.currentBucket === void 0) {
			const result$1 = this.backing.next();
			if (result$1.done) return result$1;
			this.currentBucket = result$1.value[Symbol.iterator]();
		}
		const result = this.currentBucket.next();
		if (result.done) {
			this.currentBucket = void 0;
			return this.next();
		}
		return result;
	}
};
const empty$15 = () => {
	const self = Object.create(MutableHashMapProto);
	self.referential = /* @__PURE__ */ new Map();
	self.buckets = /* @__PURE__ */ new Map();
	self.bucketsSize = 0;
	return self;
};
const get$4 = /* @__PURE__ */ dual(2, (self, key) => {
	if (isEqual(key) === false) return self.referential.has(key) ? some$4(self.referential.get(key)) : none$7();
	const hash$1 = key[symbol$1]();
	const bucket = self.buckets.get(hash$1);
	if (bucket === void 0) return none$7();
	return getFromBucket(self, bucket, key);
});
var getFromBucket = (self, bucket, key, remove$7 = false) => {
	for (let i = 0, len = bucket.length; i < len; i++) if (key[symbol](bucket[i][0])) {
		const value$2 = bucket[i][1];
		if (remove$7) {
			bucket.splice(i, 1);
			self.bucketsSize--;
		}
		return some$4(value$2);
	}
	return none$7();
};
const has$2 = /* @__PURE__ */ dual(2, (self, key) => isSome(get$4(self, key)));
const set$2 = /* @__PURE__ */ dual(3, (self, key, value$2) => {
	if (isEqual(key) === false) {
		self.referential.set(key, value$2);
		return self;
	}
	const hash$1 = key[symbol$1]();
	const bucket = self.buckets.get(hash$1);
	if (bucket === void 0) {
		self.buckets.set(hash$1, [[key, value$2]]);
		self.bucketsSize++;
		return self;
	}
	removeFromBucket(self, bucket, key);
	bucket.push([key, value$2]);
	self.bucketsSize++;
	return self;
});
var removeFromBucket = (self, bucket, key) => {
	for (let i = 0, len = bucket.length; i < len; i++) if (key[symbol](bucket[i][0])) {
		bucket.splice(i, 1);
		self.bucketsSize--;
		return;
	}
};
Symbol.iterator;
Symbol.iterator;
const ClockTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Clock");
const clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
const MAX_TIMER_MILLIS = 2 ** 31 - 1;
const globalClockScheduler = { unsafeSchedule(task, duration$2) {
	const millis$1 = toMillis(duration$2);
	if (millis$1 > MAX_TIMER_MILLIS) return constFalse;
	let completed = false;
	const handle = setTimeout(() => {
		completed = true;
		task();
	}, millis$1);
	return () => {
		clearTimeout(handle);
		return !completed;
	};
} };
var performanceNowNanos = /* @__PURE__ */ function() {
	const bigint1e6$1 = /* @__PURE__ */ BigInt(1e6);
	if (typeof performance === "undefined" || typeof performance.now !== "function") return () => BigInt(Date.now()) * bigint1e6$1;
	let origin;
	return () => {
		if (origin === void 0) origin = BigInt(Date.now()) * bigint1e6$1 - BigInt(Math.round(performance.now() * 1e6));
		return origin + BigInt(Math.round(performance.now() * 1e6));
	};
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
	const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
	if (!processHrtime) return performanceNowNanos;
	const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
	return () => origin + processHrtime.bigint();
}();
var ClockImpl = class {
	[ClockTypeId$1] = ClockTypeId$1;
	unsafeCurrentTimeMillis() {
		return Date.now();
	}
	unsafeCurrentTimeNanos() {
		return processOrPerformanceNow();
	}
	currentTimeMillis = /* @__PURE__ */ sync$6(() => this.unsafeCurrentTimeMillis());
	currentTimeNanos = /* @__PURE__ */ sync$6(() => this.unsafeCurrentTimeNanos());
	scheduler() {
		return succeed$12(globalClockScheduler);
	}
	sleep(duration$2) {
		return async_((resume$1) => {
			return asVoid$3(sync$6(globalClockScheduler.unsafeSchedule(() => resume$1(void_$4), duration$2)));
		});
	}
};
const make$26 = () => new ClockImpl();
const OP_INVALID_DATA = "InvalidData";
const OP_MISSING_DATA = "MissingData";
const OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
const OP_UNSUPPORTED = "Unsupported";
const ConfigErrorTypeId$1 = /* @__PURE__ */ Symbol.for("effect/ConfigError");
const proto$3 = {
	_tag: "ConfigError",
	[ConfigErrorTypeId$1]: ConfigErrorTypeId$1
};
const And$1 = (self, that) => {
	const error = Object.create(proto$3);
	error._op = "And";
	error.left = self;
	error.right = that;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `${this.left} and ${this.right}`;
		}
	});
	Object.defineProperty(error, "message", {
		enumerable: false,
		get() {
			return this.toString();
		}
	});
	return error;
};
const Or$1 = (self, that) => {
	const error = Object.create(proto$3);
	error._op = "Or";
	error.left = self;
	error.right = that;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `${this.left} or ${this.right}`;
		}
	});
	Object.defineProperty(error, "message", {
		enumerable: false,
		get() {
			return this.toString();
		}
	});
	return error;
};
const InvalidData$1 = (path$5, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$3);
	error._op = OP_INVALID_DATA;
	error.path = path$5;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Invalid data at ${pipe(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
const MissingData$1 = (path$5, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$3);
	error._op = OP_MISSING_DATA;
	error.path = path$5;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Missing data at ${pipe(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
const SourceUnavailable$1 = (path$5, message, cause$2, options = { pathDelim: "." }) => {
	const error = Object.create(proto$3);
	error._op = OP_SOURCE_UNAVAILABLE;
	error.path = path$5;
	error.message = message;
	error.cause = cause$2;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Source unavailable at ${pipe(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
const Unsupported$1 = (path$5, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$3);
	error._op = OP_UNSUPPORTED;
	error.path = path$5;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Unsupported operation at ${pipe(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
const isConfigError$1 = (u) => hasProperty(u, ConfigErrorTypeId$1);
const prefixed$1 = /* @__PURE__ */ dual(2, (self, prefix) => {
	switch (self._op) {
		case "And": return And$1(prefixed$1(self.left, prefix), prefixed$1(self.right, prefix));
		case "Or": return Or$1(prefixed$1(self.left, prefix), prefixed$1(self.right, prefix));
		case OP_INVALID_DATA: return InvalidData$1([...prefix, ...self.path], self.message);
		case OP_MISSING_DATA: return MissingData$1([...prefix, ...self.path], self.message);
		case OP_SOURCE_UNAVAILABLE: return SourceUnavailable$1([...prefix, ...self.path], self.message, self.cause);
		case OP_UNSUPPORTED: return Unsupported$1([...prefix, ...self.path], self.message);
	}
});
var IsMissingDataOnlyReducer = {
	andCase: (_, left$2, right$2) => left$2 && right$2,
	orCase: (_, left$2, right$2) => left$2 && right$2,
	invalidDataCase: constFalse,
	missingDataCase: constTrue,
	sourceUnavailableCase: constFalse,
	unsupportedCase: constFalse
};
const reduceWithContext$2 = /* @__PURE__ */ dual(3, (self, context$3, reducer) => {
	const input = [self];
	const output = [];
	while (input.length > 0) {
		const error = input.pop();
		switch (error._op) {
			case "And":
				input.push(error.right);
				input.push(error.left);
				output.push(left({ _op: "AndCase" }));
				break;
			case "Or":
				input.push(error.right);
				input.push(error.left);
				output.push(left({ _op: "OrCase" }));
				break;
			case OP_INVALID_DATA:
				output.push(right(reducer.invalidDataCase(context$3, error.path, error.message)));
				break;
			case OP_MISSING_DATA:
				output.push(right(reducer.missingDataCase(context$3, error.path, error.message)));
				break;
			case OP_SOURCE_UNAVAILABLE:
				output.push(right(reducer.sourceUnavailableCase(context$3, error.path, error.message, error.cause)));
				break;
			case OP_UNSUPPORTED:
				output.push(right(reducer.unsupportedCase(context$3, error.path, error.message)));
				break;
		}
	}
	const accumulator = [];
	while (output.length > 0) {
		const either$4 = output.pop();
		switch (either$4._op) {
			case "Left":
				switch (either$4.left._op) {
					case "AndCase": {
						const left$2 = accumulator.pop();
						const right$2 = accumulator.pop();
						const value$2 = reducer.andCase(context$3, left$2, right$2);
						accumulator.push(value$2);
						break;
					}
					case "OrCase": {
						const left$2 = accumulator.pop();
						const right$2 = accumulator.pop();
						const value$2 = reducer.orCase(context$3, left$2, right$2);
						accumulator.push(value$2);
						break;
					}
				}
				break;
			case "Right":
				accumulator.push(either$4.right);
				break;
		}
	}
	if (accumulator.length === 0) throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
	return accumulator.pop();
});
const isMissingDataOnly$1 = (self) => reduceWithContext$2(self, void 0, IsMissingDataOnlyReducer);
const empty$13 = { _tag: "Empty" };
const andThen$2 = /* @__PURE__ */ dual(2, (self, that) => ({
	_tag: "AndThen",
	first: self,
	second: that
}));
const mapName = /* @__PURE__ */ dual(2, (self, f) => andThen$2(self, {
	_tag: "MapName",
	f
}));
const nested$3 = /* @__PURE__ */ dual(2, (self, name) => andThen$2(self, {
	_tag: "Nested",
	name
}));
const unnested$1 = /* @__PURE__ */ dual(2, (self, name) => andThen$2(self, {
	_tag: "Unnested",
	name
}));
const patch$3 = /* @__PURE__ */ dual(2, (path$5, patch$11) => {
	let input = of$2(patch$11);
	let output = path$5;
	while (isCons(input)) {
		const patch$12 = input.head;
		switch (patch$12._tag) {
			case "Empty":
				input = input.tail;
				break;
			case "AndThen":
				input = cons(patch$12.first, cons(patch$12.second, input.tail));
				break;
			case "MapName":
				output = map$18(output, patch$12.f);
				input = input.tail;
				break;
			case "Nested":
				output = prepend$2(output, patch$12.name);
				input = input.tail;
				break;
			case "Unnested":
				if (pipe(head$3(output), contains$4(patch$12.name))) {
					output = tailNonEmpty$1(output);
					input = input.tail;
				} else return left(MissingData$1(output, `Expected ${patch$12.name} to be in path in ConfigProvider#unnested`));
				break;
		}
	}
	return right(output);
});
const OP_CONSTANT = "Constant";
const OP_FAIL = "Fail";
const OP_FALLBACK = "Fallback";
const OP_DESCRIBED = "Described";
const OP_LAZY = "Lazy";
const OP_MAP_OR_FAIL = "MapOrFail";
const OP_NESTED = "Nested";
const OP_PRIMITIVE = "Primitive";
const OP_SEQUENCE = "Sequence";
const OP_HASHMAP = "HashMap";
const OP_ZIP_WITH$1 = "ZipWith";
const lowerCase$1 = (str) => str.toLowerCase();
const upperCase$1 = (str) => str.toUpperCase();
var replace = (input, re, value$2) => re instanceof RegExp ? input.replace(re, value$2) : re.reduce((input$1, re$1) => input$1.replace(re$1, value$2), input);
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
var noCase = (input, options = {}) => {
	const { delimiter = " ", splitRegexp = DEFAULT_SPLIT_REGEXP, stripRegexp = DEFAULT_STRIP_REGEXP, transform: transform$3 = lowerCase$1 } = options;
	const result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
	let start$2 = 0;
	let end$2 = result.length;
	while (result.charAt(start$2) === "\0") start$2++;
	while (result.charAt(end$2 - 1) === "\0") end$2--;
	return result.slice(start$2, end$2).split("\0").map(transform$3).join(delimiter);
};
const constantCase$1 = (input, options) => noCase(input, {
	delimiter: "_",
	transform: upperCase$1,
	...options
});
const kebabCase$1 = (input, options) => noCase(input, {
	delimiter: "-",
	...options
});
const snakeCase$1 = (input, options) => noCase(input, {
	delimiter: "_",
	...options
});
var concat = (l, r) => [...l, ...r];
const ConfigProviderTypeId = /* @__PURE__ */ Symbol.for("effect/ConfigProvider");
const configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
const FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for("effect/ConfigProviderFlat");
const make$25 = (options) => ({
	[ConfigProviderTypeId]: ConfigProviderTypeId,
	pipe() {
		return pipeArguments(this, arguments);
	},
	...options
});
const makeFlat = (options) => ({
	[FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
	patch: options.patch,
	load: (path$5, config$1, split = true) => options.load(path$5, config$1, split),
	enumerateChildren: options.enumerateChildren
});
const fromFlat = (flat) => make$25({
	load: (config$1) => flatMap$6(fromFlatLoop(flat, empty$34(), config$1, false), (chunk$4) => match$13(head$3(chunk$4), {
		onNone: () => fail$12(MissingData$1(empty$34(), `Expected a single value having structure: ${config$1}`)),
		onSome: succeed$12
	})),
	flattened: flat
});
const fromEnv = (options) => {
	const { pathDelim, seqDelim } = Object.assign({}, {
		pathDelim: "_",
		seqDelim: ","
	}, options);
	const makePathString = (path$5) => pipe(path$5, join$3(pathDelim));
	const unmakePathString = (pathString) => pathString.split(pathDelim);
	const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
	const load = (path$5, primitive$2, split = true) => {
		const pathString = makePathString(path$5);
		const current = getEnv();
		return pipe(pathString in current ? some$4(current[pathString]) : none$7(), mapError$4(() => MissingData$1(path$5, `Expected ${pathString} to exist in the process context`)), flatMap$6((value$2) => parsePrimitive(value$2, path$5, primitive$2, seqDelim, split)));
	};
	const enumerateChildren = (path$5) => sync$6(() => {
		const current = getEnv();
		return fromIterable$6(Object.keys(current).map((value$2) => unmakePathString(value$2.toUpperCase())).filter((keyPath) => {
			for (let i = 0; i < path$5.length; i++) {
				const pathComponent = pipe(path$5, unsafeGet$5(i));
				const currentElement = keyPath[i];
				if (currentElement === void 0 || pathComponent !== currentElement) return false;
			}
			return true;
		}).flatMap((keyPath) => keyPath.slice(path$5.length, path$5.length + 1)));
	});
	return fromFlat(makeFlat({
		load,
		enumerateChildren,
		patch: empty$13
	}));
};
const fromMap = (map$21, config$1) => {
	const { pathDelim, seqDelim } = Object.assign({
		seqDelim: ",",
		pathDelim: "."
	}, config$1);
	const makePathString = (path$5) => pipe(path$5, join$3(pathDelim));
	const unmakePathString = (pathString) => pathString.split(pathDelim);
	const mapWithIndexSplit = splitIndexInKeys(map$21, (str) => unmakePathString(str), makePathString);
	const load = (path$5, primitive$2, split = true) => {
		const pathString = makePathString(path$5);
		return pipe(mapWithIndexSplit.has(pathString) ? some$4(mapWithIndexSplit.get(pathString)) : none$7(), mapError$4(() => MissingData$1(path$5, `Expected ${pathString} to exist in the provided map`)), flatMap$6((value$2) => parsePrimitive(value$2, path$5, primitive$2, seqDelim, split)));
	};
	const enumerateChildren = (path$5) => sync$6(() => {
		return fromIterable$6(fromIterable$10(mapWithIndexSplit.keys()).map(unmakePathString).filter((keyPath) => {
			for (let i = 0; i < path$5.length; i++) {
				const pathComponent = pipe(path$5, unsafeGet$5(i));
				const currentElement = keyPath[i];
				if (currentElement === void 0 || pathComponent !== currentElement) return false;
			}
			return true;
		}).flatMap((keyPath) => keyPath.slice(path$5.length, path$5.length + 1)));
	});
	return fromFlat(makeFlat({
		load,
		enumerateChildren,
		patch: empty$13
	}));
};
var extend$2 = (leftDef, rightDef, left$2, right$2) => {
	const leftPad = unfold$1(left$2.length, (index) => index >= right$2.length ? none$7() : some$4([leftDef(index), index + 1]));
	const rightPad = unfold$1(right$2.length, (index) => index >= left$2.length ? none$7() : some$4([rightDef(index), index + 1]));
	return [concat(left$2, leftPad), concat(right$2, rightPad)];
};
var appendConfigPath = (path$5, config$1) => {
	let op = config$1;
	if (op._tag === "Nested") {
		const out = path$5.slice();
		while (op._tag === "Nested") {
			out.push(op.name);
			op = op.config;
		}
		return out;
	}
	return path$5;
};
var fromFlatLoop = (flat, prefix, config$1, split) => {
	const op = config$1;
	switch (op._tag) {
		case OP_CONSTANT: return succeed$12(of$4(op.value));
		case OP_DESCRIBED: return suspend$5(() => fromFlatLoop(flat, prefix, op.config, split));
		case OP_FAIL: return fail$12(MissingData$1(prefix, op.message));
		case OP_FALLBACK: return pipe(suspend$5(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll$2((error1) => {
			if (op.condition(error1)) return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll$2((error2) => fail$12(Or$1(error1, error2))));
			return fail$12(error1);
		}));
		case OP_LAZY: return suspend$5(() => fromFlatLoop(flat, prefix, op.config(), split));
		case OP_MAP_OR_FAIL: return suspend$5(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap$6(forEachSequential((a) => pipe(op.mapOrFail(a), mapError$4(prefixed$1(appendConfigPath(prefix, op.original))))))));
		case OP_NESTED: return suspend$5(() => fromFlatLoop(flat, concat(prefix, of$4(op.name)), op.config, split));
		case OP_PRIMITIVE: return pipe(patch$3(prefix, flat.patch), flatMap$6((prefix$1) => pipe(flat.load(prefix$1, op, split), flatMap$6((values$6) => {
			if (values$6.length === 0) {
				const name = pipe(last$2(prefix$1), getOrElse$5(() => "<n/a>"));
				return fail$12(MissingData$1([], `Expected ${op.description} with name ${name}`));
			}
			return succeed$12(values$6);
		}))));
		case OP_SEQUENCE: return pipe(patch$3(prefix, flat.patch), flatMap$6((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap$6(indicesFrom), flatMap$6((indices) => {
			if (indices.length === 0) return suspend$5(() => map$12(fromFlatLoop(flat, prefix, op.config, true), of$4));
			return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append$2(prefix, `[${index}]`), op.config, true)), map$12((chunkChunk) => {
				const flattened = flatten$8(chunkChunk);
				if (flattened.length === 0) return of$4(empty$34());
				return of$4(flattened);
			}));
		}))));
		case OP_HASHMAP: return suspend$5(() => pipe(patch$3(prefix, flat.patch), flatMap$6((prefix$1) => pipe(flat.enumerateChildren(prefix$1), flatMap$6((keys$5) => {
			return pipe(keys$5, forEachSequential((key) => fromFlatLoop(flat, concat(prefix$1, of$4(key)), op.valueConfig, split)), map$12((matrix) => {
				if (matrix.length === 0) return of$4(empty$27());
				return pipe(transpose(matrix), map$18((values$6) => fromIterable$5(zip$8(fromIterable$10(keys$5), values$6))));
			}));
		})))));
		case OP_ZIP_WITH$1: return suspend$5(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either$1, flatMap$6((left$2) => pipe(fromFlatLoop(flat, prefix, op.right, split), either$1, flatMap$6((right$2) => {
			if (isLeft(left$2) && isLeft(right$2)) return fail$12(And$1(left$2.left, right$2.left));
			if (isLeft(left$2) && isRight(right$2)) return fail$12(left$2.left);
			if (isRight(left$2) && isLeft(right$2)) return fail$12(right$2.left);
			if (isRight(left$2) && isRight(right$2)) {
				const fail$14 = fromFlatLoopFail(prefix, pipe(prefix, join$3(".")));
				const [lefts, rights] = extend$2(fail$14, fail$14, pipe(left$2.right, map$18(right)), pipe(right$2.right, map$18(right)));
				return pipe(lefts, zip$8(rights), forEachSequential(([left$3, right$3]) => pipe(zip$6(left$3, right$3), map$12(([left$4, right$4]) => op.zip(left$4, right$4)))));
			}
			throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
		})))));
	}
};
var fromFlatLoopFail = (prefix, path$5) => (index) => left(MissingData$1(prefix, `The element at index ${index} in a sequence at path "${path$5}" was missing`));
const mapInputPath = /* @__PURE__ */ dual(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)));
var mapInputPathFlat = (self, f) => makeFlat({
	load: (path$5, config$1, split = true) => self.load(path$5, config$1, split),
	enumerateChildren: (path$5) => self.enumerateChildren(path$5),
	patch: mapName(self.patch, f)
});
const nested$2 = /* @__PURE__ */ dual(2, (self, name) => fromFlat(makeFlat({
	load: (path$5, config$1) => self.flattened.load(path$5, config$1, true),
	enumerateChildren: (path$5) => self.flattened.enumerateChildren(path$5),
	patch: nested$3(self.flattened.patch, name)
})));
const unnested = /* @__PURE__ */ dual(2, (self, name) => fromFlat(makeFlat({
	load: (path$5, config$1) => self.flattened.load(path$5, config$1, true),
	enumerateChildren: (path$5) => self.flattened.enumerateChildren(path$5),
	patch: unnested$1(self.flattened.patch, name)
})));
const orElse$7 = /* @__PURE__ */ dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));
var orElseFlat = (self, that) => makeFlat({
	load: (path$5, config$1, split) => pipe(patch$3(path$5, self.patch), flatMap$6((patch$11) => self.load(patch$11, config$1, split)), catchAll$2((error1) => pipe(sync$6(that), flatMap$6((that$1) => pipe(patch$3(path$5, that$1.patch), flatMap$6((patch$11) => that$1.load(patch$11, config$1, split)), catchAll$2((error2) => fail$12(Or$1(error1, error2)))))))),
	enumerateChildren: (path$5) => pipe(patch$3(path$5, self.patch), flatMap$6((patch$11) => self.enumerateChildren(patch$11)), either$1, flatMap$6((left$2) => pipe(sync$6(that), flatMap$6((that$1) => pipe(patch$3(path$5, that$1.patch), flatMap$6((patch$11) => that$1.enumerateChildren(patch$11)), either$1, flatMap$6((right$2) => {
		if (isLeft(left$2) && isLeft(right$2)) return fail$12(And$1(left$2.left, right$2.left));
		if (isLeft(left$2) && isRight(right$2)) return succeed$12(right$2.right);
		if (isRight(left$2) && isLeft(right$2)) return succeed$12(left$2.right);
		if (isRight(left$2) && isRight(right$2)) return succeed$12(pipe(left$2.right, union$5(right$2.right)));
		throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
	})))))),
	patch: empty$13
});
const constantCase = (self) => mapInputPath(self, constantCase$1);
const kebabCase = (self) => mapInputPath(self, kebabCase$1);
const lowerCase = (self) => mapInputPath(self, lowerCase$1);
const snakeCase = (self) => mapInputPath(self, snakeCase$1);
const upperCase = (self) => mapInputPath(self, upperCase$1);
const within = /* @__PURE__ */ dual(3, (self, path$5, f) => {
	return orElse$7(reduceRight$3(path$5, f(reduce$12(path$5, self, (provider, name) => unnested(provider, name))), (provider, name) => nested$2(provider, name)), () => self);
});
var splitPathString = (text, delim) => {
	return text.split(/* @__PURE__ */ new RegExp(`\\s*${escape(delim)}\\s*`));
};
var parsePrimitive = (text, path$5, primitive$2, delimiter, split) => {
	if (!split) return pipe(primitive$2.parse(text), mapBoth$2({
		onFailure: prefixed$1(path$5),
		onSuccess: of$4
	}));
	return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive$2.parse(char.trim())), mapError$4(prefixed$1(path$5)));
};
var transpose = (array$5) => {
	return Object.keys(array$5[0]).map((column) => array$5.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth$2({
	onFailure: () => empty$34(),
	onSuccess: sort(Order$4)
}), either$1, map$12(merge$6));
var STR_INDEX_REGEX = /(^.+)(\[(\d+)\])$/;
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
	const match$15 = str.match(QUOTED_INDEX_REGEX);
	if (match$15 !== null) {
		const matchedIndex = match$15[2];
		return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some$4(matchedIndex) : none$7(), flatMap$13(parseInteger));
	}
	return none$7();
};
var splitIndexInKeys = (map$21, unmakePathString, makePathString) => {
	const newMap = /* @__PURE__ */ new Map();
	for (const [pathString, value$2] of map$21) {
		const keyWithIndex = pipe(unmakePathString(pathString), flatMap$12((key) => match$13(splitIndexFrom(key), {
			onNone: () => of$4(key),
			onSome: ([key$1, index]) => make$45(key$1, `[${index}]`)
		})));
		newMap.set(makePathString(keyWithIndex), value$2);
	}
	return newMap;
};
var splitIndexFrom = (key) => {
	const match$15 = key.match(STR_INDEX_REGEX);
	if (match$15 !== null) {
		const matchedString = match$15[1];
		const matchedIndex = match$15[3];
		return all$6([matchedString !== void 0 && matchedString.length > 0 ? some$4(matchedString) : none$7(), pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some$4(matchedIndex) : none$7(), flatMap$13(parseInteger))]);
	}
	return none$7();
};
var parseInteger = (str) => {
	const parsedIndex = Number.parseInt(str);
	return Number.isNaN(parsedIndex) ? none$7() : some$4(parsedIndex);
};
var keyName = (name) => ({
	_tag: "KeyName",
	name
});
var keyIndex = (index) => ({
	_tag: "KeyIndex",
	index
});
const fromJson = (json) => {
	const hiddenDelimiter = "";
	const indexedEntries = map$18(getIndexedEntries(json), ([key, value$2]) => [configPathToString(key).join(hiddenDelimiter), value$2]);
	return fromMap(new Map(indexedEntries), {
		pathDelim: hiddenDelimiter,
		seqDelim: hiddenDelimiter
	});
};
var configPathToString = (path$5) => {
	const output = [];
	let i = 0;
	while (i < path$5.length) {
		const component = path$5[i];
		if (component._tag === "KeyName") if (i + 1 < path$5.length) {
			const nextComponent = path$5[i + 1];
			if (nextComponent._tag === "KeyIndex") {
				output.push(`${component.name}[${nextComponent.index}]`);
				i += 2;
			} else {
				output.push(component.name);
				i += 1;
			}
		} else {
			output.push(component.name);
			i += 1;
		}
	}
	return output;
};
var getIndexedEntries = (config$1) => {
	const loopAny = (path$5, value$2) => {
		if (typeof value$2 === "string") return make$45([path$5, value$2]);
		if (typeof value$2 === "number" || typeof value$2 === "boolean") return make$45([path$5, String(value$2)]);
		if (isArray(value$2)) return loopArray(path$5, value$2);
		if (typeof value$2 === "object" && value$2 !== null) return loopObject(path$5, value$2);
		return empty$34();
	};
	const loopArray = (path$5, values$6) => match$12(values$6, {
		onEmpty: () => make$45([path$5, "<nil>"]),
		onNonEmpty: flatMap$12((value$2, index) => loopAny(append$2(path$5, keyIndex(index)), value$2))
	});
	const loopObject = (path$5, value$2) => Object.entries(value$2).filter(([, value$3]) => isNotNullable(value$3)).flatMap(([key, value$3]) => {
		const newPath = append$2(path$5, keyName(key));
		const result = loopAny(newPath, value$3);
		if (isEmptyReadonlyArray(result)) return make$45([newPath, ""]);
		return result;
	});
	return loopObject(empty$34(), config$1);
};
const TypeId$6 = /* @__PURE__ */ Symbol.for("effect/Console");
const consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
const defaultConsole = {
	[TypeId$6]: TypeId$6,
	assert(condition, ...args$1) {
		return sync$6(() => {
			console.assert(condition, ...args$1);
		});
	},
	clear: /* @__PURE__ */ sync$6(() => {
		console.clear();
	}),
	count(label) {
		return sync$6(() => {
			console.count(label);
		});
	},
	countReset(label) {
		return sync$6(() => {
			console.countReset(label);
		});
	},
	debug(...args$1) {
		return sync$6(() => {
			console.debug(...args$1);
		});
	},
	dir(item, options) {
		return sync$6(() => {
			console.dir(item, options);
		});
	},
	dirxml(...args$1) {
		return sync$6(() => {
			console.dirxml(...args$1);
		});
	},
	error(...args$1) {
		return sync$6(() => {
			console.error(...args$1);
		});
	},
	group(options) {
		return options?.collapsed ? sync$6(() => console.groupCollapsed(options?.label)) : sync$6(() => console.group(options?.label));
	},
	groupEnd: /* @__PURE__ */ sync$6(() => {
		console.groupEnd();
	}),
	info(...args$1) {
		return sync$6(() => {
			console.info(...args$1);
		});
	},
	log(...args$1) {
		return sync$6(() => {
			console.log(...args$1);
		});
	},
	table(tabularData, properties) {
		return sync$6(() => {
			console.table(tabularData, properties);
		});
	},
	time(label) {
		return sync$6(() => console.time(label));
	},
	timeEnd(label) {
		return sync$6(() => console.timeEnd(label));
	},
	timeLog(label, ...args$1) {
		return sync$6(() => {
			console.timeLog(label, ...args$1);
		});
	},
	trace(...args$1) {
		return sync$6(() => {
			console.trace(...args$1);
		});
	},
	warn(...args$1) {
		return sync$6(() => {
			console.warn(...args$1);
		});
	},
	unsafe: console
};
const RandomTypeId = /* @__PURE__ */ Symbol.for("effect/Random");
const randomTag = /* @__PURE__ */ GenericTag("effect/Random");
var RandomImpl = class {
	seed;
	[RandomTypeId] = RandomTypeId;
	PRNG;
	constructor(seed) {
		this.seed = seed;
		this.PRNG = new PCGRandom(seed);
	}
	get next() {
		return sync$6(() => this.PRNG.number());
	}
	get nextBoolean() {
		return map$12(this.next, (n) => n > .5);
	}
	get nextInt() {
		return sync$6(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
	}
	nextRange(min$2, max$4) {
		return map$12(this.next, (n) => (max$4 - min$2) * n + min$2);
	}
	nextIntBetween(min$2, max$4) {
		return sync$6(() => this.PRNG.integer(max$4 - min$2) + min$2);
	}
	shuffle(elements) {
		return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
	}
};
var shuffleWith = (elements, nextIntBounded) => {
	return suspend$5(() => pipe(sync$6(() => Array.from(elements)), flatMap$6((buffer) => {
		const numbers = [];
		for (let i = buffer.length; i >= 2; i = i - 1) numbers.push(i);
		return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map$12((k) => swap$1(buffer, n - 1, k)))), as$4(fromIterable$9(buffer)));
	})));
};
var swap$1 = (buffer, index1, index2) => {
	const tmp = buffer[index1];
	buffer[index1] = buffer[index2];
	buffer[index2] = tmp;
	return buffer;
};
const make$24 = (seed) => new RandomImpl(hash(seed));
const TracerTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Tracer");
const make$23 = (options) => ({
	[TracerTypeId$1]: TracerTypeId$1,
	...options
});
const tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
const spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
	const characters = "abcdef0123456789";
	const charactersLength = 16;
	return function(length$1) {
		let result = "";
		for (let i = 0; i < length$1; i++) result += characters.charAt(Math.floor(Math.random() * charactersLength));
		return result;
	};
}();
var NativeSpan = class {
	name;
	parent;
	context;
	startTime;
	kind;
	_tag = "Span";
	spanId;
	traceId = "native";
	sampled = true;
	status;
	attributes;
	events = [];
	links;
	constructor(name, parent, context$3, links, startTime, kind) {
		this.name = name;
		this.parent = parent;
		this.context = context$3;
		this.startTime = startTime;
		this.kind = kind;
		this.status = {
			_tag: "Started",
			startTime
		};
		this.attributes = /* @__PURE__ */ new Map();
		this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
		this.spanId = randomHexString(16);
		this.links = Array.from(links);
	}
	end(endTime, exit$3) {
		this.status = {
			_tag: "Ended",
			endTime,
			exit: exit$3,
			startTime: this.status.startTime
		};
	}
	attribute(key, value$2) {
		this.attributes.set(key, value$2);
	}
	event(name, startTime, attributes) {
		this.events.push([
			name,
			startTime,
			attributes ?? {}
		]);
	}
	addLinks(links) {
		this.links.push(...links);
	}
};
const nativeTracer = /* @__PURE__ */ make$23({
	span: (name, parent, context$3, links, startTime, kind) => new NativeSpan(name, parent, context$3, links, startTime, kind),
	context: (f) => f()
});
const addSpanStackTrace = (options) => {
	if (options?.captureStackTrace === false) return options;
	else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") return options;
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 3;
	const traceError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	let cache = false;
	return {
		...options,
		captureStackTrace: () => {
			if (cache !== false) return cache;
			if (traceError.stack !== void 0) {
				const stack = traceError.stack.split("\n");
				if (stack[3] !== void 0) {
					cache = stack[3].trim();
					return cache;
				}
			}
		}
	};
};
const DisablePropagation$1 = /* @__PURE__ */ Reference()("effect/Tracer/DisablePropagation", { defaultValue: constFalse });
const liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty$32(), /* @__PURE__ */ add$3(clockTag, /* @__PURE__ */ make$26()), /* @__PURE__ */ add$3(consoleTag, defaultConsole), /* @__PURE__ */ add$3(randomTag, /* @__PURE__ */ make$24(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add$3(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add$3(tracerTag, nativeTracer));
const currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
const sleep$3 = (duration$2) => {
	const decodedDuration = decode$3(duration$2);
	return clockWith$3((clock$2) => clock$2.sleep(decodedDuration));
};
const defaultServicesWith = (f) => withFiberRuntime$1((fiber) => f(fiber.currentDefaultServices));
const clockWith$3 = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
const currentTimeMillis$1 = /* @__PURE__ */ clockWith$3((clock$2) => clock$2.currentTimeMillis);
const configProviderWith$1 = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
const config = (config$1) => configProviderWith$1((_) => _.load(config$1));
const sleep$2 = sleep$3;
const currentTimeMillis = currentTimeMillis$1;
const Clock = clockTag;
function unsafeMake$5(fiberRefLocals) {
	return new FiberRefsImpl(fiberRefLocals);
}
function empty$12() {
	return unsafeMake$5(/* @__PURE__ */ new Map());
}
const FiberRefsSym$1 = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
	locals;
	[FiberRefsSym$1] = FiberRefsSym$1;
	constructor(locals) {
		this.locals = locals;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
	const ref = _ref;
	let parentStack = _parentStack;
	let childStack = _childStack;
	let childModified = _childModified;
	let ret = void 0;
	while (ret === void 0) if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
		const parentFiberId = headNonEmpty$1(parentStack)[0];
		const parentAncestors = tailNonEmpty$1(parentStack);
		const childFiberId = headNonEmpty$1(childStack)[0];
		const childRefValue = headNonEmpty$1(childStack)[1];
		const childAncestors = tailNonEmpty$1(childStack);
		if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
			childStack = childAncestors;
			childModified = true;
		} else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) parentStack = parentAncestors;
		else if (parentFiberId.id < childFiberId.id) {
			childStack = childAncestors;
			childModified = true;
		} else if (parentFiberId.id > childFiberId.id) parentStack = parentAncestors;
		else ret = [childRefValue, childModified];
	} else ret = [ref.initial, true];
	return ret;
};
const joinAs$1 = /* @__PURE__ */ dual(3, (self, fiberId$2, that) => {
	const parentFiberRefs = new Map(self.locals);
	that.locals.forEach((childStack, fiberRef) => {
		const childValue = childStack[0][1];
		if (!childStack[0][0][symbol](fiberId$2)) {
			if (!parentFiberRefs.has(fiberRef)) {
				if (equals(childValue, fiberRef.initial)) return;
				parentFiberRefs.set(fiberRef, [[fiberId$2, fiberRef.join(fiberRef.initial, childValue)]]);
				return;
			}
			const parentStack = parentFiberRefs.get(fiberRef);
			const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
			if (wasModified) {
				const patch$11 = fiberRef.diff(ancestor, childValue);
				const oldValue = parentStack[0][1];
				const newValue = fiberRef.join(oldValue, fiberRef.patch(patch$11)(oldValue));
				if (!equals(oldValue, newValue)) {
					let newStack;
					const parentFiberId = parentStack[0][0];
					if (parentFiberId[symbol](fiberId$2)) newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
					else newStack = [[fiberId$2, newValue], ...parentStack];
					parentFiberRefs.set(fiberRef, newStack);
				}
			}
		}
	});
	return new FiberRefsImpl(parentFiberRefs);
});
const forkAs$1 = /* @__PURE__ */ dual(2, (self, childId) => {
	const map$21 = /* @__PURE__ */ new Map();
	unsafeForkAs(self, map$21, childId);
	return new FiberRefsImpl(map$21);
});
var unsafeForkAs = (self, map$21, fiberId$2) => {
	self.locals.forEach((stack, fiberRef) => {
		const oldValue = stack[0][1];
		const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
		if (equals(oldValue, newValue)) map$21.set(fiberRef, stack);
		else map$21.set(fiberRef, [[fiberId$2, newValue], ...stack]);
	});
};
const delete_$1 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
	const locals = new Map(self.locals);
	locals.delete(fiberRef);
	return new FiberRefsImpl(locals);
});
const get$3 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
	if (!self.locals.has(fiberRef)) return none$7();
	return some$4(headNonEmpty$1(self.locals.get(fiberRef))[1]);
});
const getOrDefault$1 = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get$3(self, fiberRef), getOrElse$5(() => fiberRef.initial)));
const updateAs$1 = /* @__PURE__ */ dual(2, (self, { fiberId: fiberId$2, fiberRef, value: value$2 }) => {
	if (self.locals.size === 0) return new FiberRefsImpl(new Map([[fiberRef, [[fiberId$2, value$2]]]]));
	const locals = new Map(self.locals);
	unsafeUpdateAs(locals, fiberId$2, fiberRef, value$2);
	return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId$2, fiberRef, value$2) => {
	const oldStack = locals.get(fiberRef) ?? [];
	let newStack;
	if (isNonEmptyReadonlyArray(oldStack)) {
		const [currentId, currentValue] = headNonEmpty$1(oldStack);
		if (currentId[symbol](fiberId$2)) if (equals(currentValue, value$2)) return;
		else newStack = [[fiberId$2, value$2], ...oldStack.slice(1)];
		else newStack = [[fiberId$2, value$2], ...oldStack];
	} else newStack = [[fiberId$2, value$2]];
	locals.set(fiberRef, newStack);
};
const updateManyAs$1 = /* @__PURE__ */ dual(2, (self, { entries: entries$2, forkAs: forkAs$2 }) => {
	if (self.locals.size === 0) return new FiberRefsImpl(new Map(entries$2));
	const locals = new Map(self.locals);
	if (forkAs$2 !== void 0) unsafeForkAs(self, locals, forkAs$2);
	entries$2.forEach(([fiberRef, values$6]) => {
		if (values$6.length === 1) unsafeUpdateAs(locals, values$6[0][0], fiberRef, values$6[0][1]);
		else values$6.forEach(([fiberId$2, value$2]) => {
			unsafeUpdateAs(locals, fiberId$2, fiberRef, value$2);
		});
	});
	return new FiberRefsImpl(locals);
});
const get$2 = get$3;
const getOrDefault = getOrDefault$1;
const updateManyAs = updateManyAs$1;
const empty$11 = empty$12;
const All = logLevelAll;
const Fatal = logLevelFatal;
const Error$2 = logLevelError;
const Warning = logLevelWarning;
const Info = logLevelInfo;
const Debug = logLevelDebug;
const Trace = logLevelTrace;
const None = logLevelNone;
const greaterThan$2 = /* @__PURE__ */ greaterThan$3(/* @__PURE__ */ pipe(Order$4, /* @__PURE__ */ mapInput((level) => level.ordinal)));
const fromLiteral = (literal$2) => {
	switch (literal$2) {
		case "All": return All;
		case "Debug": return Debug;
		case "Error": return Error$2;
		case "Fatal": return Fatal;
		case "Info": return Info;
		case "Trace": return Trace;
		case "None": return None;
		case "Warning": return Warning;
	}
};
const formatLabel = (key) => key.replace(/[\s="]/g, "_");
const render$1 = (now) => (self) => {
	return `${formatLabel(self.label)}=${now - self.startTime}ms`;
};
const EffectPrototype = EffectPrototype$1;
var Base = Base$1;
var Class$3 = class extends Base {};
const TypeId$5 = /* @__PURE__ */ Symbol.for("effect/Readable");
const RefTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Ref");
const refVariance = { _A: (_) => _ };
var RefImpl = class extends Class$3 {
	ref;
	commit() {
		return this.get;
	}
	[RefTypeId$1] = refVariance;
	[TypeId$5] = TypeId$5;
	constructor(ref) {
		super();
		this.ref = ref;
		this.get = sync$6(() => get$6(this.ref));
	}
	get;
	modify(f) {
		return sync$6(() => {
			const current = get$6(this.ref);
			const [b, a] = f(current);
			if (current !== a) set$4(a)(this.ref);
			return b;
		});
	}
};
const unsafeMake$3 = (value$2) => new RefImpl(make$36(value$2));
const make$19 = (value$2) => sync$6(() => unsafeMake$3(value$2));
const get$1 = (self) => self.get;
const set$1 = /* @__PURE__ */ dual(2, (self, value$2) => self.modify(() => [void 0, value$2]));
const getAndSet$1 = /* @__PURE__ */ dual(2, (self, value$2) => self.modify((a) => [a, value$2]));
const modify$1 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
const update$3 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
const make$18 = make$19;
const get = get$1;
const getAndSet = getAndSet$1;
const set = set$1;
const OP_EMPTY$1 = "Empty";
const OP_REMOVE = "Remove";
const OP_UPDATE = "Update";
const OP_AND_THEN$1 = "AndThen";
const empty$10 = { _tag: OP_EMPTY$1 };
const diff$2 = (oldValue, newValue) => {
	const missingLocals = new Map(oldValue.locals);
	let patch$11 = empty$10;
	for (const [fiberRef, pairs] of newValue.locals.entries()) {
		const newValue$1 = headNonEmpty$1(pairs)[1];
		const old = missingLocals.get(fiberRef);
		if (old !== void 0) {
			const oldValue$1 = headNonEmpty$1(old)[1];
			if (!equals(oldValue$1, newValue$1)) patch$11 = combine$2({
				_tag: OP_UPDATE,
				fiberRef,
				patch: fiberRef.diff(oldValue$1, newValue$1)
			})(patch$11);
		} else patch$11 = combine$2({
			_tag: "Add",
			fiberRef,
			value: newValue$1
		})(patch$11);
		missingLocals.delete(fiberRef);
	}
	for (const [fiberRef] of missingLocals.entries()) patch$11 = combine$2({
		_tag: OP_REMOVE,
		fiberRef
	})(patch$11);
	return patch$11;
};
const combine$2 = /* @__PURE__ */ dual(2, (self, that) => ({
	_tag: OP_AND_THEN$1,
	first: self,
	second: that
}));
const patch$2 = /* @__PURE__ */ dual(3, (self, fiberId$2, oldValue) => {
	let fiberRefs$3 = oldValue;
	let patches = of$4(self);
	while (isNonEmptyReadonlyArray(patches)) {
		const head$4 = headNonEmpty$1(patches);
		const tail = tailNonEmpty$1(patches);
		switch (head$4._tag) {
			case OP_EMPTY$1:
				patches = tail;
				break;
			case "Add":
				fiberRefs$3 = updateAs$1(fiberRefs$3, {
					fiberId: fiberId$2,
					fiberRef: head$4.fiberRef,
					value: head$4.value
				});
				patches = tail;
				break;
			case OP_REMOVE:
				fiberRefs$3 = delete_$1(fiberRefs$3, head$4.fiberRef);
				patches = tail;
				break;
			case OP_UPDATE: {
				const value$2 = getOrDefault$1(fiberRefs$3, head$4.fiberRef);
				fiberRefs$3 = updateAs$1(fiberRefs$3, {
					fiberId: fiberId$2,
					fiberRef: head$4.fiberRef,
					value: head$4.fiberRef.patch(head$4.patch)(value$2)
				});
				patches = tail;
				break;
			}
			case OP_AND_THEN$1:
				patches = prepend$2(head$4.first)(prepend$2(head$4.second)(tail));
				break;
		}
	}
	return fiberRefs$3;
});
var MetricLabelSymbolKey = "effect/MetricLabel";
const MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
	key;
	value;
	[MetricLabelTypeId] = MetricLabelTypeId;
	_hash;
	constructor(key, value$2) {
		this.key = key;
		this.value = value$2;
		this._hash = string$2(MetricLabelSymbolKey + this.key + this.value);
	}
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isMetricLabel(that) && this.key === that.key && this.value === that.value;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const make$16 = (key, value$2) => {
	return new MetricLabelImpl(key, value$2);
};
const isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);
const asSome$1 = (self) => map$12(self, some$4);
const try_$1 = (arg) => {
	let evaluate$1;
	let onFailure = void 0;
	if (typeof arg === "function") evaluate$1 = arg;
	else {
		evaluate$1 = arg.try;
		onFailure = arg.catch;
	}
	return suspend$5(() => {
		try {
			return succeed$12(internalCall(evaluate$1));
		} catch (error) {
			return fail$12(onFailure ? internalCall(() => onFailure(error)) : new UnknownException$1(error, "An unknown error occurred in Effect.try"));
		}
	});
};
const catchTags$1 = /* @__PURE__ */ dual(2, (self, cases) => {
	let keys$5;
	return catchIf$1(self, (e) => {
		keys$5 ??= Object.keys(cases);
		return hasProperty(e, "_tag") && isString(e["_tag"]) && keys$5.includes(e["_tag"]);
	}, (e) => cases[e["_tag"]](e));
});
const diffFiberRefs$1 = (self) => summarized$1(self, fiberRefs, diff$2);
const diffFiberRefsAndRuntimeFlags = (self) => summarized$1(self, zip$6(fiberRefs, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff$2(refs, refsNew), diff$3(flags, flagsNew)]);
const eventually$1 = (self) => orElse$8(self, () => flatMap$6(yieldNow$3(), () => eventually$1(self)));
var findLoop = (iterator, index, f, value$2) => flatMap$6(f(value$2, index), (result) => {
	if (result) return succeed$12(some$4(value$2));
	const next = iterator.next();
	if (!next.done) return findLoop(iterator, index + 1, f, next.value);
	return succeed$12(none$7());
});
const match$8 = /* @__PURE__ */ dual(2, (self, options) => matchEffect$2(self, {
	onFailure: (e) => succeed$12(options.onFailure(e)),
	onSuccess: (a) => succeed$12(options.onSuccess(a))
}));
var forAllLoop = (iterator, index, f) => {
	const next = iterator.next();
	return next.done ? succeed$12(true) : flatMap$6(f(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed$12(b));
};
const fiberRefs = /* @__PURE__ */ withFiberRuntime$1((state) => succeed$12(state.getFiberRefs()));
const ignore$1 = (self) => match$8(self, {
	onFailure: constVoid,
	onSuccess: constVoid
});
const iterate$1 = (initial, options) => suspend$5(() => {
	if (options.while(initial)) return flatMap$6(options.body(initial), (z2) => iterate$1(z2, options));
	return succeed$12(initial);
});
const logWithLevel = (level) => (...message) => {
	const levelOption = fromNullable$2(level);
	let cause$2 = void 0;
	for (let i = 0, len = message.length; i < len; i++) {
		const msg = message[i];
		if (isCause$1(msg)) {
			if (cause$2 !== void 0) cause$2 = sequential$3(cause$2, msg);
			else cause$2 = msg;
			message = [...message.slice(0, i), ...message.slice(i + 1)];
			i--;
		}
	}
	if (cause$2 === void 0) cause$2 = empty$16;
	return withFiberRuntime$1((fiberState) => {
		fiberState.log(message, cause$2, levelOption);
		return void_$4;
	});
};
const logInfo$1 = /* @__PURE__ */ logWithLevel(Info);
const logWarning$1 = /* @__PURE__ */ logWithLevel(Warning);
const logError$1 = /* @__PURE__ */ logWithLevel(Error$2);
var loopInternal = (initial, cont, inc, body) => suspend$5(() => cont(initial) ? flatMap$6(body(initial), (a) => map$12(loopInternal(inc(initial), cont, inc, body), prepend(a))) : sync$6(() => empty$26()));
var loopDiscard = (initial, cont, inc, body) => suspend$5(() => cont(initial) ? flatMap$6(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_$4);
const memoize$1 = (self) => pipe(deferredMake(), flatMap$6((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred$1(deferred), once$2, map$12((complete$4) => zipRight$3(complete$4, pipe(deferredAwait(deferred), flatMap$6(([patch$11, a]) => as$4(zip$6(patchFiberRefs$1(patch$11[0]), updateRuntimeFlags(patch$11[1])), a))))))));
const once$2 = (self) => map$12(make$18(true), (ref) => asVoid$3(whenEffect$1(self, getAndSet(ref, false))));
const orElseSucceed$1 = /* @__PURE__ */ dual(2, (self, evaluate$1) => orElse$8(self, () => sync$6(evaluate$1)));
const patchFiberRefs$1 = (patch$11) => updateFiberRefs$1((fiberId$2, fiberRefs$3) => pipe(patch$11, patch$2(fiberId$2, fiberRefs$3)));
const provideService$1 = /* @__PURE__ */ dual(3, (self, tag, service$1) => contextWithEffect$1((env) => provideContext$1(self, add$3(env, tag, service$1))));
var reduceWhileLoop = (iterator, index, state, predicate, f) => {
	const next = iterator.next();
	if (!next.done && predicate(state)) return flatMap$6(f(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
	return succeed$12(state);
};
var repeatNLoop = (self, n) => flatMap$6(self, (a) => n <= 0 ? succeed$12(a) : zipRight$3(yieldNow$3(), repeatNLoop(self, n - 1)));
const succeedNone$1 = /* @__PURE__ */ succeed$12(/* @__PURE__ */ none$7());
const summarized$1 = /* @__PURE__ */ dual(3, (self, summary$2, f) => flatMap$6(summary$2, (start$2) => flatMap$6(self, (value$2) => map$12(summary$2, (end$2) => [f(start$2, end$2), value$2]))));
const tapError$2 = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const either$4 = failureOrCause$1(cause$2);
		switch (either$4._tag) {
			case "Left": return zipRight$3(f(either$4.left), failCause$9(cause$2));
			case "Right": return failCause$9(cause$2);
		}
	},
	onSuccess: succeed$12
}));
const tryPromise$1 = (arg) => {
	let evaluate$1;
	let catcher = void 0;
	if (typeof arg === "function") evaluate$1 = arg;
	else {
		evaluate$1 = arg.try;
		catcher = arg.catch;
	}
	const fail$14 = (e) => catcher ? failSync$3(() => catcher(e)) : fail$12(new UnknownException$1(e, "An unknown error occurred in Effect.tryPromise"));
	if (evaluate$1.length >= 1) return async_((resolve, signal) => {
		try {
			evaluate$1(signal).then((a) => resolve(succeed$12(a)), (e) => resolve(fail$14(e)));
		} catch (e) {
			resolve(fail$14(e));
		}
	});
	return async_((resolve) => {
		try {
			evaluate$1().then((a) => resolve(succeed$12(a)), (e) => resolve(fail$14(e)));
		} catch (e) {
			resolve(fail$14(e));
		}
	});
};
const updateFiberRefs$1 = (f) => withFiberRuntime$1((state) => {
	state.setFiberRefs(f(state.id(), state.getFiberRefs()));
	return void_$4;
});
var bigint0$1 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap$13((span$1) => get$9(span$1.context, DisablePropagation$1) ? span$1._tag === "Span" ? filterDisablePropagation(span$1.parent) : none$7() : some$4(span$1));
const unsafeMakeSpan = (fiber, name, options) => {
	const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get$9(options.context, DisablePropagation$1);
	const context$3 = fiber.getFiberRef(currentContext);
	const parent = options.parent ? some$4(options.parent) : options.root ? none$7() : filterDisablePropagation(getOption(context$3, spanTag));
	let span$1;
	if (disablePropagation) span$1 = noopSpan({
		name,
		parent,
		context: add$3(options.context ?? empty$32(), DisablePropagation$1, true)
	});
	else {
		const services = fiber.getFiberRef(currentServices);
		const tracer$2 = get$9(services, tracerTag);
		const clock$2 = get$9(services, Clock);
		const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
		const fiberRefs$3 = fiber.getFiberRefs();
		const annotationsFromEnv = get$2(fiberRefs$3, currentTracerSpanAnnotations);
		const linksFromEnv = get$2(fiberRefs$3, currentTracerSpanLinks);
		const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty$34();
		span$1 = tracer$2.span(name, parent, options.context ?? empty$32(), links, timingEnabled ? clock$2.unsafeCurrentTimeNanos() : bigint0$1, options.kind ?? "internal", options);
		if (annotationsFromEnv._tag === "Some") forEach$5(annotationsFromEnv.value, (value$2, key) => span$1.attribute(key, value$2));
		if (options.attributes !== void 0) Object.entries(options.attributes).forEach(([k, v]) => span$1.attribute(k, v));
	}
	if (typeof options.captureStackTrace === "function") spanToTrace.set(span$1, options.captureStackTrace);
	return span$1;
};
const endSpan = (span$1, exit$3, clock$2, timingEnabled) => sync$6(() => {
	if (span$1.status._tag === "Ended") return;
	if (exitIsFailure(exit$3) && spanToTrace.has(span$1)) span$1.attribute("code.stacktrace", spanToTrace.get(span$1)());
	span$1.end(timingEnabled ? clock$2.unsafeCurrentTimeNanos() : bigint0$1, exit$3);
});
const OP_SEQUENTIAL = "Sequential";
const OP_PARALLEL = "Parallel";
const OP_PARALLEL_N = "ParallelN";
const sequential$2 = { _tag: OP_SEQUENTIAL };
const parallel$2 = { _tag: OP_PARALLEL };
const parallelN$1 = (parallelism) => ({
	_tag: OP_PARALLEL_N,
	parallelism
});
const isSequential$1 = (self) => self._tag === OP_SEQUENTIAL;
const isParallel$1 = (self) => self._tag === OP_PARALLEL;
const sequential$1 = sequential$2;
const parallel$1 = parallel$2;
const parallelN = parallelN$1;
const diff$1 = diff$2;
const patch$1 = patch$2;
var FiberStatusSymbolKey = "effect/FiberStatus";
const FiberStatusTypeId$1 = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
const OP_DONE$1 = "Done";
const OP_RUNNING = "Running";
const OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string$2(`${FiberStatusSymbolKey}-${OP_DONE$1}`);
var Done = class {
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_DONE$1;
	[symbol$1]() {
		return DoneHash;
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === "Done";
	}
};
var Running = class {
	runtimeFlags;
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_RUNNING;
	constructor(runtimeFlags$1) {
		this.runtimeFlags = runtimeFlags$1;
	}
	[symbol$1]() {
		return pipe(hash(FiberStatusSymbolKey), combine$11(hash(this._tag)), combine$11(hash(this.runtimeFlags)), cached$2(this));
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === "Running" && this.runtimeFlags === that.runtimeFlags;
	}
};
var Suspended = class {
	runtimeFlags;
	blockingOn;
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_SUSPENDED;
	constructor(runtimeFlags$1, blockingOn) {
		this.runtimeFlags = runtimeFlags$1;
		this.blockingOn = blockingOn;
	}
	[symbol$1]() {
		return pipe(hash(FiberStatusSymbolKey), combine$11(hash(this._tag)), combine$11(hash(this.runtimeFlags)), combine$11(hash(this.blockingOn)), cached$2(this));
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === "Suspended" && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
	}
};
const done$5 = /* @__PURE__ */ new Done();
const running$1 = (runtimeFlags$1) => new Running(runtimeFlags$1);
const suspended$1 = (runtimeFlags$1, blockingOn) => new Suspended(runtimeFlags$1, blockingOn);
const isFiberStatus$1 = (u) => hasProperty(u, FiberStatusTypeId$1);
const isDone$3 = (self) => self._tag === OP_DONE$1;
const done$4 = done$5;
const running = running$1;
const suspended = suspended$1;
const isDone$2 = isDone$3;
const TypeId$4 = /* @__PURE__ */ Symbol.for("effect/Micro");
const MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
const MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = { _E: identity };
var MicroCauseImpl = class extends globalThis.Error {
	_tag;
	traces;
	[MicroCauseTypeId];
	constructor(_tag, originalError$1, traces) {
		const causeName = `MicroCause.${_tag}`;
		let name;
		let message;
		let stack;
		if (originalError$1 instanceof globalThis.Error) {
			name = `(${causeName}) ${originalError$1.name}`;
			message = originalError$1.message;
			const messageLines = message.split("\n").length;
			stack = originalError$1.stack ? `(${causeName}) ${originalError$1.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
		} else {
			name = causeName;
			message = toStringUnknown(originalError$1, 0);
			stack = `${name}: ${message}`;
		}
		if (traces.length > 0) stack += `\n    ${traces.join("\n    ")}`;
		super(message);
		this._tag = _tag;
		this.traces = traces;
		this[MicroCauseTypeId] = microCauseVariance;
		this.name = name;
		this.stack = stack;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toString() {
		return this.stack;
	}
	[NodeInspectSymbol]() {
		return this.stack;
	}
};
var Die = class extends MicroCauseImpl {
	defect;
	constructor(defect, traces = []) {
		super("Die", defect, traces);
		this.defect = defect;
	}
};
const causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
	constructor(traces = []) {
		super("Interrupt", "interrupted", traces);
	}
};
const causeInterrupt = (traces = []) => new Interrupt(traces);
const causeIsInterrupt = (self) => self._tag === "Interrupt";
const MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance$1 = {
	_A: identity,
	_E: identity
};
var MicroFiberImpl = class {
	context;
	interruptible;
	[MicroFiberTypeId];
	_stack = [];
	_observers = [];
	_exit;
	_children;
	currentOpCount = 0;
	constructor(context$3, interruptible$4 = true) {
		this.context = context$3;
		this.interruptible = interruptible$4;
		this[MicroFiberTypeId] = fiberVariance$1;
	}
	getRef(ref) {
		return unsafeGetReference(this.context, ref);
	}
	addObserver(cb) {
		if (this._exit) {
			cb(this._exit);
			return constVoid;
		}
		this._observers.push(cb);
		return () => {
			const index = this._observers.indexOf(cb);
			if (index >= 0) this._observers.splice(index, 1);
		};
	}
	_interrupted = false;
	unsafeInterrupt() {
		if (this._exit) return;
		this._interrupted = true;
		if (this.interruptible) this.evaluate(exitInterrupt);
	}
	unsafePoll() {
		return this._exit;
	}
	evaluate(effect) {
		if (this._exit) return;
		else if (this._yielded !== void 0) {
			const yielded = this._yielded;
			this._yielded = void 0;
			yielded();
		}
		const exit$3 = this.runLoop(effect);
		if (exit$3 === Yield) return;
		const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
		if (interruptChildren !== void 0) return this.evaluate(flatMap$4(interruptChildren, () => exit$3));
		this._exit = exit$3;
		for (let i = 0; i < this._observers.length; i++) this._observers[i](exit$3);
		this._observers.length = 0;
	}
	runLoop(effect) {
		let yielding = false;
		let current = effect;
		this.currentOpCount = 0;
		try {
			while (true) {
				this.currentOpCount++;
				if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
					yielding = true;
					const prev = current;
					current = flatMap$4(yieldNow$2, () => prev);
				}
				current = current[evaluate](this);
				if (current === Yield) {
					const yielded = this._yielded;
					if (MicroExitTypeId in yielded) {
						this._yielded = void 0;
						return yielded;
					}
					return Yield;
				}
			}
		} catch (error) {
			if (!hasProperty(current, evaluate)) return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
			return exitDie(error);
		}
	}
	getCont(symbol$2) {
		while (true) {
			const op = this._stack.pop();
			if (!op) return void 0;
			const cont = op[ensureCont] && op[ensureCont](this);
			if (cont) return { [symbol$2]: cont };
			if (op[symbol$2]) return op;
		}
	}
	_yielded = void 0;
	yieldWith(value$2) {
		this._yielded = value$2;
		return Yield;
	}
	children() {
		return this._children ??= /* @__PURE__ */ new Set();
	}
};
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({ interruptChildren: void 0 }));
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
	_A: identity,
	_E: identity,
	_R: identity
};
var MicroProto = {
	...EffectPrototype,
	_op: "Micro",
	[TypeId$4]: microVariance,
	pipe() {
		return pipeArguments(this, arguments);
	},
	[Symbol.iterator]() {
		return new SingleShotGen(new YieldWrap(this));
	},
	toJSON() {
		return {
			_id: "Micro",
			op: this[identifier],
			...args in this ? { args: this[args] } : void 0
		};
	},
	toString() {
		return format(this);
	},
	[NodeInspectSymbol]() {
		return format(this);
	}
};
function defaultEvaluate(_fiber) {
	return exitDie(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
	...MicroProto,
	[identifier]: options.op,
	[evaluate]: options.eval ?? defaultEvaluate,
	[successCont]: options.contA,
	[failureCont]: options.contE,
	[ensureCont]: options.ensure
});
var makePrimitive = (options) => {
	const Proto$1 = makePrimitiveProto(options);
	return function() {
		const self = Object.create(Proto$1);
		self[args] = options.single === false ? arguments : arguments[0];
		return self;
	};
};
var makeExit = (options) => {
	const Proto$1 = {
		...makePrimitiveProto(options),
		[MicroExitTypeId]: MicroExitTypeId,
		_tag: options.op,
		get [options.prop]() {
			return this[args];
		},
		toJSON() {
			return {
				_id: "MicroExit",
				_tag: options.op,
				[options.prop]: this[args]
			};
		},
		[symbol](that) {
			return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
		},
		[symbol$1]() {
			return cached$2(this, combine$11(string$2(options.op))(hash(this[args])));
		}
	};
	return function(value$2) {
		const self = Object.create(Proto$1);
		self[args] = value$2;
		self[successCont] = void 0;
		self[failureCont] = void 0;
		self[ensureCont] = void 0;
		return self;
	};
};
const succeed$9 = /* @__PURE__ */ makeExit({
	op: "Success",
	prop: "value",
	eval(fiber) {
		const cont = fiber.getCont(successCont);
		return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
	}
});
const failCause$6 = /* @__PURE__ */ makeExit({
	op: "Failure",
	prop: "cause",
	eval(fiber) {
		let cont = fiber.getCont(failureCont);
		while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) cont = fiber.getCont(failureCont);
		return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
	}
});
const yieldNow$2 = /* @__PURE__ */ (/* @__PURE__ */ makePrimitive({
	op: "Yield",
	eval(fiber) {
		let resumed = false;
		fiber.getRef(CurrentScheduler).scheduleTask(() => {
			if (resumed) return;
			fiber.evaluate(exitVoid);
		}, this[args] ?? 0);
		return fiber.yieldWith(() => {
			resumed = true;
		});
	}
}))(0);
var void_$2 = /* @__PURE__ */ succeed$9(void 0);
const withMicroFiber = /* @__PURE__ */ makePrimitive({
	op: "WithMicroFiber",
	eval(fiber) {
		return this[args](fiber);
	}
});
const flatMap$4 = /* @__PURE__ */ dual(2, (self, f) => {
	const onSuccess = Object.create(OnSuccessProto);
	onSuccess[args] = self;
	onSuccess[successCont] = f;
	return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
	op: "OnSuccess",
	eval(fiber) {
		fiber._stack.push(this);
		return this[args];
	}
});
const isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
const exitSucceed = succeed$9;
const exitFailCause = failCause$6;
const exitInterrupt = /* @__PURE__ */ exitFailCause(/* @__PURE__ */ causeInterrupt());
const exitDie = (defect) => exitFailCause(causeDie(defect));
const exitVoid = /* @__PURE__ */ exitSucceed(void 0);
var setImmediate$1 = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault = class {
	tasks = [];
	running = false;
	scheduleTask(task, _priority) {
		this.tasks.push(task);
		if (!this.running) {
			this.running = true;
			setImmediate$1(this.afterScheduled);
		}
	}
	afterScheduled = () => {
		this.running = false;
		this.runTasks();
	};
	runTasks() {
		const tasks = this.tasks;
		this.tasks = [];
		for (let i = 0, len = tasks.length; i < len; i++) tasks[i]();
	}
	shouldYield(fiber) {
		return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
	}
	flush() {
		while (this.tasks.length > 0) this.runTasks();
	}
};
const updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
	const prev = fiber.context;
	fiber.context = f(prev);
	return onExit$1(self, () => {
		fiber.context = prev;
		return void_$2;
	});
}));
const provideContext = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge$4(provided)));
var MaxOpsBeforeYield = class extends Reference()("effect/Micro/currentMaxOpsBeforeYield", { defaultValue: () => 2048 }) {};
Reference()("effect/Micro/currentConcurrency", { defaultValue: () => "unbounded" });
var CurrentScheduler = class extends Reference()("effect/Micro/currentScheduler", { defaultValue: () => new MicroSchedulerDefault() }) {};
const matchCauseEffect$1 = /* @__PURE__ */ dual(2, (self, options) => {
	const primitive$2 = Object.create(OnSuccessAndFailureProto);
	primitive$2[args] = self;
	primitive$2[successCont] = options.onSuccess;
	primitive$2[failureCont] = options.onFailure;
	return primitive$2;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
	op: "OnSuccessAndFailure",
	eval(fiber) {
		fiber._stack.push(this);
		return this[args];
	}
});
const onExit$1 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask$1((restore) => matchCauseEffect$1(restore(self), {
	onFailure: (cause$2) => flatMap$4(f(exitFailCause(cause$2)), () => failCause$6(cause$2)),
	onSuccess: (a) => flatMap$4(f(exitSucceed(a)), () => succeed$9(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
	op: "SetInterruptible",
	ensure(fiber) {
		fiber.interruptible = this[args];
		if (fiber._interrupted && fiber.interruptible) return () => exitInterrupt;
	}
});
const interruptible$1 = (self) => withMicroFiber((fiber) => {
	if (fiber.interruptible) return self;
	fiber.interruptible = true;
	fiber._stack.push(setInterruptible(false));
	if (fiber._interrupted) return exitInterrupt;
	return self;
});
const uninterruptibleMask$1 = (f) => withMicroFiber((fiber) => {
	if (!fiber.interruptible) return f(identity);
	fiber.interruptible = false;
	fiber._stack.push(setInterruptible(true));
	return f(interruptible$1);
});
const runFork$1 = (effect, options) => {
	const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
	fiber.evaluate(effect);
	if (options?.signal) if (options.signal.aborted) fiber.unsafeInterrupt();
	else {
		const abort = () => fiber.unsafeInterrupt();
		options.signal.addEventListener("abort", abort, { once: true });
		fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
	}
	return fiber;
};
var PriorityBuckets = class {
	buckets = [];
	scheduleTask(task, priority) {
		const length$1 = this.buckets.length;
		let bucket = void 0;
		let index = 0;
		for (; index < length$1; index++) if (this.buckets[index][0] <= priority) bucket = this.buckets[index];
		else break;
		if (bucket && bucket[0] === priority) bucket[1].push(task);
		else if (index === length$1) this.buckets.push([priority, [task]]);
		else this.buckets.splice(index, 0, [priority, [task]]);
	}
};
var MixedScheduler = class {
	maxNextTickBeforeTimer;
	running = false;
	tasks = /* @__PURE__ */ new PriorityBuckets();
	constructor(maxNextTickBeforeTimer) {
		this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
	}
	starveInternal(depth) {
		const tasks = this.tasks.buckets;
		this.tasks.buckets = [];
		for (const [_, toRun] of tasks) for (let i = 0; i < toRun.length; i++) toRun[i]();
		if (this.tasks.buckets.length === 0) this.running = false;
		else this.starve(depth);
	}
	starve(depth = 0) {
		if (depth >= this.maxNextTickBeforeTimer) setTimeout(() => this.starveInternal(0), 0);
		else Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
	}
	shouldYield(fiber) {
		return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
	}
	scheduleTask(task, priority) {
		this.tasks.scheduleTask(task, priority);
		if (!this.running) {
			this.running = true;
			this.starve();
		}
	}
};
const defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
	tasks = /* @__PURE__ */ new PriorityBuckets();
	deferred = false;
	scheduleTask(task, priority) {
		if (this.deferred) defaultScheduler.scheduleTask(task, priority);
		else this.tasks.scheduleTask(task, priority);
	}
	shouldYield(fiber) {
		return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
	}
	flush() {
		while (this.tasks.buckets.length > 0) {
			const tasks = this.tasks.buckets;
			this.tasks.buckets = [];
			for (const [_, toRun] of tasks) for (let i = 0; i < toRun.length; i++) toRun[i]();
		}
		this.deferred = true;
	}
};
const currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
const currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));
const match$5 = (concurrency, sequential$4, unbounded$1, bounded) => {
	switch (concurrency) {
		case void 0: return sequential$4();
		case "unbounded": return unbounded$1();
		case "inherit": return fiberRefGetWith(currentConcurrency, (concurrency$1) => concurrency$1 === "unbounded" ? unbounded$1() : concurrency$1 > 1 ? bounded(concurrency$1) : sequential$4());
		default: return concurrency > 1 ? bounded(concurrency) : sequential$4();
	}
};
const OP_INTERRUPT_SIGNAL = "InterruptSignal";
const OP_STATEFUL = "Stateful";
const OP_RESUME = "Resume";
const OP_YIELD_NOW = "YieldNow";
const interruptSignal = (cause$2) => ({
	_tag: OP_INTERRUPT_SIGNAL,
	cause: cause$2
});
const stateful = (onFiber) => ({
	_tag: OP_STATEFUL,
	onFiber
});
const resume = (effect) => ({
	_tag: OP_RESUME,
	effect
});
const yieldNow$1 = () => ({ _tag: OP_YIELD_NOW });
const FiberScopeTypeId = /* @__PURE__ */ Symbol.for("effect/FiberScope");
var Global = class {
	[FiberScopeTypeId] = FiberScopeTypeId;
	fiberId = none$6;
	roots = /* @__PURE__ */ new Set();
	add(_runtimeFlags, child$1) {
		this.roots.add(child$1);
		child$1.addObserver(() => {
			this.roots.delete(child$1);
		});
	}
};
var Local = class {
	fiberId;
	parent;
	[FiberScopeTypeId] = FiberScopeTypeId;
	constructor(fiberId$2, parent) {
		this.fiberId = fiberId$2;
		this.parent = parent;
	}
	add(_runtimeFlags, child$1) {
		this.parent.tell(stateful((parentFiber) => {
			parentFiber.addChild(child$1);
			child$1.addObserver(() => {
				parentFiber.removeChild(child$1);
			});
		}));
	}
};
const unsafeMake$1 = (fiber) => {
	return new Local(fiber.id(), fiber);
};
const globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());
const FiberTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Fiber");
const fiberVariance = {
	_E: (_) => _,
	_A: (_) => _
};
var fiberProto = {
	[FiberTypeId$1]: fiberVariance,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const RuntimeFiberTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Fiber");
const join$1 = (self) => zipLeft$3(flatten$4(self.await), self.inheritAll);
({ ...CommitPrototype$1 }), { ...fiberProto };
const currentFiberURI = "effect/FiberCurrent";
const LoggerTypeId = /* @__PURE__ */ Symbol.for("effect/Logger");
var loggerVariance = {
	_Message: (_) => _,
	_Output: (_) => _
};
const makeLogger = (log$2) => ({
	[LoggerTypeId]: loggerVariance,
	log: log$2,
	pipe() {
		return pipeArguments(this, arguments);
	}
});
var textOnly = /^[^\s"=]*$/;
var format$1 = (quoteValue, whitespace) => ({ annotations: annotations$1, cause: cause$2, date: date$2, fiberId: fiberId$2, logLevel: logLevel$2, message, spans }) => {
	const formatValue = (value$2) => value$2.match(textOnly) ? value$2 : quoteValue(value$2);
	const format$3 = (label, value$2) => `${formatLabel(label)}=${formatValue(value$2)}`;
	const append$3 = (label, value$2) => " " + format$3(label, value$2);
	let out = format$3("timestamp", date$2.toISOString());
	out += append$3("level", logLevel$2.label);
	out += append$3("fiber", threadName$1(fiberId$2));
	const messages = ensure(message);
	for (let i = 0; i < messages.length; i++) out += append$3("message", toStringUnknown(messages[i], whitespace));
	if (!isEmptyType$1(cause$2)) out += append$3("cause", pretty$3(cause$2, { renderErrorCause: true }));
	for (const span$1 of spans) out += " " + render$1(date$2.getTime())(span$1);
	for (const [label, value$2] of annotations$1) out += append$3(label, toStringUnknown(value$2, whitespace));
	return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
const stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format$1(escapeDoubleQuotes));
var colors = {
	bold: "1",
	red: "31",
	green: "32",
	yellow: "33",
	blue: "34",
	cyan: "36",
	white: "37",
	gray: "90",
	black: "30",
	bgBrightRed: "101"
};
colors.gray, colors.blue, colors.green, colors.yellow, colors.red, colors.bgBrightRed, colors.black;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
hasProcessStdout && process.stdout.isTTY;
hasProcessStdout || "Deno" in globalThis;
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
const MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
	values;
	[MetricBoundariesTypeId] = MetricBoundariesTypeId;
	constructor(values$6) {
		this.values = values$6;
		this._hash = pipe(string$2(MetricBoundariesSymbolKey), combine$11(array$3(this.values)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](u) {
		return isMetricBoundaries(u) && equals(this.values, u.values);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
const fromIterable$4 = (iterable) => {
	return new MetricBoundariesImpl(pipe(iterable, appendAll$2(of$3(Number.POSITIVE_INFINITY)), dedupe));
};
const exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable$4);
const MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for("effect/MetricKeyType");
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
const CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
const FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for("effect/MetricKeyType/Frequency");
const GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for("effect/MetricKeyType/Gauge");
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
const HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
const SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for("effect/MetricKeyType/Summary");
var metricKeyTypeVariance = {
	_In: (_) => _,
	_Out: (_) => _
};
var CounterKeyType = class {
	incremental;
	bigint;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
	constructor(incremental, bigint) {
		this.incremental = incremental;
		this.bigint = bigint;
		this._hash = string$2(CounterKeyTypeSymbolKey);
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isCounterKey(that);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var HistogramKeyType = class {
	boundaries;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
	constructor(boundaries) {
		this.boundaries = boundaries;
		this._hash = pipe(string$2(HistogramKeyTypeSymbolKey), combine$11(hash(this.boundaries)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const counter$4 = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
const histogram$4 = (boundaries) => {
	return new HistogramKeyType(boundaries);
};
const isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
const isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
const isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
const isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
const isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);
const MetricKeyTypeId = /* @__PURE__ */ Symbol.for("effect/MetricKey");
var metricKeyVariance = { _Type: (_) => _ };
var arrayEquivilence = /* @__PURE__ */ getEquivalence$3(equals);
var MetricKeyImpl = class {
	name;
	keyType;
	description;
	tags;
	[MetricKeyTypeId] = metricKeyVariance;
	constructor(name, keyType, description, tags = []) {
		this.name = name;
		this.keyType = keyType;
		this.description = description;
		this.tags = tags;
		this._hash = pipe(string$2(this.name + this.description), combine$11(hash(this.keyType)), combine$11(array$3(this.tags)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](u) {
		return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
const counter$3 = (name, options) => new MetricKeyImpl(name, counter$4(options), fromNullable$2(options?.description));
const histogram$3 = (name, boundaries, description) => new MetricKeyImpl(name, histogram$4(boundaries), fromNullable$2(description));
const taggedWithLabels$1 = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union$8(self.tags, extraTags)));
const MetricStateTypeId = /* @__PURE__ */ Symbol.for("effect/MetricState");
var CounterStateSymbolKey = "effect/MetricState/Counter";
const CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
const FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
const GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
const HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
const SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = { _A: (_) => _ };
var CounterState = class {
	count;
	[MetricStateTypeId] = metricStateVariance;
	[CounterStateTypeId] = CounterStateTypeId;
	constructor(count) {
		this.count = count;
	}
	[symbol$1]() {
		return pipe(hash(CounterStateSymbolKey), combine$11(hash(this.count)), cached$2(this));
	}
	[symbol](that) {
		return isCounterState(that) && this.count === that.count;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var arrayEquals = /* @__PURE__ */ getEquivalence$3(equals);
var FrequencyState = class {
	occurrences;
	[MetricStateTypeId] = metricStateVariance;
	[FrequencyStateTypeId] = FrequencyStateTypeId;
	constructor(occurrences) {
		this.occurrences = occurrences;
	}
	_hash;
	[symbol$1]() {
		return pipe(string$2(FrequencyStateSymbolKey), combine$11(array$3(fromIterable$10(this.occurrences.entries()))), cached$2(this));
	}
	[symbol](that) {
		return isFrequencyState(that) && arrayEquals(fromIterable$10(this.occurrences.entries()), fromIterable$10(that.occurrences.entries()));
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var GaugeState = class {
	value;
	[MetricStateTypeId] = metricStateVariance;
	[GaugeStateTypeId] = GaugeStateTypeId;
	constructor(value$2) {
		this.value = value$2;
	}
	[symbol$1]() {
		return pipe(hash(GaugeStateSymbolKey), combine$11(hash(this.value)), cached$2(this));
	}
	[symbol](u) {
		return isGaugeState(u) && this.value === u.value;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var HistogramState = class {
	buckets;
	count;
	min;
	max;
	sum;
	[MetricStateTypeId] = metricStateVariance;
	[HistogramStateTypeId] = HistogramStateTypeId;
	constructor(buckets, count, min$2, max$4, sum) {
		this.buckets = buckets;
		this.count = count;
		this.min = min$2;
		this.max = max$4;
		this.sum = sum;
	}
	[symbol$1]() {
		return pipe(hash(HistogramStateSymbolKey), combine$11(hash(this.buckets)), combine$11(hash(this.count)), combine$11(hash(this.min)), combine$11(hash(this.max)), combine$11(hash(this.sum)), cached$2(this));
	}
	[symbol](that) {
		return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var SummaryState = class {
	error;
	quantiles;
	count;
	min;
	max;
	sum;
	[MetricStateTypeId] = metricStateVariance;
	[SummaryStateTypeId] = SummaryStateTypeId;
	constructor(error, quantiles, count, min$2, max$4, sum) {
		this.error = error;
		this.quantiles = quantiles;
		this.count = count;
		this.min = min$2;
		this.max = max$4;
		this.sum = sum;
	}
	[symbol$1]() {
		return pipe(hash(SummaryStateSymbolKey), combine$11(hash(this.error)), combine$11(hash(this.quantiles)), combine$11(hash(this.count)), combine$11(hash(this.min)), combine$11(hash(this.max)), combine$11(hash(this.sum)), cached$2(this));
	}
	[symbol](that) {
		return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const counter$2 = (count) => new CounterState(count);
const frequency$1 = (occurrences) => {
	return new FrequencyState(occurrences);
};
const gauge$1 = (count) => new GaugeState(count);
const histogram$2 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
const summary$1 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
const isCounterState = (u) => hasProperty(u, CounterStateTypeId);
const isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
const isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
const isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
const isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);
const MetricHookTypeId = /* @__PURE__ */ Symbol.for("effect/MetricHook");
var metricHookVariance = {
	_In: (_) => _,
	_Out: (_) => _
};
const make$15 = (options) => ({
	[MetricHookTypeId]: metricHookVariance,
	pipe() {
		return pipeArguments(this, arguments);
	},
	...options
});
var bigint0 = /* @__PURE__ */ BigInt(0);
const counter$1 = (key) => {
	let sum = key.keyType.bigint ? bigint0 : 0;
	const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value$2) => value$2 >= bigint0 : (value$2) => value$2 >= 0 : (_value) => true;
	const update$5 = (value$2) => {
		if (canUpdate(value$2)) sum = sum + value$2;
	};
	return make$15({
		get: () => counter$2(sum),
		update: update$5,
		modify: update$5
	});
};
const frequency = (key) => {
	const values$6 = /* @__PURE__ */ new Map();
	for (const word of key.keyType.preregisteredWords) values$6.set(word, 0);
	const update$5 = (word) => {
		const slotCount = values$6.get(word) ?? 0;
		values$6.set(word, slotCount + 1);
	};
	return make$15({
		get: () => frequency$1(values$6),
		update: update$5,
		modify: update$5
	});
};
const gauge = (_key, startAt) => {
	let value$2 = startAt;
	return make$15({
		get: () => gauge$1(value$2),
		update: (v) => {
			value$2 = v;
		},
		modify: (v) => {
			value$2 = value$2 + v;
		}
	});
};
const histogram$1 = (key) => {
	const bounds = key.keyType.boundaries.values;
	const size$11 = bounds.length;
	const values$6 = new Uint32Array(size$11 + 1);
	const boundaries = new Float64Array(size$11);
	let count = 0;
	let sum = 0;
	let min$2 = Number.MAX_VALUE;
	let max$4 = Number.MIN_VALUE;
	pipe(bounds, sort(Order$4), map$18((n, i) => {
		boundaries[i] = n;
	}));
	const update$5 = (value$2) => {
		let from = 0;
		let to = size$11;
		while (from !== to) {
			const mid = Math.floor(from + (to - from) / 2);
			if (value$2 <= boundaries[mid]) to = mid;
			else from = mid;
			if (to === from + 1) if (value$2 <= boundaries[from]) to = from;
			else from = to;
		}
		values$6[from] = values$6[from] + 1;
		count = count + 1;
		sum = sum + value$2;
		if (value$2 < min$2) min$2 = value$2;
		if (value$2 > max$4) max$4 = value$2;
	};
	const getBuckets = () => {
		const builder = allocate(size$11);
		let cumulated = 0;
		for (let i = 0; i < size$11; i++) {
			const boundary = boundaries[i];
			const value$2 = values$6[i];
			cumulated = cumulated + value$2;
			builder[i] = [boundary, cumulated];
		}
		return builder;
	};
	return make$15({
		get: () => histogram$2({
			buckets: getBuckets(),
			count,
			min: min$2,
			max: max$4,
			sum
		}),
		update: update$5,
		modify: update$5
	});
};
const summary = (key) => {
	const { error, maxAge, maxSize, quantiles } = key.keyType;
	const sortedQuantiles = pipe(quantiles, sort(Order$4));
	const values$6 = allocate(maxSize);
	let head$4 = 0;
	let count = 0;
	let sum = 0;
	let min$2 = 0;
	let max$4 = 0;
	const snapshot = (now) => {
		const builder = [];
		let i = 0;
		while (i !== maxSize - 1) {
			const item = values$6[i];
			if (item != null) {
				const [t, v] = item;
				const age = millis(now - t);
				if (greaterThanOrEqualTo(age, zero) && lessThanOrEqualTo(age, maxAge)) builder.push(v);
			}
			i = i + 1;
		}
		return calculateQuantiles(error, sortedQuantiles, sort(builder, Order$4));
	};
	const observe = (value$2, timestamp) => {
		if (maxSize > 0) {
			head$4 = head$4 + 1;
			const target = head$4 % maxSize;
			values$6[target] = [timestamp, value$2];
		}
		min$2 = count === 0 ? value$2 : Math.min(min$2, value$2);
		max$4 = count === 0 ? value$2 : Math.max(max$4, value$2);
		count = count + 1;
		sum = sum + value$2;
	};
	return make$15({
		get: () => summary$1({
			error,
			quantiles: snapshot(Date.now()),
			count,
			min: min$2,
			max: max$4,
			sum
		}),
		update: ([value$2, timestamp]) => observe(value$2, timestamp),
		modify: ([value$2, timestamp]) => observe(value$2, timestamp)
	});
};
var calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
	const sampleCount = sortedSamples.length;
	if (!isNonEmptyReadonlyArray(sortedQuantiles)) return empty$34();
	const head$4 = sortedQuantiles[0];
	const tail = sortedQuantiles.slice(1);
	const resolvedHead = resolveQuantile(error, sampleCount, none$7(), 0, head$4, sortedSamples);
	const resolved = of$4(resolvedHead);
	tail.forEach((quantile) => {
		resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
	});
	return map$18(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
	let error_1 = error;
	let sampleCount_1 = sampleCount;
	let current_1 = current;
	let consumed_1 = consumed;
	let quantile_1 = quantile;
	let rest_1 = rest;
	let error_2 = error;
	let sampleCount_2 = sampleCount;
	let current_2 = current;
	let consumed_2 = consumed;
	let quantile_2 = quantile;
	let rest_2 = rest;
	while (1) {
		if (!isNonEmptyReadonlyArray(rest_1)) return {
			quantile: quantile_1,
			value: none$7(),
			consumed: consumed_1,
			rest: []
		};
		if (quantile_1 === 1) return {
			quantile: quantile_1,
			value: some$4(lastNonEmpty(rest_1)),
			consumed: consumed_1 + rest_1.length,
			rest: []
		};
		const headValue = headNonEmpty$1(rest_1);
		const sameHead = span(rest_1, (n) => n === headValue);
		const desired = quantile_1 * sampleCount_1;
		const allowedError = error_1 / 2 * desired;
		const candConsumed = consumed_1 + sameHead[0].length;
		const candError = Math.abs(candConsumed - desired);
		if (candConsumed < desired - allowedError) {
			error_2 = error_1;
			sampleCount_2 = sampleCount_1;
			current_2 = head$3(rest_1);
			consumed_2 = candConsumed;
			quantile_2 = quantile_1;
			rest_2 = sameHead[1];
			error_1 = error_2;
			sampleCount_1 = sampleCount_2;
			current_1 = current_2;
			consumed_1 = consumed_2;
			quantile_1 = quantile_2;
			rest_1 = rest_2;
			continue;
		}
		if (candConsumed > desired + allowedError) {
			const valueToReturn = isNone$2(current_1) ? some$4(headValue) : current_1;
			return {
				quantile: quantile_1,
				value: valueToReturn,
				consumed: consumed_1,
				rest: rest_1
			};
		}
		switch (current_1._tag) {
			case "None":
				error_2 = error_1;
				sampleCount_2 = sampleCount_1;
				current_2 = head$3(rest_1);
				consumed_2 = candConsumed;
				quantile_2 = quantile_1;
				rest_2 = sameHead[1];
				error_1 = error_2;
				sampleCount_1 = sampleCount_2;
				current_1 = current_2;
				consumed_1 = consumed_2;
				quantile_1 = quantile_2;
				rest_1 = rest_2;
				continue;
			case "Some":
				if (candError < Math.abs(desired - current_1.value)) {
					error_2 = error_1;
					sampleCount_2 = sampleCount_1;
					current_2 = head$3(rest_1);
					consumed_2 = candConsumed;
					quantile_2 = quantile_1;
					rest_2 = sameHead[1];
					error_1 = error_2;
					sampleCount_1 = sampleCount_2;
					current_1 = current_2;
					consumed_1 = consumed_2;
					quantile_1 = quantile_2;
					rest_1 = rest_2;
					continue;
				}
				return {
					quantile: quantile_1,
					value: some$4(current_1.value),
					consumed: consumed_1,
					rest: rest_1
				};
		}
	}
	throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};
const MetricPairTypeId = /* @__PURE__ */ Symbol.for("effect/MetricPair");
var metricPairVariance = { _Type: (_) => _ };
const unsafeMake = (metricKey, metricState) => {
	return {
		[MetricPairTypeId]: metricPairVariance,
		metricKey,
		metricState,
		pipe() {
			return pipeArguments(this, arguments);
		}
	};
};
const MetricRegistryTypeId = /* @__PURE__ */ Symbol.for("effect/MetricRegistry");
var MetricRegistryImpl = class {
	[MetricRegistryTypeId] = MetricRegistryTypeId;
	map = /* @__PURE__ */ empty$15();
	snapshot() {
		const result = [];
		for (const [key, hook] of this.map) result.push(unsafeMake(key, hook.get()));
		return result;
	}
	get(key) {
		const hook = pipe(this.map, get$4(key), getOrUndefined);
		if (hook == null) {
			if (isCounterKey(key.keyType)) return this.getCounter(key);
			if (isGaugeKey(key.keyType)) return this.getGauge(key);
			if (isFrequencyKey(key.keyType)) return this.getFrequency(key);
			if (isHistogramKey(key.keyType)) return this.getHistogram(key);
			if (isSummaryKey(key.keyType)) return this.getSummary(key);
			throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
		} else return hook;
	}
	getCounter(key) {
		let value$2 = pipe(this.map, get$4(key), getOrUndefined);
		if (value$2 == null) {
			const counter$5 = counter$1(key);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set$2(key, counter$5));
			value$2 = counter$5;
		}
		return value$2;
	}
	getFrequency(key) {
		let value$2 = pipe(this.map, get$4(key), getOrUndefined);
		if (value$2 == null) {
			const frequency$2 = frequency(key);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set$2(key, frequency$2));
			value$2 = frequency$2;
		}
		return value$2;
	}
	getGauge(key) {
		let value$2 = pipe(this.map, get$4(key), getOrUndefined);
		if (value$2 == null) {
			const gauge$2 = gauge(key, key.keyType.bigint ? BigInt(0) : 0);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set$2(key, gauge$2));
			value$2 = gauge$2;
		}
		return value$2;
	}
	getHistogram(key) {
		let value$2 = pipe(this.map, get$4(key), getOrUndefined);
		if (value$2 == null) {
			const histogram$5 = histogram$1(key);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set$2(key, histogram$5));
			value$2 = histogram$5;
		}
		return value$2;
	}
	getSummary(key) {
		let value$2 = pipe(this.map, get$4(key), getOrUndefined);
		if (value$2 == null) {
			const summary$2 = summary(key);
			if (!pipe(this.map, has$2(key))) pipe(this.map, set$2(key, summary$2));
			value$2 = summary$2;
		}
		return value$2;
	}
};
const make$14 = () => {
	return new MetricRegistryImpl();
};
const MetricTypeId = /* @__PURE__ */ Symbol.for("effect/Metric");
var metricVariance = {
	_Type: (_) => _,
	_In: (_) => _,
	_Out: (_) => _
};
const globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make$14());
const make$13 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
	const metric = Object.assign((effect) => tap$2(effect, (a) => update$1(metric, a)), {
		[MetricTypeId]: metricVariance,
		keyType,
		unsafeUpdate,
		unsafeValue,
		unsafeModify,
		register() {
			this.unsafeValue([]);
			return this;
		},
		pipe() {
			return pipeArguments(this, arguments);
		}
	});
	return metric;
};
const counter = (name, options) => fromMetricKey(counter$3(name, options));
const fromMetricKey = (key) => {
	let untaggedHook;
	const hookCache = /* @__PURE__ */ new WeakMap();
	const hook = (extraTags) => {
		if (extraTags.length === 0) {
			if (untaggedHook !== void 0) return untaggedHook;
			untaggedHook = globalMetricRegistry.get(key);
			return untaggedHook;
		}
		let hook$1 = hookCache.get(extraTags);
		if (hook$1 !== void 0) return hook$1;
		hook$1 = globalMetricRegistry.get(taggedWithLabels$1(key, extraTags));
		hookCache.set(extraTags, hook$1);
		return hook$1;
	};
	return make$13(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
const histogram = (name, boundaries, description) => fromMetricKey(histogram$3(name, boundaries, description));
const tagged$2 = /* @__PURE__ */ dual(3, (self, key, value$2) => taggedWithLabels(self, [make$16(key, value$2)]));
const taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => {
	return make$13(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union$8(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union$8(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union$8(extraTags, extraTags1)));
});
const update$1 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync$6(() => self.unsafeUpdate(input, tags))));
({ ...StructuralPrototype });
const complete$2 = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map$21) => sync$6(() => {
	if (map$21.has(self)) {
		const entry = map$21.get(self);
		if (!entry.state.completed) {
			entry.state.completed = true;
			deferredUnsafeDone(entry.result, result);
		}
	}
})));
const Direction$1 = {
	Forward: 0,
	Backward: 1
};
Symbol.iterator;
var keys$1 = (self, direction) => {
	const begin = self[Symbol.iterator]();
	let count = 0;
	return {
		[Symbol.iterator]: () => keys$1(self, direction),
		next: () => {
			count++;
			const entry = begin.key;
			if (direction === Direction$1.Forward) begin.moveNext();
			else begin.movePrev();
			switch (entry._tag) {
				case "None": return {
					done: true,
					value: count
				};
				case "Some": return {
					done: false,
					value: entry.value
				};
			}
		}
	};
};
var values$1 = (self, direction) => {
	const begin = self[Symbol.iterator]();
	let count = 0;
	return {
		[Symbol.iterator]: () => values$1(self, direction),
		next: () => {
			count++;
			const entry = begin.value;
			if (direction === Direction$1.Forward) begin.moveNext();
			else begin.movePrev();
			switch (entry._tag) {
				case "None": return {
					done: true,
					value: count
				};
				case "Some": return {
					done: false,
					value: entry.value
				};
			}
		}
	};
};
Symbol.iterator;
const SupervisorTypeId = /* @__PURE__ */ Symbol.for("effect/Supervisor");
const supervisorVariance = { _T: (_) => _ };
var ProxySupervisor = class ProxySupervisor {
	underlying;
	value0;
	[SupervisorTypeId] = supervisorVariance;
	constructor(underlying, value0) {
		this.underlying = underlying;
		this.value0 = value0;
	}
	get value() {
		return this.value0;
	}
	onStart(context$3, effect, parent, fiber) {
		this.underlying.onStart(context$3, effect, parent, fiber);
	}
	onEnd(value$2, fiber) {
		this.underlying.onEnd(value$2, fiber);
	}
	onEffect(fiber, effect) {
		this.underlying.onEffect(fiber, effect);
	}
	onSuspend(fiber) {
		this.underlying.onSuspend(fiber);
	}
	onResume(fiber) {
		this.underlying.onResume(fiber);
	}
	map(f) {
		return new ProxySupervisor(this, pipe(this.value, map$12(f)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
};
var Zip = class Zip {
	left;
	right;
	_tag = "Zip";
	[SupervisorTypeId] = supervisorVariance;
	constructor(left$2, right$2) {
		this.left = left$2;
		this.right = right$2;
	}
	get value() {
		return zip$6(this.left.value, this.right.value);
	}
	onStart(context$3, effect, parent, fiber) {
		this.left.onStart(context$3, effect, parent, fiber);
		this.right.onStart(context$3, effect, parent, fiber);
	}
	onEnd(value$2, fiber) {
		this.left.onEnd(value$2, fiber);
		this.right.onEnd(value$2, fiber);
	}
	onEffect(fiber, effect) {
		this.left.onEffect(fiber, effect);
		this.right.onEffect(fiber, effect);
	}
	onSuspend(fiber) {
		this.left.onSuspend(fiber);
		this.right.onSuspend(fiber);
	}
	onResume(fiber) {
		this.left.onResume(fiber);
		this.right.onResume(fiber);
	}
	map(f) {
		return new ProxySupervisor(this, pipe(this.value, map$12(f)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
};
const isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
var Const = class {
	effect;
	[SupervisorTypeId] = supervisorVariance;
	constructor(effect) {
		this.effect = effect;
	}
	get value() {
		return this.effect;
	}
	onStart(_context, _effect, _parent, _fiber) {}
	onEnd(_value, _fiber) {}
	onEffect(_fiber, _effect) {}
	onSuspend(_fiber) {}
	onResume(_fiber) {}
	map(f) {
		return new ProxySupervisor(this, pipe(this.value, map$12(f)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
	onRun(execution, _fiber) {
		return execution();
	}
};
const fromEffect$2 = (effect) => {
	return new Const(effect);
};
const none$2 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect$2(void_$4));
const make$10 = make$32;
const OP_EMPTY = "Empty";
const OP_ADD_SUPERVISOR = "AddSupervisor";
const OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
const OP_AND_THEN = "AndThen";
const empty$6 = { _tag: OP_EMPTY };
const combine = (self, that) => {
	return {
		_tag: OP_AND_THEN,
		first: self,
		second: that
	};
};
const patch = (self, supervisor) => {
	return patchLoop(supervisor, of$3(self));
};
var patchLoop = (_supervisor, _patches) => {
	let supervisor = _supervisor;
	let patches = _patches;
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		switch (head$4._tag) {
			case OP_EMPTY:
				patches = tailNonEmpty(patches);
				break;
			case OP_ADD_SUPERVISOR:
				supervisor = supervisor.zip(head$4.supervisor);
				patches = tailNonEmpty(patches);
				break;
			case OP_REMOVE_SUPERVISOR:
				supervisor = removeSupervisor(supervisor, head$4.supervisor);
				patches = tailNonEmpty(patches);
				break;
			case OP_AND_THEN:
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tailNonEmpty(patches)));
				break;
		}
	}
	return supervisor;
};
var removeSupervisor = (self, that) => {
	if (equals(self, that)) return none$2;
	else if (isZip(self)) return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
	else return self;
};
var toSet = (self) => {
	if (equals(self, none$2)) return empty$28();
	else if (isZip(self)) return pipe(toSet(self.left), union$5(toSet(self.right)));
	else return make$37(self);
};
const diff = (oldValue, newValue) => {
	if (equals(oldValue, newValue)) return empty$6;
	const oldSupervisors = toSet(oldValue);
	const newSupervisors = toSet(newValue);
	return combine(pipe(newSupervisors, difference(oldSupervisors), reduce$8(empty$6, (patch$11, supervisor) => combine(patch$11, {
		_tag: OP_ADD_SUPERVISOR,
		supervisor
	}))), pipe(oldSupervisors, difference(newSupervisors), reduce$8(empty$6, (patch$11, supervisor) => combine(patch$11, {
		_tag: OP_REMOVE_SUPERVISOR,
		supervisor
	}))));
};
const differ = /* @__PURE__ */ make$10({
	empty: empty$6,
	patch,
	combine,
	diff
});
const fiberStarted = /* @__PURE__ */ counter("effect_fiber_started", { incremental: true });
const fiberActive = /* @__PURE__ */ counter("effect_fiber_active");
const fiberSuccesses = /* @__PURE__ */ counter("effect_fiber_successes", { incremental: true });
const fiberFailures = /* @__PURE__ */ counter("effect_fiber_failures", { incremental: true });
const fiberLifetimes = /* @__PURE__ */ tagged$2(/* @__PURE__ */ histogram("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
	start: .5,
	factor: 2,
	count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
	_E: (_) => _,
	_A: (_) => _
};
var absurd = (_) => {
	throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({ currentOp: null }));
var contOpSuccess = {
	[OP_ON_SUCCESS]: (_, cont, value$2) => {
		return internalCall(() => cont.effect_instruction_i1(value$2));
	},
	["OnStep"]: (_, _cont, value$2) => {
		return exitSucceed$1(exitSucceed$1(value$2));
	},
	[OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value$2) => {
		return internalCall(() => cont.effect_instruction_i2(value$2));
	},
	[OP_REVERT_FLAGS]: (self, cont, value$2) => {
		self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
		if (interruptible$3(self.currentRuntimeFlags) && self.isInterrupted()) return exitFailCause$1(self.getInterruptedCause());
		else return exitSucceed$1(value$2);
	},
	[OP_WHILE]: (self, cont, value$2) => {
		internalCall(() => cont.effect_instruction_i2(value$2));
		if (internalCall(() => cont.effect_instruction_i0())) {
			self.pushStack(cont);
			return internalCall(() => cont.effect_instruction_i1());
		} else return void_$4;
	},
	[OP_ITERATOR]: (self, cont, value$2) => {
		while (true) {
			const state = internalCall(() => cont.effect_instruction_i0.next(value$2));
			if (state.done) return exitSucceed$1(state.value);
			const primitive$2 = yieldWrapGet(state.value);
			if (!exitIsExit(primitive$2)) {
				self.pushStack(cont);
				return primitive$2;
			} else if (primitive$2._tag === "Failure") return primitive$2;
			value$2 = primitive$2.value;
		}
	}
};
var drainQueueWhileRunningTable = {
	[OP_INTERRUPT_SIGNAL]: (self, runtimeFlags$1, cur, message) => {
		self.processNewInterruptSignal(message.cause);
		return interruptible$3(runtimeFlags$1) ? exitFailCause$1(message.cause) : cur;
	},
	[OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
		throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
	},
	[OP_STATEFUL]: (self, runtimeFlags$1, cur, message) => {
		message.onFiber(self, running(runtimeFlags$1));
		return cur;
	},
	[OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
		return flatMap$6(yieldNow$3(), () => cur);
	}
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten$6(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential$4]) => {
	const map$21 = /* @__PURE__ */ new Map();
	const arr = [];
	for (const block of sequential$4) {
		arr.push(toReadonlyArray(block));
		for (const entry of block) map$21.set(entry.request, entry);
	}
	const flat = arr.flat();
	return fiberRefLocally$1(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
		entry.listeners.interrupted = true;
	})), currentRequestMap, map$21);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();
var FiberRuntime = class extends Class$3 {
	[FiberTypeId$1] = fiberVariance;
	[RuntimeFiberTypeId$1] = runtimeFiberVariance;
	_fiberRefs;
	_fiberId;
	_queue = /* @__PURE__ */ new Array();
	_children = null;
	_observers = /* @__PURE__ */ new Array();
	_running = false;
	_stack = [];
	_asyncInterruptor = null;
	_asyncBlockingOn = null;
	_exitValue = null;
	_steps = [];
	_isYielding = false;
	currentRuntimeFlags;
	currentOpCount = 0;
	currentSupervisor;
	currentScheduler;
	currentTracer;
	currentSpan;
	currentContext;
	currentDefaultServices;
	constructor(fiberId$2, fiberRefs0, runtimeFlags0) {
		super();
		this.currentRuntimeFlags = runtimeFlags0;
		this._fiberId = fiberId$2;
		this._fiberRefs = fiberRefs0;
		if (runtimeMetrics(runtimeFlags0)) {
			const tags = this.getFiberRef(currentMetricLabels);
			fiberStarted.unsafeUpdate(1, tags);
			fiberActive.unsafeUpdate(1, tags);
		}
		this.refreshRefCache();
	}
	commit() {
		return join$1(this);
	}
	id() {
		return this._fiberId;
	}
	resume(effect) {
		this.tell(resume(effect));
	}
	get status() {
		return this.ask((_, status$2) => status$2);
	}
	get runtimeFlags() {
		return this.ask((state, status$2) => {
			if (isDone$2(status$2)) return state.currentRuntimeFlags;
			return status$2.runtimeFlags;
		});
	}
	scope() {
		return unsafeMake$1(this);
	}
	get children() {
		return this.ask((fiber) => Array.from(fiber.getChildren()));
	}
	getChildren() {
		if (this._children === null) this._children = /* @__PURE__ */ new Set();
		return this._children;
	}
	getInterruptedCause() {
		return this.getFiberRef(currentInterruptedCause);
	}
	fiberRefs() {
		return this.ask((fiber) => fiber.getFiberRefs());
	}
	ask(f) {
		return suspend$5(() => {
			const deferred = deferredUnsafeMake(this._fiberId);
			this.tell(stateful((fiber, status$2) => {
				deferredUnsafeDone(deferred, sync$6(() => f(fiber, status$2)));
			}));
			return deferredAwait(deferred);
		});
	}
	tell(message) {
		this._queue.push(message);
		if (!this._running) {
			this._running = true;
			this.drainQueueLaterOnExecutor();
		}
	}
	get await() {
		return async_((resume$1) => {
			const cb = (exit$3) => resume$1(succeed$12(exit$3));
			this.tell(stateful((fiber, _) => {
				if (fiber._exitValue !== null) cb(this._exitValue);
				else fiber.addObserver(cb);
			}));
			return sync$6(() => this.tell(stateful((fiber, _) => {
				fiber.removeObserver(cb);
			})));
		}, this.id());
	}
	get inheritAll() {
		return withFiberRuntime$1((parentFiber, parentStatus) => {
			const parentFiberId = parentFiber.id();
			const parentFiberRefs = parentFiber.getFiberRefs();
			const parentRuntimeFlags = parentStatus.runtimeFlags;
			const updatedFiberRefs = joinAs$1(parentFiberRefs, parentFiberId, this.getFiberRefs());
			parentFiber.setFiberRefs(updatedFiberRefs);
			return updateRuntimeFlags(pipe(diff$3(parentRuntimeFlags, parentFiber.getFiberRef(currentRuntimeFlags)), exclude(1), exclude(16)));
		});
	}
	get poll() {
		return sync$6(() => fromNullable$2(this._exitValue));
	}
	unsafePoll() {
		return this._exitValue;
	}
	interruptAsFork(fiberId$2) {
		return sync$6(() => this.tell(interruptSignal(interrupt$6(fiberId$2))));
	}
	unsafeInterruptAsFork(fiberId$2) {
		this.tell(interruptSignal(interrupt$6(fiberId$2)));
	}
	addObserver(observer) {
		if (this._exitValue !== null) observer(this._exitValue);
		else this._observers.push(observer);
	}
	removeObserver(observer) {
		this._observers = this._observers.filter((o) => o !== observer);
	}
	getFiberRefs() {
		this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
		return this._fiberRefs;
	}
	unsafeDeleteFiberRef(fiberRef) {
		this._fiberRefs = delete_$1(this._fiberRefs, fiberRef);
	}
	getFiberRef(fiberRef) {
		if (this._fiberRefs.locals.has(fiberRef)) return this._fiberRefs.locals.get(fiberRef)[0][1];
		return fiberRef.initial;
	}
	setFiberRef(fiberRef, value$2) {
		this._fiberRefs = updateAs$1(this._fiberRefs, {
			fiberId: this._fiberId,
			fiberRef,
			value: value$2
		});
		this.refreshRefCache();
	}
	refreshRefCache() {
		this.currentDefaultServices = this.getFiberRef(currentServices);
		this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
		this.currentSupervisor = this.getFiberRef(currentSupervisor);
		this.currentScheduler = this.getFiberRef(currentScheduler);
		this.currentContext = this.getFiberRef(currentContext);
		this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
	}
	setFiberRefs(fiberRefs$3) {
		this._fiberRefs = fiberRefs$3;
		this.refreshRefCache();
	}
	addChild(child$1) {
		this.getChildren().add(child$1);
	}
	removeChild(child$1) {
		this.getChildren().delete(child$1);
	}
	transferChildren(scope$3) {
		const children$2 = this._children;
		this._children = null;
		if (children$2 !== null && children$2.size > 0) {
			for (const child$1 of children$2) if (child$1._exitValue === null) scope$3.add(this.currentRuntimeFlags, child$1);
		}
	}
	drainQueueOnCurrentThread() {
		let recurse = true;
		while (recurse) {
			let evaluationSignal = EvaluationSignalContinue;
			const prev = globalThis[currentFiberURI];
			globalThis[currentFiberURI] = this;
			try {
				while (evaluationSignal === EvaluationSignalContinue) evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
			} finally {
				this._running = false;
				globalThis[currentFiberURI] = prev;
			}
			if (this._queue.length > 0 && !this._running) {
				this._running = true;
				if (evaluationSignal === EvaluationSignalYieldNow) {
					this.drainQueueLaterOnExecutor();
					recurse = false;
				} else recurse = true;
			} else recurse = false;
		}
	}
	drainQueueLaterOnExecutor() {
		this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
	}
	drainQueueWhileRunning(runtimeFlags$1, cur0) {
		let cur = cur0;
		while (this._queue.length > 0) {
			const message = this._queue.splice(0, 1)[0];
			cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags$1, cur, message);
		}
		return cur;
	}
	isInterrupted() {
		return !isEmpty$4(this.getFiberRef(currentInterruptedCause));
	}
	addInterruptedCause(cause$2) {
		const oldSC = this.getFiberRef(currentInterruptedCause);
		this.setFiberRef(currentInterruptedCause, sequential$3(oldSC, cause$2));
	}
	processNewInterruptSignal(cause$2) {
		this.addInterruptedCause(cause$2);
		this.sendInterruptSignalToAllChildren();
	}
	sendInterruptSignalToAllChildren() {
		if (this._children === null || this._children.size === 0) return false;
		let told = false;
		for (const child$1 of this._children) {
			child$1.tell(interruptSignal(interrupt$6(this.id())));
			told = true;
		}
		return told;
	}
	interruptAllChildren() {
		if (this.sendInterruptSignalToAllChildren()) {
			const it = this._children.values();
			this._children = null;
			let isDone$5 = false;
			const body = () => {
				const next = it.next();
				if (!next.done) return asVoid$3(next.value.await);
				else return sync$6(() => {
					isDone$5 = true;
				});
			};
			return whileLoop$2({
				while: () => !isDone$5,
				body,
				step: () => {}
			});
		}
		return null;
	}
	reportExitValue(exit$3) {
		if (runtimeMetrics(this.currentRuntimeFlags)) {
			const tags = this.getFiberRef(currentMetricLabels);
			const startTimeMillis = this.id().startTimeMillis;
			const endTimeMillis = Date.now();
			fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
			fiberActive.unsafeUpdate(-1, tags);
			switch (exit$3._tag) {
				case OP_SUCCESS:
					fiberSuccesses.unsafeUpdate(1, tags);
					break;
				case OP_FAILURE:
					fiberFailures.unsafeUpdate(1, tags);
					break;
			}
		}
		if (exit$3._tag === "Failure") {
			const level = this.getFiberRef(currentUnhandledErrorLogLevel);
			if (!isInterruptedOnly$1(exit$3.cause) && level._tag === "Some") this.log("Fiber terminated with an unhandled error", exit$3.cause, level);
		}
	}
	setExitValue(exit$3) {
		this._exitValue = exit$3;
		this.reportExitValue(exit$3);
		for (let i = this._observers.length - 1; i >= 0; i--) this._observers[i](exit$3);
		this._observers = [];
	}
	getLoggers() {
		return this.getFiberRef(currentLoggers);
	}
	log(message, cause$2, overrideLogLevel) {
		const logLevel$2 = isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
		if (greaterThan$2(this.getFiberRef(currentMinimumLogLevel), logLevel$2)) return;
		const spans = this.getFiberRef(currentLogSpan);
		const annotations$1 = this.getFiberRef(currentLogAnnotations);
		const loggers = this.getLoggers();
		const contextMap = this.getFiberRefs();
		if (size$8(loggers) > 0) {
			const clockService = get$9(this.getFiberRef(currentServices), clockTag);
			const date$2 = new Date(clockService.unsafeCurrentTimeMillis());
			withRedactableContext(contextMap, () => {
				for (const logger of loggers) logger.log({
					fiberId: this.id(),
					logLevel: logLevel$2,
					message,
					cause: cause$2,
					context: contextMap,
					spans,
					annotations: annotations$1,
					date: date$2
				});
			});
		}
	}
	evaluateMessageWhileSuspended(message) {
		switch (message._tag) {
			case OP_YIELD_NOW: return EvaluationSignalYieldNow;
			case OP_INTERRUPT_SIGNAL:
				this.processNewInterruptSignal(message.cause);
				if (this._asyncInterruptor !== null) {
					this._asyncInterruptor(exitFailCause$1(message.cause));
					this._asyncInterruptor = null;
				}
				return EvaluationSignalContinue;
			case OP_RESUME:
				this._asyncInterruptor = null;
				this._asyncBlockingOn = null;
				this.evaluateEffect(message.effect);
				return EvaluationSignalContinue;
			case OP_STATEFUL:
				message.onFiber(this, this._exitValue !== null ? done$4 : suspended(this.currentRuntimeFlags, this._asyncBlockingOn));
				return EvaluationSignalContinue;
			default: return absurd(message);
		}
	}
	evaluateEffect(effect0) {
		this.currentSupervisor.onResume(this);
		try {
			let effect = interruptible$3(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause$1(this.getInterruptedCause()) : effect0;
			while (effect !== null) {
				const eff = effect;
				const exit$3 = this.runLoop(eff);
				if (exit$3 === YieldedOp) {
					const op = yieldedOpChannel.currentOp;
					yieldedOpChannel.currentOp = null;
					if (op._op === "Yield") if (cooperativeYielding(this.currentRuntimeFlags)) {
						this.tell(yieldNow$1());
						this.tell(resume(exitVoid$1));
						effect = null;
					} else effect = exitVoid$1;
					else if (op._op === "Async") effect = null;
				} else {
					this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable$1(16));
					const interruption$1 = this.interruptAllChildren();
					if (interruption$1 !== null) effect = flatMap$6(interruption$1, () => exit$3);
					else {
						if (this._queue.length === 0) this.setExitValue(exit$3);
						else this.tell(resume(exit$3));
						effect = null;
					}
				}
			}
		} finally {
			this.currentSupervisor.onSuspend(this);
		}
	}
	start(effect) {
		if (!this._running) {
			this._running = true;
			const prev = globalThis[currentFiberURI];
			globalThis[currentFiberURI] = this;
			try {
				this.evaluateEffect(effect);
			} finally {
				this._running = false;
				globalThis[currentFiberURI] = prev;
				if (this._queue.length > 0) this.drainQueueLaterOnExecutor();
			}
		} else this.tell(resume(effect));
	}
	startFork(effect) {
		this.tell(resume(effect));
	}
	patchRuntimeFlags(oldRuntimeFlags, patch$11) {
		const newRuntimeFlags = patch$4(oldRuntimeFlags, patch$11);
		globalThis[currentFiberURI] = this;
		this.currentRuntimeFlags = newRuntimeFlags;
		return newRuntimeFlags;
	}
	initiateAsync(runtimeFlags$1, asyncRegister) {
		let alreadyCalled = false;
		const callback = (effect) => {
			if (!alreadyCalled) {
				alreadyCalled = true;
				this.tell(resume(effect));
			}
		};
		if (interruptible$3(runtimeFlags$1)) this._asyncInterruptor = callback;
		try {
			asyncRegister(callback);
		} catch (e) {
			callback(failCause$9(die$6(e)));
		}
	}
	pushStack(cont) {
		this._stack.push(cont);
		if (cont._op === "OnStep") this._steps.push({
			refs: this.getFiberRefs(),
			flags: this.currentRuntimeFlags
		});
	}
	popStack() {
		const item = this._stack.pop();
		if (item) {
			if (item._op === "OnStep") this._steps.pop();
			return item;
		}
	}
	getNextSuccessCont() {
		let frame = this.popStack();
		while (frame) {
			if (frame._op !== "OnFailure") return frame;
			frame = this.popStack();
		}
	}
	getNextFailCont() {
		let frame = this.popStack();
		while (frame) {
			if (frame._op !== "OnSuccess" && frame._op !== "While" && frame._op !== "Iterator") return frame;
			frame = this.popStack();
		}
	}
	["Tag"](op) {
		return sync$6(() => unsafeGet$3(this.currentContext, op));
	}
	["Left"](op) {
		return fail$12(op.left);
	}
	["None"](_) {
		return fail$12(new NoSuchElementException$1());
	}
	["Right"](op) {
		return exitSucceed$1(op.right);
	}
	["Some"](op) {
		return exitSucceed$1(op.value);
	}
	["Micro"](op) {
		return unsafeAsync((microResume) => {
			let resume$1 = microResume;
			const fiber = runFork$1(provideContext(op, this.currentContext));
			fiber.addObserver((exit$3) => {
				if (exit$3._tag === "Success") return resume$1(exitSucceed$1(exit$3.value));
				switch (exit$3.cause._tag) {
					case "Interrupt": return resume$1(exitFailCause$1(interrupt$6(none$6)));
					case "Fail": return resume$1(fail$12(exit$3.cause.error));
					case "Die": return resume$1(die$5(exit$3.cause.defect));
				}
			});
			return unsafeAsync((abortResume) => {
				resume$1 = (_) => {
					abortResume(void_$4);
				};
				fiber.unsafeInterrupt();
			});
		});
	}
	[OP_SYNC](op) {
		const value$2 = internalCall(() => op.effect_instruction_i0());
		const cont = this.getNextSuccessCont();
		if (cont !== void 0) {
			if (!(cont._op in contOpSuccess)) absurd(cont);
			return contOpSuccess[cont._op](this, cont, value$2);
		} else {
			yieldedOpChannel.currentOp = exitSucceed$1(value$2);
			return YieldedOp;
		}
	}
	[OP_SUCCESS](op) {
		const oldCur = op;
		const cont = this.getNextSuccessCont();
		if (cont !== void 0) {
			if (!(cont._op in contOpSuccess)) absurd(cont);
			return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
		} else {
			yieldedOpChannel.currentOp = oldCur;
			return YieldedOp;
		}
	}
	[OP_FAILURE](op) {
		const cause$2 = op.effect_instruction_i0;
		const cont = this.getNextFailCont();
		if (cont !== void 0) switch (cont._op) {
			case OP_ON_FAILURE:
			case OP_ON_SUCCESS_AND_FAILURE: if (!(interruptible$3(this.currentRuntimeFlags) && this.isInterrupted())) return internalCall(() => cont.effect_instruction_i1(cause$2));
			else return exitFailCause$1(stripFailures$1(cause$2));
			case "OnStep": if (!(interruptible$3(this.currentRuntimeFlags) && this.isInterrupted())) return exitSucceed$1(exitFailCause$1(cause$2));
			else return exitFailCause$1(stripFailures$1(cause$2));
			case OP_REVERT_FLAGS:
				this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
				if (interruptible$3(this.currentRuntimeFlags) && this.isInterrupted()) return exitFailCause$1(sequential$3(cause$2, this.getInterruptedCause()));
				else return exitFailCause$1(cause$2);
			default: absurd(cont);
		}
		else {
			yieldedOpChannel.currentOp = exitFailCause$1(cause$2);
			return YieldedOp;
		}
	}
	[OP_WITH_RUNTIME](op) {
		return internalCall(() => op.effect_instruction_i0(this, running(this.currentRuntimeFlags)));
	}
	["Blocked"](op) {
		const refs = this.getFiberRefs();
		const flags = this.currentRuntimeFlags;
		if (this._steps.length > 0) {
			const frames = [];
			const snap = this._steps[this._steps.length - 1];
			let frame = this.popStack();
			while (frame && frame._op !== "OnStep") {
				frames.push(frame);
				frame = this.popStack();
			}
			this.setFiberRefs(snap.refs);
			this.currentRuntimeFlags = snap.flags;
			const patchRefs = diff$1(snap.refs, refs);
			const patchFlags = diff$3(snap.flags, flags);
			return exitSucceed$1(blocked$1(op.effect_instruction_i0, withFiberRuntime$1((newFiber) => {
				while (frames.length > 0) newFiber.pushStack(frames.pop());
				newFiber.setFiberRefs(patch$1(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
				newFiber.currentRuntimeFlags = patch$4(patchFlags)(newFiber.currentRuntimeFlags);
				return op.effect_instruction_i1;
			})));
		}
		return uninterruptibleMask$2((restore) => flatMap$6(forkDaemon$1(runRequestBlock$1(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
	}
	["RunBlocked"](op) {
		return runBlockedRequests(op.effect_instruction_i0);
	}
	[OP_UPDATE_RUNTIME_FLAGS](op) {
		const updateFlags = op.effect_instruction_i0;
		const oldRuntimeFlags = this.currentRuntimeFlags;
		const newRuntimeFlags = patch$4(oldRuntimeFlags, updateFlags);
		if (interruptible$3(newRuntimeFlags) && this.isInterrupted()) return exitFailCause$1(this.getInterruptedCause());
		else {
			this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
			if (op.effect_instruction_i1) {
				const revertFlags = diff$3(newRuntimeFlags, oldRuntimeFlags);
				this.pushStack(new RevertFlags(revertFlags, op));
				return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
			} else return exitVoid$1;
		}
	}
	[OP_ON_SUCCESS](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	["OnStep"](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ON_FAILURE](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ON_SUCCESS_AND_FAILURE](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ASYNC](op) {
		this._asyncBlockingOn = op.effect_instruction_i1;
		this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
		yieldedOpChannel.currentOp = op;
		return YieldedOp;
	}
	[OP_YIELD](op) {
		this._isYielding = false;
		yieldedOpChannel.currentOp = op;
		return YieldedOp;
	}
	[OP_WHILE](op) {
		const check$1 = op.effect_instruction_i0;
		const body = op.effect_instruction_i1;
		if (check$1()) {
			this.pushStack(op);
			return body();
		} else return exitVoid$1;
	}
	[OP_ITERATOR](op) {
		return contOpSuccess[OP_ITERATOR](this, op, void 0);
	}
	[OP_COMMIT](op) {
		return internalCall(() => op.commit());
	}
	runLoop(effect0) {
		let cur = effect0;
		this.currentOpCount = 0;
		while (true) {
			if ((this.currentRuntimeFlags & 2) !== 0) this.currentSupervisor.onEffect(this, cur);
			if (this._queue.length > 0) cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
			if (!this._isYielding) {
				this.currentOpCount += 1;
				const shouldYield = this.currentScheduler.shouldYield(this);
				if (shouldYield !== false) {
					this._isYielding = true;
					this.currentOpCount = 0;
					const oldCur = cur;
					cur = flatMap$6(yieldNow$3({ priority: shouldYield }), () => oldCur);
				}
			}
			try {
				cur = this.currentTracer.context(() => {
					if (_version !== cur[EffectTypeId$2]._V) {
						const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
						if (level._tag === "Some") {
							const effectVersion = cur[EffectTypeId$2]._V;
							this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty$16, level);
						}
					}
					return this[cur._op](cur);
				}, this);
				if (cur === YieldedOp) {
					const op = yieldedOpChannel.currentOp;
					if (op._op === "Yield" || op._op === "Async") return YieldedOp;
					yieldedOpChannel.currentOp = null;
					return op._op === "Success" || op._op === "Failure" ? op : exitFailCause$1(die$6(op));
				}
			} catch (e) {
				if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) cur = dieMessage$1(`Not a valid effect: ${toStringUnknown(cur)}`);
				else if (isInterruptedException$1(e)) cur = exitFailCause$1(sequential$3(die$6(e), interrupt$6(none$6)));
				else cur = die$5(e);
			}
		}
	}
	run = () => {
		this.drainQueueOnCurrentThread();
	};
};
const currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
const loggerWithConsoleLog = (self) => makeLogger((opts) => {
	get$9(getOrDefault(opts.context, currentServices), consoleTag).unsafe.log(self.log(opts));
});
const defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
const tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({ annotations: annotations$1, cause: cause$2, context: context$3, fiberId: fiberId$2, logLevel: logLevel$2, message }) => {
	const span$1 = getOption(getOrDefault$1(context$3, currentContext), spanTag);
	if (span$1._tag === "None" || span$1.value._tag === "ExternalSpan") return;
	const clockService = unsafeGet$3(getOrDefault$1(context$3, currentServices), clockTag);
	const attributes = {};
	for (const [key, value$2] of annotations$1) attributes[key] = value$2;
	attributes["effect.fiberId"] = threadName(fiberId$2);
	attributes["effect.logLevel"] = logLevel$2.label;
	if (cause$2 !== null && cause$2._tag !== "Empty") attributes["effect.cause"] = pretty$3(cause$2, { renderErrorCause: true });
	span$1.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
const currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make$37(defaultLogger, tracerLogger)));
const acquireRelease$1 = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[0]), (acquire, release) => uninterruptible$1(tap$2(acquire, (a) => addFinalizer$2((exit$3) => release(a, exit$3)))));
const addFinalizer$2 = (finalizer) => withFiberRuntime$1((runtime$4) => {
	const acquireRefs = runtime$4.getFiberRefs();
	const acquireFlags = disable$1(runtime$4.currentRuntimeFlags, 1);
	return flatMap$6(scope$2, (scope$3) => scopeAddFinalizerExit(scope$3, (exit$3) => withFiberRuntime$1((runtimeFinalizer) => {
		const preRefs = runtimeFinalizer.getFiberRefs();
		const preFlags = runtimeFinalizer.currentRuntimeFlags;
		const patchRefs = diff$1(preRefs, acquireRefs);
		const patchFlags = diff$3(preFlags, acquireFlags);
		const inverseRefs = diff$1(acquireRefs, preRefs);
		runtimeFinalizer.setFiberRefs(patch$1(patchRefs, runtimeFinalizer.id(), acquireRefs));
		return ensuring$1(withRuntimeFlags(finalizer(exit$3), patchFlags), sync$6(() => {
			runtimeFinalizer.setFiberRefs(patch$1(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
		}));
	})));
});
var existsLoop = (iterator, index, f) => {
	const next = iterator.next();
	if (next.done) return succeed$12(false);
	return flatMap$6(f(next.value, index), (b) => b ? succeed$12(b) : existsLoop(iterator, index + 1, f));
};
var allResolveInput = (input) => {
	if (Array.isArray(input) || isIterable(input)) return [input, none$7()];
	const keys$5 = Object.keys(input);
	const size$11 = keys$5.length;
	return [keys$5.map((k) => input[k]), some$4((values$6) => {
		const res = {};
		for (let i = 0; i < size$11; i++) res[keys$5[i]] = values$6[i];
		return res;
	})];
};
var allValidate = (effects, reconcile, options) => {
	const eitherEffects = [];
	for (const effect of effects) eitherEffects.push(either$1(effect));
	return flatMap$6(forEach$1(eitherEffects, identity, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		concurrentFinalizers: options?.concurrentFinalizers
	}), (eithers) => {
		const none$9 = none$7();
		const size$11 = eithers.length;
		const errors = new Array(size$11);
		const successes = new Array(size$11);
		let errored = false;
		for (let i = 0; i < size$11; i++) {
			const either$4 = eithers[i];
			if (either$4._tag === "Left") {
				errors[i] = some$4(either$4.left);
				errored = true;
			} else {
				successes[i] = either$4.right;
				errors[i] = none$9;
			}
		}
		if (errored) return reconcile._tag === "Some" ? fail$12(reconcile.value(errors)) : fail$12(errors);
		else if (options?.discard) return void_$4;
		return reconcile._tag === "Some" ? succeed$12(reconcile.value(successes)) : succeed$12(successes);
	});
};
var allEither = (effects, reconcile, options) => {
	const eitherEffects = [];
	for (const effect of effects) eitherEffects.push(either$1(effect));
	if (options?.discard) return forEach$1(eitherEffects, identity, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		discard: true,
		concurrentFinalizers: options?.concurrentFinalizers
	});
	return map$12(forEach$1(eitherEffects, identity, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		concurrentFinalizers: options?.concurrentFinalizers
	}), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
const all$4 = (arg, options) => {
	const [effects, reconcile] = allResolveInput(arg);
	if (options?.mode === "validate") return allValidate(effects, reconcile, options);
	else if (options?.mode === "either") return allEither(effects, reconcile, options);
	return options?.discard !== true && reconcile._tag === "Some" ? map$12(forEach$1(effects, identity, options), reconcile.value) : forEach$1(effects, identity, options);
};
const forEach$1 = /* @__PURE__ */ dual((args$1) => isIterable(args$1[0]), (self, f, options) => withFiberRuntime$1((r) => {
	const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
	if (options?.discard) return match$5(options.concurrency, () => finalizersMaskInternal(sequential$1, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel$1, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
	return match$5(options?.concurrency, () => finalizersMaskInternal(sequential$1, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel$1, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
const forEachParUnbounded = (self, f, batching) => suspend$5(() => {
	const as$6 = fromIterable$10(self);
	const array$5 = new Array(as$6.length);
	const fn = (a, i) => flatMap$6(f(a, i), (b) => sync$6(() => array$5[i] = b));
	return zipRight$3(forEachConcurrentDiscard(as$6, fn, batching, false), succeed$12(array$5));
});
const forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask$2((restore) => transplant$1((graft) => withFiberRuntime$1((parent) => {
	let todos = Array.from(self).reverse();
	let target = todos.length;
	if (target === 0) return void_$4;
	let counter$5 = 0;
	let interrupted$2 = false;
	const fibersCount = n ? Math.min(todos.length, n) : todos.length;
	const fibers = /* @__PURE__ */ new Set();
	const results = new Array();
	const interruptAll$2 = () => fibers.forEach((fiber) => {
		fiber.currentScheduler.scheduleTask(() => {
			fiber.unsafeInterruptAsFork(parent.id());
		}, 0);
	});
	const startOrder = new Array();
	const joinOrder = new Array();
	const residual = new Array();
	const collectExits = () => {
		const exits = results.filter(({ exit: exit$3 }) => exit$3._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({ exit: exit$3 }) => exit$3);
		if (exits.length === 0) exits.push(exitVoid$1);
		return exits;
	};
	const runFiber = (eff, interruptImmediately = false) => {
		const runnable = uninterruptible$1(graft(eff));
		const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
		parent.currentScheduler.scheduleTask(() => {
			if (interruptImmediately) fiber.unsafeInterruptAsFork(parent.id());
			fiber.resume(runnable);
		}, 0);
		return fiber;
	};
	const onInterruptSignal = () => {
		if (!processAll) {
			target -= todos.length;
			todos = [];
		}
		interrupted$2 = true;
		interruptAll$2();
	};
	const stepOrExit = batching ? step$1 : exit$2;
	const processingFiber = runFiber(async_((resume$1) => {
		const pushResult = (res, index) => {
			if (res._op === "Blocked") residual.push(res);
			else {
				results.push({
					index,
					exit: res
				});
				if (res._op === "Failure" && !interrupted$2) onInterruptSignal();
			}
		};
		const next = () => {
			if (todos.length > 0) {
				const a = todos.pop();
				let index = counter$5++;
				const returnNextElement = () => {
					const a$1 = todos.pop();
					index = counter$5++;
					return flatMap$6(yieldNow$3(), () => flatMap$6(stepOrExit(restore(f(a$1, index))), onRes));
				};
				const onRes = (res) => {
					if (todos.length > 0) {
						pushResult(res, index);
						if (todos.length > 0) return returnNextElement();
					}
					return succeed$12(res);
				};
				const fiber = runFiber(flatMap$6(stepOrExit(restore(f(a, index))), onRes));
				startOrder.push(fiber);
				fibers.add(fiber);
				if (interrupted$2) fiber.currentScheduler.scheduleTask(() => {
					fiber.unsafeInterruptAsFork(parent.id());
				}, 0);
				fiber.addObserver((wrapped) => {
					let exit$3;
					if (wrapped._op === "Failure") exit$3 = wrapped;
					else exit$3 = wrapped.effect_instruction_i0;
					joinOrder.push(fiber);
					fibers.delete(fiber);
					pushResult(exit$3, index);
					if (results.length === target) resume$1(succeed$12(getOrElse$5(exitCollectAll(collectExits(), { parallel: true }), () => exitVoid$1)));
					else if (residual.length + results.length === target) {
						const exits = collectExits();
						resume$1(succeed$12(blocked$1(residual.map((blocked$2) => blocked$2.effect_instruction_i0).reduce(par), forEachConcurrentDiscard([getOrElse$5(exitCollectAll(exits, { parallel: true }), () => exitVoid$1), ...residual.map((blocked$2) => blocked$2.effect_instruction_i1)], (i) => i, batching, true, n))));
					} else next();
				});
			}
		};
		for (let i = 0; i < fibersCount; i++) next();
	}));
	return asVoid$3(onExit$2(flatten$4(restore(join$1(processingFiber))), exitMatch({
		onFailure: (cause$2) => {
			onInterruptSignal();
			const target$1 = residual.length + 1;
			const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
			const toPop = Array.from(residual);
			return async_((cb) => {
				const exits = [];
				let count = 0;
				let index = 0;
				const check$1 = (index$1, hitNext) => (exit$3) => {
					exits[index$1] = exit$3;
					count++;
					if (count === target$1) cb(exitSucceed$1(exitFailCause$1(cause$2)));
					if (toPop.length > 0 && hitNext) next();
				};
				const next = () => {
					runFiber(toPop.pop(), true).addObserver(check$1(index, true));
					index++;
				};
				processingFiber.addObserver(check$1(index, false));
				index++;
				for (let i = 0; i < concurrency; i++) next();
			});
		},
		onSuccess: () => forEachSequential(joinOrder, (f$1) => f$1.inheritAll)
	})));
})));
const forEachParN = (self, n, f, batching) => suspend$5(() => {
	const as$6 = fromIterable$10(self);
	const array$5 = new Array(as$6.length);
	const fn = (a, i) => map$12(f(a, i), (b) => array$5[i] = b);
	return zipRight$3(forEachConcurrentDiscard(as$6, fn, batching, false, n), succeed$12(array$5));
});
const forkDaemon$1 = (self) => forkWithScopeOverride(self, globalScope);
const unsafeFork$1 = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
	childFiber.resume(effect);
	return childFiber;
};
const unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	return unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
};
const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	const childId = unsafeMake$7();
	const childFiberRefs = forkAs$1(parentFiber.getFiberRefs(), childId);
	const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
	const childContext = getOrDefault$1(childFiberRefs, currentContext);
	const supervisor = childFiber.currentSupervisor;
	supervisor.onStart(childContext, effect, some$4(parentFiber), childFiber);
	childFiber.addObserver((exit$3) => supervisor.onEnd(exit$3, childFiber));
	(overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse$5(() => parentFiber.scope()))).add(parentRuntimeFlags, childFiber);
	return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime$1((parentFiber, parentStatus) => succeed$12(unsafeFork$1(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
const parallelFinalizers$1 = (self) => contextWithEffect$1((context$3) => match$13(getOption(context$3, scopeTag), {
	onNone: () => self,
	onSome: (scope$3) => {
		switch (scope$3.strategy._tag) {
			case "Parallel": return self;
			case "Sequential":
			case "ParallelN": return flatMap$6(scopeFork(scope$3, parallel$1), (inner) => scopeExtend(self, inner));
		}
	}
}));
const parallelNFinalizers = (parallelism) => (self) => contextWithEffect$1((context$3) => match$13(getOption(context$3, scopeTag), {
	onNone: () => self,
	onSome: (scope$3) => {
		if (scope$3.strategy._tag === "ParallelN" && scope$3.strategy.parallelism === parallelism) return self;
		return flatMap$6(scopeFork(scope$3, parallelN(parallelism)), (inner) => scopeExtend(self, inner));
	}
}));
const finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect$1((context$3) => match$13(getOption(context$3, scopeTag), {
	onNone: () => self(identity),
	onSome: (scope$3) => {
		if (concurrentFinalizers === true) {
			const patch$11 = strategy._tag === "Parallel" ? parallelFinalizers$1 : strategy._tag === "Sequential" ? sequentialFinalizers$1 : parallelNFinalizers(strategy.parallelism);
			switch (scope$3.strategy._tag) {
				case "Parallel": return patch$11(self(parallelFinalizers$1));
				case "Sequential": return patch$11(self(sequentialFinalizers$1));
				case "ParallelN": return patch$11(self(parallelNFinalizers(scope$3.strategy.parallelism)));
			}
		} else return self(identity);
	}
}));
const scopeWith$1 = (f) => flatMap$6(scopeTag, f);
const scopedWith$1 = (f) => flatMap$6(scopeMake(), (scope$3) => onExit$2(f(scope$3), (exit$3) => scope$3.close(exit$3)));
const scopedEffect = (effect) => flatMap$6(scopeMake(), (scope$3) => scopeUse(effect, scope$3));
const sequentialFinalizers$1 = (self) => contextWithEffect$1((context$3) => match$13(getOption(context$3, scopeTag), {
	onNone: () => self,
	onSome: (scope$3) => {
		switch (scope$3.strategy._tag) {
			case "Sequential": return self;
			case "Parallel":
			case "ParallelN": return flatMap$6(scopeFork(scope$3, sequential$1), (inner) => scopeExtend(self, inner));
		}
	}
}));
const withConfigProviderScoped$1 = (provider) => fiberRefLocallyScopedWith$1(currentServices, add$3(configProviderTag, provider));
const zipWithOptions = /* @__PURE__ */ dual((args$1) => isEffect$1(args$1[1]), (self, that, f, options) => map$12(all$4([self, that], {
	concurrency: options?.concurrent ? 2 : 1,
	batching: options?.batching,
	concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
const withRuntimeFlagsScoped = (update$5) => {
	if (update$5 === empty$18) return void_$4;
	return pipe(runtimeFlags, flatMap$6((runtimeFlags$1) => {
		const revertRuntimeFlags = diff$3(patch$4(runtimeFlags$1, update$5), runtimeFlags$1);
		return pipe(updateRuntimeFlags(update$5), zipRight$3(addFinalizer$2(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid$3);
	}), uninterruptible$1);
};
const scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
const scope$2 = scopeTag;
var scopeUnsafeAddFinalizer = (scope$3, fin) => {
	if (scope$3.state._tag === "Open") scope$3.state.finalizers.set({}, fin);
};
var ScopeImplProto = {
	[ScopeTypeId$1]: ScopeTypeId$1,
	[CloseableScopeTypeId$1]: CloseableScopeTypeId$1,
	pipe() {
		return pipeArguments(this, arguments);
	},
	fork(strategy) {
		return sync$6(() => {
			const newScope = scopeUnsafeMake(strategy);
			if (this.state._tag === "Closed") {
				newScope.state = this.state;
				return newScope;
			}
			const key = {};
			const fin = (exit$3) => newScope.close(exit$3);
			this.state.finalizers.set(key, fin);
			scopeUnsafeAddFinalizer(newScope, (_) => sync$6(() => {
				if (this.state._tag === "Open") this.state.finalizers.delete(key);
			}));
			return newScope;
		});
	},
	close(exit$3) {
		return suspend$5(() => {
			if (this.state._tag === "Closed") return void_$4;
			const finalizers = Array.from(this.state.finalizers.values()).reverse();
			this.state = {
				_tag: "Closed",
				exit: exit$3
			};
			if (finalizers.length === 0) return void_$4;
			return isSequential$1(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit$2(fin(exit$3))), flatMap$6((results) => pipe(exitCollectAll(results), map$19(exitAsVoid), getOrElse$5(() => exitVoid$1)))) : isParallel$1(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit$2(fin(exit$3)), false), flatMap$6((results) => pipe(exitCollectAll(results, { parallel: true }), map$19(exitAsVoid), getOrElse$5(() => exitVoid$1)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit$2(fin(exit$3)), false), flatMap$6((results) => pipe(exitCollectAll(results, { parallel: true }), map$19(exitAsVoid), getOrElse$5(() => exitVoid$1))));
		});
	},
	addFinalizer(fin) {
		return suspend$5(() => {
			if (this.state._tag === "Closed") return fin(this.state.exit);
			this.state.finalizers.set({}, fin);
			return void_$4;
		});
	}
};
var scopeUnsafeMake = (strategy = sequential$2) => {
	const scope$3 = Object.create(ScopeImplProto);
	scope$3.strategy = strategy;
	scope$3.state = {
		_tag: "Open",
		finalizers: /* @__PURE__ */ new Map()
	};
	return scope$3;
};
const scopeMake = (strategy = sequential$2) => sync$6(() => scopeUnsafeMake(strategy));
const scopeExtend = /* @__PURE__ */ dual(2, (effect, scope$3) => mapInputContext$1(effect, merge$4(make$43(scopeTag, scope$3))));
const scopeUse = /* @__PURE__ */ dual(2, (effect, scope$3) => pipe(effect, scopeExtend(scope$3), onExit$2((exit$3) => scope$3.close(exit$3))));
const fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
	differ,
	fork: empty$6
});
const fiberRefLocallyScoped$1 = /* @__PURE__ */ dual(2, (self, value$2) => asVoid$3(acquireRelease$1(flatMap$6(fiberRefGet(self), (oldValue) => as$4(fiberRefSet(self, value$2), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
const fiberRefLocallyScopedWith$1 = /* @__PURE__ */ dual(2, (self, f) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped$1(self, f(a))));
const currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none$5);
const currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none$2);
const ensuring$1 = /* @__PURE__ */ dual(2, (self, finalizer) => uninterruptibleMask$2((restore) => matchCauseEffect$2(restore(self), {
	onFailure: (cause1) => matchCauseEffect$2(finalizer, {
		onFailure: (cause2) => failCause$9(sequential$3(cause1, cause2)),
		onSuccess: () => failCause$9(cause1)
	}),
	onSuccess: (a) => as$4(finalizer, a)
})));
const invokeWithInterrupt = (self, entries$2, onInterrupt$2) => fiberIdWith$1((id$2) => flatMap$6(flatMap$6(forkDaemon$1(interruptible$2(self)), (processing) => async_((cb) => {
	const counts = entries$2.map((_) => _.listeners.count);
	const checkDone = () => {
		if (counts.every((count) => count === 0)) {
			if (entries$2.every((_) => {
				if (_.result.state.current._tag === "Pending") return true;
				else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted$2(_.result.state.current.effect.cause)) return true;
				else return false;
			})) {
				cleanup.forEach((f) => f());
				onInterrupt$2?.();
				cb(interruptFiber(processing));
			}
		}
	};
	processing.addObserver((exit$3) => {
		cleanup.forEach((f) => f());
		cb(exit$3);
	});
	const cleanup = entries$2.map((r, i) => {
		const observer = (count) => {
			counts[i] = count;
			checkDone();
		};
		r.listeners.addObserver(observer);
		return () => r.listeners.removeObserver(observer);
	});
	checkDone();
	return sync$6(() => {
		cleanup.forEach((f) => f());
	});
})), () => suspend$5(() => {
	return forEachSequentialDiscard(entries$2.flatMap((entry) => {
		if (!entry.state.completed) return [entry];
		return [];
	}), (entry) => complete$2(entry.request, exitInterrupt$1(id$2)));
})));
const makeSpanScoped$1 = (name, options) => {
	options = addSpanStackTrace(options);
	return uninterruptible$1(withFiberRuntime$1((fiber) => {
		const scope$3 = unsafeGet$3(fiber.getFiberRef(currentContext), scopeTag);
		const span$1 = unsafeMakeSpan(fiber, name, options);
		const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
		const clock_ = get$9(fiber.getFiberRef(currentServices), clockTag);
		return as$4(scopeAddFinalizerExit(scope$3, (exit$3) => endSpan(span$1, exit$3, clock_, timingEnabled)), span$1);
	}));
};
const withTracerScoped$1 = (value$2) => fiberRefLocallyScopedWith$1(currentServices, add$3(tracerTag, value$2));
const fail$7 = fail$13;
const die$2 = die$6;
const isFailType = isFailType$1;
const failureOrCause = failureOrCause$1;
const pretty$1 = pretty$3;
const IntervalTypeId$1 = /* @__PURE__ */ Symbol.for("effect/ScheduleInterval");
const empty$3 = {
	[IntervalTypeId$1]: IntervalTypeId$1,
	startMillis: 0,
	endMillis: 0
};
const start$1 = (self) => {
	return pipe(self.intervals, head$2, getOrElse$5(() => empty$3)).startMillis;
};
const end$1 = (self) => {
	return pipe(self.intervals, head$2, getOrElse$5(() => empty$3)).endMillis;
};
const lessThan$1 = /* @__PURE__ */ dual(2, (self, that) => start$1(self) < start$1(that));
const isNonEmpty$1 = (self) => {
	return isNonEmpty$4(self.intervals);
};
const start = start$1;
const end = end$1;
const lessThan = lessThan$1;
const isNonEmpty = isNonEmpty$1;
const OP_CONTINUE = "Continue";
const OP_DONE = "Done";
const _continue$1 = (intervals) => {
	return {
		_tag: OP_CONTINUE,
		intervals
	};
};
const done$2 = { _tag: OP_DONE };
const isDone$1 = (self) => {
	return self._tag === OP_DONE;
};
var _continue = _continue$1;
const done$1 = done$2;
const isDone = isDone$1;
const Scope = scopeTag;
const close = scopeClose;
const fork$1 = scopeFork;
var Semaphore = class {
	permits;
	waiters = /* @__PURE__ */ new Set();
	taken = 0;
	constructor(permits) {
		this.permits = permits;
	}
	get free() {
		return this.permits - this.taken;
	}
	take = (n) => asyncInterrupt((resume$1) => {
		if (this.free < n) {
			const observer = () => {
				if (this.free < n) return;
				this.waiters.delete(observer);
				this.taken += n;
				resume$1(succeed$12(n));
			};
			this.waiters.add(observer);
			return sync$6(() => {
				this.waiters.delete(observer);
			});
		}
		this.taken += n;
		return resume$1(succeed$12(n));
	});
	updateTakenUnsafe(fiber, f) {
		this.taken = f(this.taken);
		if (this.waiters.size > 0) fiber.getFiberRef(currentScheduler).scheduleTask(() => {
			const iter = this.waiters.values();
			let item = iter.next();
			while (item.done === false && this.free > 0) {
				item.value();
				item = iter.next();
			}
		}, fiber.getFiberRef(currentSchedulingPriority));
		return succeed$12(this.free);
	}
	updateTaken(f) {
		return withFiberRuntime$1((fiber) => this.updateTakenUnsafe(fiber, f));
	}
	resize = (permits) => asVoid$3(withFiberRuntime$1((fiber) => {
		this.permits = permits;
		if (this.free < 0) return void_$4;
		return this.updateTakenUnsafe(fiber, (taken) => taken);
	}));
	release = (n) => this.updateTaken((taken) => taken - n);
	releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
	withPermits = (n) => (self) => uninterruptibleMask$2((restore) => flatMap$6(restore(this.take(n)), (permits) => ensuring$1(restore(self), this.release(permits))));
	withPermitsIfAvailable = (n) => (self) => uninterruptibleMask$2((restore) => suspend$5(() => {
		if (this.free < n) return succeedNone$1;
		this.taken += n;
		return ensuring$1(restore(asSome$1(self)), this.release(n));
	}));
};
const unsafeMakeSemaphore$1 = (permits) => new Semaphore(permits);
const SynchronizedTypeId = /* @__PURE__ */ Symbol.for("effect/Ref/SynchronizedRef");
const synchronizedVariance = { _A: (_) => _ };
var SynchronizedImpl = class extends Class$3 {
	ref;
	withLock;
	[SynchronizedTypeId] = synchronizedVariance;
	[RefTypeId$1] = refVariance;
	[TypeId$5] = TypeId$5;
	constructor(ref, withLock) {
		super();
		this.ref = ref;
		this.withLock = withLock;
		this.get = get$1(this.ref);
	}
	get;
	commit() {
		return this.get;
	}
	modify(f) {
		return this.modifyEffect((a) => succeed$12(f(a)));
	}
	modifyEffect(f) {
		return this.withLock(pipe(flatMap$6(get$1(this.ref), f), flatMap$6(([b, a]) => as$4(set$1(this.ref, a), b))));
	}
};
const makeSynchronized = (value$2) => sync$6(() => unsafeMakeSynchronized(value$2));
const unsafeMakeSynchronized = (value$2) => {
	return new SynchronizedImpl(unsafeMake$3(value$2), unsafeMakeSemaphore$1(1).withPermits(1));
};
const TypeId$1 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");
const OP_EXTEND_SCOPE = "ExtendScope";
const OP_FOLD = "Fold";
const OP_FRESH = "Fresh";
const OP_FROM_EFFECT = "FromEffect";
const OP_SCOPED = "Scoped";
const OP_SUSPEND = "Suspend";
const OP_PROVIDE = "Provide";
const OP_PROVIDE_MERGE = "ProvideMerge";
const OP_MERGE_ALL = "MergeAll";
const OP_ZIP_WITH = "ZipWith";
const interruptAs = interruptAsFiber;
var makeDual = (f) => function() {
	if (arguments.length === 1) {
		const runtime$4 = arguments[0];
		return (effect, ...args$1) => f(runtime$4, effect, ...args$1);
	}
	return f.apply(this, arguments);
};
const unsafeFork = /* @__PURE__ */ makeDual((runtime$4, self, options) => {
	const fiberId$2 = unsafeMake$7();
	const fiberRefUpdates = [[currentContext, [[fiberId$2, runtime$4.context]]]];
	if (options?.scheduler) fiberRefUpdates.push([currentScheduler, [[fiberId$2, options.scheduler]]]);
	let fiberRefs$3 = updateManyAs(runtime$4.fiberRefs, {
		entries: fiberRefUpdates,
		forkAs: fiberId$2
	});
	if (options?.updateRefs) fiberRefs$3 = options.updateRefs(fiberRefs$3, fiberId$2);
	const fiberRuntime = new FiberRuntime(fiberId$2, fiberRefs$3, runtime$4.runtimeFlags);
	let effect = self;
	if (options?.scope) effect = flatMap$6(fork$1(options.scope, sequential$2), (closeableScope) => zipRight$3(scopeAddFinalizer(closeableScope, fiberIdWith$1((id$2) => equals(id$2, fiberRuntime.id()) ? void_$4 : interruptAsFiber(fiberRuntime, id$2))), onExit$2(self, (exit$3) => close(closeableScope, exit$3))));
	const supervisor = fiberRuntime.currentSupervisor;
	if (supervisor !== none$2) {
		supervisor.onStart(runtime$4.context, effect, none$7(), fiberRuntime);
		fiberRuntime.addObserver((exit$3) => supervisor.onEnd(exit$3, fiberRuntime));
	}
	globalScope.add(runtime$4.runtimeFlags, fiberRuntime);
	if (options?.immediate === false) fiberRuntime.resume(effect);
	else fiberRuntime.start(effect);
	return fiberRuntime;
});
const unsafeRunCallback = /* @__PURE__ */ makeDual((runtime$4, effect, options = {}) => {
	const fiberRuntime = unsafeFork(runtime$4, effect, options);
	if (options.onExit) fiberRuntime.addObserver((exit$3) => {
		options.onExit(exit$3);
	});
	return (id$2, cancelOptions) => unsafeRunCallback(runtime$4)(pipe(fiberRuntime, interruptAs(id$2 ?? none$6)), {
		...cancelOptions,
		onExit: cancelOptions?.onExit ? (exit$3) => cancelOptions.onExit(flatten$3(exit$3)) : void 0
	});
});
const unsafeRunSync = /* @__PURE__ */ makeDual((runtime$4, effect) => {
	const result = unsafeRunSyncExit(runtime$4)(effect);
	if (result._tag === "Failure") throw fiberFailure(result.effect_instruction_i0);
	return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
	fiber;
	_tag = "AsyncFiberException";
	constructor(fiber) {
		super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
		this.fiber = fiber;
		this.name = this._tag;
		this.stack = this.message;
	}
};
var asyncFiberException = (fiber) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 0;
	const error = new AsyncFiberExceptionImpl(fiber);
	Error.stackTraceLimit = limit;
	return error;
};
const FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
const FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
	[FiberFailureId];
	[FiberFailureCauseId];
	constructor(cause$2) {
		const head$4 = prettyErrors$1(cause$2)[0];
		super(head$4?.message || "An error has occurred");
		this[FiberFailureId] = FiberFailureId;
		this[FiberFailureCauseId] = cause$2;
		this.name = head$4 ? `(FiberFailure) ${head$4.name}` : "FiberFailure";
		if (head$4?.stack) this.stack = head$4.stack;
	}
	toJSON() {
		return {
			_id: "FiberFailure",
			cause: this[FiberFailureCauseId].toJSON()
		};
	}
	toString() {
		return "(FiberFailure) " + pretty$3(this[FiberFailureCauseId], { renderErrorCause: true });
	}
	[NodeInspectSymbol]() {
		return this.toString();
	}
};
const fiberFailure = (cause$2) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 0;
	const error = new FiberFailureImpl(cause$2);
	Error.stackTraceLimit = limit;
	return error;
};
var fastPath = (effect) => {
	const op = effect;
	switch (op._op) {
		case "Failure":
		case "Success": return op;
		case "Left": return exitFail(op.left);
		case "Right": return exitSucceed$1(op.right);
		case "Some": return exitSucceed$1(op.value);
		case "None": return exitFail(new NoSuchElementException$1());
	}
};
const unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime$4, effect) => {
	const op = fastPath(effect);
	if (op) return op;
	const scheduler = new SyncScheduler();
	const fiberRuntime = unsafeFork(runtime$4)(effect, { scheduler });
	scheduler.flush();
	const result = fiberRuntime.unsafePoll();
	if (result) return result;
	return exitDie$1(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
const unsafeRunPromise = /* @__PURE__ */ makeDual((runtime$4, effect, options) => unsafeRunPromiseExit(runtime$4, effect, options).then((result) => {
	switch (result._tag) {
		case OP_SUCCESS: return result.effect_instruction_i0;
		case OP_FAILURE: throw fiberFailure(result.effect_instruction_i0);
	}
}));
const unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime$4, effect, options) => new Promise((resolve) => {
	const op = fastPath(effect);
	if (op) resolve(op);
	const fiber = unsafeFork(runtime$4)(effect);
	fiber.addObserver((exit$3) => {
		resolve(exit$3);
	});
	if (options?.signal !== void 0) if (options.signal.aborted) fiber.unsafeInterruptAsFork(fiber.id());
	else options.signal.addEventListener("abort", () => {
		fiber.unsafeInterruptAsFork(fiber.id());
	}, { once: true });
}));
var RuntimeImpl = class {
	context;
	runtimeFlags;
	fiberRefs;
	constructor(context$3, runtimeFlags$1, fiberRefs$3) {
		this.context = context$3;
		this.runtimeFlags = runtimeFlags$1;
		this.fiberRefs = fiberRefs$3;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const make$4 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
const runtime$1 = () => withFiberRuntime$1((state, status$2) => succeed$12(new RuntimeImpl(state.getFiberRef(currentContext), status$2.runtimeFlags, state.getFiberRefs())));
const defaultRuntime = /* @__PURE__ */ make$4({
	context: /* @__PURE__ */ empty$32(),
	runtimeFlags: /* @__PURE__ */ make$30(1, 32, 4),
	fiberRefs: /* @__PURE__ */ empty$11()
});
const unsafeForkEffect = /* @__PURE__ */ unsafeFork(defaultRuntime);
const unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
const unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
const modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));
const LayerTypeId = /* @__PURE__ */ Symbol.for("effect/Layer");
var layerVariance = {
	_RIn: (_) => _,
	_E: (_) => _,
	_ROut: (_) => _
};
const proto$2 = {
	[LayerTypeId]: layerVariance,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const MemoMapTypeId = /* @__PURE__ */ Symbol.for("effect/Layer/MemoMap");
const CurrentMemoMap = /* @__PURE__ */ Reference()("effect/Layer/CurrentMemoMap", { defaultValue: () => unsafeMakeMemoMap() });
const isLayer = (u) => hasProperty(u, LayerTypeId);
const isFresh = (self) => {
	return self._op_layer === OP_FRESH;
};
var MemoMapImpl = class {
	ref;
	[MemoMapTypeId];
	constructor(ref) {
		this.ref = ref;
		this[MemoMapTypeId] = MemoMapTypeId;
	}
	getOrElseMemoize(layer, scope$3) {
		return pipe(modifyEffect(this.ref, (map$21) => {
			const inMap = map$21.get(layer);
			if (inMap !== void 0) {
				const [acquire, release] = inMap;
				return succeed$12([pipe(acquire, flatMap$6(([patch$11, b]) => pipe(patchFiberRefs$1(patch$11), as$4(b))), onExit$2(exitMatch({
					onFailure: () => void_$4,
					onSuccess: () => scopeAddFinalizerExit(scope$3, release)
				}))), map$21]);
			}
			return pipe(make$19(0), flatMap$6((observers) => pipe(deferredMake(), flatMap$6((deferred) => pipe(make$19(() => void_$4), map$12((finalizerRef) => {
				const resource = uninterruptibleMask$2((restore) => pipe(scopeMake(), flatMap$6((innerScope) => pipe(restore(flatMap$6(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs$1(f(this)))), exit$2, flatMap$6((exit$3) => {
					switch (exit$3._tag) {
						case OP_FAILURE: return pipe(deferredFailCause(deferred, exit$3.effect_instruction_i0), zipRight$3(scopeClose(innerScope, exit$3)), zipRight$3(failCause$9(exit$3.effect_instruction_i0)));
						case OP_SUCCESS: return pipe(set$1(finalizerRef, (exit$4) => pipe(scopeClose(innerScope, exit$4), whenEffect$1(modify$1(observers, (n) => [n === 1, n - 1])), asVoid$3)), zipRight$3(update$3(observers, (n) => n + 1)), zipRight$3(scopeAddFinalizerExit(scope$3, (exit$4) => pipe(sync$6(() => map$21.delete(layer)), zipRight$3(get$1(finalizerRef)), flatMap$6((finalizer) => finalizer(exit$4))))), zipRight$3(deferredSucceed(deferred, exit$3.effect_instruction_i0)), as$4(exit$3.effect_instruction_i0[1]));
					}
				})))));
				const memoized = [pipe(deferredAwait(deferred), onExit$2(exitMatchEffect({
					onFailure: () => void_$4,
					onSuccess: () => update$3(observers, (n) => n + 1)
				}))), (exit$3) => pipe(get$1(finalizerRef), flatMap$6((finalizer) => finalizer(exit$3)))];
				return [resource, isFresh(layer) ? map$21 : map$21.set(layer, memoized)];
			}))))));
		}), flatten$4);
	}
};
const makeMemoMap = /* @__PURE__ */ suspend$5(() => map$12(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
const unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
const build = (self) => scopeWith$1((scope$3) => buildWithScope(self, scope$3));
const buildWithScope = /* @__PURE__ */ dual(2, (self, scope$3) => flatMap$6(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope$3)));
const buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope$3) => flatMap$6(makeBuilder(self, scope$3), (run) => provideService$1(run(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self, scope$3, inMemoMap = false) => {
	const op = self;
	switch (op._op_layer) {
		case "Locally": return sync$6(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope$3)));
		case "ExtendScope": return sync$6(() => (memoMap) => scopeWith$1((scope$4) => memoMap.getOrElseMemoize(op.layer, scope$4)));
		case "Fold": return sync$6(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope$3), matchCauseEffect$2({
			onFailure: (cause$2) => memoMap.getOrElseMemoize(op.failureK(cause$2), scope$3),
			onSuccess: (value$2) => memoMap.getOrElseMemoize(op.successK(value$2), scope$3)
		})));
		case "Fresh": return sync$6(() => (_) => pipe(op.layer, buildWithScope(scope$3)));
		case "FromEffect": return inMemoMap ? sync$6(() => (_) => op.effect) : sync$6(() => (memoMap) => memoMap.getOrElseMemoize(self, scope$3));
		case "Provide": return sync$6(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope$3), flatMap$6((env) => pipe(memoMap.getOrElseMemoize(op.second, scope$3), provideContext$1(env)))));
		case "Scoped": return inMemoMap ? sync$6(() => (_) => scopeExtend(op.effect, scope$3)) : sync$6(() => (memoMap) => memoMap.getOrElseMemoize(self, scope$3));
		case "Suspend": return sync$6(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope$3));
		case "ProvideMerge": return sync$6(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope$3), zipWith$6(memoMap.getOrElseMemoize(op.second, scope$3), op.zipK)));
		case "ZipWith": return gen$1(function* () {
			const parallelScope = yield* scopeFork(scope$3, parallel$2);
			const firstScope = yield* scopeFork(parallelScope, sequential$2);
			const secondScope = yield* scopeFork(parallelScope, sequential$2);
			return (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, { concurrent: true }));
		});
		case "MergeAll": {
			const layers = op.layers;
			return map$12(scopeFork(scope$3, parallel$2), (parallelScope) => (memoMap) => {
				const contexts = new Array(layers.length);
				return map$12(forEachConcurrentDiscard(layers, fnUntraced$1(function* (layer, i) {
					const scope$4 = yield* scopeFork(parallelScope, sequential$2);
					contexts[i] = yield* memoMap.getOrElseMemoize(layer, scope$4);
				}), false, false), () => mergeAll$3(...contexts));
			});
		}
	}
};
const catchAll$1 = /* @__PURE__ */ dual(2, (self, onFailure) => match$1(self, {
	onFailure,
	onSuccess: succeedContext
}));
const catchAllCause$1 = /* @__PURE__ */ dual(2, (self, onFailure) => matchCause$1(self, {
	onFailure,
	onSuccess: succeedContext
}));
const die$1 = (defect) => failCause$2(die$2(defect));
const dieSync$1 = (evaluate$1) => failCauseSync$1(() => die$2(evaluate$1()));
const discard = (self) => map$5(self, () => empty$32());
const context$1 = () => fromEffectContext(context$2());
const extendScope = (self) => {
	const extendScope$1 = Object.create(proto$2);
	extendScope$1._op_layer = OP_EXTEND_SCOPE;
	extendScope$1.layer = self;
	return extendScope$1;
};
const fail$5 = (error) => failCause$2(fail$7(error));
const failSync$1 = (evaluate$1) => failCauseSync$1(() => fail$7(evaluate$1()));
const failCause$2 = (cause$2) => fromEffectContext(failCause$9(cause$2));
const failCauseSync$1 = (evaluate$1) => fromEffectContext(failCauseSync$3(evaluate$1));
const flatMap$2 = /* @__PURE__ */ dual(2, (self, f) => match$1(self, {
	onFailure: fail$5,
	onSuccess: f
}));
const flatten$1 = /* @__PURE__ */ dual(2, (self, tag) => flatMap$2(self, get$9(tag)));
const fresh = (self) => {
	const fresh$1 = Object.create(proto$2);
	fresh$1._op_layer = OP_FRESH;
	fresh$1.layer = self;
	return fresh$1;
};
const fromEffect = /* @__PURE__ */ dual(2, (a, b) => {
	const tagFirst = isTag(a);
	const tag = tagFirst ? a : b;
	return fromEffectContext(map$12(tagFirst ? b : a, (service$1) => make$43(tag, service$1)));
});
const fromEffectDiscard = (effect) => fromEffectContext(map$12(effect, () => empty$32()));
function fromEffectContext(effect) {
	const fromEffect$4 = Object.create(proto$2);
	fromEffect$4._op_layer = OP_FROM_EFFECT;
	fromEffect$4.effect = effect;
	return fromEffect$4;
}
const fiberRefLocally = /* @__PURE__ */ dual(3, (self, ref, value$2) => locallyEffect(self, fiberRefLocally$1(ref, value$2)));
const locallyEffect = /* @__PURE__ */ dual(2, (self, f) => {
	const locally$1 = Object.create(proto$2);
	locally$1._op_layer = "Locally";
	locally$1.self = self;
	locally$1.f = f;
	return locally$1;
});
const fiberRefLocallyWith = /* @__PURE__ */ dual(3, (self, ref, value$2) => locallyEffect(self, fiberRefLocallyWith$1(ref, value$2)));
const fiberRefLocallyScoped = (self, value$2) => scopedDiscard(fiberRefLocallyScoped$1(self, value$2));
const fiberRefLocallyScopedWith = (self, value$2) => scopedDiscard(fiberRefLocallyScopedWith$1(self, value$2));
const fromFunction = (tagA, tagB, f) => fromEffectContext(map$12(tagA, (a) => make$43(tagB, f(a))));
const launch = (self) => scopedEffect(zipRight$3(scopeWith$1((scope$3) => pipe(self, buildWithScope(scope$3))), never$3));
const mock = function() {
	if (arguments.length === 1) return (service$1) => mockImpl(arguments[0], service$1);
	return mockImpl(arguments[0], arguments[1]);
};
var mockImpl = (tag, service$1) => succeed$5(tag, new Proxy({ ...service$1 }, {
	get(target, prop, _receiver) {
		if (prop in target) return target[prop];
		const prevLimit = Error.stackTraceLimit;
		Error.stackTraceLimit = 2;
		const error = /* @__PURE__ */ new Error(`${tag.key}: Unimplemented method "${prop.toString()}"`);
		Error.stackTraceLimit = prevLimit;
		error.name = "UnimplementedError";
		return makeUnimplemented(error);
	},
	has: constTrue
}));
var makeUnimplemented = (error) => {
	const dead = die$5(error);
	function unimplemented() {
		return dead;
	}
	Object.assign(unimplemented, dead);
	Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
	return unimplemented;
};
const map$5 = /* @__PURE__ */ dual(2, (self, f) => flatMap$2(self, (context$3) => succeedContext(f(context$3))));
const mapError$2 = /* @__PURE__ */ dual(2, (self, f) => catchAll$1(self, (error) => failSync$1(() => f(error))));
const matchCause$1 = /* @__PURE__ */ dual(2, (self, { onFailure, onSuccess }) => {
	const fold = Object.create(proto$2);
	fold._op_layer = OP_FOLD;
	fold.layer = self;
	fold.failureK = onFailure;
	fold.successK = onSuccess;
	return fold;
});
const match$1 = /* @__PURE__ */ dual(2, (self, { onFailure, onSuccess }) => matchCause$1(self, {
	onFailure: (cause$2) => {
		const failureOrCause$2 = failureOrCause(cause$2);
		switch (failureOrCause$2._tag) {
			case "Left": return onFailure(failureOrCause$2.left);
			case "Right": return failCause$2(failureOrCause$2.right);
		}
	},
	onSuccess
}));
const memoize = (self) => scopeWith$1((scope$3) => map$12(memoize$1(buildWithScope(self, scope$3)), fromEffectContext));
const merge$1 = /* @__PURE__ */ dual(2, (self, that) => zipWith$3(self, that, (a, b) => merge$4(a, b)));
const mergeAll$1 = (...layers) => {
	const mergeAll$5 = Object.create(proto$2);
	mergeAll$5._op_layer = OP_MERGE_ALL;
	mergeAll$5.layers = layers;
	return mergeAll$5;
};
const orDie$1 = (self) => catchAll$1(self, (defect) => die$1(defect));
const orElse$4 = /* @__PURE__ */ dual(2, (self, that) => catchAll$1(self, that));
const passthrough$1 = (self) => merge$1(context$1(), self);
const project = /* @__PURE__ */ dual(4, (self, tagA, tagB, f) => map$5(self, (context$3) => make$43(tagB, f(unsafeGet$3(context$3, tagA)))));
const retry$1 = /* @__PURE__ */ dual(2, (self, schedule$1) => suspend$3(() => {
	const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
	return pipe(succeed$5(stateTag, { state: schedule$1.initial }), flatMap$2((env) => retryLoop(self, schedule$1, stateTag, pipe(env, get$9(stateTag)).state)));
}));
var retryLoop = (self, schedule$1, stateTag, state) => {
	return pipe(self, catchAll$1((error) => pipe(retryUpdate(schedule$1, stateTag, error, state), flatMap$2((env) => fresh(retryLoop(self, schedule$1, stateTag, pipe(env, get$9(stateTag)).state))))));
};
var retryUpdate = (schedule$1, stateTag, error, state) => {
	return fromEffect(stateTag, pipe(currentTimeMillis, flatMap$6((now) => pipe(schedule$1.step(now, error, state), flatMap$6(([state$1, _, decision]) => isDone(decision) ? fail$12(error) : pipe(sleep$2(millis(start(decision.intervals) - now)), as$4({ state: state$1 })))))));
};
const scoped$1 = /* @__PURE__ */ dual(2, (a, b) => {
	const tagFirst = isTag(a);
	const tag = tagFirst ? a : b;
	return scopedContext(map$12(tagFirst ? b : a, (service$1) => make$43(tag, service$1)));
});
const scopedDiscard = (effect) => scopedContext(pipe(effect, as$4(empty$32())));
const scopedContext = (effect) => {
	const scoped$3 = Object.create(proto$2);
	scoped$3._op_layer = OP_SCOPED;
	scoped$3.effect = effect;
	return scoped$3;
};
const scope$1 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map$12(/* @__PURE__ */ acquireRelease$1(/* @__PURE__ */ scopeMake(), (scope$3, exit$3) => scope$3.close(exit$3)), (scope$3) => make$43(Scope, scope$3)));
const service = (tag) => fromEffect(tag, tag);
const succeed$5 = /* @__PURE__ */ dual(2, (a, b) => {
	const tagFirst = isTag(a);
	return fromEffectContext(succeed$12(make$43(tagFirst ? a : b, tagFirst ? b : a)));
});
const succeedContext = (context$3) => {
	return fromEffectContext(succeed$12(context$3));
};
const empty = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty$32());
const suspend$3 = (evaluate$1) => {
	const suspend$6 = Object.create(proto$2);
	suspend$6._op_layer = OP_SUSPEND;
	suspend$6.evaluate = evaluate$1;
	return suspend$6;
};
const sync$3 = /* @__PURE__ */ dual(2, (a, b) => {
	const tagFirst = isTag(a);
	const tag = tagFirst ? a : b;
	const evaluate$1 = tagFirst ? b : a;
	return fromEffectContext(sync$6(() => make$43(tag, evaluate$1())));
});
const syncContext = (evaluate$1) => {
	return fromEffectContext(sync$6(evaluate$1));
};
const tap$1 = /* @__PURE__ */ dual(2, (self, f) => flatMap$2(self, (context$3) => fromEffectContext(as$4(f(context$3), context$3))));
const tapError$1 = /* @__PURE__ */ dual(2, (self, f) => catchAll$1(self, (e) => fromEffectContext(flatMap$6(f(e), () => fail$12(e)))));
const tapErrorCause$1 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause$1(self, (cause$2) => fromEffectContext(flatMap$6(f(cause$2), () => failCause$9(cause$2)))));
const toRuntime = (self) => pipe(scopeWith$1((scope$3) => buildWithScope(self, scope$3)), flatMap$6((context$3) => pipe(runtime$1(), provideContext$1(context$3))));
const toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self, memoMap) => flatMap$6(scopeWith$1((scope$3) => buildWithMemoMap(self, memoMap, scope$3)), (context$3) => pipe(runtime$1(), provideContext$1(context$3))));
const provide$1 = /* @__PURE__ */ dual(2, (self, that) => suspend$3(() => {
	const provideTo = Object.create(proto$2);
	provideTo._op_layer = OP_PROVIDE;
	provideTo.first = Object.create(proto$2, {
		_op_layer: {
			value: OP_PROVIDE_MERGE,
			enumerable: true
		},
		first: {
			value: context$1(),
			enumerable: true
		},
		second: { value: Array.isArray(that) ? mergeAll$1(...that) : that },
		zipK: { value: (a, b) => pipe(a, merge$4(b)) }
	});
	provideTo.second = self;
	return provideTo;
}));
const provideMerge = /* @__PURE__ */ dual(2, (that, self) => {
	const zipWith$8 = Object.create(proto$2);
	zipWith$8._op_layer = OP_PROVIDE_MERGE;
	zipWith$8.first = self;
	zipWith$8.second = provide$1(that, self);
	zipWith$8.zipK = (a, b) => {
		return pipe(a, merge$4(b));
	};
	return zipWith$8;
});
const zipWith$3 = /* @__PURE__ */ dual(3, (self, that, f) => suspend$3(() => {
	const zipWith$8 = Object.create(proto$2);
	zipWith$8._op_layer = OP_ZIP_WITH;
	zipWith$8.first = self;
	zipWith$8.second = that;
	zipWith$8.zipK = f;
	return zipWith$8;
}));
const unwrapEffect = (self) => {
	const tag = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
	return flatMap$2(fromEffect(tag, self), (context$3) => get$9(context$3, tag));
};
const unwrapScoped = (self) => {
	const tag = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
	return flatMap$2(scoped$1(tag, self), (context$3) => get$9(context$3, tag));
};
const annotateLogs$1 = /* @__PURE__ */ dual((args$1) => isLayer(args$1[0]), function() {
	const args$1 = arguments;
	return fiberRefLocallyWith(args$1[0], currentLogAnnotations, typeof args$1[1] === "string" ? set$3(args$1[1], args$1[2]) : (annotations$1) => Object.entries(args$1[1]).reduce((acc, [key, value$2]) => set$3(acc, key, value$2), annotations$1));
});
const annotateSpans$1 = /* @__PURE__ */ dual((args$1) => isLayer(args$1[0]), function() {
	const args$1 = arguments;
	return fiberRefLocallyWith(args$1[0], currentTracerSpanAnnotations, typeof args$1[1] === "string" ? set$3(args$1[1], args$1[2]) : (annotations$1) => Object.entries(args$1[1]).reduce((acc, [key, value$2]) => set$3(acc, key, value$2), annotations$1));
});
const withSpan$1 = function() {
	const dataFirst = typeof arguments[0] !== "string";
	const name = dataFirst ? arguments[1] : arguments[0];
	const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
	if (dataFirst) {
		const self = arguments[0];
		return unwrapScoped(map$12(options?.onEnd ? tap$2(makeSpanScoped$1(name, options), (span$1) => addFinalizer$2((exit$3) => options.onEnd(span$1, exit$3))) : makeSpanScoped$1(name, options), (span$1) => withParentSpan$1(self, span$1)));
	}
	return (self) => unwrapScoped(map$12(options?.onEnd ? tap$2(makeSpanScoped$1(name, options), (span$1) => addFinalizer$2((exit$3) => options.onEnd(span$1, exit$3))) : makeSpanScoped$1(name, options), (span$1) => withParentSpan$1(self, span$1)));
};
const withParentSpan$1 = /* @__PURE__ */ dual(2, (self, span$1) => provide$1(self, succeedContext(make$43(spanTag, span$1))));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer) => scopedWith$1((scope$3) => flatMap$6(buildWithScope(layer, scope$3), (context$3) => provideSomeContext(self, context$3))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
	const patchRefs = diff$1(defaultRuntime.fiberRefs, rt.fiberRefs);
	const patchFlags = diff$3(defaultRuntime.runtimeFlags, rt.runtimeFlags);
	return uninterruptibleMask$2((restore) => withFiberRuntime$1((fiber) => {
		const oldContext = fiber.getFiberRef(currentContext);
		const oldRefs = fiber.getFiberRefs();
		const newRefs = patch$1(fiber.id(), oldRefs)(patchRefs);
		const oldFlags = fiber.currentRuntimeFlags;
		const newFlags = patch$4(patchFlags)(oldFlags);
		const rollbackRefs = diff$1(newRefs, oldRefs);
		const rollbackFlags = diff$3(newFlags, oldFlags);
		fiber.setFiberRefs(newRefs);
		fiber.currentRuntimeFlags = newFlags;
		return ensuring$1(provideSomeContext(restore(self), merge$4(oldContext, rt.context)), withFiberRuntime$1((fiber$1) => {
			fiber$1.setFiberRefs(patch$1(fiber$1.id(), fiber$1.getFiberRefs())(rollbackRefs));
			fiber$1.currentRuntimeFlags = patch$4(rollbackFlags)(fiber$1.currentRuntimeFlags);
			return void_$4;
		}));
	}));
});
const effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
	if (Array.isArray(source)) return provideSomeLayer(self, mergeAll$1(...source));
	else if (isLayer(source)) return provideSomeLayer(self, source);
	else if (isContext(source)) return provideSomeContext(self, source);
	else if (TypeId$1 in source) return flatMap$6(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
	else return provideSomeRuntime(self, source);
});
const Error$1 = /* @__PURE__ */ function() {
	const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
	return { BaseEffectError: class extends YieldableError$1 {
		constructor(args$1) {
			super(args$1?.message, args$1?.cause ? { cause: args$1.cause } : void 0);
			if (args$1) {
				Object.assign(this, args$1);
				Object.defineProperty(this, plainArgsSymbol, {
					value: args$1,
					enumerable: false
				});
			}
		}
		toJSON() {
			return {
				...this[plainArgsSymbol],
				...this
			};
		}
	} }.BaseEffectError;
}();
const TaggedError$1 = (tag) => {
	const O = { BaseEffectError: class extends Error$1 {
		_tag = tag;
	} };
	O.BaseEffectError.prototype.name = tag;
	return O.BaseEffectError;
};
var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
	const combined = f(lInterval, rInterval);
	if (isNonEmpty(combined)) return succeed$12([
		[lState, rState],
		[out, out2],
		_continue(combined)
	]);
	if (pipe(lInterval, lessThan(rInterval))) return flatMap$6(self.step(end(lInterval), input, lState), ([lState$1, out$1, decision]) => {
		if (isDone(decision)) return succeed$12([
			[lState$1, rState],
			[out$1, out2],
			done$1
		]);
		return intersectWithLoop(self, that, input, lState$1, out$1, decision.intervals, rState, out2, rInterval, f);
	});
	return flatMap$6(that.step(end(rInterval), input, rState), ([rState$1, out2$1, decision]) => {
		if (isDone(decision)) return succeed$12([
			[lState, rState$1],
			[out, out2$1],
			done$1
		]);
		return intersectWithLoop(self, that, input, lState, out, lInterval, rState$1, out2$1, decision.intervals, f);
	});
};
var repeatOrElseEffectLoop = (self, driver$1, orElse$10, value$2) => matchEffect$2(driver$1.next(value$2), {
	onFailure: () => orDie$2(driver$1.last),
	onSuccess: (b) => matchEffect$2(self, {
		onFailure: (error) => orElse$10(error, some$4(b)),
		onSuccess: (value$3) => repeatOrElseEffectLoop(self, driver$1, orElse$10, value$3)
	})
});
var retryOrElse_EffectLoop = (self, driver$1, orElse$10) => {
	return catchAll$2(self, (e) => matchEffect$2(driver$1.next(e), {
		onFailure: () => pipe(driver$1.last, orDie$2, flatMap$6((out) => orElse$10(e, out))),
		onSuccess: () => retryOrElse_EffectLoop(self, driver$1, orElse$10)
	}));
};
var scheduleFrom_EffectLoop = (self, initial, driver$1) => matchEffect$2(driver$1.next(initial), {
	onFailure: () => orDie$2(driver$1.last),
	onSuccess: () => flatMap$6(self, (a) => scheduleFrom_EffectLoop(self, a, driver$1))
});
const isEffect = isEffect$1;
const all$2 = all$4;
const forEach = forEach$1;
const fail$3 = fail$12;
const gen = gen$1;
const succeed$3 = succeed$12;
const suspend$2 = suspend$5;
const sync$2 = sync$6;
var _void = void_$4;
const catchAll = catchAll$2;
const catchIf = catchIf$1;
const catchTags = catchTags$1;
const ignore = ignore$1;
var try_ = try_$1;
const tryPromise = tryPromise$1;
const as = as$4;
const map$3 = map$12;
const mapError$1 = mapError$4;
const acquireRelease = acquireRelease$1;
const scoped = scopedEffect;
const provide = effect_provide;
const either = either$1;
const flatMap$1 = flatMap$6;
const tapError = tapError$2;
const logInfo = logInfo$1;
const logWarning = logWarning$1;
const logError = logError$1;
const orElseSucceed = orElseSucceed$1;
const runFork = unsafeForkEffect;
const runPromise = unsafeRunPromiseEffect;
const runSync = unsafeRunSyncEffect;
var makeTagProxy = (TagClass) => {
	const cache = /* @__PURE__ */ new Map();
	return new Proxy(TagClass, { get(target, prop, receiver) {
		if (prop in target) return Reflect.get(target, prop, receiver);
		if (cache.has(prop)) return cache.get(prop);
		const fn = (...args$1) => andThen$3(target, (s) => {
			if (typeof s[prop] === "function") {
				cache.set(prop, (...args$2) => andThen$3(target, (s$1) => s$1[prop](...args$2)));
				return s[prop](...args$1);
			}
			cache.set(prop, andThen$3(target, (s$1) => s$1[prop]));
			return s[prop];
		});
		const cn = andThen$3(target, (s) => s[prop]);
		Object.assign(fn, cn);
		const apply = fn.apply;
		const bind$3 = fn.bind;
		const call = fn.call;
		const proto$5 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
		proto$5.apply = apply;
		proto$5.bind = bind$3;
		proto$5.call = call;
		Object.setPrototypeOf(fn, proto$5);
		cache.set(prop, fn);
		return fn;
	} });
};
const Service = function() {
	return function() {
		const [id$2, maker] = arguments;
		const proxy = "accessors" in maker ? maker["accessors"] : false;
		const limit = Error.stackTraceLimit;
		Error.stackTraceLimit = 2;
		const creationError = /* @__PURE__ */ new Error();
		Error.stackTraceLimit = limit;
		let patchState = "unchecked";
		const TagClass = function(service$1) {
			if (patchState === "unchecked") {
				const proto$5 = Object.getPrototypeOf(service$1);
				if (proto$5 === Object.prototype || proto$5 === null) patchState = "plain";
				else {
					const selfProto = Object.getPrototypeOf(this);
					Object.setPrototypeOf(selfProto, proto$5);
					patchState = "patched";
				}
			}
			if (patchState === "plain") Object.assign(this, service$1);
			else if (patchState === "patched") {
				Object.setPrototypeOf(service$1, Object.getPrototypeOf(this));
				return service$1;
			}
		};
		TagClass.prototype._tag = id$2;
		Object.defineProperty(TagClass, "make", { get() {
			return (service$1) => new this(service$1);
		} });
		Object.defineProperty(TagClass, "use", { get() {
			return (body) => andThen$3(this, body);
		} });
		TagClass.key = id$2;
		Object.assign(TagClass, TagProto);
		Object.defineProperty(TagClass, "stack", { get() {
			return creationError.stack;
		} });
		const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
		const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
		let layerCache;
		let isFunction$2 = false;
		if ("effect" in maker) {
			isFunction$2 = typeof maker.effect === "function";
			Object.defineProperty(TagClass, layerName, { get() {
				if (isFunction$2) return function() {
					return fromEffect(TagClass, map$3(maker.effect.apply(null, arguments), (_) => new this(_)));
				}.bind(this);
				return layerCache ??= fromEffect(TagClass, map$3(maker.effect, (_) => new this(_)));
			} });
		} else if ("scoped" in maker) {
			isFunction$2 = typeof maker.scoped === "function";
			Object.defineProperty(TagClass, layerName, { get() {
				if (isFunction$2) return function() {
					return scoped$1(TagClass, map$3(maker.scoped.apply(null, arguments), (_) => new this(_)));
				}.bind(this);
				return layerCache ??= scoped$1(TagClass, map$3(maker.scoped, (_) => new this(_)));
			} });
		} else if ("sync" in maker) Object.defineProperty(TagClass, layerName, { get() {
			return layerCache ??= sync$3(TagClass, () => new this(maker.sync()));
		} });
		else Object.defineProperty(TagClass, layerName, { get() {
			return layerCache ??= succeed$5(TagClass, new this(maker.succeed));
		} });
		if (hasDeps) {
			let layerWithDepsCache;
			Object.defineProperty(TagClass, "Default", { get() {
				if (isFunction$2) return function() {
					return provide$1(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
				};
				return layerWithDepsCache ??= provide$1(this.DefaultWithoutDependencies, maker.dependencies);
			} });
		}
		return proxy === true ? makeTagProxy(TagClass) : TagClass;
	};
};
const InvalidData = InvalidData$1;
const isConfigError = isConfigError$1;
const isMissingDataOnly = isMissingDataOnly$1;
var RedactedSymbolKey = "effect/Redacted";
const redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
const RedactedTypeId$1 = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
const proto$1 = {
	[RedactedTypeId$1]: { _A: (_) => _ },
	pipe() {
		return pipeArguments(this, arguments);
	},
	toString() {
		return "<redacted>";
	},
	toJSON() {
		return "<redacted>";
	},
	[NodeInspectSymbol]() {
		return "<redacted>";
	},
	[symbol$1]() {
		return pipe(hash(RedactedSymbolKey), combine$11(hash(redactedRegistry.get(this))), cached$2(this));
	},
	[symbol](that) {
		return isRedacted$1(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
	}
};
const isRedacted$1 = (u) => hasProperty(u, RedactedTypeId$1);
const make$3 = (value$2) => {
	const redacted$2 = Object.create(proto$1);
	redactedRegistry.set(redacted$2, value$2);
	return redacted$2;
};
const value$1 = (self) => {
	if (redactedRegistry.has(self)) return redactedRegistry.get(self);
	else throw new Error("Unable to get redacted value");
};
({ ...proto$1 });
const ConfigTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Config");
var configVariance = { _A: (_) => _ };
var proto = {
	...CommitPrototype$1,
	[ConfigTypeId$1]: configVariance,
	commit() {
		return config(this);
	}
};
const boolean$1 = (name) => {
	const config$1 = primitive$1("a boolean property", (text) => {
		switch (text) {
			case "true":
			case "yes":
			case "on":
			case "1": return right(true);
			case "false":
			case "no":
			case "off":
			case "0": return right(false);
			default: return left(InvalidData$1([], `Expected a boolean value but received ${formatUnknown(text)}`));
		}
	});
	return name === void 0 ? config$1 : nested$1(config$1, name);
};
const map$2 = /* @__PURE__ */ dual(2, (self, f) => mapOrFail$1(self, (a) => right(f(a))));
const mapOrFail$1 = /* @__PURE__ */ dual(2, (self, f) => {
	const mapOrFail$2 = Object.create(proto);
	mapOrFail$2._tag = OP_MAP_OR_FAIL;
	mapOrFail$2.original = self;
	mapOrFail$2.mapOrFail = f;
	return mapOrFail$2;
});
const nested$1 = /* @__PURE__ */ dual(2, (self, name) => {
	const nested$4 = Object.create(proto);
	nested$4._tag = OP_NESTED;
	nested$4.name = name;
	nested$4.config = self;
	return nested$4;
});
const orElseIf$1 = /* @__PURE__ */ dual(2, (self, options) => {
	const fallback = Object.create(proto);
	fallback._tag = OP_FALLBACK;
	fallback.first = self;
	fallback.second = suspend$1(options.orElse);
	fallback.condition = options.if;
	return fallback;
});
const option$1 = (self) => {
	return pipe(self, map$2(some$4), orElseIf$1({
		orElse: () => succeed$2(none$7()),
		if: isMissingDataOnly
	}));
};
const primitive$1 = (description, parse) => {
	const primitive$2 = Object.create(proto);
	primitive$2._tag = OP_PRIMITIVE;
	primitive$2.description = description;
	primitive$2.parse = parse;
	return primitive$2;
};
const redacted$1 = (nameOrConfig) => {
	return map$2(isConfig$1(nameOrConfig) ? nameOrConfig : string$1(nameOrConfig), make$3);
};
const string$1 = (name) => {
	const config$1 = primitive$1("a text property", right);
	return name === void 0 ? config$1 : nested$1(config$1, name);
};
var struct = (r) => {
	const entries$2 = Object.entries(r);
	let result = pipe(entries$2[0][1], map$2((value$2) => ({ [entries$2[0][0]]: value$2 })));
	if (entries$2.length === 1) return result;
	const rest = entries$2.slice(1);
	for (const [key, config$1] of rest) result = pipe(result, zipWith$1(config$1, (record$1, value$2) => ({
		...record$1,
		[key]: value$2
	})));
	return result;
};
const succeed$2 = (value$2) => {
	const constant$1 = Object.create(proto);
	constant$1._tag = OP_CONSTANT;
	constant$1.value = value$2;
	constant$1.parse = () => right(value$2);
	return constant$1;
};
const suspend$1 = (config$1) => {
	const lazy = Object.create(proto);
	lazy._tag = OP_LAZY;
	lazy.config = config$1;
	return lazy;
};
const isConfig$1 = (u) => hasProperty(u, ConfigTypeId$1);
const unwrap$1 = (wrapped) => {
	if (isConfig$1(wrapped)) return wrapped;
	return struct(Object.fromEntries(Object.entries(wrapped).map(([k, a]) => [k, unwrap$1(a)])));
};
const zipWith$1 = /* @__PURE__ */ dual(3, (self, that, f) => {
	const zipWith$8 = Object.create(proto);
	zipWith$8._tag = OP_ZIP_WITH$1;
	zipWith$8.left = self;
	zipWith$8.right = that;
	zipWith$8.zip = f;
	return zipWith$8;
});
const boolean = boolean$1;
const mapOrFail = mapOrFail$1;
const option = option$1;
const redacted = redacted$1;
const string = string$1;
var Pointer = class {
	path;
	actual;
	issue;
	_tag = "Pointer";
	constructor(path$5, actual, issue) {
		this.path = path$5;
		this.actual = actual;
		this.issue = issue;
	}
};
var Unexpected = class {
	actual;
	message;
	_tag = "Unexpected";
	constructor(actual, message) {
		this.actual = actual;
		this.message = message;
	}
};
var Missing = class {
	ast;
	message;
	_tag = "Missing";
	actual = void 0;
	constructor(ast, message) {
		this.ast = ast;
		this.message = message;
	}
};
var Composite = class {
	ast;
	actual;
	issues;
	output;
	_tag = "Composite";
	constructor(ast, actual, issues, output) {
		this.ast = ast;
		this.actual = actual;
		this.issues = issues;
		this.output = output;
	}
};
var Refinement = class {
	ast;
	actual;
	kind;
	issue;
	_tag = "Refinement";
	constructor(ast, actual, kind, issue) {
		this.ast = ast;
		this.actual = actual;
		this.kind = kind;
		this.issue = issue;
	}
};
var Transformation = class {
	ast;
	actual;
	kind;
	issue;
	_tag = "Transformation";
	constructor(ast, actual, kind, issue) {
		this.ast = ast;
		this.actual = actual;
		this.kind = kind;
		this.issue = issue;
	}
};
var Type = class {
	ast;
	actual;
	message;
	_tag = "Type";
	constructor(ast, actual, message) {
		this.ast = ast;
		this.actual = actual;
		this.message = message;
	}
};
var Forbidden = class {
	ast;
	actual;
	message;
	_tag = "Forbidden";
	constructor(ast, actual, message) {
		this.ast = ast;
		this.actual = actual;
		this.message = message;
	}
};
const ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
var ParseError = class extends TaggedError$1("ParseError") {
	[ParseErrorTypeId] = ParseErrorTypeId;
	get message() {
		return this.toString();
	}
	toString() {
		return TreeFormatter.formatIssueSync(this.issue);
	}
	toJSON() {
		return {
			_id: "ParseError",
			message: this.toString()
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
const parseError = (issue) => new ParseError({ issue });
const succeed = right;
const fail = left;
var isEither = isEither$1;
const flatMap = /* @__PURE__ */ dual(2, (self, f) => {
	return isEither(self) ? match$14(self, {
		onLeft: left,
		onRight: f
	}) : flatMap$1(self, f);
});
const map = /* @__PURE__ */ dual(2, (self, f) => {
	return isEither(self) ? map$20(self, f) : map$3(self, f);
});
const mapError = /* @__PURE__ */ dual(2, (self, f) => {
	return isEither(self) ? mapLeft(self, f) : mapError$1(self, f);
});
const orElse = /* @__PURE__ */ dual(2, (self, f) => {
	return isEither(self) ? match$14(self, {
		onLeft: f,
		onRight: right
	}) : catchAll(self, f);
});
const mergeInternalOptions = (options, overrideOptions) => {
	if (overrideOptions === void 0 || isNumber(overrideOptions)) return options;
	if (options === void 0) return overrideOptions;
	return {
		...options,
		...overrideOptions
	};
};
var getEither = (ast, isDecoding, options) => {
	const parser = goMemo(ast, isDecoding);
	return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
	const parser = getEither(ast, isDecoding, options);
	return (input, overrideOptions) => getOrThrowWith$1(parser(input, overrideOptions), parseError);
};
var getEffect = (ast, isDecoding, options) => {
	const parser = goMemo(ast, isDecoding);
	return (input, overrideOptions) => parser(input, {
		...mergeInternalOptions(options, overrideOptions),
		isEffectAllowed: true
	});
};
const decodeUnknownEither = (schema, options) => getEither(schema.ast, true, options);
const decodeUnknown$1 = (schema, options) => getEffect(schema.ast, true, options);
const encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
const validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
const is = (schema, options) => {
	const parser = goMemo(typeAST(schema.ast), true);
	return (u, overrideOptions) => isRight(parser(u, {
		exact: true,
		...mergeInternalOptions(options, overrideOptions)
	}));
};
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = (ast, isDecoding) => {
	const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
	const memo = memoMap.get(ast);
	if (memo) return memo;
	const raw = go(ast, isDecoding);
	const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
	const parserWithOptions = isSome(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
	const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
	const parser = isDecoding && isSome(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
	memoMap.set(ast, parser);
	return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
	switch (ast._tag) {
		case "Refinement": if (isDecoding) {
			const from = goMemo(ast.from, true);
			return (i, options) => {
				options = options ?? defaultParseOption;
				const allErrors = options?.errors === "all";
				return handleForbidden(flatMap(orElse(from(i, options), (ef) => {
					const issue = new Refinement(ast, i, "From", ef);
					if (allErrors && hasStableFilter(ast) && isComposite(ef)) return match$13(ast.filter(i, options, ast), {
						onNone: () => left(issue),
						onSome: (ep) => left(new Composite(ast, i, [issue, new Refinement(ast, i, "Predicate", ep)]))
					});
					return left(issue);
				}), (a) => match$13(ast.filter(a, options, ast), {
					onNone: () => right(a),
					onSome: (ep) => left(new Refinement(ast, i, "Predicate", ep))
				})), ast, i, options);
			};
		} else {
			const from = goMemo(typeAST(ast), true);
			const to = goMemo(dropRightRefinement(ast.from), false);
			return (i, options) => handleForbidden(flatMap(from(i, options), (a) => to(a, options)), ast, i, options);
		}
		case "Transformation": {
			const transform$3 = getFinalTransformation(ast.transformation, isDecoding);
			const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
			const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
			return (i, options) => handleForbidden(flatMap(mapError(from(i, options), (e) => new Transformation(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap(mapError(transform$3(a, options ?? defaultParseOption, ast, i), (e) => new Transformation(ast, i, "Transformation", e)), (i2) => mapError(to(i2, options), (e) => new Transformation(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
		}
		case "Declaration": {
			const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
			return (i, options) => handleForbidden(parse(i, options ?? defaultParseOption, ast), ast, i, options);
		}
		case "Literal": return fromRefinement(ast, (u) => u === ast.literal);
		case "UniqueSymbol": return fromRefinement(ast, (u) => u === ast.symbol);
		case "UndefinedKeyword": return fromRefinement(ast, isUndefined);
		case "NeverKeyword": return fromRefinement(ast, isNever);
		case "UnknownKeyword":
		case "AnyKeyword":
		case "VoidKeyword": return right;
		case "StringKeyword": return fromRefinement(ast, isString);
		case "NumberKeyword": return fromRefinement(ast, isNumber);
		case "BooleanKeyword": return fromRefinement(ast, isBoolean$1);
		case "BigIntKeyword": return fromRefinement(ast, isBigInt);
		case "SymbolKeyword": return fromRefinement(ast, isSymbol);
		case "ObjectKeyword": return fromRefinement(ast, isObject);
		case "Enums": return fromRefinement(ast, (u) => ast.enums.some(([_, value$2]) => value$2 === u));
		case "TemplateLiteral": {
			const regex = getTemplateLiteralRegExp(ast);
			return fromRefinement(ast, (u) => isString(u) && regex.test(u));
		}
		case "TupleType": {
			const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
			const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
			let requiredTypes = ast.elements.filter((e) => !e.isOptional);
			if (ast.rest.length > 0) requiredTypes = requiredTypes.concat(ast.rest.slice(1));
			const requiredLen = requiredTypes.length;
			const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
			const concurrency = getConcurrency(ast);
			const batching = getBatching(ast);
			return (input, options) => {
				if (!isArray(input)) return left(new Type(ast, input));
				const allErrors = options?.errors === "all";
				const es = [];
				let stepKey = 0;
				const output = [];
				const len = input.length;
				for (let i$1 = len; i$1 <= requiredLen - 1; i$1++) {
					const e = new Pointer(i$1, input, new Missing(requiredTypes[i$1 - len]));
					if (allErrors) {
						es.push([stepKey++, e]);
						continue;
					} else return left(new Composite(ast, input, e, output));
				}
				if (ast.rest.length === 0) for (let i$1 = ast.elements.length; i$1 <= len - 1; i$1++) {
					const e = new Pointer(i$1, input, new Unexpected(input[i$1], `is unexpected, expected: ${expectedIndexes}`));
					if (allErrors) {
						es.push([stepKey++, e]);
						continue;
					} else return left(new Composite(ast, input, e, output));
				}
				let i = 0;
				let queue = void 0;
				for (; i < elements.length; i++) if (len < i + 1) {
					if (ast.elements[i].isOptional) continue;
				} else {
					const parser = elements[i];
					const te = parser(input[i], options);
					if (isEither(te)) {
						if (isLeft(te)) {
							const e = new Pointer(i, input, te.left);
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, sortByIndex(output)));
						}
						output.push([stepKey++, te.right]);
					} else {
						const nk = stepKey++;
						const index = i;
						if (!queue) queue = [];
						queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t) => {
							if (isLeft(t)) {
								const e = new Pointer(index, input, t.left);
								if (allErrors) {
									es$1.push([nk, e]);
									return _void;
								} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
							}
							output$1.push([nk, t.right]);
							return _void;
						}));
					}
				}
				if (isNonEmptyReadonlyArray(rest)) {
					const [head$4, ...tail] = rest;
					for (; i < len - tail.length; i++) {
						const te = head$4(input[i], options);
						if (isEither(te)) if (isLeft(te)) {
							const e = new Pointer(i, input, te.left);
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, sortByIndex(output)));
						} else output.push([stepKey++, te.right]);
						else {
							const nk = stepKey++;
							const index = i;
							if (!queue) queue = [];
							queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t) => {
								if (isLeft(t)) {
									const e = new Pointer(index, input, t.left);
									if (allErrors) {
										es$1.push([nk, e]);
										return _void;
									} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
								} else {
									output$1.push([nk, t.right]);
									return _void;
								}
							}));
						}
					}
					for (let j = 0; j < tail.length; j++) {
						i += j;
						if (len < i + 1) continue;
						else {
							const te = tail[j](input[i], options);
							if (isEither(te)) {
								if (isLeft(te)) {
									const e = new Pointer(i, input, te.left);
									if (allErrors) {
										es.push([stepKey++, e]);
										continue;
									} else return left(new Composite(ast, input, e, sortByIndex(output)));
								}
								output.push([stepKey++, te.right]);
							} else {
								const nk = stepKey++;
								const index = i;
								if (!queue) queue = [];
								queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t) => {
									if (isLeft(t)) {
										const e = new Pointer(index, input, t.left);
										if (allErrors) {
											es$1.push([nk, e]);
											return _void;
										} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
									}
									output$1.push([nk, t.right]);
									return _void;
								}));
							}
						}
					}
				}
				const computeResult = ({ es: es$1, output: output$1 }) => isNonEmptyArray(es$1) ? left(new Composite(ast, input, sortByIndex(es$1), sortByIndex(output$1))) : right(sortByIndex(output$1));
				if (queue && queue.length > 0) {
					const cqueue = queue;
					return suspend$2(() => {
						const state = {
							es: copy$1(es),
							output: copy$1(output)
						};
						return flatMap$1(forEach(cqueue, (f) => f(state), {
							concurrency,
							batching,
							discard: true
						}), () => computeResult(state));
					});
				}
				return computeResult({
					output,
					es
				});
			};
		}
		case "TypeLiteral": {
			if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) return fromRefinement(ast, isNotNullable);
			const propertySignatures = [];
			const expectedKeysMap = {};
			const expectedKeys = [];
			for (const ps of ast.propertySignatures) {
				propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
				expectedKeysMap[ps.name] = null;
				expectedKeys.push(ps.name);
			}
			const indexSignatures = ast.indexSignatures.map((is$1) => [
				goMemo(is$1.parameter, isDecoding),
				goMemo(is$1.type, isDecoding),
				is$1.parameter
			]);
			const expectedAST = Union.make(ast.indexSignatures.map((is$1) => is$1.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal$1(key))));
			const expected = goMemo(expectedAST, isDecoding);
			const concurrency = getConcurrency(ast);
			const batching = getBatching(ast);
			return (input, options) => {
				if (!isRecord(input)) return left(new Type(ast, input));
				const allErrors = options?.errors === "all";
				const es = [];
				let stepKey = 0;
				const onExcessPropertyError = options?.onExcessProperty === "error";
				const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
				const output = {};
				let inputKeys;
				if (onExcessPropertyError || onExcessPropertyPreserve) {
					inputKeys = Reflect.ownKeys(input);
					for (const key of inputKeys) {
						const te = expected(key, options);
						if (isEither(te) && isLeft(te)) if (onExcessPropertyError) {
							const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						} else output[key] = input[key];
					}
				}
				let queue = void 0;
				const isExact = options?.exact === true;
				for (let i = 0; i < propertySignatures.length; i++) {
					const ps = propertySignatures[i][1];
					const name = ps.name;
					const hasKey = Object.prototype.hasOwnProperty.call(input, name);
					if (!hasKey) {
						if (ps.isOptional) continue;
						else if (isExact) {
							const e = new Pointer(name, input, new Missing(ps));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						}
					}
					const parser = propertySignatures[i][0];
					const te = parser(input[name], options);
					if (isEither(te)) {
						if (isLeft(te)) {
							const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						}
						output[name] = te.right;
					} else {
						const nk = stepKey++;
						const index = name;
						if (!queue) queue = [];
						queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t) => {
							if (isLeft(t)) {
								const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
								if (allErrors) {
									es$1.push([nk, e]);
									return _void;
								} else return left(new Composite(ast, input, e, output$1));
							}
							output$1[index] = t.right;
							return _void;
						}));
					}
				}
				for (let i = 0; i < indexSignatures.length; i++) {
					const indexSignature = indexSignatures[i];
					const parameter = indexSignature[0];
					const type = indexSignature[1];
					const keys$5 = getKeysForIndexSignature(input, indexSignature[2]);
					for (const key of keys$5) {
						const keu = parameter(key, options);
						if (isEither(keu) && isRight(keu)) {
							const vpr = type(input[key], options);
							if (isEither(vpr)) {
								if (isLeft(vpr)) {
									const e = new Pointer(key, input, vpr.left);
									if (allErrors) {
										es.push([stepKey++, e]);
										continue;
									} else return left(new Composite(ast, input, e, output));
								} else if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) output[key] = vpr.right;
							} else {
								const nk = stepKey++;
								const index = key;
								if (!queue) queue = [];
								queue.push(({ es: es$1, output: output$1 }) => flatMap$1(either(vpr), (tv) => {
									if (isLeft(tv)) {
										const e = new Pointer(index, input, tv.left);
										if (allErrors) {
											es$1.push([nk, e]);
											return _void;
										} else return left(new Composite(ast, input, e, output$1));
									} else {
										if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) output$1[key] = tv.right;
										return _void;
									}
								}));
							}
						}
					}
				}
				const computeResult = ({ es: es$1, output: output$1 }) => {
					if (isNonEmptyArray(es$1)) return left(new Composite(ast, input, sortByIndex(es$1), output$1));
					if (options?.propertyOrder === "original") {
						const keys$5 = inputKeys || Reflect.ownKeys(input);
						for (const name of expectedKeys) if (keys$5.indexOf(name) === -1) keys$5.push(name);
						const out = {};
						for (const key of keys$5) if (Object.prototype.hasOwnProperty.call(output$1, key)) out[key] = output$1[key];
						return right(out);
					}
					return right(output$1);
				};
				if (queue && queue.length > 0) {
					const cqueue = queue;
					return suspend$2(() => {
						const state = {
							es: copy$1(es),
							output: Object.assign({}, output)
						};
						return flatMap$1(forEach(cqueue, (f) => f(state), {
							concurrency,
							batching,
							discard: true
						}), () => computeResult(state));
					});
				}
				return computeResult({
					es,
					output
				});
			};
		}
		case "Union": {
			const searchTree = getSearchTree(ast.types, isDecoding);
			const ownKeys = Reflect.ownKeys(searchTree.keys);
			const ownKeysLen = ownKeys.length;
			const astTypesLen = ast.types.length;
			const map$21 = /* @__PURE__ */ new Map();
			for (let i = 0; i < astTypesLen; i++) map$21.set(ast.types[i], goMemo(ast.types[i], isDecoding));
			const concurrency = getConcurrency(ast) ?? 1;
			const batching = getBatching(ast);
			return (input, options) => {
				const es = [];
				let stepKey = 0;
				let candidates = [];
				if (ownKeysLen > 0) if (isRecordOrArray(input)) for (let i = 0; i < ownKeysLen; i++) {
					const name = ownKeys[i];
					const buckets = searchTree.keys[name].buckets;
					if (Object.prototype.hasOwnProperty.call(input, name)) {
						const literal$2 = String(input[name]);
						if (Object.prototype.hasOwnProperty.call(buckets, literal$2)) candidates = candidates.concat(buckets[literal$2]);
						else {
							const { candidates: candidates$1, literals } = searchTree.keys[name];
							const literalsUnion = Union.make(literals);
							const errorAst = candidates$1.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates$1);
							es.push([stepKey++, new Composite(errorAst, input, new Pointer(name, input, new Type(literalsUnion, input[name])))]);
						}
					} else {
						const { candidates: candidates$1, literals } = searchTree.keys[name];
						const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
						const errorAst = candidates$1.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates$1);
						es.push([stepKey++, new Composite(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
					}
				}
				else {
					const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
					es.push([stepKey++, new Type(errorAst, input)]);
				}
				if (searchTree.otherwise.length > 0) candidates = candidates.concat(searchTree.otherwise);
				let queue = void 0;
				for (let i = 0; i < candidates.length; i++) {
					const candidate = candidates[i];
					const pr = map$21.get(candidate)(input, options);
					if (isEither(pr) && (!queue || queue.length === 0)) if (isRight(pr)) return pr;
					else es.push([stepKey++, pr.left]);
					else {
						const nk = stepKey++;
						if (!queue) queue = [];
						queue.push((state) => suspend$2(() => {
							if ("finalResult" in state) return _void;
							else return flatMap$1(either(pr), (t) => {
								if (isRight(t)) state.finalResult = t;
								else state.es.push([nk, t.left]);
								return _void;
							});
						}));
					}
				}
				const computeResult = (es$1) => isNonEmptyArray(es$1) ? es$1.length === 1 && es$1[0][1]._tag === "Type" ? left(es$1[0][1]) : left(new Composite(ast, input, sortByIndex(es$1))) : left(new Type(ast, input));
				if (queue && queue.length > 0) {
					const cqueue = queue;
					return suspend$2(() => {
						const state = { es: copy$1(es) };
						return flatMap$1(forEach(cqueue, (f) => f(state), {
							concurrency,
							batching,
							discard: true
						}), () => {
							if ("finalResult" in state) return state.finalResult;
							return computeResult(state.es);
						});
					});
				}
				return computeResult(es);
			};
		}
		case "Suspend": {
			const get$12 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
			return (a, options) => get$12()(a, options);
		}
	}
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right(u) : left(new Type(ast, u));
const getLiterals = (ast, isDecoding) => {
	switch (ast._tag) {
		case "Declaration": {
			const annotation = getSurrogateAnnotation(ast);
			if (isSome(annotation)) return getLiterals(annotation.value, isDecoding);
			break;
		}
		case "TypeLiteral": {
			const out = [];
			for (let i = 0; i < ast.propertySignatures.length; i++) {
				const propertySignature$1 = ast.propertySignatures[i];
				const type = isDecoding ? encodedAST(propertySignature$1.type) : typeAST(propertySignature$1.type);
				if (isLiteral(type) && !propertySignature$1.isOptional) out.push([propertySignature$1.name, type]);
			}
			return out;
		}
		case "TupleType": {
			const out = [];
			for (let i = 0; i < ast.elements.length; i++) {
				const element = ast.elements[i];
				const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
				if (isLiteral(type) && !element.isOptional) out.push([i, type]);
			}
			return out;
		}
		case "Refinement": return getLiterals(ast.from, isDecoding);
		case "Suspend": return getLiterals(ast.f(), isDecoding);
		case "Transformation": return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
	}
	return [];
};
const getSearchTree = (members, isDecoding) => {
	const keys$5 = {};
	const otherwise = [];
	const candidates = [];
	for (let i = 0; i < members.length; i++) {
		const member = members[i];
		const tags = getLiterals(member, isDecoding);
		if (tags.length > 0) {
			candidates.push(member);
			for (let j = 0; j < tags.length; j++) {
				const [key, literal$2] = tags[j];
				const hash$1 = String(literal$2.literal);
				keys$5[key] = keys$5[key] || {
					buckets: {},
					literals: [],
					candidates: []
				};
				const buckets = keys$5[key].buckets;
				if (Object.prototype.hasOwnProperty.call(buckets, hash$1)) {
					if (j < tags.length - 1) continue;
					buckets[hash$1].push(member);
					keys$5[key].literals.push(literal$2);
					keys$5[key].candidates.push(member);
				} else {
					buckets[hash$1] = [member];
					keys$5[key].literals.push(literal$2);
					keys$5[key].candidates.push(member);
					break;
				}
			}
		} else otherwise.push(member);
	}
	return {
		keys: keys$5,
		otherwise,
		candidates
	};
};
var dropRightRefinement = (ast) => isRefinement$1(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect, ast, actual, options) => {
	if (options?.isEffectAllowed === true) return effect;
	if (isEither(effect)) return effect;
	const scheduler = new SyncScheduler();
	const fiber = runFork(effect, { scheduler });
	scheduler.flush();
	const exit$3 = fiber.unsafePoll();
	if (exit$3) {
		if (isSuccess$2(exit$3)) return right(exit$3.value);
		const cause$2 = exit$3.cause;
		if (isFailType(cause$2)) return left(cause$2.error);
		return left(new Forbidden(ast, actual, pretty$1(cause$2)));
	}
	return left(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
	return es.sort(compare).map((t) => t[1]);
}
const getFinalTransformation = (transformation, isDecoding) => {
	switch (transformation._tag) {
		case "FinalTransformation": return isDecoding ? transformation.decode : transformation.encode;
		case "ComposeTransformation": return right;
		case "TypeLiteralTransformation": return (input) => {
			let out = right(input);
			for (const pst of transformation.propertySignatureTransformations) {
				const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
				const transformation$1 = isDecoding ? pst.decode : pst.encode;
				const f = (input$1) => {
					const o = transformation$1(Object.prototype.hasOwnProperty.call(input$1, from) ? some$4(input$1[from]) : none$7());
					delete input$1[from];
					if (isSome(o)) input$1[to] = o.value;
					return input$1;
				};
				out = map(out, f);
			}
			return out;
		};
	}
};
var makeTree = (value$2, forest = []) => ({
	value: value$2,
	forest
});
const TreeFormatter = {
	formatIssue: (issue) => map(formatTree(issue), drawTree),
	formatIssueSync: (issue) => {
		const e = TreeFormatter.formatIssue(issue);
		return isEither(e) ? getOrThrow$1(e) : runSync(e);
	},
	formatError: (error) => TreeFormatter.formatIssue(error.issue),
	formatErrorSync: (error) => TreeFormatter.formatIssueSync(error.issue)
};
var drawTree = (tree) => tree.value + draw("\n", tree.forest);
var draw = (indentation, forest) => {
	let r = "";
	const len = forest.length;
	let tree;
	for (let i = 0; i < len; i++) {
		tree = forest[i];
		const isLast = i === len - 1;
		r += indentation + (isLast ? "" : "") + " " + tree.value;
		r += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest);
	}
	return r;
};
var formatTransformationKind = (kind) => {
	switch (kind) {
		case "Encoded": return "Encoded side transformation failure";
		case "Transformation": return "Transformation process failure";
		case "Type": return "Type side transformation failure";
	}
};
var formatRefinementKind = (kind) => {
	switch (kind) {
		case "From": return "From side refinement failure";
		case "Predicate": return "Predicate refinement failure";
	}
};
var getAnnotated = (issue) => "ast" in issue ? some$4(issue.ast) : none$7();
var Either_void = /* @__PURE__ */ right(void 0);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap$13(getMessageAnnotation), match$13({
	onNone: () => Either_void,
	onSome: (messageAnnotation) => {
		const union$9 = messageAnnotation(issue);
		if (isString(union$9)) return right({
			message: union$9,
			override: false
		});
		if (isEffect(union$9)) return map$3(union$9, (message) => ({
			message,
			override: false
		}));
		if (isString(union$9.message)) return right({
			message: union$9.message,
			override: union$9.override
		});
		return map$3(union$9.message, (message) => ({
			message,
			override: union$9.override
		}));
	}
}));
var createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
const isComposite = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap(getCurrentMessage(issue), (currentMessage) => {
	if (currentMessage !== void 0) return !currentMessage.override && (isComposite(issue) || isRefinement(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation") ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : Either_void : right(currentMessage.message);
	return Either_void;
});
var getParseIssueTitleAnnotation = (issue) => getAnnotated(issue).pipe(flatMap$13(getParseIssueTitleAnnotation$1), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
function getRefinementExpected(ast) {
	return getDescriptionAnnotation(ast).pipe(orElse$9(() => getTitleAnnotation(ast)), orElse$9(() => getAutoTitleAnnotation(ast)), orElse$9(() => getIdentifierAnnotation(ast)), getOrElse$5(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
	if (issue.message !== void 0) return issue.message;
	return `Expected ${isRefinement$1(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast)}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
	const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
	if (isSome(missingMessageAnnotation)) {
		const annotation = missingMessageAnnotation.value();
		return isString(annotation) ? right(annotation) : annotation;
	}
	return right(issue.message ?? "is missing");
};
var formatTree = (issue) => {
	switch (issue._tag) {
		case "Type": return map(formatTypeMessage(issue), makeTree);
		case "Forbidden": return right(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
		case "Unexpected": return right(makeTree(formatUnexpectedMessage(issue)));
		case "Missing": return map(formatMissingMessage(issue), makeTree);
		case "Transformation": return flatMap(getMessage(issue), (message) => {
			if (message !== void 0) return right(makeTree(message));
			return map(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
		});
		case "Refinement": return flatMap(getMessage(issue), (message) => {
			if (message !== void 0) return right(makeTree(message));
			return map(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
		});
		case "Pointer": return map(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
		case "Composite": return flatMap(getMessage(issue), (message) => {
			if (message !== void 0) return right(makeTree(message));
			const parseIssueTitle = getParseIssueTitle(issue);
			return isNonEmpty$5(issue.issues) ? map(forEach(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
		});
	}
};
const value = value$1;
const pick = /* @__PURE__ */ dual((args$1) => isObject(args$1[0]), (s, ...keys$5) => {
	const out = {};
	for (const k of keys$5) if (k in s) out[k] = s[k];
	return out;
});
const omit = /* @__PURE__ */ dual((args$1) => isObject(args$1[0]), (s, ...keys$5) => {
	const out = { ...s };
	for (const k of keys$5) delete out[k];
	return out;
});
const TypeId = /* @__PURE__ */ Symbol.for("effect/Schema");
function make(ast) {
	return class SchemaClass {
		[TypeId] = variance;
		static ast = ast;
		static annotations(annotations$1) {
			return make(mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static pipe() {
			return pipeArguments(this, arguments);
		}
		static toString() {
			return String(ast);
		}
		static Type;
		static Encoded;
		static Context;
		static [TypeId] = variance;
	};
}
var variance = {
	_A: (_) => _,
	_I: (_) => _,
	_R: (_) => _
};
var builtInAnnotations = {
	schemaId: SchemaIdAnnotationId,
	message: MessageAnnotationId,
	missingMessage: MissingMessageAnnotationId,
	identifier: IdentifierAnnotationId,
	title: TitleAnnotationId,
	description: DescriptionAnnotationId,
	examples: ExamplesAnnotationId,
	default: DefaultAnnotationId,
	documentation: DocumentationAnnotationId,
	jsonSchema: JSONSchemaAnnotationId,
	arbitrary: ArbitraryAnnotationId,
	pretty: PrettyAnnotationId,
	equivalence: EquivalenceAnnotationId,
	concurrency: ConcurrencyAnnotationId,
	batching: BatchingAnnotationId,
	parseIssueTitle: ParseIssueTitleAnnotationId,
	parseOptions: ParseOptionsAnnotationId,
	decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations$1) => {
	if (!annotations$1) return {};
	const out = { ...annotations$1 };
	for (const key in builtInAnnotations) if (key in annotations$1) {
		const id$2 = builtInAnnotations[key];
		out[id$2] = annotations$1[key];
		delete out[key];
	}
	return out;
};
var mergeSchemaAnnotations = (ast, annotations$1) => annotations(ast, toASTAnnotations(annotations$1));
const encodedSchema = (schema) => make(encodedAST(schema.ast));
const typeSchema = (schema) => make(typeAST(schema.ast));
const decodeUnknown = (schema, options) => {
	const decodeUnknown$3 = decodeUnknown$1(schema, options);
	return (u, overrideOptions) => mapError(decodeUnknown$3(u, overrideOptions), parseError);
};
const isSchema = (u) => hasProperty(u, TypeId) && isObject(u[TypeId]);
function getDefaultLiteralAST(literals) {
	return isMembers(literals) ? Union.make(mapMembers(literals, (literal$2) => new Literal$1(literal$2))) : new Literal$1(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
	return class LiteralClass extends make(ast) {
		static annotations(annotations$1) {
			return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static literals = [...literals];
	};
}
function Literal(...literals) {
	return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var declareConstructor = (typeParameters, options, annotations$1) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters$1) => options.decode(...typeParameters$1.map(make)), (...typeParameters$1) => options.encode(...typeParameters$1.map(make)), toASTAnnotations(annotations$1)));
var declarePrimitive = (is$1, annotations$1) => {
	const decodeUnknown$3 = () => (input, _, ast) => is$1(input) ? succeed(input) : fail(new Type(ast, input));
	return makeDeclareClass([], new Declaration([], decodeUnknown$3, decodeUnknown$3, toASTAnnotations(annotations$1)));
};
function makeDeclareClass(typeParameters, ast) {
	return class DeclareClass extends make(ast) {
		static annotations(annotations$1) {
			return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static typeParameters = [...typeParameters];
	};
}
const declare = function() {
	if (Array.isArray(arguments[0])) {
		const typeParameters = arguments[0];
		const options = arguments[1];
		const annotations$2 = arguments[2];
		return declareConstructor(typeParameters, options, annotations$2);
	}
	const is$1 = arguments[0];
	const annotations$1 = arguments[1];
	return declarePrimitive(is$1, annotations$1);
};
var Never = class extends make(neverKeyword) {};
var String$ = class extends make(stringKeyword) {};
var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type$1(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
	return class TupleTypeClass extends make(ast) {
		static annotations(annotations$1) {
			return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static elements = [...elements];
		static rest = [...rest];
	};
}
function makeArrayClass(value$2, ast) {
	return class ArrayClass extends makeTupleTypeClass([], [value$2], ast) {
		static annotations(annotations$1) {
			return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static value = value$2;
	};
}
var Array$ = (value$2) => makeArrayClass(value$2);
var formatPropertySignatureToken = (isOptional) => isOptional ? "\"?:\"" : "\":\"";
var PropertySignatureDeclaration = class extends OptionalType {
	isReadonly;
	defaultValue;
	_tag = "PropertySignatureDeclaration";
	constructor(type, isOptional, isReadonly, annotations$1, defaultValue) {
		super(type, isOptional, annotations$1);
		this.isReadonly = isReadonly;
		this.defaultValue = defaultValue;
	}
	toString() {
		const token = formatPropertySignatureToken(this.isOptional);
		const type = String(this.type);
		return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
	}
};
var ToPropertySignature = class extends OptionalType {
	isReadonly;
	defaultValue;
	constructor(type, isOptional, isReadonly, annotations$1, defaultValue) {
		super(type, isOptional, annotations$1);
		this.isReadonly = isReadonly;
		this.defaultValue = defaultValue;
	}
};
var formatPropertyKey = (p) => {
	if (p === void 0) return "never";
	if (isString(p)) return JSON.stringify(p);
	return String(p);
};
var PropertySignatureTransformation = class {
	from;
	to;
	decode;
	encode;
	_tag = "PropertySignatureTransformation";
	constructor(from, to, decode$4, encode$3) {
		this.from = from;
		this.to = to;
		this.decode = decode$4;
		this.encode = encode$3;
	}
	toString() {
		return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
	}
};
var mergeSignatureAnnotations = (ast, annotations$1) => {
	switch (ast._tag) {
		case "PropertySignatureDeclaration": return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
			...ast.annotations,
			...annotations$1
		}, ast.defaultValue);
		case "PropertySignatureTransformation": return new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
			...ast.to.annotations,
			...annotations$1
		}, ast.to.defaultValue), ast.decode, ast.encode);
	}
};
const PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
const isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var PropertySignatureImpl = class PropertySignatureImpl {
	ast;
	[TypeId];
	[PropertySignatureTypeId] = null;
	_TypeToken;
	_Key;
	_EncodedToken;
	_HasDefault;
	constructor(ast) {
		this.ast = ast;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	annotations(annotations$1) {
		return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations$1)));
	}
	toString() {
		return String(this.ast);
	}
};
const makePropertySignature = (ast) => new PropertySignatureImpl(ast);
var PropertySignatureWithFromImpl = class PropertySignatureWithFromImpl extends PropertySignatureImpl {
	from;
	constructor(ast, from) {
		super(ast);
		this.from = from;
	}
	annotations(annotations$1) {
		return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations$1)), this.from);
	}
};
const propertySignature = (self) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, void 0), self);
const withConstructorDefault = /* @__PURE__ */ dual(2, (self, defaultValue) => {
	const ast = self.ast;
	switch (ast._tag) {
		case "PropertySignatureDeclaration": return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
		case "PropertySignatureTransformation": return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
	}
});
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
	const ownKeys = Reflect.ownKeys(fields);
	const pss = [];
	if (ownKeys.length > 0) {
		const from = [];
		const to = [];
		const transformations = [];
		for (let i = 0; i < ownKeys.length; i++) {
			const key = ownKeys[i];
			const field = fields[key];
			if (isPropertySignature(field)) {
				const ast = field.ast;
				switch (ast._tag) {
					case "PropertySignatureDeclaration": {
						const type = ast.type;
						const isOptional = ast.isOptional;
						const toAnnotations = ast.annotations;
						from.push(new PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
						to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
						pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
						break;
					}
					case "PropertySignatureTransformation": {
						const fromKey = ast.from.fromKey ?? key;
						from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
						to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
						transformations.push(new PropertySignatureTransformation$1(fromKey, key, ast.decode, ast.encode));
						break;
					}
				}
			} else {
				from.push(new PropertySignature(key, field.ast, false, true));
				to.push(new PropertySignature(key, typeAST(field.ast), false, true));
				pss.push(new PropertySignature(key, field.ast, false, true));
			}
		}
		if (isNonEmptyReadonlyArray(transformations)) {
			const issFrom = [];
			const issTo = [];
			for (const r of records) {
				const { indexSignatures, propertySignatures } = record(r.key.ast, r.value.ast);
				propertySignatures.forEach((ps) => {
					from.push(ps);
					to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
				});
				indexSignatures.forEach((is$1) => {
					issFrom.push(is$1);
					issTo.push(new IndexSignature(is$1.parameter, typeAST(is$1.type), is$1.isReadonly));
				});
			}
			return new Transformation$1(new TypeLiteral(from, issFrom, { [AutoTitleAnnotationId]: "Struct (Encoded side)" }), new TypeLiteral(to, issTo, { [AutoTitleAnnotationId]: "Struct (Type side)" }), new TypeLiteralTransformation(transformations));
		}
	}
	const iss = [];
	for (const r of records) {
		const { indexSignatures, propertySignatures } = record(r.key.ast, r.value.ast);
		propertySignatures.forEach((ps) => pss.push(ps));
		indexSignatures.forEach((is$1) => iss.push(is$1));
	}
	return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
	const ownKeys = Reflect.ownKeys(fields);
	for (const key of ownKeys) {
		const field = fields[key];
		if (out[key] === void 0 && isPropertySignature(field)) {
			const ast = field.ast;
			const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
			if (defaultValue !== void 0) out[key] = defaultValue();
		}
	}
	return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
	return class TypeLiteralClass extends make(ast) {
		static annotations(annotations$1) {
			return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static fields = { ...fields };
		static records = [...records];
		static make = (props, options) => {
			const propsWithDefaults = lazilyMergeDefaults(fields, { ...props });
			return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
		};
		static pick(...keys$5) {
			return Struct(pick(fields, ...keys$5));
		}
		static omit(...keys$5) {
			return Struct(omit(fields, ...keys$5));
		}
	};
}
function Struct(fields, ...records) {
	return makeTypeLiteralClass(fields, records);
}
var intersectTypeLiterals = (x, y, path$5) => {
	if (isTypeLiteral(x) && isTypeLiteral(y)) {
		const propertySignatures = [...x.propertySignatures];
		for (const ps of y.propertySignatures) {
			const name = ps.name;
			const i = propertySignatures.findIndex((ps$1) => ps$1.name === name);
			if (i === -1) propertySignatures.push(ps);
			else {
				const { isOptional, type } = propertySignatures[i];
				propertySignatures[i] = new PropertySignature(name, extendAST(type, ps.type, path$5.concat(name)), isOptional, true);
			}
		}
		return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
	}
	throw new Error(getSchemaExtendErrorMessage(x, y, path$5));
};
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement$1(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path$5) => Union.make(intersectUnionMembers([x], [y], path$5));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path$5) => flatMap$12(xs, (x) => flatMap$12(ys, (y) => {
	switch (y._tag) {
		case "Literal":
			if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean$1(y.literal) && isBooleanKeyword(x)) return [y];
			break;
		case "StringKeyword":
			if (y === stringKeyword) {
				if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) return [x];
				else if (isRefinement$1(x)) return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path$5));
			} else if (x === stringKeyword) return [y];
			break;
		case "NumberKeyword":
			if (y === numberKeyword) {
				if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) return [x];
				else if (isRefinement$1(x)) return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path$5));
			} else if (x === numberKeyword) return [y];
			break;
		case "BooleanKeyword":
			if (y === booleanKeyword) {
				if (isBooleanKeyword(x) || isLiteral(x) && isBoolean$1(x.literal)) return [x];
				else if (isRefinement$1(x)) return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path$5));
			} else if (x === booleanKeyword) return [y];
			break;
		case "Union": return intersectUnionMembers(getTypes(x), y.types, path$5);
		case "Suspend": return [new Suspend(() => extendAST(x, y.f(), path$5))];
		case "Refinement": return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path$5));
		case "TypeLiteral":
			switch (x._tag) {
				case "Union": return intersectUnionMembers(x.types, [y], path$5);
				case "Suspend": return [new Suspend(() => extendAST(x.f(), y, path$5))];
				case "Refinement": return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path$5));
				case "TypeLiteral": return [intersectTypeLiterals(x, y, path$5)];
				case "Transformation": {
					const transformation = x.transformation;
					const from = intersectTypeLiterals(x.from, y, path$5);
					const to = intersectTypeLiterals(x.to, typeAST(y), path$5);
					switch (transformation._tag) {
						case "TypeLiteralTransformation": return [new Transformation$1(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
						case "ComposeTransformation": return [new Transformation$1(from, to, composeTransformation)];
						case "FinalTransformation": return [new Transformation$1(from, to, new FinalTransformation((fromA, options, ast, fromI) => map(transformation.decode(fromA, options, ast, fromI), (partial) => ({
							...fromA,
							...partial
						})), (toI, options, ast, toA) => map(transformation.encode(toI, options, ast, toA), (partial) => ({
							...toI,
							...partial
						}))))];
					}
				}
			}
			break;
		case "Transformation":
			if (isTransformation$1(x)) {
				if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) return [new Transformation$1(intersectTypeLiterals(x.from, y.from, path$5), intersectTypeLiterals(x.to, y.to, path$5), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
			} else return intersectUnionMembers([y], [x], path$5);
			break;
	}
	throw new Error(getSchemaExtendErrorMessage(x, y, path$5));
}));
const extend = /* @__PURE__ */ dual(2, (self, that) => make(extendAST(self.ast, that.ast, [])));
const RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter$9, ast) {
	return class RefineClass extends make(ast) {
		static annotations(annotations$1) {
			return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static [RefineSchemaId] = from;
		static from = from;
		static filter = filter$9;
		static make = (a, options) => {
			return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
		};
	};
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
	if (isBoolean$1(item)) return item ? none$7() : some$4(new Type(ast, input));
	if (isString(item)) return some$4(new Type(ast, input, item));
	if (item !== void 0) {
		if ("_tag" in item) return some$4(item);
		const issue = new Type(ast, input, item.message);
		return some$4(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
	}
	return none$7();
};
var toFilterParseIssue = (out, ast, input) => {
	if (isSingle(out)) return fromFilterPredicateReturnTypeItem(out, ast, input);
	if (isNonEmptyReadonlyArray(out)) {
		const issues = filterMap$4(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
		if (isNonEmptyReadonlyArray(issues)) return some$4(issues.length === 1 ? issues[0] : new Composite(ast, input, issues));
	}
	return none$7();
};
function filter(predicate, annotations$1) {
	return (self) => {
		function filter$9(input, options, ast) {
			return toFilterParseIssue(predicate(input, options, ast), ast, input);
		}
		return makeRefineClass(self, filter$9, new Refinement$1(self.ast, filter$9, toASTAnnotations(annotations$1)));
	};
}
function makeTransformationClass(from, to, ast) {
	return class TransformationClass extends make(ast) {
		static annotations(annotations$1) {
			return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static from = from;
		static to = to;
	};
}
const transformOrFail = /* @__PURE__ */ dual((args$1) => isSchema(args$1[0]) && isSchema(args$1[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation$1(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
const transform = /* @__PURE__ */ dual((args$1) => isSchema(args$1[0]) && isSchema(args$1[1]), (from, to, options) => transformOrFail(from, to, {
	strict: true,
	decode: (fromA, _options, _ast, toA) => succeed(options.decode(fromA, toA)),
	encode: (toI, _options, _ast, toA) => succeed(options.encode(toI, toA))
}));
const MinLengthSchemaId = MinLengthSchemaId$1;
const minLength = (minLength$1, annotations$1) => (self) => self.pipe(filter((a) => a.length >= minLength$1, {
	schemaId: MinLengthSchemaId,
	title: `minLength(${minLength$1})`,
	description: `a string at least ${minLength$1} character(s) long`,
	jsonSchema: { minLength: minLength$1 },
	...annotations$1
}));
const PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
const pattern = (regex, annotations$1) => (self) => {
	const source = regex.source;
	return self.pipe(filter((a) => {
		regex.lastIndex = 0;
		return regex.test(a);
	}, {
		schemaId: PatternSchemaId,
		[PatternSchemaId]: { regex },
		description: `a string matching the pattern ${source}`,
		jsonSchema: { pattern: source },
		...annotations$1
	}));
};
const nonEmptyString = (annotations$1) => minLength(1, {
	title: "nonEmptyString",
	description: "a non empty string",
	...annotations$1
});
var NonEmptyString = class extends String$.pipe(/* @__PURE__ */ nonEmptyString({ identifier: "NonEmptyString" })) {};
declare(isUint8Array, {
	identifier: "Uint8ArrayFromSelf",
	pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
	arbitrary: () => (fc) => fc.uint8Array(),
	equivalence: () => getEquivalence$3(equals)
});
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => Reflect.ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
const getClassTag = (tag) => withConstructorDefault(propertySignature(Literal(tag)), () => tag);
const TaggedError = (identifier$1) => (tag, fieldsOr, annotations$1) => {
	class Base$2 extends Error$1 {}
	Base$2.prototype.name = tag;
	const fields = getFieldsFromFieldsOr(fieldsOr);
	const schema = getSchemaFromFieldsOr(fieldsOr);
	const newFields = { _tag: getClassTag(tag) };
	const taggedFields = extendFields(newFields, fields);
	const hasMessageField = "message" in taggedFields;
	class TaggedErrorClass extends makeClass({
		kind: "TaggedError",
		identifier: identifier$1 ?? tag,
		schema: extend(schema, Struct(newFields)),
		fields: taggedFields,
		Base: Base$2,
		annotations: annotations$1,
		disableToString: true
	}) {
		static _tag = tag;
	}
	if (!hasMessageField) Object.defineProperty(TaggedErrorClass.prototype, "message", {
		get() {
			return `{ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey$1(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
		},
		enumerable: false,
		configurable: true
	});
	return TaggedErrorClass;
};
var extendFields = (a, b) => {
	const out = { ...a };
	for (const key of Reflect.ownKeys(b)) {
		if (key in a) throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
		out[key] = b[key];
	}
	return out;
};
function getDisableValidationMakeOption(options) {
	return isBoolean$1(options) ? options : options?.disableValidation ?? false;
}
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = (annotations$1) => {
	if (annotations$1 === void 0) return [];
	else if (Array.isArray(annotations$1)) return annotations$1;
	else return [annotations$1];
};
var makeClass = ({ Base: Base$2, annotations: annotations$1, disableToString, fields, identifier: identifier$1, kind, schema }) => {
	const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier$1}`);
	const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations$1);
	const typeSchema_ = typeSchema(schema);
	const declarationSurrogate = typeSchema_.annotations({
		identifier: identifier$1,
		...typeAnnotations
	});
	const typeSide = typeSchema_.annotations({
		[AutoTitleAnnotationId]: `${identifier$1} (Type side)`,
		...typeAnnotations
	});
	const constructorSchema = schema.annotations({
		[AutoTitleAnnotationId]: `${identifier$1} (Constructor)`,
		...typeAnnotations
	});
	const encodedSide = schema.annotations({
		[AutoTitleAnnotationId]: `${identifier$1} (Encoded side)`,
		...encodedAnnotations
	});
	const transformationSurrogate = schema.annotations({
		...encodedAnnotations,
		...typeAnnotations,
		...transformationAnnotations
	});
	const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
	const klass = class extends Base$2 {
		constructor(props = {}, options = false) {
			props = { ...props };
			if (kind !== "Class") delete props["_tag"];
			props = lazilyMergeDefaults(fields, props);
			if (!getDisableValidationMakeOption(options)) props = validateSync(constructorSchema)(props);
			super(props, true);
		}
		static [TypeId] = variance;
		static get ast() {
			let out = astCache.get(this);
			if (out) return out;
			out = transform(encodedSide, declare([schema], {
				decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed(input) : fail(new Type(ast, input)),
				encode: () => (input, options) => input instanceof this ? succeed(input) : map(encodeUnknown(typeSide)(input, options), (props) => new this(props, true))
			}, {
				identifier: identifier$1,
				pretty: (pretty$4) => (self) => `${identifier$1}(${pretty$4(self)})`,
				arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
				equivalence: identity,
				[SurrogateAnnotationId]: declarationSurrogate.ast,
				...typeAnnotations
			}), {
				strict: true,
				decode: (i) => new this(i, true),
				encode: identity
			}).annotations({
				[SurrogateAnnotationId]: transformationSurrogate.ast,
				...transformationAnnotations
			}).ast;
			astCache.set(this, out);
			return out;
		}
		static pipe() {
			return pipeArguments(this, arguments);
		}
		static annotations(annotations$2) {
			return make(this.ast).annotations(annotations$2);
		}
		static toString() {
			return `(${String(encodedSide)} <-> ${identifier$1})`;
		}
		static make(...args$1) {
			return new this(...args$1);
		}
		static fields = { ...fields };
		static identifier = identifier$1;
		static extend(identifier$2) {
			return (newFieldsOr, annotations$2) => {
				const newFields = getFieldsFromFieldsOr(newFieldsOr);
				const newSchema = getSchemaFromFieldsOr(newFieldsOr);
				const extendedFields = extendFields(fields, newFields);
				return makeClass({
					kind,
					identifier: identifier$2,
					schema: extend(schema, newSchema),
					fields: extendedFields,
					Base: this,
					annotations: annotations$2
				});
			};
		}
		static transformOrFail(identifier$2) {
			return (newFieldsOr, options, annotations$2) => {
				const transformedFields = extendFields(fields, newFieldsOr);
				return makeClass({
					kind,
					identifier: identifier$2,
					schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
					fields: transformedFields,
					Base: this,
					annotations: annotations$2
				});
			};
		}
		static transformOrFailFrom(identifier$2) {
			return (newFields, options, annotations$2) => {
				const transformedFields = extendFields(fields, newFields);
				return makeClass({
					kind,
					identifier: identifier$2,
					schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
					fields: transformedFields,
					Base: this,
					annotations: annotations$2
				});
			};
		}
		get [classSymbol]() {
			return classSymbol;
		}
	};
	if (disableToString !== true) Object.defineProperty(klass.prototype, "toString", {
		value() {
			return `${identifier$1}({ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey$1(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
		},
		configurable: true,
		writable: true
	});
	return klass;
};
const Config = (name, schema) => {
	const decodeUnknownEither$1 = decodeUnknownEither(schema);
	return string(name).pipe(mapOrFail((s) => decodeUnknownEither$1(s).pipe(mapLeft((error) => InvalidData([], TreeFormatter.formatIssueSync(error))))));
};
var NotPullRequestContextError = class extends TaggedError()("NotPullRequestContextError", { message: String$ }) {};
var MissingAttributesError = class extends TaggedError()("MissingAttributesError", { message: String$ }) {};
var InvalidCommentStrategyError = class extends TaggedError()("InvalidCommentStrategyError", { value: String$ }) {};
var AttributeParseError = class extends TaggedError()("AttributeParseError", { message: String$ }) {};
var GitWorktreeError = class extends TaggedError()("GitWorktreeError", {
	operation: String$,
	message: String$
}) {};
var NixPathInfoError = class extends TaggedError()("NixPathInfoError", {
	flakeRef: String$,
	message: String$
}) {};
var NixBuildError = class extends TaggedError()("NixBuildError", {
	flakeRef: String$,
	message: String$
}) {};
var NixDixError = class extends TaggedError()("NixDixError", {
	basePath: String$,
	prPath: String$,
	message: String$
}) {};
var GitHubApiError = class extends TaggedError()("GitHubApiError", {
	operation: String$,
	message: String$
}) {};
var ArtifactError = class extends TaggedError()("ArtifactError", {
	name: String$,
	message: String$
}) {};
var InvalidDirectoryError = class extends TaggedError()("InvalidDirectoryError", { message: String$ }) {};
var import_core = /* @__PURE__ */ __toESM(require_core(), 1);
var import_exec = /* @__PURE__ */ __toESM(require_exec(), 1);
const sanitizeBranchName = (ref) => ref.replace(/[^a-zA-Z0-9-]/g, "-");
var execGit = (args$1, ignoreReturnCode = false) => tryPromise({
	try: () => import_exec.exec("git", args$1, { ignoreReturnCode }),
	catch: () => new GitWorktreeError({
		operation: args$1[0] ?? "unknown",
		message: `Failed to execute git ${args$1.join(" ")}`
	})
});
var worktreeExists = (path$5) => tryPromise({
	try: async () => {
		let stdout = "";
		await import_exec.exec("git", [
			"worktree",
			"list",
			"--porcelain"
		], {
			listeners: { stdout: (data) => stdout += data.toString() },
			silent: true
		});
		return stdout.includes(`worktree ${path$5}`);
	},
	catch: (error) => error
}).pipe(catchAll((error) => logWarning(`Failed to check worktree existence: ${error}`).pipe(as(false))));
const removeWorktree = (path$5) => worktreeExists(path$5).pipe(flatMap$1((exists$4) => exists$4 ? execGit([
	"worktree",
	"remove",
	"--force",
	path$5
], true) : _void), ignore);
var fetchRef = (baseRef) => tryPromise({
	try: () => import_exec.exec("git", [
		"fetch",
		"origin",
		`+${baseRef}:refs/remotes/origin/${baseRef}`,
		"--depth=1"
	]),
	catch: () => new GitWorktreeError({
		operation: "fetch",
		message: `Failed to fetch ${baseRef}`
	})
});
var addWorktree = (worktreePath, baseRef) => tryPromise({
	try: () => import_exec.exec("git", [
		"worktree",
		"add",
		"--detach",
		worktreePath,
		`origin/${baseRef}`
	]),
	catch: () => new GitWorktreeError({
		operation: "create",
		message: `Failed to create worktree for ${baseRef}`
	})
});
var GitService = class extends Service()("GitService", { succeed: { createWorktree: (baseRef, runId) => {
	const worktreePath = nodePath.join(fs.realpathSync(os.tmpdir()), `dix-base-${sanitizeBranchName(baseRef)}-${runId}`);
	return acquireRelease(gen(function* () {
		yield* removeWorktree(worktreePath);
		yield* fetchRef(baseRef);
		yield* addWorktree(worktreePath, baseRef);
		yield* sync$2(() => import_core.saveState("worktreePath", worktreePath));
		yield* logInfo(`Created worktree for base branch ${baseRef} at ${worktreePath}`);
		return { path: worktreePath };
	}), (worktree) => gen(function* () {
		yield* removeWorktree(worktree.path);
		yield* logInfo(`Cleaned up worktree at ${worktree.path}`);
	}));
} } }) {};
export { MemoMapTypeId as $, fromNullable$2 as $n, succeed$5 as $t, catchAll as A, fromJson as An, launch as At, map$3 as B, unnested as Bn, mock as Bt, option as C, spanTag as Cn, fresh as Ct, Service as D, constantCase as Dn, fromFunction as Dt, isConfigError as E, configProviderTag as En, fromEffectDiscard as Et, forEach as F, makeFlat as Fn, match$1 as Ft, scoped as G, Interruption as Gn, provide$1 as Gt, orElseSucceed as H, within as Hn, orElse$4 as Ht, gen as I, mapInputPath as In, matchCause$1 as It, tapError as J, WindDown as Jn, scope$1 as Jt, succeed$3 as K, OpSupervision as Kn, provideMerge as Kt, logError as L, nested$2 as Ln, memoize as Lt, catchTags as M, kebabCase as Mn, makeMemoMap as Mt, fail$3 as N, lowerCase as Nn, map$5 as Nt, all$2 as O, fromEnv as On, isFresh as Ot, flatMap$1 as P, make$25 as Pn, mapError$2 as Pt, LayerTypeId as Q, flatMap$13 as Qn, service as Qt, logInfo as R, orElse$7 as Rn, merge$1 as Rt, boolean as S, addSpanStackTrace as Sn, flatten$1 as St, string as T, FlatConfigProviderTypeId as Tn, fromEffectContext as Tt, provide as U, tap$2 as Un, passthrough$1 as Ut, mapError$1 as V, upperCase as Vn, orDie$1 as Vt, runPromise as W, CooperativeYielding as Wn, project as Wt, try_ as X, enable$2 as Xn, scopedContext as Xt, tryPromise as Y, disable$2 as Yn, scoped$1 as Yt, CurrentMemoMap as Z, make$43 as Zn, scopedDiscard as Zt, Struct as _, withRuntimeFlagsScoped as _n, __require as _r, fiberRefLocally as _t, GitHubApiError as a, tapError$1 as an, none$7 as ar, catchAll$1 as at, pattern as b, make$18 as bn, fiberRefLocallyWith as bt, MissingAttributesError as c, toRuntimeWithMemoMap as cn, require_core as cr, die$1 as ct, NixPathInfoError as d, withParentSpan$1 as dn, require_lib as dr, empty as dt, succeedContext as en, getOrElse$5 as er, annotateLogs$1 as et, NotPullRequestContextError as f, withSpan$1 as fn, require_undici as fr, extendScope as ft, NonEmptyString as g, withConfigProviderScoped$1 as gn, __export as gr, failSync$1 as gt, Literal as h, makeSpanScoped$1 as hn, __esmMin as hr, failCauseSync$1 as ht, AttributeParseError as i, tap$1 as in, match$13 as ir, buildWithScope as it, catchIf as j, fromMap as jn, locallyEffect as jt, as as k, fromFlat as kn, isLayer as kt, NixBuildError as l, unwrapEffect as ln, require_exec as lr, dieSync$1 as lt, Config as m, addFinalizer$2 as mn, __commonJSMin as mr, failCause$2 as mt, removeWorktree as n, sync$3 as nn, isSome as nr, build as nt, InvalidCommentStrategyError as o, tapErrorCause$1 as on, some$4 as or, catchAllCause$1 as ot, Array$ as p, zipWith$3 as pn, require_tunnel as pr, fail$5 as pt, sync$2 as q, RuntimeMetrics as qn, retry$1 as qt, ArtifactError as r, syncContext as rn, map$19 as rr, buildWithMemoMap as rt, InvalidDirectoryError as s, toRuntime as sn, pipe as sr, context$1 as st, GitService as t, suspend$3 as tn, isNone$2 as tr, annotateSpans$1 as tt, NixDixError as u, unwrapScoped as un, require_auth as ur, discard as ut, decodeUnknown as v, withTracerScoped$1 as vn, __toCommonJS as vr, fiberRefLocallyScoped as vt, redacted as w, ConfigProviderTypeId as wn, fromEffect as wt, value as x, set as xn, flatMap$2 as xt, filter as y, get as yn, __toESM as yr, fiberRefLocallyScopedWith as yt, logWarning as z, snakeCase as zn, mergeAll$1 as zt };

//# sourceMappingURL=git-D6XTKqCz.js.map