import { $ as MemoMapTypeId$1, $n as fromNullable, $t as succeed$1, A as catchAll$2, An as fromJson$1, At as launch$1, B as map$4, Bn as unnested$1, Bt as mock$1, C as option, Cn as spanTag, Ct as fresh$1, D as Service, Dn as constantCase$1, Dt as fromFunction$1, E as isConfigError, En as configProviderTag, Et as fromEffectDiscard, F as forEach, Fn as makeFlat$1, Ft as match$1, G as scoped$2, Gn as Interruption, Gt as provide$1, H as orElseSucceed, Hn as within$1, Ht as orElse$2, I as gen, In as mapInputPath$1, It as matchCause$1, J as tapError$2, Jn as WindDown, Jt as scope$1, K as succeed$2, Kn as OpSupervision, Kt as provideMerge$1, L as logError, Ln as nested$1, Lt as memoize$2, M as catchTags, Mn as kebabCase$1, Mt as makeMemoMap$1, N as fail$2, Nn as lowerCase$1, Nt as map$3, O as all, On as fromEnv$1, Ot as isFresh$1, P as flatMap$3, Pn as make$2, Pt as mapError$1, Q as LayerTypeId$1, Qn as flatMap$2, Qt as service$1, R as logInfo, Rn as orElse$3, Rt as merge$2, S as boolean, Sn as addSpanStackTrace, St as flatten$1, T as string, Tn as FlatConfigProviderTypeId$1, Tt as fromEffectContext, U as provide$2, Un as tap$1, Ut as passthrough$1, V as mapError$2, Vn as upperCase$1, Vt as orDie$1, W as runPromise, Wn as CooperativeYielding, Wt as project$1, X as try_, Xn as enable, Xt as scopedContext$1, Y as tryPromise, Yn as disable, Yt as scoped$1, Z as CurrentMemoMap$1, Zn as make$1, Zt as scopedDiscard$1, _ as Struct, _n as withRuntimeFlagsScoped, _r as __require, _t as fiberRefLocally, a as GitHubApiError, an as tapError$1, ar as none, at as catchAll$1, b as pattern, bn as make$3, bt as fiberRefLocallyWith, c as MissingAttributesError, cn as toRuntimeWithMemoMap$1, cr as require_core$1, ct as die$1, d as NixPathInfoError, dn as withParentSpan$1, dr as require_lib$2, dt as empty$1, en as succeedContext$1, er as getOrElse, et as annotateLogs$1, f as NotPullRequestContextError, fn as withSpan$1, fr as require_undici, ft as extendScope$1, g as NonEmptyString, gn as withConfigProviderScoped, gr as __export, gt as failSync$1, h as Literal, hn as makeSpanScoped, hr as __esmMin, ht as failCauseSync$1, i as AttributeParseError, in as tap$2, ir as match$2, it as buildWithScope$1, j as catchIf, jn as fromMap$1, jt as locallyEffect$1, k as as, kn as fromFlat$1, kt as isLayer$1, l as NixBuildError, ln as unwrapEffect$1, lr as require_exec, lt as dieSync$1, m as Config, mn as addFinalizer, mr as __commonJSMin, mt as failCause$1, nn as sync$1, nr as isSome, nt as build$1, o as InvalidCommentStrategyError, on as tapErrorCause$1, or as some$2, ot as catchAllCause$1, p as Array$, pn as zipWith$1, pr as require_tunnel, pt as fail$1, q as sync$2, qn as RuntimeMetrics, qt as retry$3, r as ArtifactError, rn as syncContext$1, rr as map$5, rt as buildWithMemoMap$1, s as InvalidDirectoryError, sn as toRuntime$1, sr as pipe, st as context$1, t as GitService, tn as suspend$1, tr as isNone, tt as annotateSpans$1, u as NixDixError, un as unwrapScoped$1, ur as require_auth, ut as discard$1, v as decodeUnknown, vn as withTracerScoped, vr as __toCommonJS, vt as fiberRefLocallyScoped, w as redacted, wn as ConfigProviderTypeId$1, wt as fromEffect, x as value, xn as set, xt as flatMap$1, y as filter$2, yn as get, yr as __toESM, yt as fiberRefLocallyScopedWith$1, z as logWarning, zn as snakeCase$1, zt as mergeAll$1 } from "./assets/git-D6XTKqCz.js";
import * as os from "os";
import * as crypto$1 from "crypto";
import * as nodePath$1 from "path";
import * as fs from "fs/promises";
import * as nodePath from "node:path";
const setConfigProvider$1 = (configProvider) => scopedDiscard$1(withConfigProviderScoped(configProvider));
const merge$1 = merge$2;
const mergeAll = mergeAll$1;
const setConfigProvider = setConfigProvider$1;
const fromEnv = fromEnv$1;
const fromMap = fromMap$1;
const orElse = orElse$3;
var import_core$2 = /* @__PURE__ */ __toESM(require_core$1(), 1);
var import_exec = /* @__PURE__ */ __toESM(require_exec(), 1);
var execNix = (args, ignoreReturnCode = true) => {
	const stdoutChunks = [];
	const stderrChunks = [];
	return tryPromise({
		try: () => import_exec.exec("nix", args, {
			listeners: {
				stdout: (data) => {
					stdoutChunks.push(data.toString());
				},
				stderr: (data) => {
					stderrChunks.push(data.toString());
				}
			},
			ignoreReturnCode
		}),
		catch: (error) => error
	}).pipe(catchAll$2((error) => logWarning(`nix exec failed unexpectedly: ${error}`).pipe(as(-1))), map$4((exitCode) => ({
		exitCode,
		stdout: stdoutChunks.join("").trim(),
		stderr: stderrChunks.join("").trim()
	})));
};
var execPrefetch = (flakeRef) => tryPromise({
	try: () => import_exec.exec("nix", [
		"flake",
		"prefetch-inputs",
		flakeRef
	], {
		ignoreReturnCode: true,
		listeners: { stderr: () => {} }
	}),
	catch: () => /* @__PURE__ */ new Error("prefetch failed")
}).pipe(orElseSucceed(() => 1));
var NixService = class extends Service()("NixService", { effect: gen(function* () {
	const prefetchLogged = yield* make$3(false);
	return {
		prefetchFlakeInputs: (flakeRef) => gen(function* () {
			if ((yield* execPrefetch(flakeRef)) !== 0) {
				if (!(yield* get(prefetchLogged))) {
					yield* set(prefetchLogged, true);
					yield* logInfo("Skipping parallel input fetch: nix flake prefetch-inputs requires Nix 2.31.0+");
				}
			}
		}),
		getNixPath: (flakeRef, build$2) => gen(function* () {
			if (build$2) {
				const buildResult = yield* execNix([
					"build",
					flakeRef,
					"--no-link"
				]);
				if (buildResult.exitCode !== 0) return yield* fail$2(new NixBuildError({
					flakeRef,
					message: buildResult.stderr || "unknown error"
				}));
			}
			const { exitCode, stdout, stderr } = yield* execNix(build$2 ? ["path-info", flakeRef] : [
				"path-info",
				"--derivation",
				flakeRef
			]);
			if (exitCode !== 0) return yield* fail$2(new NixPathInfoError({
				flakeRef,
				message: stderr || "unknown error"
			}));
			if (!stdout) return yield* fail$2(new NixPathInfoError({
				flakeRef,
				message: "nix path-info returned empty output"
			}));
			return stdout;
		}),
		getDixDiff: (basePath, prPath, inputsFromPath) => gen(function* () {
			const { exitCode, stdout, stderr } = yield* execNix([
				"run",
				"nixpkgs#dix",
				"--inputs-from",
				`path:${inputsFromPath}`,
				"--",
				basePath,
				prPath
			]);
			if (exitCode !== 0) return yield* fail$2(new NixDixError({
				basePath,
				prPath,
				message: stderr || "dix failed with no error message"
			}));
			if (stderr) yield* logInfo(`dix stderr: ${stderr}`);
			return stdout;
		})
	};
}) }) {};
var require_context = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Context = void 0;
	var fs_1$1 = __require("fs");
	var os_1$1 = __require("os");
	var Context = class {
		constructor() {
			var _a, _b, _c;
			this.payload = {};
			if (process.env.GITHUB_EVENT_PATH) if ((0, fs_1$1.existsSync)(process.env.GITHUB_EVENT_PATH)) this.payload = JSON.parse((0, fs_1$1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
			else {
				const path$5 = process.env.GITHUB_EVENT_PATH;
				process.stdout.write(`GITHUB_EVENT_PATH ${path$5} does not exist${os_1$1.EOL}`);
			}
			this.eventName = process.env.GITHUB_EVENT_NAME;
			this.sha = process.env.GITHUB_SHA;
			this.ref = process.env.GITHUB_REF;
			this.workflow = process.env.GITHUB_WORKFLOW;
			this.action = process.env.GITHUB_ACTION;
			this.actor = process.env.GITHUB_ACTOR;
			this.job = process.env.GITHUB_JOB;
			this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10);
			this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
			this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
			this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
			this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
			this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
		}
		get issue() {
			const payload = this.payload;
			return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
		}
		get repo() {
			if (process.env.GITHUB_REPOSITORY) {
				const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
				return {
					owner,
					repo
				};
			}
			if (this.payload.repository) return {
				owner: this.payload.repository.owner.login,
				repo: this.payload.repository.name
			};
			throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
		}
	};
	exports.Context = Context;
}));
var require_proxy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkBypass = exports.getProxyUrl = void 0;
	function getProxyUrl(reqUrl) {
		const usingSsl = reqUrl.protocol === "https:";
		if (checkBypass(reqUrl)) return;
		const proxyVar = (() => {
			if (usingSsl) return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
			else return process.env["http_proxy"] || process.env["HTTP_PROXY"];
		})();
		if (proxyVar) try {
			return new DecodedURL(proxyVar);
		} catch (_a) {
			if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://")) return new DecodedURL(`http://${proxyVar}`);
		}
		else return;
	}
	exports.getProxyUrl = getProxyUrl;
	function checkBypass(reqUrl) {
		if (!reqUrl.hostname) return false;
		const reqHost = reqUrl.hostname;
		if (isLoopbackAddress(reqHost)) return true;
		const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
		if (!noProxy) return false;
		let reqPort;
		if (reqUrl.port) reqPort = Number(reqUrl.port);
		else if (reqUrl.protocol === "http:") reqPort = 80;
		else if (reqUrl.protocol === "https:") reqPort = 443;
		const upperReqHosts = [reqUrl.hostname.toUpperCase()];
		if (typeof reqPort === "number") upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
		for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) return true;
		return false;
	}
	exports.checkBypass = checkBypass;
	function isLoopbackAddress(host) {
		const hostLower = host.toLowerCase();
		return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
	}
	var DecodedURL = class extends URL {
		constructor(url, base) {
			super(url, base);
			this._decodedUsername = decodeURIComponent(super.username);
			this._decodedPassword = decodeURIComponent(super.password);
		}
		get username() {
			return this._decodedUsername;
		}
		get password() {
			return this._decodedPassword;
		}
	};
}));
var require_lib$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
	var http$2 = __importStar(__require("http"));
	var https$1 = __importStar(__require("https"));
	var pm = __importStar(require_proxy());
	var tunnel = __importStar(require_tunnel());
	var undici_1 = require_undici();
	var HttpCodes;
	(function(HttpCodes) {
		HttpCodes[HttpCodes["OK"] = 200] = "OK";
		HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
		HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
		HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
		HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
		HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
		HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
		HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
		HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
		HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
		HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
		HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
		HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
		HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
		HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
		HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
		HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
		HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
		HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
		HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
		HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
		HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
		HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
		HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
		HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
		HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
		HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
	var Headers;
	(function(Headers) {
		Headers["Accept"] = "accept";
		Headers["ContentType"] = "content-type";
	})(Headers || (exports.Headers = Headers = {}));
	var MediaTypes;
	(function(MediaTypes) {
		MediaTypes["ApplicationJson"] = "application/json";
	})(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
	function getProxyUrl(serverUrl) {
		const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
		return proxyUrl ? proxyUrl.href : "";
	}
	exports.getProxyUrl = getProxyUrl;
	var HttpRedirectCodes = [
		HttpCodes.MovedPermanently,
		HttpCodes.ResourceMoved,
		HttpCodes.SeeOther,
		HttpCodes.TemporaryRedirect,
		HttpCodes.PermanentRedirect
	];
	var HttpResponseRetryCodes = [
		HttpCodes.BadGateway,
		HttpCodes.ServiceUnavailable,
		HttpCodes.GatewayTimeout
	];
	var RetryableHttpVerbs = [
		"OPTIONS",
		"GET",
		"DELETE",
		"HEAD"
	];
	var ExponentialBackoffCeiling = 10;
	var ExponentialBackoffTimeSlice = 5;
	var HttpClientError = class HttpClientError extends Error {
		constructor(message, statusCode) {
			super(message);
			this.name = "HttpClientError";
			this.statusCode = statusCode;
			Object.setPrototypeOf(this, HttpClientError.prototype);
		}
	};
	exports.HttpClientError = HttpClientError;
	var HttpClientResponse = class {
		constructor(message) {
			this.message = message;
		}
		readBody() {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve$1) => __awaiter(this, void 0, void 0, function* () {
					let output = Buffer.alloc(0);
					this.message.on("data", (chunk) => {
						output = Buffer.concat([output, chunk]);
					});
					this.message.on("end", () => {
						resolve$1(output.toString());
					});
				}));
			});
		}
		readBodyBuffer() {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve$1) => __awaiter(this, void 0, void 0, function* () {
					const chunks = [];
					this.message.on("data", (chunk) => {
						chunks.push(chunk);
					});
					this.message.on("end", () => {
						resolve$1(Buffer.concat(chunks));
					});
				}));
			});
		}
	};
	exports.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
		return new URL(requestUrl).protocol === "https:";
	}
	exports.isHttps = isHttps;
	var HttpClient = class {
		constructor(userAgent$1, handlers, requestOptions) {
			this._ignoreSslError = false;
			this._allowRedirects = true;
			this._allowRedirectDowngrade = false;
			this._maxRedirects = 50;
			this._allowRetries = false;
			this._maxRetries = 1;
			this._keepAlive = false;
			this._disposed = false;
			this.userAgent = userAgent$1;
			this.handlers = handlers || [];
			this.requestOptions = requestOptions;
			if (requestOptions) {
				if (requestOptions.ignoreSslError != null) this._ignoreSslError = requestOptions.ignoreSslError;
				this._socketTimeout = requestOptions.socketTimeout;
				if (requestOptions.allowRedirects != null) this._allowRedirects = requestOptions.allowRedirects;
				if (requestOptions.allowRedirectDowngrade != null) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
				if (requestOptions.maxRedirects != null) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
				if (requestOptions.keepAlive != null) this._keepAlive = requestOptions.keepAlive;
				if (requestOptions.allowRetries != null) this._allowRetries = requestOptions.allowRetries;
				if (requestOptions.maxRetries != null) this._maxRetries = requestOptions.maxRetries;
			}
		}
		options(requestUrl, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
			});
		}
		get(requestUrl, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("GET", requestUrl, null, additionalHeaders || {});
			});
		}
		del(requestUrl, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("DELETE", requestUrl, null, additionalHeaders || {});
			});
		}
		post(requestUrl, data, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("POST", requestUrl, data, additionalHeaders || {});
			});
		}
		patch(requestUrl, data, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("PATCH", requestUrl, data, additionalHeaders || {});
			});
		}
		put(requestUrl, data, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("PUT", requestUrl, data, additionalHeaders || {});
			});
		}
		head(requestUrl, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request("HEAD", requestUrl, null, additionalHeaders || {});
			});
		}
		sendStream(verb, requestUrl, stream$5, additionalHeaders) {
			return __awaiter(this, void 0, void 0, function* () {
				return this.request(verb, requestUrl, stream$5, additionalHeaders);
			});
		}
		getJson(requestUrl, additionalHeaders = {}) {
			return __awaiter(this, void 0, void 0, function* () {
				additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
				const res = yield this.get(requestUrl, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		postJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.post(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		putJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.put(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		patchJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.patch(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		request(verb, requestUrl, data, headers) {
			return __awaiter(this, void 0, void 0, function* () {
				if (this._disposed) throw new Error("Client has already been disposed.");
				const parsedUrl = new URL(requestUrl);
				let info = this._prepareRequest(verb, parsedUrl, headers);
				const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
				let numTries = 0;
				let response;
				do {
					response = yield this.requestRaw(info, data);
					if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
						let authenticationHandler;
						for (const handler$1 of this.handlers) if (handler$1.canHandleAuthentication(response)) {
							authenticationHandler = handler$1;
							break;
						}
						if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info, data);
						else return response;
					}
					let redirectsRemaining = this._maxRedirects;
					while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
						const redirectUrl = response.message.headers["location"];
						if (!redirectUrl) break;
						const parsedRedirectUrl = new URL(redirectUrl);
						if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
						yield response.readBody();
						if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
							for (const header in headers) if (header.toLowerCase() === "authorization") delete headers[header];
						}
						info = this._prepareRequest(verb, parsedRedirectUrl, headers);
						response = yield this.requestRaw(info, data);
						redirectsRemaining--;
					}
					if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) return response;
					numTries += 1;
					if (numTries < maxTries) {
						yield response.readBody();
						yield this._performExponentialBackoff(numTries);
					}
				} while (numTries < maxTries);
				return response;
			});
		}
		dispose() {
			if (this._agent) this._agent.destroy();
			this._disposed = true;
		}
		requestRaw(info, data) {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve$1, reject$3) => {
					function callbackForResult(err, res) {
						if (err) reject$3(err);
						else if (!res) reject$3(/* @__PURE__ */ new Error("Unknown error"));
						else resolve$1(res);
					}
					this.requestRawWithCallback(info, data, callbackForResult);
				});
			});
		}
		requestRawWithCallback(info, data, onResult) {
			if (typeof data === "string") {
				if (!info.options.headers) info.options.headers = {};
				info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
			}
			let callbackCalled = false;
			function handleResult(err, res) {
				if (!callbackCalled) {
					callbackCalled = true;
					onResult(err, res);
				}
			}
			const req = info.httpModule.request(info.options, (msg) => {
				handleResult(void 0, new HttpClientResponse(msg));
			});
			let socket;
			req.on("socket", (sock) => {
				socket = sock;
			});
			req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
				if (socket) socket.end();
				handleResult(/* @__PURE__ */ new Error(`Request timeout: ${info.options.path}`));
			});
			req.on("error", function(err) {
				handleResult(err);
			});
			if (data && typeof data === "string") req.write(data, "utf8");
			if (data && typeof data !== "string") {
				data.on("close", function() {
					req.end();
				});
				data.pipe(req);
			} else req.end();
		}
		getAgent(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			return this._getAgent(parsedUrl);
		}
		getAgentDispatcher(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			if (!(proxyUrl && proxyUrl.hostname)) return;
			return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
		}
		_prepareRequest(method, requestUrl, headers) {
			const info = {};
			info.parsedUrl = requestUrl;
			const usingSsl = info.parsedUrl.protocol === "https:";
			info.httpModule = usingSsl ? https$1 : http$2;
			const defaultPort = usingSsl ? 443 : 80;
			info.options = {};
			info.options.host = info.parsedUrl.hostname;
			info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
			info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
			info.options.method = method;
			info.options.headers = this._mergeHeaders(headers);
			if (this.userAgent != null) info.options.headers["user-agent"] = this.userAgent;
			info.options.agent = this._getAgent(info.parsedUrl);
			if (this.handlers) for (const handler$1 of this.handlers) handler$1.prepareRequest(info.options);
			return info;
		}
		_mergeHeaders(headers) {
			if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
			return lowercaseKeys(headers || {});
		}
		_getExistingOrDefaultHeader(additionalHeaders, header, _default) {
			let clientHeader;
			if (this.requestOptions && this.requestOptions.headers) clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
			return additionalHeaders[header] || clientHeader || _default;
		}
		_getAgent(parsedUrl) {
			let agent;
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			const useProxy = proxyUrl && proxyUrl.hostname;
			if (this._keepAlive && useProxy) agent = this._proxyAgent;
			if (!useProxy) agent = this._agent;
			if (agent) return agent;
			const usingSsl = parsedUrl.protocol === "https:";
			let maxSockets = 100;
			if (this.requestOptions) maxSockets = this.requestOptions.maxSockets || http$2.globalAgent.maxSockets;
			if (proxyUrl && proxyUrl.hostname) {
				const agentOptions = {
					maxSockets,
					keepAlive: this._keepAlive,
					proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && { proxyAuth: `${proxyUrl.username}:${proxyUrl.password}` }), {
						host: proxyUrl.hostname,
						port: proxyUrl.port
					})
				};
				let tunnelAgent;
				const overHttps = proxyUrl.protocol === "https:";
				if (usingSsl) tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
				else tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
				agent = tunnelAgent(agentOptions);
				this._proxyAgent = agent;
			}
			if (!agent) {
				const options = {
					keepAlive: this._keepAlive,
					maxSockets
				};
				agent = usingSsl ? new https$1.Agent(options) : new http$2.Agent(options);
				this._agent = agent;
			}
			if (usingSsl && this._ignoreSslError) agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
			return agent;
		}
		_getProxyAgentDispatcher(parsedUrl, proxyUrl) {
			let proxyAgent;
			if (this._keepAlive) proxyAgent = this._proxyAgentDispatcher;
			if (proxyAgent) return proxyAgent;
			const usingSsl = parsedUrl.protocol === "https:";
			proxyAgent = new undici_1.ProxyAgent(Object.assign({
				uri: proxyUrl.href,
				pipelining: !this._keepAlive ? 0 : 1
			}, (proxyUrl.username || proxyUrl.password) && { token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}` }));
			this._proxyAgentDispatcher = proxyAgent;
			if (usingSsl && this._ignoreSslError) proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, { rejectUnauthorized: false });
			return proxyAgent;
		}
		_performExponentialBackoff(retryNumber) {
			return __awaiter(this, void 0, void 0, function* () {
				retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
				const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
				return new Promise((resolve$1) => setTimeout(() => resolve$1(), ms));
			});
		}
		_processResponse(res, options) {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve$1, reject$3) => __awaiter(this, void 0, void 0, function* () {
					const statusCode = res.message.statusCode || 0;
					const response = {
						statusCode,
						result: null,
						headers: {}
					};
					if (statusCode === HttpCodes.NotFound) resolve$1(response);
					function dateTimeDeserializer(key, value$1) {
						if (typeof value$1 === "string") {
							const a = new Date(value$1);
							if (!isNaN(a.valueOf())) return a;
						}
						return value$1;
					}
					let obj;
					let contents;
					try {
						contents = yield res.readBody();
						if (contents && contents.length > 0) {
							if (options && options.deserializeDates) obj = JSON.parse(contents, dateTimeDeserializer);
							else obj = JSON.parse(contents);
							response.result = obj;
						}
						response.headers = res.message.headers;
					} catch (err) {}
					if (statusCode > 299) {
						let msg;
						if (obj && obj.message) msg = obj.message;
						else if (contents && contents.length > 0) msg = contents;
						else msg = `Failed request: (${statusCode})`;
						const err = new HttpClientError(msg, statusCode);
						err.result = response.result;
						reject$3(err);
					} else resolve$1(response);
				}));
			});
		}
	};
	exports.HttpClient = HttpClient;
	var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
}));
var require_utils$4 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = void 0;
	var httpClient = __importStar(require_lib$1());
	var undici_1 = require_undici();
	function getAuthString(token, options) {
		if (!token && !options.auth) throw new Error("Parameter token or opts.auth is required");
		else if (token && options.auth) throw new Error("Parameters token and opts.auth may not both be specified");
		return typeof options.auth === "string" ? options.auth : `token ${token}`;
	}
	exports.getAuthString = getAuthString;
	function getProxyAgent(destinationUrl) {
		return new httpClient.HttpClient().getAgent(destinationUrl);
	}
	exports.getProxyAgent = getProxyAgent;
	function getProxyAgentDispatcher(destinationUrl) {
		return new httpClient.HttpClient().getAgentDispatcher(destinationUrl);
	}
	exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
	function getProxyFetch(destinationUrl) {
		const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
		const proxyFetch = (url, opts) => __awaiter(this, void 0, void 0, function* () {
			return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
		});
		return proxyFetch;
	}
	exports.getProxyFetch = getProxyFetch;
	function getApiBaseUrl() {
		return process.env["GITHUB_API_URL"] || "https://api.github.com";
	}
	exports.getApiBaseUrl = getApiBaseUrl;
}));
function getUserAgent() {
	if (typeof navigator === "object" && "userAgent" in navigator) return navigator.userAgent;
	if (typeof process === "object" && process.version !== void 0) return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
	return "<environment undetectable>";
}
var init_dist_web$6 = __esmMin((() => {}));
var require_register = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = register;
	function register(state, name$1, method, options) {
		if (typeof method !== "function") throw new Error("method for before hook must be a function");
		if (!options) options = {};
		if (Array.isArray(name$1)) return name$1.reverse().reduce(function(callback, name$2) {
			return register.bind(null, state, name$2, callback, options);
		}, method)();
		return Promise.resolve().then(function() {
			if (!state.registry[name$1]) return method(options);
			return state.registry[name$1].reduce(function(method$1, registered) {
				return registered.hook.bind(null, method$1, options);
			}, method)();
		});
	}
}));
var require_add = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = addHook;
	function addHook(state, kind, name$1, hook$1) {
		var orig = hook$1;
		if (!state.registry[name$1]) state.registry[name$1] = [];
		if (kind === "before") hook$1 = function(method, options) {
			return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
		};
		if (kind === "after") hook$1 = function(method, options) {
			var result;
			return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
				result = result_;
				return orig(result, options);
			}).then(function() {
				return result;
			});
		};
		if (kind === "error") hook$1 = function(method, options) {
			return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
				return orig(error, options);
			});
		};
		state.registry[name$1].push({
			hook: hook$1,
			orig
		});
	}
}));
var require_remove = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = removeHook;
	function removeHook(state, name$1, method) {
		if (!state.registry[name$1]) return;
		var index$1 = state.registry[name$1].map(function(registered) {
			return registered.orig;
		}).indexOf(method);
		if (index$1 === -1) return;
		state.registry[name$1].splice(index$1, 1);
	}
}));
var require_before_after_hook = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var register = require_register();
	var addHook = require_add();
	var removeHook = require_remove();
	var bind = Function.bind;
	var bindable = bind.bind(bind);
	function bindApi(hook$1, state, name$1) {
		var removeHookRef = bindable(removeHook, null).apply(null, name$1 ? [state, name$1] : [state]);
		hook$1.api = { remove: removeHookRef };
		hook$1.remove = removeHookRef;
		[
			"before",
			"error",
			"after",
			"wrap"
		].forEach(function(kind) {
			var args = name$1 ? [
				state,
				kind,
				name$1
			] : [state, kind];
			hook$1[kind] = hook$1.api[kind] = bindable(addHook, null).apply(null, args);
		});
	}
	function HookSingular() {
		var singularHookName = "h";
		var singularHookState = { registry: {} };
		var singularHook = register.bind(null, singularHookState, singularHookName);
		bindApi(singularHook, singularHookState, singularHookName);
		return singularHook;
	}
	function HookCollection() {
		var state = { registry: {} };
		var hook$1 = register.bind(null, state);
		bindApi(hook$1, state);
		return hook$1;
	}
	var collectionHookDeprecationMessageDisplayed = false;
	function Hook() {
		if (!collectionHookDeprecationMessageDisplayed) {
			console.warn("[before-after-hook]: \"Hook()\" repurposing warning, use \"Hook.Collection()\". Read more: https://git.io/upgrade-before-after-hook-to-1.4");
			collectionHookDeprecationMessageDisplayed = true;
		}
		return HookCollection();
	}
	Hook.Singular = HookSingular.bind();
	Hook.Collection = HookCollection.bind();
	module.exports = Hook;
	module.exports.Hook = Hook;
	module.exports.Singular = Hook.Singular;
	module.exports.Collection = Hook.Collection;
}));
var VERSION$7;
var init_version$2 = __esmMin((() => {
	VERSION$7 = "9.0.6";
}));
var userAgent, DEFAULTS;
var init_defaults = __esmMin((() => {
	init_dist_web$6();
	init_version$2();
	userAgent = `octokit-endpoint.js/${VERSION$7} ${getUserAgent()}`;
	DEFAULTS = {
		method: "GET",
		baseUrl: "https://api.github.com",
		headers: {
			accept: "application/vnd.github.v3+json",
			"user-agent": userAgent
		},
		mediaType: { format: "" }
	};
}));
function lowercaseKeys(object) {
	if (!object) return {};
	return Object.keys(object).reduce((newObj, key) => {
		newObj[key.toLowerCase()] = object[key];
		return newObj;
	}, {});
}
var init_lowercase_keys = __esmMin((() => {}));
function isPlainObject$1(value$1) {
	if (typeof value$1 !== "object" || value$1 === null) return false;
	if (Object.prototype.toString.call(value$1) !== "[object Object]") return false;
	const proto = Object.getPrototypeOf(value$1);
	if (proto === null) return true;
	const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
	return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value$1);
}
var init_is_plain_object$1 = __esmMin((() => {}));
function mergeDeep(defaults, options) {
	const result = Object.assign({}, defaults);
	Object.keys(options).forEach((key) => {
		if (isPlainObject$1(options[key])) if (!(key in defaults)) Object.assign(result, { [key]: options[key] });
		else result[key] = mergeDeep(defaults[key], options[key]);
		else Object.assign(result, { [key]: options[key] });
	});
	return result;
}
var init_merge_deep = __esmMin((() => {
	init_is_plain_object$1();
}));
function removeUndefinedProperties(obj) {
	for (const key in obj) if (obj[key] === void 0) delete obj[key];
	return obj;
}
var init_remove_undefined_properties = __esmMin((() => {}));
function merge(defaults, route, options) {
	if (typeof route === "string") {
		let [method, url] = route.split(" ");
		options = Object.assign(url ? {
			method,
			url
		} : { url: method }, options);
	} else options = Object.assign({}, route);
	options.headers = lowercaseKeys(options.headers);
	removeUndefinedProperties(options);
	removeUndefinedProperties(options.headers);
	const mergedOptions = mergeDeep(defaults || {}, options);
	if (options.url === "/graphql") {
		if (defaults && defaults.mediaType.previews?.length) mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview$1) => !mergedOptions.mediaType.previews.includes(preview$1)).concat(mergedOptions.mediaType.previews);
		mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview$1) => preview$1.replace(/-preview/, ""));
	}
	return mergedOptions;
}
var init_merge = __esmMin((() => {
	init_lowercase_keys();
	init_merge_deep();
	init_remove_undefined_properties();
}));
function addQueryParameters(url, parameters) {
	const separator = /\?/.test(url) ? "&" : "?";
	const names = Object.keys(parameters);
	if (names.length === 0) return url;
	return url + separator + names.map((name$1) => {
		if (name$1 === "q") return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
		return `${name$1}=${encodeURIComponent(parameters[name$1])}`;
	}).join("&");
}
var init_add_query_parameters = __esmMin((() => {}));
function removeNonChars(variableName) {
	return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
	const matches = url.match(urlVariableRegex);
	if (!matches) return [];
	return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
var urlVariableRegex;
var init_extract_url_variable_names = __esmMin((() => {
	urlVariableRegex = /\{[^{}}]+\}/g;
}));
function omit(object, keysToOmit) {
	const result = { __proto__: null };
	for (const key of Object.keys(object)) if (keysToOmit.indexOf(key) === -1) result[key] = object[key];
	return result;
}
var init_omit = __esmMin((() => {}));
function encodeReserved(str) {
	return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
		if (!/%[0-9A-Fa-f]/.test(part)) part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
		return part;
	}).join("");
}
function encodeUnreserved(str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
		return "%" + c.charCodeAt(0).toString(16).toUpperCase();
	});
}
function encodeValue(operator, value$1, key) {
	value$1 = operator === "+" || operator === "#" ? encodeReserved(value$1) : encodeUnreserved(value$1);
	if (key) return encodeUnreserved(key) + "=" + value$1;
	else return value$1;
}
function isDefined(value$1) {
	return value$1 !== void 0 && value$1 !== null;
}
function isKeyOperator(operator) {
	return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context$2, operator, key, modifier) {
	var value$1 = context$2[key], result = [];
	if (isDefined(value$1) && value$1 !== "") if (typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean") {
		value$1 = value$1.toString();
		if (modifier && modifier !== "*") value$1 = value$1.substring(0, parseInt(modifier, 10));
		result.push(encodeValue(operator, value$1, isKeyOperator(operator) ? key : ""));
	} else if (modifier === "*") if (Array.isArray(value$1)) value$1.filter(isDefined).forEach(function(value2) {
		result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
	});
	else Object.keys(value$1).forEach(function(k) {
		if (isDefined(value$1[k])) result.push(encodeValue(operator, value$1[k], k));
	});
	else {
		const tmp = [];
		if (Array.isArray(value$1)) value$1.filter(isDefined).forEach(function(value2) {
			tmp.push(encodeValue(operator, value2));
		});
		else Object.keys(value$1).forEach(function(k) {
			if (isDefined(value$1[k])) {
				tmp.push(encodeUnreserved(k));
				tmp.push(encodeValue(operator, value$1[k].toString()));
			}
		});
		if (isKeyOperator(operator)) result.push(encodeUnreserved(key) + "=" + tmp.join(","));
		else if (tmp.length !== 0) result.push(tmp.join(","));
	}
	else if (operator === ";") {
		if (isDefined(value$1)) result.push(encodeUnreserved(key));
	} else if (value$1 === "" && (operator === "&" || operator === "?")) result.push(encodeUnreserved(key) + "=");
	else if (value$1 === "") result.push("");
	return result;
}
function parseUrl(template) {
	return { expand: expand.bind(null, template) };
}
function expand(template, context$2) {
	var operators = [
		"+",
		"#",
		".",
		"/",
		";",
		"?",
		"&"
	];
	template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_$1, expression, literal) {
		if (expression) {
			let operator = "";
			const values = [];
			if (operators.indexOf(expression.charAt(0)) !== -1) {
				operator = expression.charAt(0);
				expression = expression.substr(1);
			}
			expression.split(/,/g).forEach(function(variable) {
				var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
				values.push(getValues(context$2, operator, tmp[1], tmp[2] || tmp[3]));
			});
			if (operator && operator !== "+") {
				var separator = ",";
				if (operator === "?") separator = "&";
				else if (operator !== "#") separator = operator;
				return (values.length !== 0 ? operator : "") + values.join(separator);
			} else return values.join(",");
		} else return encodeReserved(literal);
	});
	if (template === "/") return template;
	else return template.replace(/\/$/, "");
}
var init_url_template = __esmMin((() => {}));
function parse(options) {
	let method = options.method.toUpperCase();
	let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
	let headers = Object.assign({}, options.headers);
	let body;
	let parameters = omit(options, [
		"method",
		"baseUrl",
		"url",
		"headers",
		"request",
		"mediaType"
	]);
	const urlVariableNames = extractUrlVariableNames(url);
	url = parseUrl(url).expand(parameters);
	if (!/^http/.test(url)) url = options.baseUrl + url;
	const remainingParameters = omit(parameters, Object.keys(options).filter((option$1) => urlVariableNames.includes(option$1)).concat("baseUrl"));
	if (!/application\/octet-stream/i.test(headers.accept)) {
		if (options.mediaType.format) headers.accept = headers.accept.split(/,/).map((format) => format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
		if (url.endsWith("/graphql")) {
			if (options.mediaType.previews?.length) headers.accept = (headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || []).concat(options.mediaType.previews).map((preview$1) => {
				return `application/vnd.github.${preview$1}-preview${options.mediaType.format ? `.${options.mediaType.format}` : "+json"}`;
			}).join(",");
		}
	}
	if (["GET", "HEAD"].includes(method)) url = addQueryParameters(url, remainingParameters);
	else if ("data" in remainingParameters) body = remainingParameters.data;
	else if (Object.keys(remainingParameters).length) body = remainingParameters;
	if (!headers["content-type"] && typeof body !== "undefined") headers["content-type"] = "application/json; charset=utf-8";
	if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") body = "";
	return Object.assign({
		method,
		url,
		headers
	}, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
var init_parse = __esmMin((() => {
	init_add_query_parameters();
	init_extract_url_variable_names();
	init_omit();
	init_url_template();
}));
function endpointWithDefaults(defaults, route, options) {
	return parse(merge(defaults, route, options));
}
var init_endpoint_with_defaults = __esmMin((() => {
	init_merge();
	init_parse();
}));
function withDefaults$2(oldDefaults, newDefaults) {
	const DEFAULTS$1 = merge(oldDefaults, newDefaults);
	const endpoint$1 = endpointWithDefaults.bind(null, DEFAULTS$1);
	return Object.assign(endpoint$1, {
		DEFAULTS: DEFAULTS$1,
		defaults: withDefaults$2.bind(null, DEFAULTS$1),
		merge: merge.bind(null, DEFAULTS$1),
		parse
	});
}
var init_with_defaults$1 = __esmMin((() => {
	init_endpoint_with_defaults();
	init_merge();
	init_parse();
}));
var endpoint;
var init_dist_src$4 = __esmMin((() => {
	init_with_defaults$1();
	init_defaults();
	endpoint = withDefaults$2(null, DEFAULTS);
}));
var VERSION$6;
var init_version$1 = __esmMin((() => {
	VERSION$6 = "8.4.1";
}));
function isPlainObject(value$1) {
	if (typeof value$1 !== "object" || value$1 === null) return false;
	if (Object.prototype.toString.call(value$1) !== "[object Object]") return false;
	const proto = Object.getPrototypeOf(value$1);
	if (proto === null) return true;
	const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
	return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value$1);
}
var init_is_plain_object = __esmMin((() => {}));
var Deprecation;
var init_dist_web$5 = __esmMin((() => {
	Deprecation = class extends Error {
		constructor(message) {
			super(message);
			/* istanbul ignore next */
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			this.name = "Deprecation";
		}
	};
}));
var require_wrappy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = wrappy;
	function wrappy(fn, cb) {
		if (fn && cb) return wrappy(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i = 0; i < args.length; i++) args[i] = arguments[i];
			var ret = fn.apply(this, args);
			var cb$1 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb$1) Object.keys(cb$1).forEach(function(k) {
				ret[k] = cb$1[k];
			});
			return ret;
		}
	}
}));
var require_once = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var wrappy = require_wrappy();
	module.exports = wrappy(once);
	module.exports.strict = wrappy(onceStrict);
	once.proto = once(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once(fn) {
		var f = function() {
			if (f.called) return f.value;
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.called = false;
		return f;
	}
	function onceStrict(fn) {
		var f = function() {
			if (f.called) throw new Error(f.onceError);
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.onceError = (fn.name || "Function wrapped with `once`") + " shouldn't be called more than once";
		f.called = false;
		return f;
	}
}));
var import_once, logOnceCode, logOnceHeaders, RequestError;
var init_dist_src$3 = __esmMin((() => {
	init_dist_web$5();
	import_once = /* @__PURE__ */ __toESM(require_once());
	logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
	logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
	RequestError = class extends Error {
		constructor(message, statusCode, options) {
			super(message);
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			this.name = "HttpError";
			this.status = statusCode;
			let headers;
			if ("headers" in options && typeof options.headers !== "undefined") headers = options.headers;
			if ("response" in options) {
				this.response = options.response;
				headers = options.response.headers;
			}
			const requestCopy = Object.assign({}, options.request);
			if (options.request.headers.authorization) requestCopy.headers = Object.assign({}, options.request.headers, { authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]") });
			requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
			this.request = requestCopy;
			Object.defineProperty(this, "code", { get() {
				logOnceCode(new Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
				return statusCode;
			} });
			Object.defineProperty(this, "headers", { get() {
				logOnceHeaders(new Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
				return headers || {};
			} });
		}
	};
}));
function getBufferResponse(response) {
	return response.arrayBuffer();
}
var init_get_buffer_response = __esmMin((() => {}));
function fetchWrapper(requestOptions) {
	const log$1 = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
	const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
	if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) requestOptions.body = JSON.stringify(requestOptions.body);
	let headers = {};
	let status;
	let url;
	let { fetch } = globalThis;
	if (requestOptions.request?.fetch) fetch = requestOptions.request.fetch;
	if (!fetch) throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
	return fetch(requestOptions.url, {
		method: requestOptions.method,
		body: requestOptions.body,
		redirect: requestOptions.request?.redirect,
		headers: requestOptions.headers,
		signal: requestOptions.request?.signal,
		...requestOptions.body && { duplex: "half" }
	}).then(async (response) => {
		url = response.url;
		status = response.status;
		for (const keyAndValue of response.headers) headers[keyAndValue[0]] = keyAndValue[1];
		if ("deprecation" in headers) {
			const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
			const deprecationLink = matches && matches.pop();
			log$1.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
		}
		if (status === 204 || status === 205) return;
		if (requestOptions.method === "HEAD") {
			if (status < 400) return;
			throw new RequestError(response.statusText, status, {
				response: {
					url,
					status,
					headers,
					data: void 0
				},
				request: requestOptions
			});
		}
		if (status === 304) throw new RequestError("Not modified", status, {
			response: {
				url,
				status,
				headers,
				data: await getResponseData(response)
			},
			request: requestOptions
		});
		if (status >= 400) {
			const data = await getResponseData(response);
			throw new RequestError(toErrorMessage(data), status, {
				response: {
					url,
					status,
					headers,
					data
				},
				request: requestOptions
			});
		}
		return parseSuccessResponseBody ? await getResponseData(response) : response.body;
	}).then((data) => {
		return {
			status,
			url,
			headers,
			data
		};
	}).catch((error) => {
		if (error instanceof RequestError) throw error;
		else if (error.name === "AbortError") throw error;
		let message = error.message;
		if (error.name === "TypeError" && "cause" in error) {
			if (error.cause instanceof Error) message = error.cause.message;
			else if (typeof error.cause === "string") message = error.cause;
		}
		throw new RequestError(message, 500, { request: requestOptions });
	});
}
async function getResponseData(response) {
	const contentType = response.headers.get("content-type");
	if (/application\/json/.test(contentType)) return response.json().catch(() => response.text()).catch(() => "");
	if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) return response.text();
	return getBufferResponse(response);
}
function toErrorMessage(data) {
	if (typeof data === "string") return data;
	let suffix;
	if ("documentation_url" in data) suffix = ` - ${data.documentation_url}`;
	else suffix = "";
	if ("message" in data) {
		if (Array.isArray(data.errors)) return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
		return `${data.message}${suffix}`;
	}
	return `Unknown error: ${JSON.stringify(data)}`;
}
var init_fetch_wrapper = __esmMin((() => {
	init_is_plain_object();
	init_dist_src$3();
	init_get_buffer_response();
}));
function withDefaults$1(oldEndpoint, newDefaults) {
	const endpoint$1 = oldEndpoint.defaults(newDefaults);
	const newApi = function(route, parameters) {
		const endpointOptions = endpoint$1.merge(route, parameters);
		if (!endpointOptions.request || !endpointOptions.request.hook) return fetchWrapper(endpoint$1.parse(endpointOptions));
		const request$1 = (route2, parameters2) => {
			return fetchWrapper(endpoint$1.parse(endpoint$1.merge(route2, parameters2)));
		};
		Object.assign(request$1, {
			endpoint: endpoint$1,
			defaults: withDefaults$1.bind(null, endpoint$1)
		});
		return endpointOptions.request.hook(request$1, endpointOptions);
	};
	return Object.assign(newApi, {
		endpoint: endpoint$1,
		defaults: withDefaults$1.bind(null, endpoint$1)
	});
}
var init_with_defaults = __esmMin((() => {
	init_fetch_wrapper();
}));
var request;
var init_dist_src$2 = __esmMin((() => {
	init_dist_src$4();
	init_dist_web$6();
	init_version$1();
	init_with_defaults();
	request = withDefaults$1(endpoint, { headers: { "user-agent": `octokit-request.js/${VERSION$6} ${getUserAgent()}` } });
}));
function _buildMessageForResponseErrors(data) {
	return `Request failed due to following response errors:
` + data.errors.map((e$1) => ` - ${e$1.message}`).join("\n");
}
function graphql(request2, query, options) {
	if (options) {
		if (typeof query === "string" && "query" in options) return Promise.reject(/* @__PURE__ */ new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
		for (const key in options) {
			if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
			return Promise.reject(/* @__PURE__ */ new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
		}
	}
	const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
	const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
		if (NON_VARIABLE_OPTIONS.includes(key)) {
			result[key] = parsedOptions[key];
			return result;
		}
		if (!result.variables) result.variables = {};
		result.variables[key] = parsedOptions[key];
		return result;
	}, {});
	const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
	if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
	return request2(requestOptions).then((response) => {
		if (response.data.errors) {
			const headers = {};
			for (const key of Object.keys(response.headers)) headers[key] = response.headers[key];
			throw new GraphqlResponseError(requestOptions, headers, response.data);
		}
		return response.data.data;
	});
}
function withDefaults(request2, newDefaults) {
	const newRequest = request2.defaults(newDefaults);
	const newApi = (query, options) => {
		return graphql(newRequest, query, options);
	};
	return Object.assign(newApi, {
		defaults: withDefaults.bind(null, newRequest),
		endpoint: newRequest.endpoint
	});
}
function withCustomRequest(customRequest) {
	return withDefaults(customRequest, {
		method: "POST",
		url: "/graphql"
	});
}
var VERSION$5, GraphqlResponseError, NON_VARIABLE_OPTIONS, FORBIDDEN_VARIABLE_OPTIONS, GHES_V3_SUFFIX_REGEX;
var init_dist_web$4 = __esmMin((() => {
	init_dist_src$2();
	init_dist_web$6();
	VERSION$5 = "7.1.1";
	GraphqlResponseError = class extends Error {
		constructor(request2, headers, response) {
			super(_buildMessageForResponseErrors(response));
			this.request = request2;
			this.headers = headers;
			this.response = response;
			this.name = "GraphqlResponseError";
			this.errors = response.errors;
			this.data = response.data;
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
		}
	};
	NON_VARIABLE_OPTIONS = [
		"method",
		"baseUrl",
		"url",
		"headers",
		"request",
		"query",
		"mediaType"
	];
	FORBIDDEN_VARIABLE_OPTIONS = [
		"query",
		"method",
		"url"
	];
	GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
	withDefaults(request, {
		headers: { "user-agent": `octokit-graphql.js/${VERSION$5} ${getUserAgent()}` },
		method: "POST",
		url: "/graphql"
	});
}));
async function auth(token) {
	const isApp = token.split(/\./).length === 3;
	const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
	const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
	return {
		type: "token",
		token,
		tokenType: isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth"
	};
}
var REGEX_IS_INSTALLATION_LEGACY, REGEX_IS_INSTALLATION, REGEX_IS_USER_TO_SERVER;
var init_auth = __esmMin((() => {
	REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
	REGEX_IS_INSTALLATION = /^ghs_/;
	REGEX_IS_USER_TO_SERVER = /^ghu_/;
}));
function withAuthorizationPrefix(token) {
	if (token.split(/\./).length === 3) return `bearer ${token}`;
	return `token ${token}`;
}
var init_with_authorization_prefix = __esmMin((() => {}));
async function hook(token, request$1, route, parameters) {
	const endpoint$1 = request$1.endpoint.merge(route, parameters);
	endpoint$1.headers.authorization = withAuthorizationPrefix(token);
	return request$1(endpoint$1);
}
var init_hook = __esmMin((() => {
	init_with_authorization_prefix();
}));
var createTokenAuth;
var init_dist_src$1 = __esmMin((() => {
	init_auth();
	init_hook();
	createTokenAuth = function createTokenAuth2(token) {
		if (!token) throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
		if (typeof token !== "string") throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
		token = token.replace(/^(token|bearer) +/i, "");
		return Object.assign(auth.bind(null, token), { hook: hook.bind(null, token) });
	};
}));
var dist_web_exports$3 = /* @__PURE__ */ __export({ Octokit: () => Octokit }, 1);
function createLogger(logger = {}) {
	if (typeof logger.debug !== "function") logger.debug = noop;
	if (typeof logger.info !== "function") logger.info = noop;
	if (typeof logger.warn !== "function") logger.warn = consoleWarn;
	if (typeof logger.error !== "function") logger.error = consoleError;
	return logger;
}
var import_before_after_hook, VERSION$4, noop, consoleWarn, consoleError, userAgentTrail, Octokit;
var init_dist_web$3 = __esmMin((() => {
	init_dist_web$6();
	import_before_after_hook = require_before_after_hook();
	init_dist_src$2();
	init_dist_web$4();
	init_dist_src$1();
	VERSION$4 = "5.2.2";
	noop = () => {};
	consoleWarn = console.warn.bind(console);
	consoleError = console.error.bind(console);
	userAgentTrail = `octokit-core.js/${VERSION$4} ${getUserAgent()}`;
	Octokit = class {
		static {
			this.VERSION = VERSION$4;
		}
		static defaults(defaults) {
			const OctokitWithDefaults = class extends this {
				constructor(...args) {
					const options = args[0] || {};
					if (typeof defaults === "function") {
						super(defaults(options));
						return;
					}
					super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? { userAgent: `${options.userAgent} ${defaults.userAgent}` } : null));
				}
			};
			return OctokitWithDefaults;
		}
		static {
			this.plugins = [];
		}
		static plugin(...newPlugins) {
			const currentPlugins = this.plugins;
			const NewOctokit = class extends this {
				static {
					this.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
				}
			};
			return NewOctokit;
		}
		constructor(options = {}) {
			const hook$1 = new import_before_after_hook.Collection();
			const requestDefaults = {
				baseUrl: request.endpoint.DEFAULTS.baseUrl,
				headers: {},
				request: Object.assign({}, options.request, { hook: hook$1.bind(null, "request") }),
				mediaType: {
					previews: [],
					format: ""
				}
			};
			requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
			if (options.baseUrl) requestDefaults.baseUrl = options.baseUrl;
			if (options.previews) requestDefaults.mediaType.previews = options.previews;
			if (options.timeZone) requestDefaults.headers["time-zone"] = options.timeZone;
			this.request = request.defaults(requestDefaults);
			this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
			this.log = createLogger(options.log);
			this.hook = hook$1;
			if (!options.authStrategy) if (!options.auth) this.auth = async () => ({ type: "unauthenticated" });
			else {
				const auth$1 = createTokenAuth(options.auth);
				hook$1.wrap("request", auth$1.hook);
				this.auth = auth$1;
			}
			else {
				const { authStrategy, ...otherOptions } = options;
				const auth$1 = authStrategy(Object.assign({
					request: this.request,
					log: this.log,
					octokit: this,
					octokitOptions: otherOptions
				}, options.auth));
				hook$1.wrap("request", auth$1.hook);
				this.auth = auth$1;
			}
			const classConstructor = this.constructor;
			for (let i = 0; i < classConstructor.plugins.length; ++i) Object.assign(this, classConstructor.plugins[i](this, options));
		}
	};
}));
var VERSION$3;
var init_version = __esmMin((() => {
	VERSION$3 = "10.4.1";
}));
var endpoints_default;
var init_endpoints = __esmMin((() => {
	endpoints_default = {
		actions: {
			addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
			addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
			addSelectedRepoToOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
			approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
			cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
			createEnvironmentVariable: ["POST /repositories/{repository_id}/environments/{environment_name}/variables"],
			createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			createOrgVariable: ["POST /orgs/{org}/actions/variables"],
			createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
			createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
			createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
			createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
			createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
			createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
			deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
			deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
			deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
			deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			deleteEnvironmentVariable: ["DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
			deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			deleteRepoVariable: ["DELETE /repos/{owner}/{repo}/actions/variables/{name}"],
			deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
			deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
			deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
			deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
			disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
			disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
			downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
			downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
			downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
			downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
			enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
			enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
			forceCancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"],
			generateRunnerJitconfigForOrg: ["POST /orgs/{org}/actions/runners/generate-jitconfig"],
			generateRunnerJitconfigForRepo: ["POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"],
			getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
			getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
			getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
			getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
			getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
			getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
			getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
			getCustomOidcSubClaimForRepo: ["GET /repos/{owner}/{repo}/actions/oidc/customization/sub"],
			getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
			getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			getEnvironmentVariable: ["GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
			getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
			getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
			getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
			getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
			getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
			getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
			getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
			getRepoPermissions: [
				"GET /repos/{owner}/{repo}/actions/permissions",
				{},
				{ renamed: ["actions", "getGithubActionsPermissionsRepository"] }
			],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
			getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
			getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
			getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
			getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
			getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
			getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
			getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
			getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
			getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
			listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
			listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
			listEnvironmentVariables: ["GET /repositories/{repository_id}/environments/{environment_name}/variables"],
			listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
			listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
			listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
			listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
			listOrgVariables: ["GET /orgs/{org}/actions/variables"],
			listRepoOrganizationSecrets: ["GET /repos/{owner}/{repo}/actions/organization-secrets"],
			listRepoOrganizationVariables: ["GET /repos/{owner}/{repo}/actions/organization-variables"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
			listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
			listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
			listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
			listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
			listSelectedReposForOrgVariable: ["GET /orgs/{org}/actions/variables/{name}/repositories"],
			listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
			listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
			listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
			listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
			listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
			listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
			reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
			reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
			reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
			removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
			removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
			removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
			removeSelectedRepoFromOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
			reviewCustomGatesForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"],
			reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
			setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
			setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
			setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
			setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			setCustomOidcSubClaimForRepo: ["PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"],
			setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
			setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
			setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
			setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
			setSelectedReposForOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories"],
			setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
			setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"],
			updateEnvironmentVariable: ["PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
			updateRepoVariable: ["PATCH /repos/{owner}/{repo}/actions/variables/{name}"]
		},
		activity: {
			checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
			deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
			deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
			getFeeds: ["GET /feeds"],
			getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
			getThread: ["GET /notifications/threads/{thread_id}"],
			getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
			listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
			listNotificationsForAuthenticatedUser: ["GET /notifications"],
			listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
			listPublicEvents: ["GET /events"],
			listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
			listPublicEventsForUser: ["GET /users/{username}/events/public"],
			listPublicOrgEvents: ["GET /orgs/{org}/events"],
			listReceivedEventsForUser: ["GET /users/{username}/received_events"],
			listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
			listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
			listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
			listReposStarredByAuthenticatedUser: ["GET /user/starred"],
			listReposStarredByUser: ["GET /users/{username}/starred"],
			listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
			listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
			listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
			listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
			markNotificationsAsRead: ["PUT /notifications"],
			markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
			markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
			markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
			setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
			setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
			starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
			unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
		},
		apps: {
			addRepoToInstallation: [
				"PUT /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
			],
			addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
			checkToken: ["POST /applications/{client_id}/token"],
			createFromManifest: ["POST /app-manifests/{code}/conversions"],
			createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
			deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
			deleteInstallation: ["DELETE /app/installations/{installation_id}"],
			deleteToken: ["DELETE /applications/{client_id}/token"],
			getAuthenticated: ["GET /app"],
			getBySlug: ["GET /apps/{app_slug}"],
			getInstallation: ["GET /app/installations/{installation_id}"],
			getOrgInstallation: ["GET /orgs/{org}/installation"],
			getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
			getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
			getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
			getUserInstallation: ["GET /users/{username}/installation"],
			getWebhookConfigForApp: ["GET /app/hook/config"],
			getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
			listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
			listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
			listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
			listInstallationRequestsForAuthenticatedApp: ["GET /app/installation-requests"],
			listInstallations: ["GET /app/installations"],
			listInstallationsForAuthenticatedUser: ["GET /user/installations"],
			listPlans: ["GET /marketplace_listing/plans"],
			listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
			listReposAccessibleToInstallation: ["GET /installation/repositories"],
			listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
			listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
			listWebhookDeliveries: ["GET /app/hook/deliveries"],
			redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
			removeRepoFromInstallation: [
				"DELETE /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
			],
			removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
			resetToken: ["PATCH /applications/{client_id}/token"],
			revokeInstallationAccessToken: ["DELETE /installation/token"],
			scopeToken: ["POST /applications/{client_id}/token/scoped"],
			suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
			unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
			updateWebhookConfigForApp: ["PATCH /app/hook/config"]
		},
		billing: {
			getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
			getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
			getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
			getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
			getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
			getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
		},
		checks: {
			create: ["POST /repos/{owner}/{repo}/check-runs"],
			createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
			get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
			getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
			listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
			listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
			listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
			listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
			rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
			rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
			setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
			update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
		},
		codeScanning: {
			deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
			getAlert: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
				{},
				{ renamedParameters: { alert_id: "alert_number" } }
			],
			getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
			getCodeqlDatabase: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],
			getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
			getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
			listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
			listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
			listAlertsInstances: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
				{},
				{ renamed: ["codeScanning", "listAlertInstances"] }
			],
			listCodeqlDatabases: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases"],
			listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
			updateDefaultSetup: ["PATCH /repos/{owner}/{repo}/code-scanning/default-setup"],
			uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
		},
		codesOfConduct: {
			getAllCodesOfConduct: ["GET /codes_of_conduct"],
			getConductCode: ["GET /codes_of_conduct/{key}"]
		},
		codespaces: {
			addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			checkPermissionsForDevcontainer: ["GET /repos/{owner}/{repo}/codespaces/permissions_check"],
			codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
			createForAuthenticatedUser: ["POST /user/codespaces"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
			createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
			createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
			deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
			deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
			exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
			getCodespacesForUserInOrg: ["GET /orgs/{org}/members/{username}/codespaces"],
			getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
			getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
			getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
			getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
			listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
			listForAuthenticatedUser: ["GET /user/codespaces"],
			listInOrganization: [
				"GET /orgs/{org}/codespaces",
				{},
				{ renamedParameters: { org_id: "org" } }
			],
			listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
			listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
			listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
			listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
			preFlightWithRepoForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/new"],
			publishForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/publish"],
			removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
			setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
			startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
			stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
			stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
			updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
		},
		copilot: {
			addCopilotSeatsForTeams: ["POST /orgs/{org}/copilot/billing/selected_teams"],
			addCopilotSeatsForUsers: ["POST /orgs/{org}/copilot/billing/selected_users"],
			cancelCopilotSeatAssignmentForTeams: ["DELETE /orgs/{org}/copilot/billing/selected_teams"],
			cancelCopilotSeatAssignmentForUsers: ["DELETE /orgs/{org}/copilot/billing/selected_users"],
			getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
			getCopilotSeatDetailsForUser: ["GET /orgs/{org}/members/{username}/copilot"],
			listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
		},
		dependabot: {
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
			getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			listAlertsForEnterprise: ["GET /enterprises/{enterprise}/dependabot/alerts"],
			listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
			listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"]
		},
		dependencyGraph: {
			createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
			diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"],
			exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
		},
		emojis: { get: ["GET /emojis"] },
		gists: {
			checkIsStarred: ["GET /gists/{gist_id}/star"],
			create: ["POST /gists"],
			createComment: ["POST /gists/{gist_id}/comments"],
			delete: ["DELETE /gists/{gist_id}"],
			deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
			fork: ["POST /gists/{gist_id}/forks"],
			get: ["GET /gists/{gist_id}"],
			getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
			getRevision: ["GET /gists/{gist_id}/{sha}"],
			list: ["GET /gists"],
			listComments: ["GET /gists/{gist_id}/comments"],
			listCommits: ["GET /gists/{gist_id}/commits"],
			listForUser: ["GET /users/{username}/gists"],
			listForks: ["GET /gists/{gist_id}/forks"],
			listPublic: ["GET /gists/public"],
			listStarred: ["GET /gists/starred"],
			star: ["PUT /gists/{gist_id}/star"],
			unstar: ["DELETE /gists/{gist_id}/star"],
			update: ["PATCH /gists/{gist_id}"],
			updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
		},
		git: {
			createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
			createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
			createRef: ["POST /repos/{owner}/{repo}/git/refs"],
			createTag: ["POST /repos/{owner}/{repo}/git/tags"],
			createTree: ["POST /repos/{owner}/{repo}/git/trees"],
			deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
			getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
			getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
			getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
			getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
			getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
			listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
			updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
		},
		gitignore: {
			getAllTemplates: ["GET /gitignore/templates"],
			getTemplate: ["GET /gitignore/templates/{name}"]
		},
		interactions: {
			getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
			getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
			getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
			getRestrictionsForYourPublicRepos: [
				"GET /user/interaction-limits",
				{},
				{ renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
			],
			removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
			removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
			removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
			removeRestrictionsForYourPublicRepos: [
				"DELETE /user/interaction-limits",
				{},
				{ renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
			],
			setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
			setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
			setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
			setRestrictionsForYourPublicRepos: [
				"PUT /user/interaction-limits",
				{},
				{ renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
			]
		},
		issues: {
			addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
			addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
			checkUserCanBeAssignedToIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"],
			create: ["POST /repos/{owner}/{repo}/issues"],
			createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
			createLabel: ["POST /repos/{owner}/{repo}/labels"],
			createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
			deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
			deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
			get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
			getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
			getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
			getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
			list: ["GET /issues"],
			listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
			listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
			listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
			listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
			listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
			listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
			listForAuthenticatedUser: ["GET /user/issues"],
			listForOrg: ["GET /orgs/{org}/issues"],
			listForRepo: ["GET /repos/{owner}/{repo}/issues"],
			listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
			listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
			listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
			lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
			removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
			setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
			updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
			updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
		},
		licenses: {
			get: ["GET /licenses/{license}"],
			getAllCommonlyUsed: ["GET /licenses"],
			getForRepo: ["GET /repos/{owner}/{repo}/license"]
		},
		markdown: {
			render: ["POST /markdown"],
			renderRaw: ["POST /markdown/raw", { headers: { "content-type": "text/plain; charset=utf-8" } }]
		},
		meta: {
			get: ["GET /meta"],
			getAllVersions: ["GET /versions"],
			getOctocat: ["GET /octocat"],
			getZen: ["GET /zen"],
			root: ["GET /"]
		},
		migrations: {
			cancelImport: [
				"DELETE /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import" }
			],
			deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
			deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
			downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
			getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
			getCommitAuthors: [
				"GET /repos/{owner}/{repo}/import/authors",
				{},
				{ deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors" }
			],
			getImportStatus: [
				"GET /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status" }
			],
			getLargeFiles: [
				"GET /repos/{owner}/{repo}/import/large_files",
				{},
				{ deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files" }
			],
			getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
			getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
			listForAuthenticatedUser: ["GET /user/migrations"],
			listForOrg: ["GET /orgs/{org}/migrations"],
			listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
			listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
			listReposForUser: [
				"GET /user/migrations/{migration_id}/repositories",
				{},
				{ renamed: ["migrations", "listReposForAuthenticatedUser"] }
			],
			mapCommitAuthor: [
				"PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
				{},
				{ deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author" }
			],
			setLfsPreference: [
				"PATCH /repos/{owner}/{repo}/import/lfs",
				{},
				{ deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference" }
			],
			startForAuthenticatedUser: ["POST /user/migrations"],
			startForOrg: ["POST /orgs/{org}/migrations"],
			startImport: [
				"PUT /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import" }
			],
			unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
			unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
			updateImport: [
				"PATCH /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import" }
			]
		},
		oidc: {
			getOidcCustomSubTemplateForOrg: ["GET /orgs/{org}/actions/oidc/customization/sub"],
			updateOidcCustomSubTemplateForOrg: ["PUT /orgs/{org}/actions/oidc/customization/sub"]
		},
		orgs: {
			addSecurityManagerTeam: ["PUT /orgs/{org}/security-managers/teams/{team_slug}"],
			assignTeamToOrgRole: ["PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
			assignUserToOrgRole: ["PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"],
			blockUser: ["PUT /orgs/{org}/blocks/{username}"],
			cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
			checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
			checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
			checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
			convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
			createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
			createInvitation: ["POST /orgs/{org}/invitations"],
			createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
			createOrUpdateCustomPropertiesValuesForRepos: ["PATCH /orgs/{org}/properties/values"],
			createOrUpdateCustomProperty: ["PUT /orgs/{org}/properties/schema/{custom_property_name}"],
			createWebhook: ["POST /orgs/{org}/hooks"],
			delete: ["DELETE /orgs/{org}"],
			deleteCustomOrganizationRole: ["DELETE /orgs/{org}/organization-roles/{role_id}"],
			deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
			enableOrDisableSecurityProductOnAllOrgRepos: ["POST /orgs/{org}/{security_product}/{enablement}"],
			get: ["GET /orgs/{org}"],
			getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
			getCustomProperty: ["GET /orgs/{org}/properties/schema/{custom_property_name}"],
			getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
			getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
			getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
			getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
			getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
			getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
			list: ["GET /organizations"],
			listAppInstallations: ["GET /orgs/{org}/installations"],
			listBlockedUsers: ["GET /orgs/{org}/blocks"],
			listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
			listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
			listForAuthenticatedUser: ["GET /user/orgs"],
			listForUser: ["GET /users/{username}/orgs"],
			listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
			listMembers: ["GET /orgs/{org}/members"],
			listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
			listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
			listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
			listOrgRoles: ["GET /orgs/{org}/organization-roles"],
			listOrganizationFineGrainedPermissions: ["GET /orgs/{org}/organization-fine-grained-permissions"],
			listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
			listPatGrantRepositories: ["GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"],
			listPatGrantRequestRepositories: ["GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"],
			listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
			listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
			listPendingInvitations: ["GET /orgs/{org}/invitations"],
			listPublicMembers: ["GET /orgs/{org}/public_members"],
			listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
			listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /orgs/{org}/hooks"],
			patchCustomOrganizationRole: ["PATCH /orgs/{org}/organization-roles/{role_id}"],
			pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
			removeCustomProperty: ["DELETE /orgs/{org}/properties/schema/{custom_property_name}"],
			removeMember: ["DELETE /orgs/{org}/members/{username}"],
			removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
			removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
			removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
			removeSecurityManagerTeam: ["DELETE /orgs/{org}/security-managers/teams/{team_slug}"],
			reviewPatGrantRequest: ["POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"],
			reviewPatGrantRequestsInBulk: ["POST /orgs/{org}/personal-access-token-requests"],
			revokeAllOrgRolesTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}"],
			revokeAllOrgRolesUser: ["DELETE /orgs/{org}/organization-roles/users/{username}"],
			revokeOrgRoleTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
			revokeOrgRoleUser: ["DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"],
			setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
			setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
			unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
			update: ["PATCH /orgs/{org}"],
			updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
			updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
			updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
			updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
			updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
		},
		packages: {
			deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
			deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
			deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
			deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getAllPackageVersionsForAPackageOwnedByAnOrg: [
				"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
			],
			getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
				"GET /user/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"] }
			],
			getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
			getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
			getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
			getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
			getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
			getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
			getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			listDockerMigrationConflictingPackagesForAuthenticatedUser: ["GET /user/docker/conflicts"],
			listDockerMigrationConflictingPackagesForOrganization: ["GET /orgs/{org}/docker/conflicts"],
			listDockerMigrationConflictingPackagesForUser: ["GET /users/{username}/docker/conflicts"],
			listPackagesForAuthenticatedUser: ["GET /user/packages"],
			listPackagesForOrganization: ["GET /orgs/{org}/packages"],
			listPackagesForUser: ["GET /users/{username}/packages"],
			restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
			restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
			restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
		},
		projects: {
			addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
			createCard: ["POST /projects/columns/{column_id}/cards"],
			createColumn: ["POST /projects/{project_id}/columns"],
			createForAuthenticatedUser: ["POST /user/projects"],
			createForOrg: ["POST /orgs/{org}/projects"],
			createForRepo: ["POST /repos/{owner}/{repo}/projects"],
			delete: ["DELETE /projects/{project_id}"],
			deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
			deleteColumn: ["DELETE /projects/columns/{column_id}"],
			get: ["GET /projects/{project_id}"],
			getCard: ["GET /projects/columns/cards/{card_id}"],
			getColumn: ["GET /projects/columns/{column_id}"],
			getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
			listCards: ["GET /projects/columns/{column_id}/cards"],
			listCollaborators: ["GET /projects/{project_id}/collaborators"],
			listColumns: ["GET /projects/{project_id}/columns"],
			listForOrg: ["GET /orgs/{org}/projects"],
			listForRepo: ["GET /repos/{owner}/{repo}/projects"],
			listForUser: ["GET /users/{username}/projects"],
			moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
			moveColumn: ["POST /projects/columns/{column_id}/moves"],
			removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
			update: ["PATCH /projects/{project_id}"],
			updateCard: ["PATCH /projects/columns/cards/{card_id}"],
			updateColumn: ["PATCH /projects/columns/{column_id}"]
		},
		pulls: {
			checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			create: ["POST /repos/{owner}/{repo}/pulls"],
			createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
			createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
			deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
			dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
			get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
			getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
			list: ["GET /repos/{owner}/{repo}/pulls"],
			listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
			listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
			listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
			listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
			listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
			listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
			update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
			updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
			updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
		},
		rateLimit: { get: ["GET /rate_limit"] },
		reactions: {
			createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
			createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
			createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
			createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
			createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
			createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
			createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
			deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
			deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
			deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
			deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
			listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
			listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
			listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
			listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
			listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
			listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
			listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
		},
		repos: {
			acceptInvitation: [
				"PATCH /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
			],
			acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
			addAppAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
			addStatusCheckContexts: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			addTeamAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			addUserAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			cancelPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"],
			checkAutomatedSecurityFixes: ["GET /repos/{owner}/{repo}/automated-security-fixes"],
			checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
			checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
			codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
			compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
			compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
			createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
			createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
			createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
			createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
			createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
			createDeploymentBranchPolicy: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
			createDeploymentProtectionRule: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
			createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
			createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
			createForAuthenticatedUser: ["POST /user/repos"],
			createFork: ["POST /repos/{owner}/{repo}/forks"],
			createInOrg: ["POST /orgs/{org}/repos"],
			createOrUpdateCustomPropertiesValues: ["PATCH /repos/{owner}/{repo}/properties/values"],
			createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
			createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
			createOrgRuleset: ["POST /orgs/{org}/rulesets"],
			createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
			createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
			createRelease: ["POST /repos/{owner}/{repo}/releases"],
			createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
			createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
			createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
			createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
			declineInvitation: [
				"DELETE /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
			],
			declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
			delete: ["DELETE /repos/{owner}/{repo}"],
			deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
			deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
			deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
			deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
			deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
			deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
			deleteDeploymentBranchPolicy: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
			deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
			deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
			deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
			deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
			deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
			deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
			disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
			disableDeploymentProtectionRule: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
			disablePrivateVulnerabilityReporting: ["DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"],
			disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
			downloadArchive: [
				"GET /repos/{owner}/{repo}/zipball/{ref}",
				{},
				{ renamed: ["repos", "downloadZipballArchive"] }
			],
			downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
			downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
			enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
			enablePrivateVulnerabilityReporting: ["PUT /repos/{owner}/{repo}/private-vulnerability-reporting"],
			enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
			generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
			get: ["GET /repos/{owner}/{repo}"],
			getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
			getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			getAllDeploymentProtectionRules: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
			getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
			getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
			getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
			getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
			getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
			getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
			getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
			getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
			getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
			getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
			getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
			getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
			getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
			getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
			getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
			getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
			getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
			getCustomDeploymentProtectionRule: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
			getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
			getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
			getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
			getDeploymentBranchPolicy: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
			getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
			getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
			getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
			getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
			getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
			getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
			getOrgRulesets: ["GET /orgs/{org}/rulesets"],
			getPages: ["GET /repos/{owner}/{repo}/pages"],
			getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
			getPagesDeployment: ["GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"],
			getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
			getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
			getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
			getReadme: ["GET /repos/{owner}/{repo}/readme"],
			getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
			getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
			getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
			getRepoRuleSuite: ["GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"],
			getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
			getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
			getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
			getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
			getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
			getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
			getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
			getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
			getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
			getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
			listActivities: ["GET /repos/{owner}/{repo}/activity"],
			listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
			listBranches: ["GET /repos/{owner}/{repo}/branches"],
			listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
			listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
			listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
			listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
			listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
			listCommits: ["GET /repos/{owner}/{repo}/commits"],
			listContributors: ["GET /repos/{owner}/{repo}/contributors"],
			listCustomDeploymentRuleIntegrations: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"],
			listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
			listDeploymentBranchPolicies: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
			listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
			listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
			listForAuthenticatedUser: ["GET /user/repos"],
			listForOrg: ["GET /orgs/{org}/repos"],
			listForUser: ["GET /users/{username}/repos"],
			listForks: ["GET /repos/{owner}/{repo}/forks"],
			listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
			listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
			listLanguages: ["GET /repos/{owner}/{repo}/languages"],
			listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
			listPublic: ["GET /repositories"],
			listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
			listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
			listReleases: ["GET /repos/{owner}/{repo}/releases"],
			listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
			listTags: ["GET /repos/{owner}/{repo}/tags"],
			listTeams: ["GET /repos/{owner}/{repo}/teams"],
			listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
			merge: ["POST /repos/{owner}/{repo}/merges"],
			mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
			pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
			removeAppAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
			removeStatusCheckContexts: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			removeTeamAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			removeUserAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
			replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
			requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
			setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			setAppAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			setStatusCheckContexts: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			setTeamAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			setUserAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
			transfer: ["POST /repos/{owner}/{repo}/transfer"],
			update: ["PATCH /repos/{owner}/{repo}"],
			updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
			updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
			updateDeploymentBranchPolicy: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
			updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
			updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
			updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
			updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			updateStatusCheckPotection: [
				"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
				{},
				{ renamed: ["repos", "updateStatusCheckProtection"] }
			],
			updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
			updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
			uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", { baseUrl: "https://uploads.github.com" }]
		},
		search: {
			code: ["GET /search/code"],
			commits: ["GET /search/commits"],
			issuesAndPullRequests: ["GET /search/issues"],
			labels: ["GET /search/labels"],
			repos: ["GET /search/repositories"],
			topics: ["GET /search/topics"],
			users: ["GET /search/users"]
		},
		secretScanning: {
			getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
			listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
			listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
			listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
		},
		securityAdvisories: {
			createFork: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"],
			createPrivateVulnerabilityReport: ["POST /repos/{owner}/{repo}/security-advisories/reports"],
			createRepositoryAdvisory: ["POST /repos/{owner}/{repo}/security-advisories"],
			createRepositoryAdvisoryCveRequest: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"],
			getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
			getRepositoryAdvisory: ["GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
			listGlobalAdvisories: ["GET /advisories"],
			listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
			listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
			updateRepositoryAdvisory: ["PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"]
		},
		teams: {
			addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			create: ["POST /orgs/{org}/teams"],
			createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
			createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
			deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
			getByName: ["GET /orgs/{org}/teams/{team_slug}"],
			getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			list: ["GET /orgs/{org}/teams"],
			listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
			listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
			listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
			listForAuthenticatedUser: ["GET /user/teams"],
			listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
			listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
			listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
			listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
			removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
		},
		users: {
			addEmailForAuthenticated: [
				"POST /user/emails",
				{},
				{ renamed: ["users", "addEmailForAuthenticatedUser"] }
			],
			addEmailForAuthenticatedUser: ["POST /user/emails"],
			addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
			block: ["PUT /user/blocks/{username}"],
			checkBlocked: ["GET /user/blocks/{username}"],
			checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
			checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
			createGpgKeyForAuthenticated: [
				"POST /user/gpg_keys",
				{},
				{ renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
			],
			createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
			createPublicSshKeyForAuthenticated: [
				"POST /user/keys",
				{},
				{ renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
			],
			createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
			createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
			deleteEmailForAuthenticated: [
				"DELETE /user/emails",
				{},
				{ renamed: ["users", "deleteEmailForAuthenticatedUser"] }
			],
			deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
			deleteGpgKeyForAuthenticated: [
				"DELETE /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
			],
			deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
			deletePublicSshKeyForAuthenticated: [
				"DELETE /user/keys/{key_id}",
				{},
				{ renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
			],
			deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
			deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
			deleteSshSigningKeyForAuthenticatedUser: ["DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"],
			follow: ["PUT /user/following/{username}"],
			getAuthenticated: ["GET /user"],
			getByUsername: ["GET /users/{username}"],
			getContextForUser: ["GET /users/{username}/hovercard"],
			getGpgKeyForAuthenticated: [
				"GET /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
			],
			getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
			getPublicSshKeyForAuthenticated: [
				"GET /user/keys/{key_id}",
				{},
				{ renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
			],
			getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
			getSshSigningKeyForAuthenticatedUser: ["GET /user/ssh_signing_keys/{ssh_signing_key_id}"],
			list: ["GET /users"],
			listBlockedByAuthenticated: [
				"GET /user/blocks",
				{},
				{ renamed: ["users", "listBlockedByAuthenticatedUser"] }
			],
			listBlockedByAuthenticatedUser: ["GET /user/blocks"],
			listEmailsForAuthenticated: [
				"GET /user/emails",
				{},
				{ renamed: ["users", "listEmailsForAuthenticatedUser"] }
			],
			listEmailsForAuthenticatedUser: ["GET /user/emails"],
			listFollowedByAuthenticated: [
				"GET /user/following",
				{},
				{ renamed: ["users", "listFollowedByAuthenticatedUser"] }
			],
			listFollowedByAuthenticatedUser: ["GET /user/following"],
			listFollowersForAuthenticatedUser: ["GET /user/followers"],
			listFollowersForUser: ["GET /users/{username}/followers"],
			listFollowingForUser: ["GET /users/{username}/following"],
			listGpgKeysForAuthenticated: [
				"GET /user/gpg_keys",
				{},
				{ renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
			],
			listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
			listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
			listPublicEmailsForAuthenticated: [
				"GET /user/public_emails",
				{},
				{ renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
			],
			listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
			listPublicKeysForUser: ["GET /users/{username}/keys"],
			listPublicSshKeysForAuthenticated: [
				"GET /user/keys",
				{},
				{ renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
			],
			listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
			listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
			listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
			listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
			listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
			setPrimaryEmailVisibilityForAuthenticated: [
				"PATCH /user/email/visibility",
				{},
				{ renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
			],
			setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
			unblock: ["DELETE /user/blocks/{username}"],
			unfollow: ["DELETE /user/following/{username}"],
			updateAuthenticated: ["PATCH /user"]
		}
	};
}));
function endpointsToMethods(octokit) {
	const newMethods = {};
	for (const scope$2 of endpointMethodsMap.keys()) newMethods[scope$2] = new Proxy({
		octokit,
		scope: scope$2,
		cache: {}
	}, handler);
	return newMethods;
}
function decorate(octokit, scope$2, methodName, defaults, decorations) {
	const requestWithDefaults = octokit.request.defaults(defaults);
	function withDecorations(...args) {
		let options = requestWithDefaults.endpoint.merge(...args);
		if (decorations.mapToData) {
			options = Object.assign({}, options, {
				data: options[decorations.mapToData],
				[decorations.mapToData]: void 0
			});
			return requestWithDefaults(options);
		}
		if (decorations.renamed) {
			const [newScope, newMethodName] = decorations.renamed;
			octokit.log.warn(`octokit.${scope$2}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
		}
		if (decorations.deprecated) octokit.log.warn(decorations.deprecated);
		if (decorations.renamedParameters) {
			const options2 = requestWithDefaults.endpoint.merge(...args);
			for (const [name$1, alias] of Object.entries(decorations.renamedParameters)) if (name$1 in options2) {
				octokit.log.warn(`"${name$1}" parameter is deprecated for "octokit.${scope$2}.${methodName}()". Use "${alias}" instead`);
				if (!(alias in options2)) options2[alias] = options2[name$1];
				delete options2[name$1];
			}
			return requestWithDefaults(options2);
		}
		return requestWithDefaults(...args);
	}
	return Object.assign(withDecorations, requestWithDefaults);
}
var endpointMethodsMap, handler;
var init_endpoints_to_methods = __esmMin((() => {
	init_endpoints();
	endpointMethodsMap = /* @__PURE__ */ new Map();
	for (const [scope$2, endpoints] of Object.entries(endpoints_default)) for (const [methodName, endpoint$1] of Object.entries(endpoints)) {
		const [route, defaults, decorations] = endpoint$1;
		const [method, url] = route.split(/ /);
		const endpointDefaults = Object.assign({
			method,
			url
		}, defaults);
		if (!endpointMethodsMap.has(scope$2)) endpointMethodsMap.set(scope$2, /* @__PURE__ */ new Map());
		endpointMethodsMap.get(scope$2).set(methodName, {
			scope: scope$2,
			methodName,
			endpointDefaults,
			decorations
		});
	}
	handler = {
		has({ scope: scope$2 }, methodName) {
			return endpointMethodsMap.get(scope$2).has(methodName);
		},
		getOwnPropertyDescriptor(target, methodName) {
			return {
				value: this.get(target, methodName),
				configurable: true,
				writable: true,
				enumerable: true
			};
		},
		defineProperty(target, methodName, descriptor) {
			Object.defineProperty(target.cache, methodName, descriptor);
			return true;
		},
		deleteProperty(target, methodName) {
			delete target.cache[methodName];
			return true;
		},
		ownKeys({ scope: scope$2 }) {
			return [...endpointMethodsMap.get(scope$2).keys()];
		},
		set(target, methodName, value$1) {
			return target.cache[methodName] = value$1;
		},
		get({ octokit, scope: scope$2, cache }, methodName) {
			if (cache[methodName]) return cache[methodName];
			const method = endpointMethodsMap.get(scope$2).get(methodName);
			if (!method) return;
			const { endpointDefaults, decorations } = method;
			if (decorations) cache[methodName] = decorate(octokit, scope$2, methodName, endpointDefaults, decorations);
			else cache[methodName] = octokit.request.defaults(endpointDefaults);
			return cache[methodName];
		}
	};
}));
var dist_src_exports = /* @__PURE__ */ __export({
	legacyRestEndpointMethods: () => legacyRestEndpointMethods,
	restEndpointMethods: () => restEndpointMethods
}, 1);
function restEndpointMethods(octokit) {
	return { rest: endpointsToMethods(octokit) };
}
function legacyRestEndpointMethods(octokit) {
	const api = endpointsToMethods(octokit);
	return {
		...api,
		rest: api
	};
}
var init_dist_src = __esmMin((() => {
	init_version();
	init_endpoints_to_methods();
	restEndpointMethods.VERSION = VERSION$3;
	legacyRestEndpointMethods.VERSION = VERSION$3;
}));
var dist_web_exports$2 = /* @__PURE__ */ __export({
	composePaginateRest: () => composePaginateRest,
	isPaginatingEndpoint: () => isPaginatingEndpoint,
	paginateRest: () => paginateRest,
	paginatingEndpoints: () => paginatingEndpoints
}, 1);
function normalizePaginatedListResponse(response) {
	if (!response.data) return {
		...response,
		data: []
	};
	if (!("total_count" in response.data && !("url" in response.data))) return response;
	const incompleteResults = response.data.incomplete_results;
	const repositorySelection = response.data.repository_selection;
	const totalCount = response.data.total_count;
	delete response.data.incomplete_results;
	delete response.data.repository_selection;
	delete response.data.total_count;
	const namespaceKey = Object.keys(response.data)[0];
	response.data = response.data[namespaceKey];
	if (typeof incompleteResults !== "undefined") response.data.incomplete_results = incompleteResults;
	if (typeof repositorySelection !== "undefined") response.data.repository_selection = repositorySelection;
	response.data.total_count = totalCount;
	return response;
}
function iterator(octokit, route, parameters) {
	const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
	const requestMethod = typeof route === "function" ? route : octokit.request;
	const method = options.method;
	const headers = options.headers;
	let url = options.url;
	return { [Symbol.asyncIterator]: () => ({ async next() {
		if (!url) return { done: true };
		try {
			const normalizedResponse = normalizePaginatedListResponse(await requestMethod({
				method,
				url,
				headers
			}));
			url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
			return { value: normalizedResponse };
		} catch (error) {
			if (error.status !== 409) throw error;
			url = "";
			return { value: {
				status: 200,
				headers: {},
				data: []
			} };
		}
	} }) };
}
function paginate(octokit, route, parameters, mapFn) {
	if (typeof parameters === "function") {
		mapFn = parameters;
		parameters = void 0;
	}
	return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator2, mapFn) {
	return iterator2.next().then((result) => {
		if (result.done) return results;
		let earlyExit = false;
		function done() {
			earlyExit = true;
		}
		results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
		if (earlyExit) return results;
		return gather(octokit, results, iterator2, mapFn);
	});
}
function isPaginatingEndpoint(arg) {
	if (typeof arg === "string") return paginatingEndpoints.includes(arg);
	else return false;
}
function paginateRest(octokit) {
	return { paginate: Object.assign(paginate.bind(null, octokit), { iterator: iterator.bind(null, octokit) }) };
}
var VERSION$2, composePaginateRest, paginatingEndpoints;
var init_dist_web$2 = __esmMin((() => {
	VERSION$2 = "9.2.2";
	composePaginateRest = Object.assign(paginate, { iterator });
	paginatingEndpoints = [
		"GET /advisories",
		"GET /app/hook/deliveries",
		"GET /app/installation-requests",
		"GET /app/installations",
		"GET /assignments/{assignment_id}/accepted_assignments",
		"GET /classrooms",
		"GET /classrooms/{classroom_id}/assignments",
		"GET /enterprises/{enterprise}/dependabot/alerts",
		"GET /enterprises/{enterprise}/secret-scanning/alerts",
		"GET /events",
		"GET /gists",
		"GET /gists/public",
		"GET /gists/starred",
		"GET /gists/{gist_id}/comments",
		"GET /gists/{gist_id}/commits",
		"GET /gists/{gist_id}/forks",
		"GET /installation/repositories",
		"GET /issues",
		"GET /licenses",
		"GET /marketplace_listing/plans",
		"GET /marketplace_listing/plans/{plan_id}/accounts",
		"GET /marketplace_listing/stubbed/plans",
		"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
		"GET /networks/{owner}/{repo}/events",
		"GET /notifications",
		"GET /organizations",
		"GET /orgs/{org}/actions/cache/usage-by-repository",
		"GET /orgs/{org}/actions/permissions/repositories",
		"GET /orgs/{org}/actions/runners",
		"GET /orgs/{org}/actions/secrets",
		"GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/actions/variables",
		"GET /orgs/{org}/actions/variables/{name}/repositories",
		"GET /orgs/{org}/blocks",
		"GET /orgs/{org}/code-scanning/alerts",
		"GET /orgs/{org}/codespaces",
		"GET /orgs/{org}/codespaces/secrets",
		"GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/copilot/billing/seats",
		"GET /orgs/{org}/dependabot/alerts",
		"GET /orgs/{org}/dependabot/secrets",
		"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/events",
		"GET /orgs/{org}/failed_invitations",
		"GET /orgs/{org}/hooks",
		"GET /orgs/{org}/hooks/{hook_id}/deliveries",
		"GET /orgs/{org}/installations",
		"GET /orgs/{org}/invitations",
		"GET /orgs/{org}/invitations/{invitation_id}/teams",
		"GET /orgs/{org}/issues",
		"GET /orgs/{org}/members",
		"GET /orgs/{org}/members/{username}/codespaces",
		"GET /orgs/{org}/migrations",
		"GET /orgs/{org}/migrations/{migration_id}/repositories",
		"GET /orgs/{org}/organization-roles/{role_id}/teams",
		"GET /orgs/{org}/organization-roles/{role_id}/users",
		"GET /orgs/{org}/outside_collaborators",
		"GET /orgs/{org}/packages",
		"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
		"GET /orgs/{org}/personal-access-token-requests",
		"GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
		"GET /orgs/{org}/personal-access-tokens",
		"GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
		"GET /orgs/{org}/projects",
		"GET /orgs/{org}/properties/values",
		"GET /orgs/{org}/public_members",
		"GET /orgs/{org}/repos",
		"GET /orgs/{org}/rulesets",
		"GET /orgs/{org}/rulesets/rule-suites",
		"GET /orgs/{org}/secret-scanning/alerts",
		"GET /orgs/{org}/security-advisories",
		"GET /orgs/{org}/teams",
		"GET /orgs/{org}/teams/{team_slug}/discussions",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
		"GET /orgs/{org}/teams/{team_slug}/invitations",
		"GET /orgs/{org}/teams/{team_slug}/members",
		"GET /orgs/{org}/teams/{team_slug}/projects",
		"GET /orgs/{org}/teams/{team_slug}/repos",
		"GET /orgs/{org}/teams/{team_slug}/teams",
		"GET /projects/columns/{column_id}/cards",
		"GET /projects/{project_id}/collaborators",
		"GET /projects/{project_id}/columns",
		"GET /repos/{owner}/{repo}/actions/artifacts",
		"GET /repos/{owner}/{repo}/actions/caches",
		"GET /repos/{owner}/{repo}/actions/organization-secrets",
		"GET /repos/{owner}/{repo}/actions/organization-variables",
		"GET /repos/{owner}/{repo}/actions/runners",
		"GET /repos/{owner}/{repo}/actions/runs",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
		"GET /repos/{owner}/{repo}/actions/secrets",
		"GET /repos/{owner}/{repo}/actions/variables",
		"GET /repos/{owner}/{repo}/actions/workflows",
		"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
		"GET /repos/{owner}/{repo}/activity",
		"GET /repos/{owner}/{repo}/assignees",
		"GET /repos/{owner}/{repo}/branches",
		"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
		"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
		"GET /repos/{owner}/{repo}/code-scanning/alerts",
		"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
		"GET /repos/{owner}/{repo}/code-scanning/analyses",
		"GET /repos/{owner}/{repo}/codespaces",
		"GET /repos/{owner}/{repo}/codespaces/devcontainers",
		"GET /repos/{owner}/{repo}/codespaces/secrets",
		"GET /repos/{owner}/{repo}/collaborators",
		"GET /repos/{owner}/{repo}/comments",
		"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/commits",
		"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
		"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
		"GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
		"GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
		"GET /repos/{owner}/{repo}/commits/{ref}/status",
		"GET /repos/{owner}/{repo}/commits/{ref}/statuses",
		"GET /repos/{owner}/{repo}/contributors",
		"GET /repos/{owner}/{repo}/dependabot/alerts",
		"GET /repos/{owner}/{repo}/dependabot/secrets",
		"GET /repos/{owner}/{repo}/deployments",
		"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
		"GET /repos/{owner}/{repo}/environments",
		"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
		"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
		"GET /repos/{owner}/{repo}/events",
		"GET /repos/{owner}/{repo}/forks",
		"GET /repos/{owner}/{repo}/hooks",
		"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
		"GET /repos/{owner}/{repo}/invitations",
		"GET /repos/{owner}/{repo}/issues",
		"GET /repos/{owner}/{repo}/issues/comments",
		"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/issues/events",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/events",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
		"GET /repos/{owner}/{repo}/keys",
		"GET /repos/{owner}/{repo}/labels",
		"GET /repos/{owner}/{repo}/milestones",
		"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
		"GET /repos/{owner}/{repo}/notifications",
		"GET /repos/{owner}/{repo}/pages/builds",
		"GET /repos/{owner}/{repo}/projects",
		"GET /repos/{owner}/{repo}/pulls",
		"GET /repos/{owner}/{repo}/pulls/comments",
		"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
		"GET /repos/{owner}/{repo}/releases",
		"GET /repos/{owner}/{repo}/releases/{release_id}/assets",
		"GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
		"GET /repos/{owner}/{repo}/rules/branches/{branch}",
		"GET /repos/{owner}/{repo}/rulesets",
		"GET /repos/{owner}/{repo}/rulesets/rule-suites",
		"GET /repos/{owner}/{repo}/secret-scanning/alerts",
		"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
		"GET /repos/{owner}/{repo}/security-advisories",
		"GET /repos/{owner}/{repo}/stargazers",
		"GET /repos/{owner}/{repo}/subscribers",
		"GET /repos/{owner}/{repo}/tags",
		"GET /repos/{owner}/{repo}/teams",
		"GET /repos/{owner}/{repo}/topics",
		"GET /repositories",
		"GET /repositories/{repository_id}/environments/{environment_name}/secrets",
		"GET /repositories/{repository_id}/environments/{environment_name}/variables",
		"GET /search/code",
		"GET /search/commits",
		"GET /search/issues",
		"GET /search/labels",
		"GET /search/repositories",
		"GET /search/topics",
		"GET /search/users",
		"GET /teams/{team_id}/discussions",
		"GET /teams/{team_id}/discussions/{discussion_number}/comments",
		"GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
		"GET /teams/{team_id}/discussions/{discussion_number}/reactions",
		"GET /teams/{team_id}/invitations",
		"GET /teams/{team_id}/members",
		"GET /teams/{team_id}/projects",
		"GET /teams/{team_id}/repos",
		"GET /teams/{team_id}/teams",
		"GET /user/blocks",
		"GET /user/codespaces",
		"GET /user/codespaces/secrets",
		"GET /user/emails",
		"GET /user/followers",
		"GET /user/following",
		"GET /user/gpg_keys",
		"GET /user/installations",
		"GET /user/installations/{installation_id}/repositories",
		"GET /user/issues",
		"GET /user/keys",
		"GET /user/marketplace_purchases",
		"GET /user/marketplace_purchases/stubbed",
		"GET /user/memberships/orgs",
		"GET /user/migrations",
		"GET /user/migrations/{migration_id}/repositories",
		"GET /user/orgs",
		"GET /user/packages",
		"GET /user/packages/{package_type}/{package_name}/versions",
		"GET /user/public_emails",
		"GET /user/repos",
		"GET /user/repository_invitations",
		"GET /user/social_accounts",
		"GET /user/ssh_signing_keys",
		"GET /user/starred",
		"GET /user/subscriptions",
		"GET /user/teams",
		"GET /users",
		"GET /users/{username}/events",
		"GET /users/{username}/events/orgs/{org}",
		"GET /users/{username}/events/public",
		"GET /users/{username}/followers",
		"GET /users/{username}/following",
		"GET /users/{username}/gists",
		"GET /users/{username}/gpg_keys",
		"GET /users/{username}/keys",
		"GET /users/{username}/orgs",
		"GET /users/{username}/packages",
		"GET /users/{username}/projects",
		"GET /users/{username}/received_events",
		"GET /users/{username}/received_events/public",
		"GET /users/{username}/repos",
		"GET /users/{username}/social_accounts",
		"GET /users/{username}/ssh_signing_keys",
		"GET /users/{username}/starred",
		"GET /users/{username}/subscriptions"
	];
	paginateRest.VERSION = VERSION$2;
}));
var require_utils$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
	var Context = __importStar(require_context());
	var Utils = __importStar(require_utils$4());
	var core_1 = (init_dist_web$3(), __toCommonJS(dist_web_exports$3));
	var plugin_rest_endpoint_methods_1 = (init_dist_src(), __toCommonJS(dist_src_exports));
	var plugin_paginate_rest_1 = (init_dist_web$2(), __toCommonJS(dist_web_exports$2));
	exports.context = new Context.Context();
	var baseUrl = Utils.getApiBaseUrl();
	exports.defaults = {
		baseUrl,
		request: {
			agent: Utils.getProxyAgent(baseUrl),
			fetch: Utils.getProxyFetch(baseUrl)
		}
	};
	exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
	function getOctokitOptions(token, options) {
		const opts = Object.assign({}, options || {});
		const auth$1 = Utils.getAuthString(token, opts);
		if (auth$1) opts.auth = auth$1;
		return opts;
	}
	exports.getOctokitOptions = getOctokitOptions;
}));
var require_github = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOctokit = exports.context = void 0;
	var Context = __importStar(require_context());
	var utils_1 = require_utils$3();
	exports.context = new Context.Context();
	function getOctokit(token, options, ...additionalPlugins) {
		return new (utils_1.GitHub.plugin(...additionalPlugins))((0, utils_1.getOctokitOptions)(token, options));
	}
	exports.getOctokit = getOctokit;
}));
var require_config = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getUploadChunkSize = getUploadChunkSize;
	exports.getRuntimeToken = getRuntimeToken;
	exports.getResultsServiceUrl = getResultsServiceUrl;
	exports.isGhes = isGhes;
	exports.getGitHubWorkspaceDir = getGitHubWorkspaceDir;
	exports.getConcurrency = getConcurrency;
	exports.getUploadChunkTimeout = getUploadChunkTimeout;
	exports.getMaxArtifactListCount = getMaxArtifactListCount;
	var os_1 = __importDefault(__require("os"));
	var core_1 = require_core$1();
	function getUploadChunkSize() {
		return 8 * 1024 * 1024;
	}
	function getRuntimeToken() {
		const token = process.env["ACTIONS_RUNTIME_TOKEN"];
		if (!token) throw new Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
		return token;
	}
	function getResultsServiceUrl() {
		const resultsUrl = process.env["ACTIONS_RESULTS_URL"];
		if (!resultsUrl) throw new Error("Unable to get the ACTIONS_RESULTS_URL env variable");
		return new URL(resultsUrl).origin;
	}
	function isGhes() {
		const hostname = new URL(process.env["GITHUB_SERVER_URL"] || "https://github.com").hostname.trimEnd().toUpperCase();
		const isGitHubHost = hostname === "GITHUB.COM";
		const isGheHost = hostname.endsWith(".GHE.COM");
		const isLocalHost = hostname.endsWith(".LOCALHOST");
		return !isGitHubHost && !isGheHost && !isLocalHost;
	}
	function getGitHubWorkspaceDir() {
		const ghWorkspaceDir = process.env["GITHUB_WORKSPACE"];
		if (!ghWorkspaceDir) throw new Error("Unable to get the GITHUB_WORKSPACE env variable");
		return ghWorkspaceDir;
	}
	function getConcurrency() {
		const numCPUs = os_1.default.cpus().length;
		let concurrencyCap = 32;
		if (numCPUs > 4) {
			const concurrency = 16 * numCPUs;
			concurrencyCap = concurrency > 300 ? 300 : concurrency;
		}
		const concurrencyOverride = process.env["ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY"];
		if (concurrencyOverride) {
			const concurrency = parseInt(concurrencyOverride);
			if (isNaN(concurrency) || concurrency < 1) throw new Error("Invalid value set for ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY env variable");
			if (concurrency < concurrencyCap) {
				(0, core_1.info)(`Set concurrency based on the value set in ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY.`);
				return concurrency;
			}
			(0, core_1.info)(`ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY is higher than the cap of ${concurrencyCap} based on the number of cpus. Set it to the maximum value allowed.`);
			return concurrencyCap;
		}
		return 5;
	}
	function getUploadChunkTimeout() {
		const timeoutVar = process.env["ACTIONS_ARTIFACT_UPLOAD_TIMEOUT_MS"];
		if (!timeoutVar) return 3e5;
		const timeout$1 = parseInt(timeoutVar);
		if (isNaN(timeout$1)) throw new Error("Invalid value set for ACTIONS_ARTIFACT_UPLOAD_TIMEOUT_MS env variable");
		return timeout$1;
	}
	function getMaxArtifactListCount() {
		const maxCountVar = process.env["ACTIONS_ARTIFACT_MAX_ARTIFACT_COUNT"] || "1000";
		const maxCount = parseInt(maxCountVar);
		if (isNaN(maxCount) || maxCount < 1) throw new Error("Invalid value set for ACTIONS_ARTIFACT_MAX_ARTIFACT_COUNT env variable");
		return maxCount;
	}
}));
function typeofJsonValue(value$1) {
	let t$1 = typeof value$1;
	if (t$1 == "object") {
		if (Array.isArray(value$1)) return "array";
		if (value$1 === null) return "null";
	}
	return t$1;
}
function isJsonObject(value$1) {
	return value$1 !== null && typeof value$1 == "object" && !Array.isArray(value$1);
}
var init_json_typings = __esmMin((() => {}));
function base64decode(base64Str) {
	let es = base64Str.length * 3 / 4;
	if (base64Str[base64Str.length - 2] == "=") es -= 2;
	else if (base64Str[base64Str.length - 1] == "=") es -= 1;
	let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
	for (let i = 0; i < base64Str.length; i++) {
		b = decTable[base64Str.charCodeAt(i)];
		if (b === void 0) switch (base64Str[i]) {
			case "=": groupPos = 0;
			case "\n":
			case "\r":
			case "	":
			case " ": continue;
			default: throw Error(`invalid base64 string.`);
		}
		switch (groupPos) {
			case 0:
				p = b;
				groupPos = 1;
				break;
			case 1:
				bytes[bytePos++] = p << 2 | (b & 48) >> 4;
				p = b;
				groupPos = 2;
				break;
			case 2:
				bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
				p = b;
				groupPos = 3;
				break;
			case 3:
				bytes[bytePos++] = (p & 3) << 6 | b;
				groupPos = 0;
				break;
		}
	}
	if (groupPos == 1) throw Error(`invalid base64 string.`);
	return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
	let base64 = "", groupPos = 0, b, p = 0;
	for (let i = 0; i < bytes.length; i++) {
		b = bytes[i];
		switch (groupPos) {
			case 0:
				base64 += encTable[b >> 2];
				p = (b & 3) << 4;
				groupPos = 1;
				break;
			case 1:
				base64 += encTable[p | b >> 4];
				p = (b & 15) << 2;
				groupPos = 2;
				break;
			case 2:
				base64 += encTable[p | b >> 6];
				base64 += encTable[b & 63];
				groupPos = 0;
				break;
		}
	}
	if (groupPos) {
		base64 += encTable[p];
		base64 += "=";
		if (groupPos == 1) base64 += "=";
	}
	return base64;
}
var encTable, decTable;
var init_base64 = __esmMin((() => {
	encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
	decTable = [];
	for (let i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;
	decTable["-".charCodeAt(0)] = encTable.indexOf("+");
	decTable["_".charCodeAt(0)] = encTable.indexOf("/");
}));
function utf8read(bytes) {
	if (bytes.length < 1) return "";
	let pos = 0, parts = [], chunk = [], i = 0, t$1;
	let len = bytes.length;
	while (pos < len) {
		t$1 = bytes[pos++];
		if (t$1 < 128) chunk[i++] = t$1;
		else if (t$1 > 191 && t$1 < 224) chunk[i++] = (t$1 & 31) << 6 | bytes[pos++] & 63;
		else if (t$1 > 239 && t$1 < 365) {
			t$1 = ((t$1 & 7) << 18 | (bytes[pos++] & 63) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63) - 65536;
			chunk[i++] = 55296 + (t$1 >> 10);
			chunk[i++] = 56320 + (t$1 & 1023);
		} else chunk[i++] = (t$1 & 15) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63;
		if (i > 8191) {
			parts.push(fromCharCodes(chunk));
			i = 0;
		}
	}
	if (parts.length) {
		if (i) parts.push(fromCharCodes(chunk.slice(0, i)));
		return parts.join("");
	}
	return fromCharCodes(chunk.slice(0, i));
}
var fromCharCodes;
var init_protobufjs_utf8 = __esmMin((() => {
	fromCharCodes = (chunk) => String.fromCharCode.apply(String, chunk);
}));
function mergeBinaryOptions(a, b) {
	return Object.assign(Object.assign({}, a), b);
}
var UnknownFieldHandler, WireType;
var init_binary_format_contract = __esmMin((() => {
	(function(UnknownFieldHandler$1) {
		UnknownFieldHandler$1.symbol = Symbol.for("protobuf-ts/unknown");
		UnknownFieldHandler$1.onRead = (typeName, message, fieldNo, wireType, data) => {
			(is(message) ? message[UnknownFieldHandler$1.symbol] : message[UnknownFieldHandler$1.symbol] = []).push({
				no: fieldNo,
				wireType,
				data
			});
		};
		UnknownFieldHandler$1.onWrite = (typeName, message, writer) => {
			for (let { no, wireType, data } of UnknownFieldHandler$1.list(message)) writer.tag(no, wireType).raw(data);
		};
		UnknownFieldHandler$1.list = (message, fieldNo) => {
			if (is(message)) {
				let all$1 = message[UnknownFieldHandler$1.symbol];
				return fieldNo ? all$1.filter((uf) => uf.no == fieldNo) : all$1;
			}
			return [];
		};
		UnknownFieldHandler$1.last = (message, fieldNo) => UnknownFieldHandler$1.list(message, fieldNo).slice(-1)[0];
		const is = (message) => message && Array.isArray(message[UnknownFieldHandler$1.symbol]);
	})(UnknownFieldHandler || (UnknownFieldHandler = {}));
	(function(WireType$1) {
		WireType$1[WireType$1["Varint"] = 0] = "Varint";
		WireType$1[WireType$1["Bit64"] = 1] = "Bit64";
		WireType$1[WireType$1["LengthDelimited"] = 2] = "LengthDelimited";
		WireType$1[WireType$1["StartGroup"] = 3] = "StartGroup";
		WireType$1[WireType$1["EndGroup"] = 4] = "EndGroup";
		WireType$1[WireType$1["Bit32"] = 5] = "Bit32";
	})(WireType || (WireType = {}));
}));
function varint64read() {
	let lowBits = 0;
	let highBits = 0;
	for (let shift = 0; shift < 28; shift += 7) {
		let b = this.buf[this.pos++];
		lowBits |= (b & 127) << shift;
		if ((b & 128) == 0) {
			this.assertBounds();
			return [lowBits, highBits];
		}
	}
	let middleByte = this.buf[this.pos++];
	lowBits |= (middleByte & 15) << 28;
	highBits = (middleByte & 112) >> 4;
	if ((middleByte & 128) == 0) {
		this.assertBounds();
		return [lowBits, highBits];
	}
	for (let shift = 3; shift <= 31; shift += 7) {
		let b = this.buf[this.pos++];
		highBits |= (b & 127) << shift;
		if ((b & 128) == 0) {
			this.assertBounds();
			return [lowBits, highBits];
		}
	}
	throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
	for (let i = 0; i < 28; i = i + 7) {
		const shift = lo >>> i;
		const hasNext = !(shift >>> 7 == 0 && hi == 0);
		const byte = (hasNext ? shift | 128 : shift) & 255;
		bytes.push(byte);
		if (!hasNext) return;
	}
	const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
	const hasMoreBits = !(hi >> 3 == 0);
	bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
	if (!hasMoreBits) return;
	for (let i = 3; i < 31; i = i + 7) {
		const shift = hi >>> i;
		const hasNext = !(shift >>> 7 == 0);
		const byte = (hasNext ? shift | 128 : shift) & 255;
		bytes.push(byte);
		if (!hasNext) return;
	}
	bytes.push(hi >>> 31 & 1);
}
function int64fromString(dec) {
	let minus = dec[0] == "-";
	if (minus) dec = dec.slice(1);
	const base = 1e6;
	let lowBits = 0;
	let highBits = 0;
	function add1e6digit(begin, end) {
		const digit1e6 = Number(dec.slice(begin, end));
		highBits *= base;
		lowBits = lowBits * base + digit1e6;
		if (lowBits >= TWO_PWR_32_DBL$1) {
			highBits = highBits + (lowBits / TWO_PWR_32_DBL$1 | 0);
			lowBits = lowBits % TWO_PWR_32_DBL$1;
		}
	}
	add1e6digit(-24, -18);
	add1e6digit(-18, -12);
	add1e6digit(-12, -6);
	add1e6digit(-6);
	return [
		minus,
		lowBits,
		highBits
	];
}
function int64toString(bitsLow, bitsHigh) {
	if (bitsHigh >>> 0 <= 2097151) return "" + (TWO_PWR_32_DBL$1 * bitsHigh + (bitsLow >>> 0));
	let low = bitsLow & 16777215;
	let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
	let high = bitsHigh >> 16 & 65535;
	let digitA = low + mid * 6777216 + high * 6710656;
	let digitB = mid + high * 8147497;
	let digitC = high * 2;
	let base = 1e7;
	if (digitA >= base) {
		digitB += Math.floor(digitA / base);
		digitA %= base;
	}
	if (digitB >= base) {
		digitC += Math.floor(digitB / base);
		digitB %= base;
	}
	function decimalFrom1e7(digit1e7, needLeadingZeros) {
		let partial = digit1e7 ? String(digit1e7) : "";
		if (needLeadingZeros) return "0000000".slice(partial.length) + partial;
		return partial;
	}
	return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + decimalFrom1e7(digitA, 1);
}
function varint32write(value$1, bytes) {
	if (value$1 >= 0) {
		while (value$1 > 127) {
			bytes.push(value$1 & 127 | 128);
			value$1 = value$1 >>> 7;
		}
		bytes.push(value$1);
	} else {
		for (let i = 0; i < 9; i++) {
			bytes.push(value$1 & 127 | 128);
			value$1 = value$1 >> 7;
		}
		bytes.push(1);
	}
}
function varint32read() {
	let b = this.buf[this.pos++];
	let result = b & 127;
	if ((b & 128) == 0) {
		this.assertBounds();
		return result;
	}
	b = this.buf[this.pos++];
	result |= (b & 127) << 7;
	if ((b & 128) == 0) {
		this.assertBounds();
		return result;
	}
	b = this.buf[this.pos++];
	result |= (b & 127) << 14;
	if ((b & 128) == 0) {
		this.assertBounds();
		return result;
	}
	b = this.buf[this.pos++];
	result |= (b & 127) << 21;
	if ((b & 128) == 0) {
		this.assertBounds();
		return result;
	}
	b = this.buf[this.pos++];
	result |= (b & 15) << 28;
	for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++) b = this.buf[this.pos++];
	if ((b & 128) != 0) throw new Error("invalid varint");
	this.assertBounds();
	return result >>> 0;
}
var TWO_PWR_32_DBL$1;
var init_goog_varint = __esmMin((() => {
	TWO_PWR_32_DBL$1 = 65536 * 65536;
}));
function detectBi() {
	const dv = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(8));
	BI = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" ? {
		MIN: BigInt("-9223372036854775808"),
		MAX: BigInt("9223372036854775807"),
		UMIN: BigInt("0"),
		UMAX: BigInt("18446744073709551615"),
		C: BigInt,
		V: dv
	} : void 0;
}
function assertBi(bi) {
	if (!bi) throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var BI, RE_DECIMAL_STR, TWO_PWR_32_DBL, HALF_2_PWR_32, SharedPbLong, PbULong, PbLong;
var init_pb_long = __esmMin((() => {
	init_goog_varint();
	detectBi();
	RE_DECIMAL_STR = /^-?[0-9]+$/;
	TWO_PWR_32_DBL = 4294967296;
	HALF_2_PWR_32 = 2147483648;
	SharedPbLong = class {
		constructor(lo, hi) {
			this.lo = lo | 0;
			this.hi = hi | 0;
		}
		isZero() {
			return this.lo == 0 && this.hi == 0;
		}
		toNumber() {
			let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
			if (!Number.isSafeInteger(result)) throw new Error("cannot convert to safe number");
			return result;
		}
	};
	PbULong = class PbULong extends SharedPbLong {
		static from(value$1) {
			if (BI) switch (typeof value$1) {
				case "string":
					if (value$1 == "0") return this.ZERO;
					if (value$1 == "") throw new Error("string is no integer");
					value$1 = BI.C(value$1);
				case "number":
					if (value$1 === 0) return this.ZERO;
					value$1 = BI.C(value$1);
				case "bigint":
					if (!value$1) return this.ZERO;
					if (value$1 < BI.UMIN) throw new Error("signed value for ulong");
					if (value$1 > BI.UMAX) throw new Error("ulong too large");
					BI.V.setBigUint64(0, value$1, true);
					return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
			}
			else switch (typeof value$1) {
				case "string":
					if (value$1 == "0") return this.ZERO;
					value$1 = value$1.trim();
					if (!RE_DECIMAL_STR.test(value$1)) throw new Error("string is no integer");
					let [minus, lo, hi] = int64fromString(value$1);
					if (minus) throw new Error("signed value for ulong");
					return new PbULong(lo, hi);
				case "number":
					if (value$1 == 0) return this.ZERO;
					if (!Number.isSafeInteger(value$1)) throw new Error("number is no integer");
					if (value$1 < 0) throw new Error("signed value for ulong");
					return new PbULong(value$1, value$1 / TWO_PWR_32_DBL);
			}
			throw new Error("unknown value " + typeof value$1);
		}
		toString() {
			return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
		}
		toBigInt() {
			assertBi(BI);
			BI.V.setInt32(0, this.lo, true);
			BI.V.setInt32(4, this.hi, true);
			return BI.V.getBigUint64(0, true);
		}
	};
	PbULong.ZERO = new PbULong(0, 0);
	PbLong = class PbLong extends SharedPbLong {
		static from(value$1) {
			if (BI) switch (typeof value$1) {
				case "string":
					if (value$1 == "0") return this.ZERO;
					if (value$1 == "") throw new Error("string is no integer");
					value$1 = BI.C(value$1);
				case "number":
					if (value$1 === 0) return this.ZERO;
					value$1 = BI.C(value$1);
				case "bigint":
					if (!value$1) return this.ZERO;
					if (value$1 < BI.MIN) throw new Error("signed long too small");
					if (value$1 > BI.MAX) throw new Error("signed long too large");
					BI.V.setBigInt64(0, value$1, true);
					return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
			}
			else switch (typeof value$1) {
				case "string":
					if (value$1 == "0") return this.ZERO;
					value$1 = value$1.trim();
					if (!RE_DECIMAL_STR.test(value$1)) throw new Error("string is no integer");
					let [minus, lo, hi] = int64fromString(value$1);
					if (minus) {
						if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0) throw new Error("signed long too small");
					} else if (hi >= HALF_2_PWR_32) throw new Error("signed long too large");
					let pbl = new PbLong(lo, hi);
					return minus ? pbl.negate() : pbl;
				case "number":
					if (value$1 == 0) return this.ZERO;
					if (!Number.isSafeInteger(value$1)) throw new Error("number is no integer");
					return value$1 > 0 ? new PbLong(value$1, value$1 / TWO_PWR_32_DBL) : new PbLong(-value$1, -value$1 / TWO_PWR_32_DBL).negate();
			}
			throw new Error("unknown value " + typeof value$1);
		}
		isNegative() {
			return (this.hi & HALF_2_PWR_32) !== 0;
		}
		negate() {
			let hi = ~this.hi, lo = this.lo;
			if (lo) lo = ~lo + 1;
			else hi += 1;
			return new PbLong(lo, hi);
		}
		toString() {
			if (BI) return this.toBigInt().toString();
			if (this.isNegative()) {
				let n$1 = this.negate();
				return "-" + int64toString(n$1.lo, n$1.hi);
			}
			return int64toString(this.lo, this.hi);
		}
		toBigInt() {
			assertBi(BI);
			BI.V.setInt32(0, this.lo, true);
			BI.V.setInt32(4, this.hi, true);
			return BI.V.getBigInt64(0, true);
		}
	};
	PbLong.ZERO = new PbLong(0, 0);
}));
function binaryReadOptions(options) {
	return options ? Object.assign(Object.assign({}, defaultsRead$1), options) : defaultsRead$1;
}
var defaultsRead$1, BinaryReader;
var init_binary_reader = __esmMin((() => {
	init_binary_format_contract();
	init_pb_long();
	init_goog_varint();
	defaultsRead$1 = {
		readUnknownField: true,
		readerFactory: (bytes) => new BinaryReader(bytes)
	};
	BinaryReader = class {
		constructor(buf, textDecoder) {
			this.varint64 = varint64read;
			this.uint32 = varint32read;
			this.buf = buf;
			this.len = buf.length;
			this.pos = 0;
			this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
			this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
				fatal: true,
				ignoreBOM: true
			});
		}
		tag() {
			let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
			if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
			return [fieldNo, wireType];
		}
		skip(wireType) {
			let start = this.pos;
			switch (wireType) {
				case WireType.Varint:
					while (this.buf[this.pos++] & 128);
					break;
				case WireType.Bit64: this.pos += 4;
				case WireType.Bit32:
					this.pos += 4;
					break;
				case WireType.LengthDelimited:
					let len = this.uint32();
					this.pos += len;
					break;
				case WireType.StartGroup:
					let t$1;
					while ((t$1 = this.tag()[1]) !== WireType.EndGroup) this.skip(t$1);
					break;
				default: throw new Error("cant skip wire type " + wireType);
			}
			this.assertBounds();
			return this.buf.subarray(start, this.pos);
		}
		assertBounds() {
			if (this.pos > this.len) throw new RangeError("premature EOF");
		}
		int32() {
			return this.uint32() | 0;
		}
		sint32() {
			let zze = this.uint32();
			return zze >>> 1 ^ -(zze & 1);
		}
		int64() {
			return new PbLong(...this.varint64());
		}
		uint64() {
			return new PbULong(...this.varint64());
		}
		sint64() {
			let [lo, hi] = this.varint64();
			let s = -(lo & 1);
			lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
			hi = hi >>> 1 ^ s;
			return new PbLong(lo, hi);
		}
		bool() {
			let [lo, hi] = this.varint64();
			return lo !== 0 || hi !== 0;
		}
		fixed32() {
			return this.view.getUint32((this.pos += 4) - 4, true);
		}
		sfixed32() {
			return this.view.getInt32((this.pos += 4) - 4, true);
		}
		fixed64() {
			return new PbULong(this.sfixed32(), this.sfixed32());
		}
		sfixed64() {
			return new PbLong(this.sfixed32(), this.sfixed32());
		}
		float() {
			return this.view.getFloat32((this.pos += 4) - 4, true);
		}
		double() {
			return this.view.getFloat64((this.pos += 8) - 8, true);
		}
		bytes() {
			let len = this.uint32();
			let start = this.pos;
			this.pos += len;
			this.assertBounds();
			return this.buf.subarray(start, start + len);
		}
		string() {
			return this.textDecoder.decode(this.bytes());
		}
	};
}));
function assert(condition, msg) {
	if (!condition) throw new Error(msg);
}
function assertNever(value$1, msg) {
	throw new Error(msg !== null && msg !== void 0 ? msg : "Unexpected object: " + value$1);
}
function assertInt32(arg) {
	if (typeof arg !== "number") throw new Error("invalid int 32: " + typeof arg);
	if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
	if (typeof arg !== "number") throw new Error("invalid uint 32: " + typeof arg);
	if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
	if (typeof arg !== "number") throw new Error("invalid float 32: " + typeof arg);
	if (!Number.isFinite(arg)) return;
	if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error("invalid float 32: " + arg);
}
var FLOAT32_MAX, FLOAT32_MIN, UINT32_MAX, INT32_MAX, INT32_MIN;
var init_assert = __esmMin((() => {
	FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
}));
function binaryWriteOptions(options) {
	return options ? Object.assign(Object.assign({}, defaultsWrite$1), options) : defaultsWrite$1;
}
var defaultsWrite$1, BinaryWriter;
var init_binary_writer = __esmMin((() => {
	init_pb_long();
	init_goog_varint();
	init_assert();
	defaultsWrite$1 = {
		writeUnknownFields: true,
		writerFactory: () => new BinaryWriter()
	};
	BinaryWriter = class {
		constructor(textEncoder) {
			this.stack = [];
			this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
			this.chunks = [];
			this.buf = [];
		}
		finish() {
			this.chunks.push(new Uint8Array(this.buf));
			let len = 0;
			for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;
			let bytes = new Uint8Array(len);
			let offset = 0;
			for (let i = 0; i < this.chunks.length; i++) {
				bytes.set(this.chunks[i], offset);
				offset += this.chunks[i].length;
			}
			this.chunks = [];
			return bytes;
		}
		fork() {
			this.stack.push({
				chunks: this.chunks,
				buf: this.buf
			});
			this.chunks = [];
			this.buf = [];
			return this;
		}
		join() {
			let chunk = this.finish();
			let prev = this.stack.pop();
			if (!prev) throw new Error("invalid state, fork stack empty");
			this.chunks = prev.chunks;
			this.buf = prev.buf;
			this.uint32(chunk.byteLength);
			return this.raw(chunk);
		}
		tag(fieldNo, type) {
			return this.uint32((fieldNo << 3 | type) >>> 0);
		}
		raw(chunk) {
			if (this.buf.length) {
				this.chunks.push(new Uint8Array(this.buf));
				this.buf = [];
			}
			this.chunks.push(chunk);
			return this;
		}
		uint32(value$1) {
			assertUInt32(value$1);
			while (value$1 > 127) {
				this.buf.push(value$1 & 127 | 128);
				value$1 = value$1 >>> 7;
			}
			this.buf.push(value$1);
			return this;
		}
		int32(value$1) {
			assertInt32(value$1);
			varint32write(value$1, this.buf);
			return this;
		}
		bool(value$1) {
			this.buf.push(value$1 ? 1 : 0);
			return this;
		}
		bytes(value$1) {
			this.uint32(value$1.byteLength);
			return this.raw(value$1);
		}
		string(value$1) {
			let chunk = this.textEncoder.encode(value$1);
			this.uint32(chunk.byteLength);
			return this.raw(chunk);
		}
		float(value$1) {
			assertFloat32(value$1);
			let chunk = new Uint8Array(4);
			new DataView(chunk.buffer).setFloat32(0, value$1, true);
			return this.raw(chunk);
		}
		double(value$1) {
			let chunk = new Uint8Array(8);
			new DataView(chunk.buffer).setFloat64(0, value$1, true);
			return this.raw(chunk);
		}
		fixed32(value$1) {
			assertUInt32(value$1);
			let chunk = new Uint8Array(4);
			new DataView(chunk.buffer).setUint32(0, value$1, true);
			return this.raw(chunk);
		}
		sfixed32(value$1) {
			assertInt32(value$1);
			let chunk = new Uint8Array(4);
			new DataView(chunk.buffer).setInt32(0, value$1, true);
			return this.raw(chunk);
		}
		sint32(value$1) {
			assertInt32(value$1);
			value$1 = (value$1 << 1 ^ value$1 >> 31) >>> 0;
			varint32write(value$1, this.buf);
			return this;
		}
		sfixed64(value$1) {
			let chunk = new Uint8Array(8);
			let view = new DataView(chunk.buffer);
			let long = PbLong.from(value$1);
			view.setInt32(0, long.lo, true);
			view.setInt32(4, long.hi, true);
			return this.raw(chunk);
		}
		fixed64(value$1) {
			let chunk = new Uint8Array(8);
			let view = new DataView(chunk.buffer);
			let long = PbULong.from(value$1);
			view.setInt32(0, long.lo, true);
			view.setInt32(4, long.hi, true);
			return this.raw(chunk);
		}
		int64(value$1) {
			let long = PbLong.from(value$1);
			varint64write(long.lo, long.hi, this.buf);
			return this;
		}
		sint64(value$1) {
			let long = PbLong.from(value$1), sign = long.hi >> 31;
			varint64write(long.lo << 1 ^ sign, (long.hi << 1 | long.lo >>> 31) ^ sign, this.buf);
			return this;
		}
		uint64(value$1) {
			let long = PbULong.from(value$1);
			varint64write(long.lo, long.hi, this.buf);
			return this;
		}
	};
}));
function jsonReadOptions(options) {
	return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
function jsonWriteOptions(options) {
	return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
function mergeJsonOptions(a, b) {
	var _a, _b;
	let c = Object.assign(Object.assign({}, a), b);
	c.typeRegistry = [...(_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : [], ...(_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : []];
	return c;
}
var defaultsWrite, defaultsRead;
var init_json_format_contract = __esmMin((() => {
	defaultsWrite = {
		emitDefaultValues: false,
		enumAsInteger: false,
		useProtoFieldName: false,
		prettySpaces: 0
	}, defaultsRead = { ignoreUnknownFields: false };
}));
var MESSAGE_TYPE;
var init_message_type_contract = __esmMin((() => {
	MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
}));
function lowerCamelCase(snakeCase$2) {
	let capNext = false;
	const sb = [];
	for (let i = 0; i < snakeCase$2.length; i++) {
		let next = snakeCase$2.charAt(i);
		if (next == "_") capNext = true;
		else if (/\d/.test(next)) {
			sb.push(next);
			capNext = true;
		} else if (capNext) {
			sb.push(next.toUpperCase());
			capNext = false;
		} else if (i == 0) sb.push(next.toLowerCase());
		else sb.push(next);
	}
	return sb.join("");
}
var init_lower_camel_case = __esmMin((() => {}));
function normalizeFieldInfo(field) {
	var _a, _b, _c, _d;
	field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
	field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
	field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
	field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
	return field;
}
function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
	var _a;
	const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
	return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : void 0;
}
function readFieldOption(messageType, fieldName, extensionName, extensionType) {
	var _a;
	const options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
	if (!options) return;
	const optionVal = options[extensionName];
	if (optionVal === void 0) return optionVal;
	return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readMessageOption(messageType, extensionName, extensionType) {
	const optionVal = messageType.options[extensionName];
	if (optionVal === void 0) return optionVal;
	return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
var ScalarType, LongType, RepeatType;
var init_reflection_info$1 = __esmMin((() => {
	init_lower_camel_case();
	(function(ScalarType$1) {
		ScalarType$1[ScalarType$1["DOUBLE"] = 1] = "DOUBLE";
		ScalarType$1[ScalarType$1["FLOAT"] = 2] = "FLOAT";
		ScalarType$1[ScalarType$1["INT64"] = 3] = "INT64";
		ScalarType$1[ScalarType$1["UINT64"] = 4] = "UINT64";
		ScalarType$1[ScalarType$1["INT32"] = 5] = "INT32";
		ScalarType$1[ScalarType$1["FIXED64"] = 6] = "FIXED64";
		ScalarType$1[ScalarType$1["FIXED32"] = 7] = "FIXED32";
		ScalarType$1[ScalarType$1["BOOL"] = 8] = "BOOL";
		ScalarType$1[ScalarType$1["STRING"] = 9] = "STRING";
		ScalarType$1[ScalarType$1["BYTES"] = 12] = "BYTES";
		ScalarType$1[ScalarType$1["UINT32"] = 13] = "UINT32";
		ScalarType$1[ScalarType$1["SFIXED32"] = 15] = "SFIXED32";
		ScalarType$1[ScalarType$1["SFIXED64"] = 16] = "SFIXED64";
		ScalarType$1[ScalarType$1["SINT32"] = 17] = "SINT32";
		ScalarType$1[ScalarType$1["SINT64"] = 18] = "SINT64";
	})(ScalarType || (ScalarType = {}));
	(function(LongType$1) {
		LongType$1[LongType$1["BIGINT"] = 0] = "BIGINT";
		LongType$1[LongType$1["STRING"] = 1] = "STRING";
		LongType$1[LongType$1["NUMBER"] = 2] = "NUMBER";
	})(LongType || (LongType = {}));
	(function(RepeatType$1) {
		RepeatType$1[RepeatType$1["NO"] = 0] = "NO";
		RepeatType$1[RepeatType$1["PACKED"] = 1] = "PACKED";
		RepeatType$1[RepeatType$1["UNPACKED"] = 2] = "UNPACKED";
	})(RepeatType || (RepeatType = {}));
}));
function isOneofGroup(any) {
	if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) return false;
	switch (typeof any.oneofKind) {
		case "string":
			if (any[any.oneofKind] === void 0) return false;
			return Object.keys(any).length == 2;
		case "undefined": return Object.keys(any).length == 1;
		default: return false;
	}
}
function getOneofValue(oneof, kind) {
	return oneof[kind];
}
function setOneofValue(oneof, kind, value$1) {
	if (oneof.oneofKind !== void 0) delete oneof[oneof.oneofKind];
	oneof.oneofKind = kind;
	if (value$1 !== void 0) oneof[kind] = value$1;
}
function clearOneofValue(oneof) {
	if (oneof.oneofKind !== void 0) delete oneof[oneof.oneofKind];
	oneof.oneofKind = void 0;
}
function getSelectedOneofValue(oneof) {
	if (oneof.oneofKind === void 0) return;
	return oneof[oneof.oneofKind];
}
var init_oneof = __esmMin((() => {}));
var ReflectionTypeCheck;
var init_reflection_type_check = __esmMin((() => {
	init_reflection_info$1();
	init_oneof();
	ReflectionTypeCheck = class {
		constructor(info) {
			var _a;
			this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
		}
		prepare() {
			if (this.data) return;
			const req = [], known = [], oneofs = [];
			for (let field of this.fields) if (field.oneof) {
				if (!oneofs.includes(field.oneof)) {
					oneofs.push(field.oneof);
					req.push(field.oneof);
					known.push(field.oneof);
				}
			} else {
				known.push(field.localName);
				switch (field.kind) {
					case "scalar":
					case "enum":
						if (!field.opt || field.repeat) req.push(field.localName);
						break;
					case "message":
						if (field.repeat) req.push(field.localName);
						break;
					case "map":
						req.push(field.localName);
						break;
				}
			}
			this.data = {
				req,
				known,
				oneofs: Object.values(oneofs)
			};
		}
		is(message, depth, allowExcessProperties = false) {
			if (depth < 0) return true;
			if (message === null || message === void 0 || typeof message != "object") return false;
			this.prepare();
			let keys = Object.keys(message), data = this.data;
			if (keys.length < data.req.length || data.req.some((n$1) => !keys.includes(n$1))) return false;
			if (!allowExcessProperties) {
				if (keys.some((k) => !data.known.includes(k))) return false;
			}
			if (depth < 1) return true;
			for (const name$1 of data.oneofs) {
				const group = message[name$1];
				if (!isOneofGroup(group)) return false;
				if (group.oneofKind === void 0) continue;
				const field = this.fields.find((f) => f.localName === group.oneofKind);
				if (!field) return false;
				if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth)) return false;
			}
			for (const field of this.fields) {
				if (field.oneof !== void 0) continue;
				if (!this.field(message[field.localName], field, allowExcessProperties, depth)) return false;
			}
			return true;
		}
		field(arg, field, allowExcessProperties, depth) {
			let repeated = field.repeat;
			switch (field.kind) {
				case "scalar":
					if (arg === void 0) return field.opt;
					if (repeated) return this.scalars(arg, field.T, depth, field.L);
					return this.scalar(arg, field.T, field.L);
				case "enum":
					if (arg === void 0) return field.opt;
					if (repeated) return this.scalars(arg, ScalarType.INT32, depth);
					return this.scalar(arg, ScalarType.INT32);
				case "message":
					if (arg === void 0) return true;
					if (repeated) return this.messages(arg, field.T(), allowExcessProperties, depth);
					return this.message(arg, field.T(), allowExcessProperties, depth);
				case "map":
					if (typeof arg != "object" || arg === null) return false;
					if (depth < 2) return true;
					if (!this.mapKeys(arg, field.K, depth)) return false;
					switch (field.V.kind) {
						case "scalar": return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
						case "enum": return this.scalars(Object.values(arg), ScalarType.INT32, depth);
						case "message": return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
					}
					break;
			}
			return true;
		}
		message(arg, type, allowExcessProperties, depth) {
			if (allowExcessProperties) return type.isAssignable(arg, depth);
			return type.is(arg, depth);
		}
		messages(arg, type, allowExcessProperties, depth) {
			if (!Array.isArray(arg)) return false;
			if (depth < 2) return true;
			if (allowExcessProperties) {
				for (let i = 0; i < arg.length && i < depth; i++) if (!type.isAssignable(arg[i], depth - 1)) return false;
			} else for (let i = 0; i < arg.length && i < depth; i++) if (!type.is(arg[i], depth - 1)) return false;
			return true;
		}
		scalar(arg, type, longType) {
			let argType = typeof arg;
			switch (type) {
				case ScalarType.UINT64:
				case ScalarType.FIXED64:
				case ScalarType.INT64:
				case ScalarType.SFIXED64:
				case ScalarType.SINT64: switch (longType) {
					case LongType.BIGINT: return argType == "bigint";
					case LongType.NUMBER: return argType == "number" && !isNaN(arg);
					default: return argType == "string";
				}
				case ScalarType.BOOL: return argType == "boolean";
				case ScalarType.STRING: return argType == "string";
				case ScalarType.BYTES: return arg instanceof Uint8Array;
				case ScalarType.DOUBLE:
				case ScalarType.FLOAT: return argType == "number" && !isNaN(arg);
				default: return argType == "number" && Number.isInteger(arg);
			}
		}
		scalars(arg, type, depth, longType) {
			if (!Array.isArray(arg)) return false;
			if (depth < 2) return true;
			if (Array.isArray(arg)) {
				for (let i = 0; i < arg.length && i < depth; i++) if (!this.scalar(arg[i], type, longType)) return false;
			}
			return true;
		}
		mapKeys(map$6, type, depth) {
			let keys = Object.keys(map$6);
			switch (type) {
				case ScalarType.INT32:
				case ScalarType.FIXED32:
				case ScalarType.SFIXED32:
				case ScalarType.SINT32:
				case ScalarType.UINT32: return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type, depth);
				case ScalarType.BOOL: return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? true : k == "false" ? false : k), type, depth);
				default: return this.scalars(keys, type, depth, LongType.STRING);
			}
		}
	};
}));
function reflectionLongConvert(long, type) {
	switch (type) {
		case LongType.BIGINT: return long.toBigInt();
		case LongType.NUMBER: return long.toNumber();
		default: return long.toString();
	}
}
var init_reflection_long_convert = __esmMin((() => {
	init_reflection_info$1();
}));
var ReflectionJsonReader;
var init_reflection_json_reader = __esmMin((() => {
	init_json_typings();
	init_base64();
	init_reflection_info$1();
	init_pb_long();
	init_assert();
	init_reflection_long_convert();
	ReflectionJsonReader = class {
		constructor(info) {
			this.info = info;
		}
		prepare() {
			var _a;
			if (this.fMap === void 0) {
				this.fMap = {};
				const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
				for (const field of fieldsInput) {
					this.fMap[field.name] = field;
					this.fMap[field.jsonName] = field;
					this.fMap[field.localName] = field;
				}
			}
		}
		assert(condition, fieldName, jsonValue) {
			if (!condition) {
				let what = typeofJsonValue(jsonValue);
				if (what == "number" || what == "boolean") what = jsonValue.toString();
				throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
			}
		}
		read(input, message, options) {
			this.prepare();
			const oneofsHandled = [];
			for (const [jsonKey, jsonValue] of Object.entries(input)) {
				const field = this.fMap[jsonKey];
				if (!field) {
					if (!options.ignoreUnknownFields) throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
					continue;
				}
				const localName = field.localName;
				let target;
				if (field.oneof) {
					if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) continue;
					if (oneofsHandled.includes(field.oneof)) throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
					oneofsHandled.push(field.oneof);
					target = message[field.oneof] = { oneofKind: localName };
				} else target = message;
				if (field.kind == "map") {
					if (jsonValue === null) continue;
					this.assert(isJsonObject(jsonValue), field.name, jsonValue);
					const fieldObj = target[localName];
					for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
						this.assert(jsonObjValue !== null, field.name + " map value", null);
						let val;
						switch (field.V.kind) {
							case "message":
								val = field.V.T().internalJsonRead(jsonObjValue, options);
								break;
							case "enum":
								val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
								if (val === false) continue;
								break;
							case "scalar":
								val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
								break;
						}
						this.assert(val !== void 0, field.name + " map value", jsonObjValue);
						let key = jsonObjKey;
						if (field.K == ScalarType.BOOL) key = key == "true" ? true : key == "false" ? false : key;
						key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
						fieldObj[key] = val;
					}
				} else if (field.repeat) {
					if (jsonValue === null) continue;
					this.assert(Array.isArray(jsonValue), field.name, jsonValue);
					const fieldArr = target[localName];
					for (const jsonItem of jsonValue) {
						this.assert(jsonItem !== null, field.name, null);
						let val;
						switch (field.kind) {
							case "message":
								val = field.T().internalJsonRead(jsonItem, options);
								break;
							case "enum":
								val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
								if (val === false) continue;
								break;
							case "scalar":
								val = this.scalar(jsonItem, field.T, field.L, field.name);
								break;
						}
						this.assert(val !== void 0, field.name, jsonValue);
						fieldArr.push(val);
					}
				} else switch (field.kind) {
					case "message":
						if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
							this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
							continue;
						}
						target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
						break;
					case "enum":
						if (jsonValue === null) continue;
						let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
						if (val === false) continue;
						target[localName] = val;
						break;
					case "scalar":
						if (jsonValue === null) continue;
						target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
						break;
				}
			}
		}
		enum(type, json, fieldName, ignoreUnknownFields) {
			if (type[0] == "google.protobuf.NullValue") assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
			if (json === null) return 0;
			switch (typeof json) {
				case "number":
					assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
					return json;
				case "string":
					let localEnumName = json;
					if (type[2] && json.substring(0, type[2].length) === type[2]) localEnumName = json.substring(type[2].length);
					let enumNumber = type[1][localEnumName];
					if (typeof enumNumber === "undefined" && ignoreUnknownFields) return false;
					assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
					return enumNumber;
			}
			assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
		}
		scalar(json, type, longType, fieldName) {
			let e$1;
			try {
				switch (type) {
					case ScalarType.DOUBLE:
					case ScalarType.FLOAT:
						if (json === null) return 0;
						if (json === "NaN") return NaN;
						if (json === "Infinity") return Number.POSITIVE_INFINITY;
						if (json === "-Infinity") return Number.NEGATIVE_INFINITY;
						if (json === "") {
							e$1 = "empty string";
							break;
						}
						if (typeof json == "string" && json.trim().length !== json.length) {
							e$1 = "extra whitespace";
							break;
						}
						if (typeof json != "string" && typeof json != "number") break;
						let float = Number(json);
						if (Number.isNaN(float)) {
							e$1 = "not a number";
							break;
						}
						if (!Number.isFinite(float)) {
							e$1 = "too large or small";
							break;
						}
						if (type == ScalarType.FLOAT) assertFloat32(float);
						return float;
					case ScalarType.INT32:
					case ScalarType.FIXED32:
					case ScalarType.SFIXED32:
					case ScalarType.SINT32:
					case ScalarType.UINT32:
						if (json === null) return 0;
						let int32;
						if (typeof json == "number") int32 = json;
						else if (json === "") e$1 = "empty string";
						else if (typeof json == "string") if (json.trim().length !== json.length) e$1 = "extra whitespace";
						else int32 = Number(json);
						if (int32 === void 0) break;
						if (type == ScalarType.UINT32) assertUInt32(int32);
						else assertInt32(int32);
						return int32;
					case ScalarType.INT64:
					case ScalarType.SFIXED64:
					case ScalarType.SINT64:
						if (json === null) return reflectionLongConvert(PbLong.ZERO, longType);
						if (typeof json != "number" && typeof json != "string") break;
						return reflectionLongConvert(PbLong.from(json), longType);
					case ScalarType.FIXED64:
					case ScalarType.UINT64:
						if (json === null) return reflectionLongConvert(PbULong.ZERO, longType);
						if (typeof json != "number" && typeof json != "string") break;
						return reflectionLongConvert(PbULong.from(json), longType);
					case ScalarType.BOOL:
						if (json === null) return false;
						if (typeof json !== "boolean") break;
						return json;
					case ScalarType.STRING:
						if (json === null) return "";
						if (typeof json !== "string") {
							e$1 = "extra whitespace";
							break;
						}
						return json;
					case ScalarType.BYTES:
						if (json === null || json === "") return new Uint8Array(0);
						if (typeof json !== "string") break;
						return base64decode(json);
				}
			} catch (error) {
				e$1 = error.message;
			}
			this.assert(false, fieldName + (e$1 ? " - " + e$1 : ""), json);
		}
	};
}));
var ReflectionJsonWriter;
var init_reflection_json_writer = __esmMin((() => {
	init_base64();
	init_pb_long();
	init_reflection_info$1();
	init_assert();
	ReflectionJsonWriter = class {
		constructor(info) {
			var _a;
			this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
		}
		write(message, options) {
			const json = {}, source = message;
			for (const field of this.fields) {
				if (!field.oneof) {
					let jsonValue$1 = this.field(field, source[field.localName], options);
					if (jsonValue$1 !== void 0) json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue$1;
					continue;
				}
				const group = source[field.oneof];
				if (group.oneofKind !== field.localName) continue;
				const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
				let jsonValue = this.field(field, group[field.localName], opt);
				assert(jsonValue !== void 0);
				json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
			}
			return json;
		}
		field(field, value$1, options) {
			let jsonValue = void 0;
			if (field.kind == "map") {
				assert(typeof value$1 == "object" && value$1 !== null);
				const jsonObj = {};
				switch (field.V.kind) {
					case "scalar":
						for (const [entryKey, entryValue] of Object.entries(value$1)) {
							const val = this.scalar(field.V.T, entryValue, field.name, false, true);
							assert(val !== void 0);
							jsonObj[entryKey.toString()] = val;
						}
						break;
					case "message":
						const messageType = field.V.T();
						for (const [entryKey, entryValue] of Object.entries(value$1)) {
							const val = this.message(messageType, entryValue, field.name, options);
							assert(val !== void 0);
							jsonObj[entryKey.toString()] = val;
						}
						break;
					case "enum":
						const enumInfo = field.V.T();
						for (const [entryKey, entryValue] of Object.entries(value$1)) {
							assert(entryValue === void 0 || typeof entryValue == "number");
							const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
							assert(val !== void 0);
							jsonObj[entryKey.toString()] = val;
						}
						break;
				}
				if (options.emitDefaultValues || Object.keys(jsonObj).length > 0) jsonValue = jsonObj;
			} else if (field.repeat) {
				assert(Array.isArray(value$1));
				const jsonArr = [];
				switch (field.kind) {
					case "scalar":
						for (let i = 0; i < value$1.length; i++) {
							const val = this.scalar(field.T, value$1[i], field.name, field.opt, true);
							assert(val !== void 0);
							jsonArr.push(val);
						}
						break;
					case "enum":
						const enumInfo = field.T();
						for (let i = 0; i < value$1.length; i++) {
							assert(value$1[i] === void 0 || typeof value$1[i] == "number");
							const val = this.enum(enumInfo, value$1[i], field.name, field.opt, true, options.enumAsInteger);
							assert(val !== void 0);
							jsonArr.push(val);
						}
						break;
					case "message":
						const messageType = field.T();
						for (let i = 0; i < value$1.length; i++) {
							const val = this.message(messageType, value$1[i], field.name, options);
							assert(val !== void 0);
							jsonArr.push(val);
						}
						break;
				}
				if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues) jsonValue = jsonArr;
			} else switch (field.kind) {
				case "scalar":
					jsonValue = this.scalar(field.T, value$1, field.name, field.opt, options.emitDefaultValues);
					break;
				case "enum":
					jsonValue = this.enum(field.T(), value$1, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
					break;
				case "message":
					jsonValue = this.message(field.T(), value$1, field.name, options);
					break;
			}
			return jsonValue;
		}
		enum(type, value$1, fieldName, optional, emitDefaultValues, enumAsInteger) {
			if (type[0] == "google.protobuf.NullValue") return !emitDefaultValues && !optional ? void 0 : null;
			if (value$1 === void 0) {
				assert(optional);
				return;
			}
			if (value$1 === 0 && !emitDefaultValues && !optional) return void 0;
			assert(typeof value$1 == "number");
			assert(Number.isInteger(value$1));
			if (enumAsInteger || !type[1].hasOwnProperty(value$1)) return value$1;
			if (type[2]) return type[2] + type[1][value$1];
			return type[1][value$1];
		}
		message(type, value$1, fieldName, options) {
			if (value$1 === void 0) return options.emitDefaultValues ? null : void 0;
			return type.internalJsonWrite(value$1, options);
		}
		scalar(type, value$1, fieldName, optional, emitDefaultValues) {
			if (value$1 === void 0) {
				assert(optional);
				return;
			}
			const ed = emitDefaultValues || optional;
			switch (type) {
				case ScalarType.INT32:
				case ScalarType.SFIXED32:
				case ScalarType.SINT32:
					if (value$1 === 0) return ed ? 0 : void 0;
					assertInt32(value$1);
					return value$1;
				case ScalarType.FIXED32:
				case ScalarType.UINT32:
					if (value$1 === 0) return ed ? 0 : void 0;
					assertUInt32(value$1);
					return value$1;
				case ScalarType.FLOAT: assertFloat32(value$1);
				case ScalarType.DOUBLE:
					if (value$1 === 0) return ed ? 0 : void 0;
					assert(typeof value$1 == "number");
					if (Number.isNaN(value$1)) return "NaN";
					if (value$1 === Number.POSITIVE_INFINITY) return "Infinity";
					if (value$1 === Number.NEGATIVE_INFINITY) return "-Infinity";
					return value$1;
				case ScalarType.STRING:
					if (value$1 === "") return ed ? "" : void 0;
					assert(typeof value$1 == "string");
					return value$1;
				case ScalarType.BOOL:
					if (value$1 === false) return ed ? false : void 0;
					assert(typeof value$1 == "boolean");
					return value$1;
				case ScalarType.UINT64:
				case ScalarType.FIXED64:
					assert(typeof value$1 == "number" || typeof value$1 == "string" || typeof value$1 == "bigint");
					let ulong = PbULong.from(value$1);
					if (ulong.isZero() && !ed) return void 0;
					return ulong.toString();
				case ScalarType.INT64:
				case ScalarType.SFIXED64:
				case ScalarType.SINT64:
					assert(typeof value$1 == "number" || typeof value$1 == "string" || typeof value$1 == "bigint");
					let long = PbLong.from(value$1);
					if (long.isZero() && !ed) return void 0;
					return long.toString();
				case ScalarType.BYTES:
					assert(value$1 instanceof Uint8Array);
					if (!value$1.byteLength) return ed ? "" : void 0;
					return base64encode(value$1);
			}
		}
	};
}));
function reflectionScalarDefault(type, longType = LongType.STRING) {
	switch (type) {
		case ScalarType.BOOL: return false;
		case ScalarType.UINT64:
		case ScalarType.FIXED64: return reflectionLongConvert(PbULong.ZERO, longType);
		case ScalarType.INT64:
		case ScalarType.SFIXED64:
		case ScalarType.SINT64: return reflectionLongConvert(PbLong.ZERO, longType);
		case ScalarType.DOUBLE:
		case ScalarType.FLOAT: return 0;
		case ScalarType.BYTES: return new Uint8Array(0);
		case ScalarType.STRING: return "";
		default: return 0;
	}
}
var init_reflection_scalar_default = __esmMin((() => {
	init_reflection_info$1();
	init_reflection_long_convert();
	init_pb_long();
}));
var ReflectionBinaryReader;
var init_reflection_binary_reader = __esmMin((() => {
	init_binary_format_contract();
	init_reflection_info$1();
	init_reflection_long_convert();
	init_reflection_scalar_default();
	ReflectionBinaryReader = class {
		constructor(info) {
			this.info = info;
		}
		prepare() {
			var _a;
			if (!this.fieldNoToField) {
				const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
				this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
			}
		}
		read(reader, message, options, length) {
			this.prepare();
			const end = length === void 0 ? reader.len : reader.pos + length;
			while (reader.pos < end) {
				const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
				if (!field) {
					let u = options.readUnknownField;
					if (u == "throw") throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
					let d = reader.skip(wireType);
					if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
					continue;
				}
				let target = message, repeated = field.repeat, localName = field.localName;
				if (field.oneof) {
					target = target[field.oneof];
					if (target.oneofKind !== localName) target = message[field.oneof] = { oneofKind: localName };
				}
				switch (field.kind) {
					case "scalar":
					case "enum":
						let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
						let L = field.kind == "scalar" ? field.L : void 0;
						if (repeated) {
							let arr = target[localName];
							if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
								let e$1 = reader.uint32() + reader.pos;
								while (reader.pos < e$1) arr.push(this.scalar(reader, T, L));
							} else arr.push(this.scalar(reader, T, L));
						} else target[localName] = this.scalar(reader, T, L);
						break;
					case "message":
						if (repeated) {
							let arr = target[localName];
							let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
							arr.push(msg);
						} else target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
						break;
					case "map":
						let [mapKey, mapVal] = this.mapEntry(field, reader, options);
						target[localName][mapKey] = mapVal;
						break;
				}
			}
		}
		mapEntry(field, reader, options) {
			let length = reader.uint32();
			let end = reader.pos + length;
			let key = void 0;
			let val = void 0;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						if (field.K == ScalarType.BOOL) key = reader.bool().toString();
						else key = this.scalar(reader, field.K, LongType.STRING);
						break;
					case 2:
						switch (field.V.kind) {
							case "scalar":
								val = this.scalar(reader, field.V.T, field.V.L);
								break;
							case "enum":
								val = reader.int32();
								break;
							case "message":
								val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
								break;
						}
						break;
					default: throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
				}
			}
			if (key === void 0) {
				let keyRaw = reflectionScalarDefault(field.K);
				key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
			}
			if (val === void 0) switch (field.V.kind) {
				case "scalar":
					val = reflectionScalarDefault(field.V.T, field.V.L);
					break;
				case "enum":
					val = 0;
					break;
				case "message":
					val = field.V.T().create();
					break;
			}
			return [key, val];
		}
		scalar(reader, type, longType) {
			switch (type) {
				case ScalarType.INT32: return reader.int32();
				case ScalarType.STRING: return reader.string();
				case ScalarType.BOOL: return reader.bool();
				case ScalarType.DOUBLE: return reader.double();
				case ScalarType.FLOAT: return reader.float();
				case ScalarType.INT64: return reflectionLongConvert(reader.int64(), longType);
				case ScalarType.UINT64: return reflectionLongConvert(reader.uint64(), longType);
				case ScalarType.FIXED64: return reflectionLongConvert(reader.fixed64(), longType);
				case ScalarType.FIXED32: return reader.fixed32();
				case ScalarType.BYTES: return reader.bytes();
				case ScalarType.UINT32: return reader.uint32();
				case ScalarType.SFIXED32: return reader.sfixed32();
				case ScalarType.SFIXED64: return reflectionLongConvert(reader.sfixed64(), longType);
				case ScalarType.SINT32: return reader.sint32();
				case ScalarType.SINT64: return reflectionLongConvert(reader.sint64(), longType);
			}
		}
	};
}));
var ReflectionBinaryWriter;
var init_reflection_binary_writer = __esmMin((() => {
	init_binary_format_contract();
	init_reflection_info$1();
	init_assert();
	init_pb_long();
	ReflectionBinaryWriter = class {
		constructor(info) {
			this.info = info;
		}
		prepare() {
			if (!this.fields) this.fields = (this.info.fields ? this.info.fields.concat() : []).sort((a, b) => a.no - b.no);
		}
		write(message, writer, options) {
			this.prepare();
			for (const field of this.fields) {
				let value$1, emitDefault, repeated = field.repeat, localName = field.localName;
				if (field.oneof) {
					const group = message[field.oneof];
					if (group.oneofKind !== localName) continue;
					value$1 = group[localName];
					emitDefault = true;
				} else {
					value$1 = message[localName];
					emitDefault = false;
				}
				switch (field.kind) {
					case "scalar":
					case "enum":
						let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
						if (repeated) {
							assert(Array.isArray(value$1));
							if (repeated == RepeatType.PACKED) this.packed(writer, T, field.no, value$1);
							else for (const item of value$1) this.scalar(writer, T, field.no, item, true);
						} else if (value$1 === void 0) assert(field.opt);
						else this.scalar(writer, T, field.no, value$1, emitDefault || field.opt);
						break;
					case "message":
						if (repeated) {
							assert(Array.isArray(value$1));
							for (const item of value$1) this.message(writer, options, field.T(), field.no, item);
						} else this.message(writer, options, field.T(), field.no, value$1);
						break;
					case "map":
						assert(typeof value$1 == "object" && value$1 !== null);
						for (const [key, val] of Object.entries(value$1)) this.mapEntry(writer, options, field, key, val);
						break;
				}
			}
			let u = options.writeUnknownFields;
			if (u !== false) (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
		}
		mapEntry(writer, options, field, key, value$1) {
			writer.tag(field.no, WireType.LengthDelimited);
			writer.fork();
			let keyValue = key;
			switch (field.K) {
				case ScalarType.INT32:
				case ScalarType.FIXED32:
				case ScalarType.UINT32:
				case ScalarType.SFIXED32:
				case ScalarType.SINT32:
					keyValue = Number.parseInt(key);
					break;
				case ScalarType.BOOL:
					assert(key == "true" || key == "false");
					keyValue = key == "true";
					break;
			}
			this.scalar(writer, field.K, 1, keyValue, true);
			switch (field.V.kind) {
				case "scalar":
					this.scalar(writer, field.V.T, 2, value$1, true);
					break;
				case "enum":
					this.scalar(writer, ScalarType.INT32, 2, value$1, true);
					break;
				case "message":
					this.message(writer, options, field.V.T(), 2, value$1);
					break;
			}
			writer.join();
		}
		message(writer, options, handler$1, fieldNo, value$1) {
			if (value$1 === void 0) return;
			handler$1.internalBinaryWrite(value$1, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
			writer.join();
		}
		scalar(writer, type, fieldNo, value$1, emitDefault) {
			let [wireType, method, isDefault] = this.scalarInfo(type, value$1);
			if (!isDefault || emitDefault) {
				writer.tag(fieldNo, wireType);
				writer[method](value$1);
			}
		}
		packed(writer, type, fieldNo, value$1) {
			if (!value$1.length) return;
			assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
			writer.tag(fieldNo, WireType.LengthDelimited);
			writer.fork();
			let [, method] = this.scalarInfo(type);
			for (let i = 0; i < value$1.length; i++) writer[method](value$1[i]);
			writer.join();
		}
		scalarInfo(type, value$1) {
			let t$1 = WireType.Varint;
			let m;
			let i = value$1 === void 0;
			let d = value$1 === 0;
			switch (type) {
				case ScalarType.INT32:
					m = "int32";
					break;
				case ScalarType.STRING:
					d = i || !value$1.length;
					t$1 = WireType.LengthDelimited;
					m = "string";
					break;
				case ScalarType.BOOL:
					d = value$1 === false;
					m = "bool";
					break;
				case ScalarType.UINT32:
					m = "uint32";
					break;
				case ScalarType.DOUBLE:
					t$1 = WireType.Bit64;
					m = "double";
					break;
				case ScalarType.FLOAT:
					t$1 = WireType.Bit32;
					m = "float";
					break;
				case ScalarType.INT64:
					d = i || PbLong.from(value$1).isZero();
					m = "int64";
					break;
				case ScalarType.UINT64:
					d = i || PbULong.from(value$1).isZero();
					m = "uint64";
					break;
				case ScalarType.FIXED64:
					d = i || PbULong.from(value$1).isZero();
					t$1 = WireType.Bit64;
					m = "fixed64";
					break;
				case ScalarType.BYTES:
					d = i || !value$1.byteLength;
					t$1 = WireType.LengthDelimited;
					m = "bytes";
					break;
				case ScalarType.FIXED32:
					t$1 = WireType.Bit32;
					m = "fixed32";
					break;
				case ScalarType.SFIXED32:
					t$1 = WireType.Bit32;
					m = "sfixed32";
					break;
				case ScalarType.SFIXED64:
					d = i || PbLong.from(value$1).isZero();
					t$1 = WireType.Bit64;
					m = "sfixed64";
					break;
				case ScalarType.SINT32:
					m = "sint32";
					break;
				case ScalarType.SINT64:
					d = i || PbLong.from(value$1).isZero();
					m = "sint64";
					break;
			}
			return [
				t$1,
				m,
				i || d
			];
		}
	};
}));
function reflectionCreate(type) {
	const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
	for (let field of type.fields) {
		let name$1 = field.localName;
		if (field.opt) continue;
		if (field.oneof) msg[field.oneof] = { oneofKind: void 0 };
		else if (field.repeat) msg[name$1] = [];
		else switch (field.kind) {
			case "scalar":
				msg[name$1] = reflectionScalarDefault(field.T, field.L);
				break;
			case "enum":
				msg[name$1] = 0;
				break;
			case "map":
				msg[name$1] = {};
				break;
		}
	}
	return msg;
}
var init_reflection_create = __esmMin((() => {
	init_reflection_scalar_default();
	init_message_type_contract();
}));
function reflectionMergePartial(info, target, source) {
	let fieldValue, input = source, output;
	for (let field of info.fields) {
		let name$1 = field.localName;
		if (field.oneof) {
			const group = input[field.oneof];
			if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) continue;
			fieldValue = group[name$1];
			output = target[field.oneof];
			output.oneofKind = group.oneofKind;
			if (fieldValue == void 0) {
				delete output[name$1];
				continue;
			}
		} else {
			fieldValue = input[name$1];
			output = target;
			if (fieldValue == void 0) continue;
		}
		if (field.repeat) output[name$1].length = fieldValue.length;
		switch (field.kind) {
			case "scalar":
			case "enum":
				if (field.repeat) for (let i = 0; i < fieldValue.length; i++) output[name$1][i] = fieldValue[i];
				else output[name$1] = fieldValue;
				break;
			case "message":
				let T = field.T();
				if (field.repeat) for (let i = 0; i < fieldValue.length; i++) output[name$1][i] = T.create(fieldValue[i]);
				else if (output[name$1] === void 0) output[name$1] = T.create(fieldValue);
				else T.mergePartial(output[name$1], fieldValue);
				break;
			case "map":
				switch (field.V.kind) {
					case "scalar":
					case "enum":
						Object.assign(output[name$1], fieldValue);
						break;
					case "message":
						let T$1 = field.V.T();
						for (let k of Object.keys(fieldValue)) output[name$1][k] = T$1.create(fieldValue[k]);
						break;
				}
				break;
		}
	}
}
var init_reflection_merge_partial = __esmMin((() => {}));
function reflectionEquals(info, a, b) {
	if (a === b) return true;
	if (!a || !b) return false;
	for (let field of info.fields) {
		let localName = field.localName;
		let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
		let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
		switch (field.kind) {
			case "enum":
			case "scalar":
				let t$1 = field.kind == "enum" ? ScalarType.INT32 : field.T;
				if (!(field.repeat ? repeatedPrimitiveEq(t$1, val_a, val_b) : primitiveEq(t$1, val_a, val_b))) return false;
				break;
			case "map":
				if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b)))) return false;
				break;
			case "message":
				let T = field.T();
				if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b))) return false;
				break;
		}
	}
	return true;
}
function primitiveEq(type, a, b) {
	if (a === b) return true;
	if (type !== ScalarType.BYTES) return false;
	let ba = a;
	let bb = b;
	if (ba.length !== bb.length) return false;
	for (let i = 0; i < ba.length; i++) if (ba[i] != bb[i]) return false;
	return true;
}
function repeatedPrimitiveEq(type, a, b) {
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) if (!primitiveEq(type, a[i], b[i])) return false;
	return true;
}
function repeatedMsgEq(type, a, b) {
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) if (!type.equals(a[i], b[i])) return false;
	return true;
}
var objectValues;
var init_reflection_equals = __esmMin((() => {
	init_reflection_info$1();
	objectValues = Object.values;
}));
var baseDescriptors, messageTypeDescriptor, MessageType;
var init_message_type = __esmMin((() => {
	init_message_type_contract();
	init_reflection_info$1();
	init_reflection_type_check();
	init_reflection_json_reader();
	init_reflection_json_writer();
	init_reflection_binary_reader();
	init_reflection_binary_writer();
	init_reflection_create();
	init_reflection_merge_partial();
	init_json_typings();
	init_json_format_contract();
	init_reflection_equals();
	init_binary_writer();
	init_binary_reader();
	baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
	messageTypeDescriptor = baseDescriptors[MESSAGE_TYPE] = {};
	MessageType = class {
		constructor(name$1, fields, options) {
			this.defaultCheckDepth = 16;
			this.typeName = name$1;
			this.fields = fields.map(normalizeFieldInfo);
			this.options = options !== null && options !== void 0 ? options : {};
			messageTypeDescriptor.value = this;
			this.messagePrototype = Object.create(null, baseDescriptors);
			this.refTypeCheck = new ReflectionTypeCheck(this);
			this.refJsonReader = new ReflectionJsonReader(this);
			this.refJsonWriter = new ReflectionJsonWriter(this);
			this.refBinReader = new ReflectionBinaryReader(this);
			this.refBinWriter = new ReflectionBinaryWriter(this);
		}
		create(value$1) {
			let message = reflectionCreate(this);
			if (value$1 !== void 0) reflectionMergePartial(this, message, value$1);
			return message;
		}
		clone(message) {
			let copy$1 = this.create();
			reflectionMergePartial(this, copy$1, message);
			return copy$1;
		}
		equals(a, b) {
			return reflectionEquals(this, a, b);
		}
		is(arg, depth = this.defaultCheckDepth) {
			return this.refTypeCheck.is(arg, depth, false);
		}
		isAssignable(arg, depth = this.defaultCheckDepth) {
			return this.refTypeCheck.is(arg, depth, true);
		}
		mergePartial(target, source) {
			reflectionMergePartial(this, target, source);
		}
		fromBinary(data, options) {
			let opt = binaryReadOptions(options);
			return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
		}
		fromJson(json, options) {
			return this.internalJsonRead(json, jsonReadOptions(options));
		}
		fromJsonString(json, options) {
			let value$1 = JSON.parse(json);
			return this.fromJson(value$1, options);
		}
		toJson(message, options) {
			return this.internalJsonWrite(message, jsonWriteOptions(options));
		}
		toJsonString(message, options) {
			var _a;
			let value$1 = this.toJson(message, options);
			return JSON.stringify(value$1, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
		}
		toBinary(message, options) {
			let opt = binaryWriteOptions(options);
			return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
		}
		internalJsonRead(json, options, target) {
			if (json !== null && typeof json == "object" && !Array.isArray(json)) {
				let message = target !== null && target !== void 0 ? target : this.create();
				this.refJsonReader.read(json, message, options);
				return message;
			}
			throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
		}
		internalJsonWrite(message, options) {
			return this.refJsonWriter.write(message, options);
		}
		internalBinaryWrite(message, writer, options) {
			this.refBinWriter.write(message, writer, options);
			return writer;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create();
			this.refBinReader.read(reader, message, options, length);
			return message;
		}
	};
}));
function containsMessageType(msg) {
	return msg[MESSAGE_TYPE] != null;
}
var init_reflection_contains_message_type = __esmMin((() => {
	init_message_type_contract();
}));
function isEnumObject(arg) {
	if (typeof arg != "object" || arg === null) return false;
	if (!arg.hasOwnProperty(0)) return false;
	for (let k of Object.keys(arg)) {
		let num = parseInt(k);
		if (!Number.isNaN(num)) {
			let nam = arg[num];
			if (nam === void 0) return false;
			if (arg[nam] !== num) return false;
		} else {
			let num$1 = arg[k];
			if (num$1 === void 0) return false;
			if (typeof num$1 !== "number") return false;
			if (arg[num$1] === void 0) return false;
		}
	}
	return true;
}
function listEnumValues(enumObject) {
	if (!isEnumObject(enumObject)) throw new Error("not a typescript enum object");
	let values = [];
	for (let [name$1, number] of Object.entries(enumObject)) if (typeof number == "number") values.push({
		name: name$1,
		number
	});
	return values;
}
function listEnumNames(enumObject) {
	return listEnumValues(enumObject).map((val) => val.name);
}
function listEnumNumbers(enumObject) {
	return listEnumValues(enumObject).map((val) => val.number).filter((num, index$1, arr) => arr.indexOf(num) == index$1);
}
var init_enum_object = __esmMin((() => {}));
var es2015_exports$1 = /* @__PURE__ */ __export({
	BinaryReader: () => BinaryReader,
	BinaryWriter: () => BinaryWriter,
	LongType: () => LongType,
	MESSAGE_TYPE: () => MESSAGE_TYPE,
	MessageType: () => MessageType,
	PbLong: () => PbLong,
	PbULong: () => PbULong,
	ReflectionBinaryReader: () => ReflectionBinaryReader,
	ReflectionBinaryWriter: () => ReflectionBinaryWriter,
	ReflectionJsonReader: () => ReflectionJsonReader,
	ReflectionJsonWriter: () => ReflectionJsonWriter,
	ReflectionTypeCheck: () => ReflectionTypeCheck,
	RepeatType: () => RepeatType,
	ScalarType: () => ScalarType,
	UnknownFieldHandler: () => UnknownFieldHandler,
	WireType: () => WireType,
	assert: () => assert,
	assertFloat32: () => assertFloat32,
	assertInt32: () => assertInt32,
	assertNever: () => assertNever,
	assertUInt32: () => assertUInt32,
	base64decode: () => base64decode,
	base64encode: () => base64encode,
	binaryReadOptions: () => binaryReadOptions,
	binaryWriteOptions: () => binaryWriteOptions,
	clearOneofValue: () => clearOneofValue,
	containsMessageType: () => containsMessageType,
	getOneofValue: () => getOneofValue,
	getSelectedOneofValue: () => getSelectedOneofValue,
	isEnumObject: () => isEnumObject,
	isJsonObject: () => isJsonObject,
	isOneofGroup: () => isOneofGroup,
	jsonReadOptions: () => jsonReadOptions,
	jsonWriteOptions: () => jsonWriteOptions,
	listEnumNames: () => listEnumNames,
	listEnumNumbers: () => listEnumNumbers,
	listEnumValues: () => listEnumValues,
	lowerCamelCase: () => lowerCamelCase,
	mergeBinaryOptions: () => mergeBinaryOptions,
	mergeJsonOptions: () => mergeJsonOptions,
	normalizeFieldInfo: () => normalizeFieldInfo,
	readFieldOption: () => readFieldOption,
	readFieldOptions: () => readFieldOptions,
	readMessageOption: () => readMessageOption,
	reflectionCreate: () => reflectionCreate,
	reflectionEquals: () => reflectionEquals,
	reflectionMergePartial: () => reflectionMergePartial,
	reflectionScalarDefault: () => reflectionScalarDefault,
	setOneofValue: () => setOneofValue,
	typeofJsonValue: () => typeofJsonValue,
	utf8read: () => utf8read
}, 1);
var init_es2015$1 = __esmMin((() => {
	init_json_typings();
	init_base64();
	init_protobufjs_utf8();
	init_binary_format_contract();
	init_binary_reader();
	init_binary_writer();
	init_pb_long();
	init_json_format_contract();
	init_message_type_contract();
	init_message_type();
	init_reflection_info$1();
	init_reflection_type_check();
	init_reflection_create();
	init_reflection_scalar_default();
	init_reflection_merge_partial();
	init_reflection_equals();
	init_reflection_binary_reader();
	init_reflection_binary_writer();
	init_reflection_json_reader();
	init_reflection_json_writer();
	init_reflection_contains_message_type();
	init_oneof();
	init_enum_object();
	init_lower_camel_case();
	init_assert();
}));
var require_timestamp$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Timestamp = void 0;
	var runtime_1 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_2 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_3 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_4 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_5 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_6 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_7 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var Timestamp$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.Timestamp", [{
				no: 1,
				name: "seconds",
				kind: "scalar",
				T: 3
			}, {
				no: 2,
				name: "nanos",
				kind: "scalar",
				T: 5
			}]);
		}
		now() {
			const msg = this.create();
			const ms = Date.now();
			msg.seconds = runtime_6.PbLong.from(Math.floor(ms / 1e3)).toString();
			msg.nanos = ms % 1e3 * 1e6;
			return msg;
		}
		toDate(message) {
			return new Date(runtime_6.PbLong.from(message.seconds).toNumber() * 1e3 + Math.ceil(message.nanos / 1e6));
		}
		fromDate(date) {
			const msg = this.create();
			const ms = date.getTime();
			msg.seconds = runtime_6.PbLong.from(Math.floor(ms / 1e3)).toString();
			msg.nanos = ms % 1e3 * 1e6;
			return msg;
		}
		internalJsonWrite(message, options) {
			let ms = runtime_6.PbLong.from(message.seconds).toNumber() * 1e3;
			if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
			if (message.nanos < 0) throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
			let z = "Z";
			if (message.nanos > 0) {
				let nanosStr = (message.nanos + 1e9).toString().substring(1);
				if (nanosStr.substring(3) === "000000") z = "." + nanosStr.substring(0, 3) + "Z";
				else if (nanosStr.substring(6) === "000") z = "." + nanosStr.substring(0, 6) + "Z";
				else z = "." + nanosStr + "Z";
			}
			return new Date(ms).toISOString().replace(".000Z", z);
		}
		internalJsonRead(json, options, target) {
			if (typeof json !== "string") throw new Error("Unable to parse Timestamp from JSON " + (0, runtime_5.typeofJsonValue)(json) + ".");
			let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
			if (!matches) throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
			let ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
			if (Number.isNaN(ms)) throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
			if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
			if (!target) target = this.create();
			target.seconds = runtime_6.PbLong.from(ms / 1e3).toString();
			target.nanos = 0;
			if (matches[7]) target.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
			return target;
		}
		create(value$1) {
			const message = {
				seconds: "0",
				nanos: 0
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.seconds = reader.int64().toString();
						break;
					case 2:
						message.nanos = reader.int32();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.seconds !== "0") writer.tag(1, runtime_1.WireType.Varint).int64(message.seconds);
			if (message.nanos !== 0) writer.tag(2, runtime_1.WireType.Varint).int32(message.nanos);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.Timestamp = new Timestamp$Type();
}));
var require_wrappers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BytesValue = exports.StringValue = exports.BoolValue = exports.UInt32Value = exports.Int32Value = exports.UInt64Value = exports.Int64Value = exports.FloatValue = exports.DoubleValue = void 0;
	var runtime_1 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_2 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_3 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_4 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_5 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_6 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_7 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var DoubleValue$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.DoubleValue", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 1
			}]);
		}
		internalJsonWrite(message, options) {
			return this.refJsonWriter.scalar(2, message.value, "value", false, true);
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, 1, void 0, "value");
			return target;
		}
		create(value$1) {
			const message = { value: 0 };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.double();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value !== 0) writer.tag(1, runtime_3.WireType.Bit64).double(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.DoubleValue = new DoubleValue$Type();
	var FloatValue$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.FloatValue", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 2
			}]);
		}
		internalJsonWrite(message, options) {
			return this.refJsonWriter.scalar(1, message.value, "value", false, true);
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, 1, void 0, "value");
			return target;
		}
		create(value$1) {
			const message = { value: 0 };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.float();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value !== 0) writer.tag(1, runtime_3.WireType.Bit32).float(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.FloatValue = new FloatValue$Type();
	var Int64Value$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.Int64Value", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 3
			}]);
		}
		internalJsonWrite(message, options) {
			return this.refJsonWriter.scalar(runtime_1.ScalarType.INT64, message.value, "value", false, true);
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, runtime_1.ScalarType.INT64, runtime_2.LongType.STRING, "value");
			return target;
		}
		create(value$1) {
			const message = { value: "0" };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.int64().toString();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value !== "0") writer.tag(1, runtime_3.WireType.Varint).int64(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.Int64Value = new Int64Value$Type();
	var UInt64Value$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.UInt64Value", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 4
			}]);
		}
		internalJsonWrite(message, options) {
			return this.refJsonWriter.scalar(runtime_1.ScalarType.UINT64, message.value, "value", false, true);
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, runtime_1.ScalarType.UINT64, runtime_2.LongType.STRING, "value");
			return target;
		}
		create(value$1) {
			const message = { value: "0" };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.uint64().toString();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value !== "0") writer.tag(1, runtime_3.WireType.Varint).uint64(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.UInt64Value = new UInt64Value$Type();
	var Int32Value$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.Int32Value", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 5
			}]);
		}
		internalJsonWrite(message, options) {
			return this.refJsonWriter.scalar(5, message.value, "value", false, true);
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, 5, void 0, "value");
			return target;
		}
		create(value$1) {
			const message = { value: 0 };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.int32();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value !== 0) writer.tag(1, runtime_3.WireType.Varint).int32(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.Int32Value = new Int32Value$Type();
	var UInt32Value$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.UInt32Value", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 13
			}]);
		}
		internalJsonWrite(message, options) {
			return this.refJsonWriter.scalar(13, message.value, "value", false, true);
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, 13, void 0, "value");
			return target;
		}
		create(value$1) {
			const message = { value: 0 };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.uint32();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value !== 0) writer.tag(1, runtime_3.WireType.Varint).uint32(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.UInt32Value = new UInt32Value$Type();
	var BoolValue$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.BoolValue", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 8
			}]);
		}
		internalJsonWrite(message, options) {
			return message.value;
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, 8, void 0, "value");
			return target;
		}
		create(value$1) {
			const message = { value: false };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.bool();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value !== false) writer.tag(1, runtime_3.WireType.Varint).bool(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.BoolValue = new BoolValue$Type();
	var StringValue$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.StringValue", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 9
			}]);
		}
		internalJsonWrite(message, options) {
			return message.value;
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, 9, void 0, "value");
			return target;
		}
		create(value$1) {
			const message = { value: "" };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.string();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value !== "") writer.tag(1, runtime_3.WireType.LengthDelimited).string(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.StringValue = new StringValue$Type();
	var BytesValue$Type = class extends runtime_7.MessageType {
		constructor() {
			super("google.protobuf.BytesValue", [{
				no: 1,
				name: "value",
				kind: "scalar",
				T: 12
			}]);
		}
		internalJsonWrite(message, options) {
			return this.refJsonWriter.scalar(12, message.value, "value", false, true);
		}
		internalJsonRead(json, options, target) {
			if (!target) target = this.create();
			target.value = this.refJsonReader.scalar(json, 12, void 0, "value");
			return target;
		}
		create(value$1) {
			const message = { value: new Uint8Array(0) };
			globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_5.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.value = reader.bytes();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.value.length) writer.tag(1, runtime_3.WireType.LengthDelimited).bytes(message.value);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.BytesValue = new BytesValue$Type();
}));
function normalizeMethodInfo(method, service$2) {
	var _a, _b, _c;
	let m = method;
	m.service = service$2;
	m.localName = (_a = m.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(m.name);
	m.serverStreaming = !!m.serverStreaming;
	m.clientStreaming = !!m.clientStreaming;
	m.options = (_b = m.options) !== null && _b !== void 0 ? _b : {};
	m.idempotency = (_c = m.idempotency) !== null && _c !== void 0 ? _c : void 0;
	return m;
}
function readMethodOptions(service$2, methodName, extensionName, extensionType) {
	var _a;
	const options = (_a = service$2.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === void 0 ? void 0 : _a.options;
	return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : void 0;
}
function readMethodOption(service$2, methodName, extensionName, extensionType) {
	var _a;
	const options = (_a = service$2.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === void 0 ? void 0 : _a.options;
	if (!options) return;
	const optionVal = options[extensionName];
	if (optionVal === void 0) return optionVal;
	return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readServiceOption(service$2, extensionName, extensionType) {
	const options = service$2.options;
	if (!options) return;
	const optionVal = options[extensionName];
	if (optionVal === void 0) return optionVal;
	return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
var init_reflection_info = __esmMin((() => {
	init_es2015$1();
}));
var ServiceType;
var init_service_type = __esmMin((() => {
	init_reflection_info();
	ServiceType = class {
		constructor(typeName, methods, options) {
			this.typeName = typeName;
			this.methods = methods.map((i) => normalizeMethodInfo(i, this));
			this.options = options !== null && options !== void 0 ? options : {};
		}
	};
}));
var RpcError;
var init_rpc_error = __esmMin((() => {
	RpcError = class extends Error {
		constructor(message, code = "UNKNOWN", meta) {
			super(message);
			this.name = "RpcError";
			Object.setPrototypeOf(this, new.target.prototype);
			this.code = code;
			this.meta = meta !== null && meta !== void 0 ? meta : {};
		}
		toString() {
			const l = [this.name + ": " + this.message];
			if (this.code) {
				l.push("");
				l.push("Code: " + this.code);
			}
			if (this.serviceName && this.methodName) l.push("Method: " + this.serviceName + "/" + this.methodName);
			let m = Object.entries(this.meta);
			if (m.length) {
				l.push("");
				l.push("Meta:");
				for (let [k, v] of m) l.push(`  ${k}: ${v}`);
			}
			return l.join("\n");
		}
	};
}));
function mergeRpcOptions(defaults, options) {
	if (!options) return defaults;
	let o$1 = {};
	copy(defaults, o$1);
	copy(options, o$1);
	for (let key of Object.keys(options)) {
		let val = options[key];
		switch (key) {
			case "jsonOptions":
				o$1.jsonOptions = mergeJsonOptions(defaults.jsonOptions, o$1.jsonOptions);
				break;
			case "binaryOptions":
				o$1.binaryOptions = mergeBinaryOptions(defaults.binaryOptions, o$1.binaryOptions);
				break;
			case "meta":
				o$1.meta = {};
				copy(defaults.meta, o$1.meta);
				copy(options.meta, o$1.meta);
				break;
			case "interceptors":
				o$1.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
				break;
		}
	}
	return o$1;
}
function copy(a, into) {
	if (!a) return;
	let c = into;
	for (let [k, v] of Object.entries(a)) if (v instanceof Date) c[k] = new Date(v.getTime());
	else if (Array.isArray(v)) c[k] = v.concat();
	else c[k] = v;
}
var init_rpc_options = __esmMin((() => {
	init_es2015$1();
}));
var DeferredState, Deferred;
var init_deferred = __esmMin((() => {
	(function(DeferredState$1) {
		DeferredState$1[DeferredState$1["PENDING"] = 0] = "PENDING";
		DeferredState$1[DeferredState$1["REJECTED"] = 1] = "REJECTED";
		DeferredState$1[DeferredState$1["RESOLVED"] = 2] = "RESOLVED";
	})(DeferredState || (DeferredState = {}));
	Deferred = class {
		constructor(preventUnhandledRejectionWarning = true) {
			this._state = DeferredState.PENDING;
			this._promise = new Promise((resolve$1, reject$3) => {
				this._resolve = resolve$1;
				this._reject = reject$3;
			});
			if (preventUnhandledRejectionWarning) this._promise.catch((_$1) => {});
		}
		get state() {
			return this._state;
		}
		get promise() {
			return this._promise;
		}
		resolve(value$1) {
			if (this.state !== DeferredState.PENDING) throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
			this._resolve(value$1);
			this._state = DeferredState.RESOLVED;
		}
		reject(reason) {
			if (this.state !== DeferredState.PENDING) throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
			this._reject(reason);
			this._state = DeferredState.REJECTED;
		}
		resolvePending(val) {
			if (this._state === DeferredState.PENDING) this.resolve(val);
		}
		rejectPending(reason) {
			if (this._state === DeferredState.PENDING) this.reject(reason);
		}
	};
}));
var RpcOutputStreamController;
var init_rpc_output_stream = __esmMin((() => {
	init_deferred();
	init_es2015$1();
	RpcOutputStreamController = class {
		constructor() {
			this._lis = {
				nxt: [],
				msg: [],
				err: [],
				cmp: []
			};
			this._closed = false;
			this._itState = { q: [] };
		}
		onNext(callback) {
			return this.addLis(callback, this._lis.nxt);
		}
		onMessage(callback) {
			return this.addLis(callback, this._lis.msg);
		}
		onError(callback) {
			return this.addLis(callback, this._lis.err);
		}
		onComplete(callback) {
			return this.addLis(callback, this._lis.cmp);
		}
		addLis(callback, list) {
			list.push(callback);
			return () => {
				let i = list.indexOf(callback);
				if (i >= 0) list.splice(i, 1);
			};
		}
		clearLis() {
			for (let l of Object.values(this._lis)) l.splice(0, l.length);
		}
		get closed() {
			return this._closed !== false;
		}
		notifyNext(message, error, complete) {
			assert((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
			if (message) this.notifyMessage(message);
			if (error) this.notifyError(error);
			if (complete) this.notifyComplete();
		}
		notifyMessage(message) {
			assert(!this.closed, "stream is closed");
			this.pushIt({
				value: message,
				done: false
			});
			this._lis.msg.forEach((l) => l(message));
			this._lis.nxt.forEach((l) => l(message, void 0, false));
		}
		notifyError(error) {
			assert(!this.closed, "stream is closed");
			this._closed = error;
			this.pushIt(error);
			this._lis.err.forEach((l) => l(error));
			this._lis.nxt.forEach((l) => l(void 0, error, false));
			this.clearLis();
		}
		notifyComplete() {
			assert(!this.closed, "stream is closed");
			this._closed = true;
			this.pushIt({
				value: null,
				done: true
			});
			this._lis.cmp.forEach((l) => l());
			this._lis.nxt.forEach((l) => l(void 0, void 0, true));
			this.clearLis();
		}
		[Symbol.asyncIterator]() {
			if (this._closed === true) this.pushIt({
				value: null,
				done: true
			});
			else if (this._closed !== false) this.pushIt(this._closed);
			return { next: () => {
				let state = this._itState;
				assert(state, "bad state");
				assert(!state.p, "iterator contract broken");
				let first = state.q.shift();
				if (first) return "value" in first ? Promise.resolve(first) : Promise.reject(first);
				state.p = new Deferred();
				return state.p.promise;
			} };
		}
		pushIt(result) {
			let state = this._itState;
			if (state.p) {
				const p = state.p;
				assert(p.state == DeferredState.PENDING, "iterator contract broken");
				"value" in result ? p.resolve(result) : p.reject(result);
				delete state.p;
			} else state.q.push(result);
		}
	};
}));
var __awaiter$5, UnaryCall;
var init_unary_call = __esmMin((() => {
	__awaiter$5 = function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	UnaryCall = class {
		constructor(method, requestHeaders, request$1, headers, response, status, trailers) {
			this.method = method;
			this.requestHeaders = requestHeaders;
			this.request = request$1;
			this.headers = headers;
			this.response = response;
			this.status = status;
			this.trailers = trailers;
		}
		then(onfulfilled, onrejected) {
			return this.promiseFinished().then((value$1) => onfulfilled ? Promise.resolve(onfulfilled(value$1)) : value$1, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
		}
		promiseFinished() {
			return __awaiter$5(this, void 0, void 0, function* () {
				let [headers, response, status, trailers] = yield Promise.all([
					this.headers,
					this.response,
					this.status,
					this.trailers
				]);
				return {
					method: this.method,
					requestHeaders: this.requestHeaders,
					request: this.request,
					headers,
					response,
					status,
					trailers
				};
			});
		}
	};
}));
var __awaiter$4, ServerStreamingCall;
var init_server_streaming_call = __esmMin((() => {
	__awaiter$4 = function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	ServerStreamingCall = class {
		constructor(method, requestHeaders, request$1, headers, response, status, trailers) {
			this.method = method;
			this.requestHeaders = requestHeaders;
			this.request = request$1;
			this.headers = headers;
			this.responses = response;
			this.status = status;
			this.trailers = trailers;
		}
		then(onfulfilled, onrejected) {
			return this.promiseFinished().then((value$1) => onfulfilled ? Promise.resolve(onfulfilled(value$1)) : value$1, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
		}
		promiseFinished() {
			return __awaiter$4(this, void 0, void 0, function* () {
				let [headers, status, trailers] = yield Promise.all([
					this.headers,
					this.status,
					this.trailers
				]);
				return {
					method: this.method,
					requestHeaders: this.requestHeaders,
					request: this.request,
					headers,
					status,
					trailers
				};
			});
		}
	};
}));
var __awaiter$3, ClientStreamingCall;
var init_client_streaming_call = __esmMin((() => {
	__awaiter$3 = function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	ClientStreamingCall = class {
		constructor(method, requestHeaders, request$1, headers, response, status, trailers) {
			this.method = method;
			this.requestHeaders = requestHeaders;
			this.requests = request$1;
			this.headers = headers;
			this.response = response;
			this.status = status;
			this.trailers = trailers;
		}
		then(onfulfilled, onrejected) {
			return this.promiseFinished().then((value$1) => onfulfilled ? Promise.resolve(onfulfilled(value$1)) : value$1, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
		}
		promiseFinished() {
			return __awaiter$3(this, void 0, void 0, function* () {
				let [headers, response, status, trailers] = yield Promise.all([
					this.headers,
					this.response,
					this.status,
					this.trailers
				]);
				return {
					method: this.method,
					requestHeaders: this.requestHeaders,
					headers,
					response,
					status,
					trailers
				};
			});
		}
	};
}));
var __awaiter$2, DuplexStreamingCall;
var init_duplex_streaming_call = __esmMin((() => {
	__awaiter$2 = function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	DuplexStreamingCall = class {
		constructor(method, requestHeaders, request$1, headers, response, status, trailers) {
			this.method = method;
			this.requestHeaders = requestHeaders;
			this.requests = request$1;
			this.headers = headers;
			this.responses = response;
			this.status = status;
			this.trailers = trailers;
		}
		then(onfulfilled, onrejected) {
			return this.promiseFinished().then((value$1) => onfulfilled ? Promise.resolve(onfulfilled(value$1)) : value$1, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
		}
		promiseFinished() {
			return __awaiter$2(this, void 0, void 0, function* () {
				let [headers, status, trailers] = yield Promise.all([
					this.headers,
					this.status,
					this.trailers
				]);
				return {
					method: this.method,
					requestHeaders: this.requestHeaders,
					headers,
					status,
					trailers
				};
			});
		}
	};
}));
function delay(ms, abort) {
	return (v) => new Promise((resolve$1, reject$3) => {
		if (abort === null || abort === void 0 ? void 0 : abort.aborted) reject$3(new RpcError("user cancel", "CANCELLED"));
		else {
			const id = setTimeout(() => resolve$1(v), ms);
			if (abort) abort.addEventListener("abort", (ev) => {
				clearTimeout(id);
				reject$3(new RpcError("user cancel", "CANCELLED"));
			});
		}
	});
}
var __awaiter$1, TestTransport, TestInputStream;
var init_test_transport = __esmMin((() => {
	init_rpc_error();
	init_es2015$1();
	init_rpc_output_stream();
	init_rpc_options();
	init_unary_call();
	init_server_streaming_call();
	init_client_streaming_call();
	init_duplex_streaming_call();
	__awaiter$1 = function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	TestTransport = class TestTransport {
		constructor(data) {
			this.suppressUncaughtRejections = true;
			this.headerDelay = 10;
			this.responseDelay = 50;
			this.betweenResponseDelay = 10;
			this.afterResponseDelay = 10;
			this.data = data !== null && data !== void 0 ? data : {};
		}
		get sentMessages() {
			if (this.lastInput instanceof TestInputStream) return this.lastInput.sent;
			else if (typeof this.lastInput == "object") return [this.lastInput.single];
			return [];
		}
		get sendComplete() {
			if (this.lastInput instanceof TestInputStream) return this.lastInput.completed;
			else if (typeof this.lastInput == "object") return true;
			return false;
		}
		promiseHeaders() {
			var _a;
			const headers = (_a = this.data.headers) !== null && _a !== void 0 ? _a : TestTransport.defaultHeaders;
			return headers instanceof RpcError ? Promise.reject(headers) : Promise.resolve(headers);
		}
		promiseSingleResponse(method) {
			if (this.data.response instanceof RpcError) return Promise.reject(this.data.response);
			let r$1;
			if (Array.isArray(this.data.response)) {
				assert(this.data.response.length > 0);
				r$1 = this.data.response[0];
			} else if (this.data.response !== void 0) r$1 = this.data.response;
			else r$1 = method.O.create();
			assert(method.O.is(r$1));
			return Promise.resolve(r$1);
		}
		streamResponses(method, stream$5, abort) {
			return __awaiter$1(this, void 0, void 0, function* () {
				const messages = [];
				if (this.data.response === void 0) messages.push(method.O.create());
				else if (Array.isArray(this.data.response)) for (let msg of this.data.response) {
					assert(method.O.is(msg));
					messages.push(msg);
				}
				else if (!(this.data.response instanceof RpcError)) {
					assert(method.O.is(this.data.response));
					messages.push(this.data.response);
				}
				try {
					yield delay(this.responseDelay, abort)(void 0);
				} catch (error) {
					stream$5.notifyError(error);
					return;
				}
				if (this.data.response instanceof RpcError) {
					stream$5.notifyError(this.data.response);
					return;
				}
				for (let msg of messages) {
					stream$5.notifyMessage(msg);
					try {
						yield delay(this.betweenResponseDelay, abort)(void 0);
					} catch (error) {
						stream$5.notifyError(error);
						return;
					}
				}
				if (this.data.status instanceof RpcError) {
					stream$5.notifyError(this.data.status);
					return;
				}
				if (this.data.trailers instanceof RpcError) {
					stream$5.notifyError(this.data.trailers);
					return;
				}
				stream$5.notifyComplete();
			});
		}
		promiseStatus() {
			var _a;
			const status = (_a = this.data.status) !== null && _a !== void 0 ? _a : TestTransport.defaultStatus;
			return status instanceof RpcError ? Promise.reject(status) : Promise.resolve(status);
		}
		promiseTrailers() {
			var _a;
			const trailers = (_a = this.data.trailers) !== null && _a !== void 0 ? _a : TestTransport.defaultTrailers;
			return trailers instanceof RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
		}
		maybeSuppressUncaught(...promise) {
			if (this.suppressUncaughtRejections) for (let p of promise) p.catch(() => {});
		}
		mergeOptions(options) {
			return mergeRpcOptions({}, options);
		}
		unary(method, input, options) {
			var _a;
			const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_$1) => {}).then(delay(this.responseDelay, options.abort)).then((_$1) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_$1) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_$1) => this.promiseStatus()), trailersPromise = responsePromise.catch((_$1) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_$1) => this.promiseTrailers());
			this.maybeSuppressUncaught(statusPromise, trailersPromise);
			this.lastInput = { single: input };
			return new UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
		}
		serverStreaming(method, input, options) {
			var _a;
			const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {}).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
			this.maybeSuppressUncaught(statusPromise, trailersPromise);
			this.lastInput = { single: input };
			return new ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
		}
		clientStreaming(method, options) {
			var _a;
			const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_$1) => {}).then(delay(this.responseDelay, options.abort)).then((_$1) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_$1) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_$1) => this.promiseStatus()), trailersPromise = responsePromise.catch((_$1) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_$1) => this.promiseTrailers());
			this.maybeSuppressUncaught(statusPromise, trailersPromise);
			this.lastInput = new TestInputStream(this.data, options.abort);
			return new ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
		}
		duplex(method, options) {
			var _a;
			const requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {}).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
			this.maybeSuppressUncaught(statusPromise, trailersPromise);
			this.lastInput = new TestInputStream(this.data, options.abort);
			return new DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
		}
	};
	TestTransport.defaultHeaders = { responseHeader: "test" };
	TestTransport.defaultStatus = {
		code: "OK",
		detail: "all good"
	};
	TestTransport.defaultTrailers = { responseTrailer: "test" };
	TestInputStream = class {
		constructor(data, abort) {
			this._completed = false;
			this._sent = [];
			this.data = data;
			this.abort = abort;
		}
		get sent() {
			return this._sent;
		}
		get completed() {
			return this._completed;
		}
		send(message) {
			if (this.data.inputMessage instanceof RpcError) return Promise.reject(this.data.inputMessage);
			const delayMs = this.data.inputMessage === void 0 ? 10 : this.data.inputMessage;
			return Promise.resolve(void 0).then(() => {
				this._sent.push(message);
			}).then(delay(delayMs, this.abort));
		}
		complete() {
			if (this.data.inputComplete instanceof RpcError) return Promise.reject(this.data.inputComplete);
			const delayMs = this.data.inputComplete === void 0 ? 10 : this.data.inputComplete;
			return Promise.resolve(void 0).then(() => {
				this._completed = true;
			}).then(delay(delayMs, this.abort));
		}
	};
}));
function stackIntercept(kind, transport, method, options, input) {
	var _a, _b, _c, _d;
	if (kind == "unary") {
		let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
		for (const curr of ((_a = options.interceptors) !== null && _a !== void 0 ? _a : []).filter((i) => i.interceptUnary).reverse()) {
			const next = tail;
			tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
		}
		return tail(method, input, options);
	}
	if (kind == "serverStreaming") {
		let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
		for (const curr of ((_b = options.interceptors) !== null && _b !== void 0 ? _b : []).filter((i) => i.interceptServerStreaming).reverse()) {
			const next = tail;
			tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
		}
		return tail(method, input, options);
	}
	if (kind == "clientStreaming") {
		let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
		for (const curr of ((_c = options.interceptors) !== null && _c !== void 0 ? _c : []).filter((i) => i.interceptClientStreaming).reverse()) {
			const next = tail;
			tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
		}
		return tail(method, options);
	}
	if (kind == "duplex") {
		let tail = (mtd, opt) => transport.duplex(mtd, opt);
		for (const curr of ((_d = options.interceptors) !== null && _d !== void 0 ? _d : []).filter((i) => i.interceptDuplex).reverse()) {
			const next = tail;
			tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
		}
		return tail(method, options);
	}
	assertNever(kind);
}
function stackUnaryInterceptors(transport, method, input, options) {
	return stackIntercept("unary", transport, method, options, input);
}
function stackServerStreamingInterceptors(transport, method, input, options) {
	return stackIntercept("serverStreaming", transport, method, options, input);
}
function stackClientStreamingInterceptors(transport, method, options) {
	return stackIntercept("clientStreaming", transport, method, options);
}
function stackDuplexStreamingInterceptors(transport, method, options) {
	return stackIntercept("duplex", transport, method, options);
}
var init_rpc_interceptor = __esmMin((() => {
	init_es2015$1();
}));
var ServerCallContextController;
var init_server_call_context = __esmMin((() => {
	ServerCallContextController = class {
		constructor(method, headers, deadline, sendResponseHeadersFn, defaultStatus = {
			code: "OK",
			detail: ""
		}) {
			this._cancelled = false;
			this._listeners = [];
			this.method = method;
			this.headers = headers;
			this.deadline = deadline;
			this.trailers = {};
			this._sendRH = sendResponseHeadersFn;
			this.status = defaultStatus;
		}
		notifyCancelled() {
			if (!this._cancelled) {
				this._cancelled = true;
				for (let l of this._listeners) l();
			}
		}
		sendResponseHeaders(data) {
			this._sendRH(data);
		}
		get cancelled() {
			return this._cancelled;
		}
		onCancel(callback) {
			const l = this._listeners;
			l.push(callback);
			return () => {
				let i = l.indexOf(callback);
				if (i >= 0) l.splice(i, 1);
			};
		}
	};
}));
var es2015_exports = /* @__PURE__ */ __export({
	ClientStreamingCall: () => ClientStreamingCall,
	Deferred: () => Deferred,
	DeferredState: () => DeferredState,
	DuplexStreamingCall: () => DuplexStreamingCall,
	RpcError: () => RpcError,
	RpcOutputStreamController: () => RpcOutputStreamController,
	ServerCallContextController: () => ServerCallContextController,
	ServerStreamingCall: () => ServerStreamingCall,
	ServiceType: () => ServiceType,
	TestTransport: () => TestTransport,
	UnaryCall: () => UnaryCall,
	mergeRpcOptions: () => mergeRpcOptions,
	readMethodOption: () => readMethodOption,
	readMethodOptions: () => readMethodOptions,
	readServiceOption: () => readServiceOption,
	stackClientStreamingInterceptors: () => stackClientStreamingInterceptors,
	stackDuplexStreamingInterceptors: () => stackDuplexStreamingInterceptors,
	stackIntercept: () => stackIntercept,
	stackServerStreamingInterceptors: () => stackServerStreamingInterceptors,
	stackUnaryInterceptors: () => stackUnaryInterceptors
}, 1);
var init_es2015 = __esmMin((() => {
	init_service_type();
	init_reflection_info();
	init_rpc_error();
	init_rpc_options();
	init_rpc_output_stream();
	init_test_transport();
	init_deferred();
	init_duplex_streaming_call();
	init_client_streaming_call();
	init_server_streaming_call();
	init_unary_call();
	init_rpc_interceptor();
	init_server_call_context();
}));
var require_artifact$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ArtifactService = exports.DeleteArtifactResponse = exports.DeleteArtifactRequest = exports.GetSignedArtifactURLResponse = exports.GetSignedArtifactURLRequest = exports.ListArtifactsResponse_MonolithArtifact = exports.ListArtifactsResponse = exports.ListArtifactsRequest = exports.FinalizeArtifactResponse = exports.FinalizeArtifactRequest = exports.CreateArtifactResponse = exports.CreateArtifactRequest = exports.FinalizeMigratedArtifactResponse = exports.FinalizeMigratedArtifactRequest = exports.MigrateArtifactResponse = exports.MigrateArtifactRequest = void 0;
	var runtime_rpc_1 = (init_es2015(), __toCommonJS(es2015_exports));
	var runtime_1 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_2 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_3 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_4 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var runtime_5 = (init_es2015$1(), __toCommonJS(es2015_exports$1));
	var wrappers_1 = require_wrappers();
	var wrappers_2 = require_wrappers();
	var timestamp_1 = require_timestamp$1();
	var MigrateArtifactRequest$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.MigrateArtifactRequest", [
				{
					no: 1,
					name: "workflow_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 2,
					name: "name",
					kind: "scalar",
					T: 9
				},
				{
					no: 3,
					name: "expires_at",
					kind: "message",
					T: () => timestamp_1.Timestamp
				}
			]);
		}
		create(value$1) {
			const message = {
				workflowRunBackendId: "",
				name: ""
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.workflowRunBackendId = reader.string();
						break;
					case 2:
						message.name = reader.string();
						break;
					case 3:
						message.expiresAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.workflowRunBackendId !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
			if (message.name !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
			if (message.expiresAt) timestamp_1.Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.MigrateArtifactRequest = new MigrateArtifactRequest$Type();
	var MigrateArtifactResponse$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.MigrateArtifactResponse", [{
				no: 1,
				name: "ok",
				kind: "scalar",
				T: 8
			}, {
				no: 2,
				name: "signed_upload_url",
				kind: "scalar",
				T: 9
			}]);
		}
		create(value$1) {
			const message = {
				ok: false,
				signedUploadUrl: ""
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.ok = reader.bool();
						break;
					case 2:
						message.signedUploadUrl = reader.string();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.ok !== false) writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
			if (message.signedUploadUrl !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.MigrateArtifactResponse = new MigrateArtifactResponse$Type();
	var FinalizeMigratedArtifactRequest$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.FinalizeMigratedArtifactRequest", [
				{
					no: 1,
					name: "workflow_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 2,
					name: "name",
					kind: "scalar",
					T: 9
				},
				{
					no: 3,
					name: "size",
					kind: "scalar",
					T: 3
				}
			]);
		}
		create(value$1) {
			const message = {
				workflowRunBackendId: "",
				name: "",
				size: "0"
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.workflowRunBackendId = reader.string();
						break;
					case 2:
						message.name = reader.string();
						break;
					case 3:
						message.size = reader.int64().toString();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.workflowRunBackendId !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
			if (message.name !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
			if (message.size !== "0") writer.tag(3, runtime_1.WireType.Varint).int64(message.size);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.FinalizeMigratedArtifactRequest = new FinalizeMigratedArtifactRequest$Type();
	var FinalizeMigratedArtifactResponse$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.FinalizeMigratedArtifactResponse", [{
				no: 1,
				name: "ok",
				kind: "scalar",
				T: 8
			}, {
				no: 2,
				name: "artifact_id",
				kind: "scalar",
				T: 3
			}]);
		}
		create(value$1) {
			const message = {
				ok: false,
				artifactId: "0"
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.ok = reader.bool();
						break;
					case 2:
						message.artifactId = reader.int64().toString();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.ok !== false) writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
			if (message.artifactId !== "0") writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.FinalizeMigratedArtifactResponse = new FinalizeMigratedArtifactResponse$Type();
	var CreateArtifactRequest$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.CreateArtifactRequest", [
				{
					no: 1,
					name: "workflow_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 2,
					name: "workflow_job_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 3,
					name: "name",
					kind: "scalar",
					T: 9
				},
				{
					no: 4,
					name: "expires_at",
					kind: "message",
					T: () => timestamp_1.Timestamp
				},
				{
					no: 5,
					name: "version",
					kind: "scalar",
					T: 5
				}
			]);
		}
		create(value$1) {
			const message = {
				workflowRunBackendId: "",
				workflowJobRunBackendId: "",
				name: "",
				version: 0
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.workflowRunBackendId = reader.string();
						break;
					case 2:
						message.workflowJobRunBackendId = reader.string();
						break;
					case 3:
						message.name = reader.string();
						break;
					case 4:
						message.expiresAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
						break;
					case 5:
						message.version = reader.int32();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.workflowRunBackendId !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
			if (message.workflowJobRunBackendId !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
			if (message.name !== "") writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
			if (message.expiresAt) timestamp_1.Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
			if (message.version !== 0) writer.tag(5, runtime_1.WireType.Varint).int32(message.version);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.CreateArtifactRequest = new CreateArtifactRequest$Type();
	var CreateArtifactResponse$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.CreateArtifactResponse", [{
				no: 1,
				name: "ok",
				kind: "scalar",
				T: 8
			}, {
				no: 2,
				name: "signed_upload_url",
				kind: "scalar",
				T: 9
			}]);
		}
		create(value$1) {
			const message = {
				ok: false,
				signedUploadUrl: ""
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.ok = reader.bool();
						break;
					case 2:
						message.signedUploadUrl = reader.string();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.ok !== false) writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
			if (message.signedUploadUrl !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.CreateArtifactResponse = new CreateArtifactResponse$Type();
	var FinalizeArtifactRequest$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.FinalizeArtifactRequest", [
				{
					no: 1,
					name: "workflow_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 2,
					name: "workflow_job_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 3,
					name: "name",
					kind: "scalar",
					T: 9
				},
				{
					no: 4,
					name: "size",
					kind: "scalar",
					T: 3
				},
				{
					no: 5,
					name: "hash",
					kind: "message",
					T: () => wrappers_2.StringValue
				}
			]);
		}
		create(value$1) {
			const message = {
				workflowRunBackendId: "",
				workflowJobRunBackendId: "",
				name: "",
				size: "0"
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.workflowRunBackendId = reader.string();
						break;
					case 2:
						message.workflowJobRunBackendId = reader.string();
						break;
					case 3:
						message.name = reader.string();
						break;
					case 4:
						message.size = reader.int64().toString();
						break;
					case 5:
						message.hash = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.hash);
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.workflowRunBackendId !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
			if (message.workflowJobRunBackendId !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
			if (message.name !== "") writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
			if (message.size !== "0") writer.tag(4, runtime_1.WireType.Varint).int64(message.size);
			if (message.hash) wrappers_2.StringValue.internalBinaryWrite(message.hash, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.FinalizeArtifactRequest = new FinalizeArtifactRequest$Type();
	var FinalizeArtifactResponse$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.FinalizeArtifactResponse", [{
				no: 1,
				name: "ok",
				kind: "scalar",
				T: 8
			}, {
				no: 2,
				name: "artifact_id",
				kind: "scalar",
				T: 3
			}]);
		}
		create(value$1) {
			const message = {
				ok: false,
				artifactId: "0"
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.ok = reader.bool();
						break;
					case 2:
						message.artifactId = reader.int64().toString();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.ok !== false) writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
			if (message.artifactId !== "0") writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.FinalizeArtifactResponse = new FinalizeArtifactResponse$Type();
	var ListArtifactsRequest$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.ListArtifactsRequest", [
				{
					no: 1,
					name: "workflow_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 2,
					name: "workflow_job_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 3,
					name: "name_filter",
					kind: "message",
					T: () => wrappers_2.StringValue
				},
				{
					no: 4,
					name: "id_filter",
					kind: "message",
					T: () => wrappers_1.Int64Value
				}
			]);
		}
		create(value$1) {
			const message = {
				workflowRunBackendId: "",
				workflowJobRunBackendId: ""
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.workflowRunBackendId = reader.string();
						break;
					case 2:
						message.workflowJobRunBackendId = reader.string();
						break;
					case 3:
						message.nameFilter = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.nameFilter);
						break;
					case 4:
						message.idFilter = wrappers_1.Int64Value.internalBinaryRead(reader, reader.uint32(), options, message.idFilter);
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.workflowRunBackendId !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
			if (message.workflowJobRunBackendId !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
			if (message.nameFilter) wrappers_2.StringValue.internalBinaryWrite(message.nameFilter, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
			if (message.idFilter) wrappers_1.Int64Value.internalBinaryWrite(message.idFilter, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.ListArtifactsRequest = new ListArtifactsRequest$Type();
	var ListArtifactsResponse$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.ListArtifactsResponse", [{
				no: 1,
				name: "artifacts",
				kind: "message",
				repeat: 1,
				T: () => exports.ListArtifactsResponse_MonolithArtifact
			}]);
		}
		create(value$1) {
			const message = { artifacts: [] };
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.artifacts.push(exports.ListArtifactsResponse_MonolithArtifact.internalBinaryRead(reader, reader.uint32(), options));
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			for (let i = 0; i < message.artifacts.length; i++) exports.ListArtifactsResponse_MonolithArtifact.internalBinaryWrite(message.artifacts[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.ListArtifactsResponse = new ListArtifactsResponse$Type();
	var ListArtifactsResponse_MonolithArtifact$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.ListArtifactsResponse.MonolithArtifact", [
				{
					no: 1,
					name: "workflow_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 2,
					name: "workflow_job_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 3,
					name: "database_id",
					kind: "scalar",
					T: 3
				},
				{
					no: 4,
					name: "name",
					kind: "scalar",
					T: 9
				},
				{
					no: 5,
					name: "size",
					kind: "scalar",
					T: 3
				},
				{
					no: 6,
					name: "created_at",
					kind: "message",
					T: () => timestamp_1.Timestamp
				},
				{
					no: 7,
					name: "digest",
					kind: "message",
					T: () => wrappers_2.StringValue
				}
			]);
		}
		create(value$1) {
			const message = {
				workflowRunBackendId: "",
				workflowJobRunBackendId: "",
				databaseId: "0",
				name: "",
				size: "0"
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.workflowRunBackendId = reader.string();
						break;
					case 2:
						message.workflowJobRunBackendId = reader.string();
						break;
					case 3:
						message.databaseId = reader.int64().toString();
						break;
					case 4:
						message.name = reader.string();
						break;
					case 5:
						message.size = reader.int64().toString();
						break;
					case 6:
						message.createdAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
						break;
					case 7:
						message.digest = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.digest);
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.workflowRunBackendId !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
			if (message.workflowJobRunBackendId !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
			if (message.databaseId !== "0") writer.tag(3, runtime_1.WireType.Varint).int64(message.databaseId);
			if (message.name !== "") writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.name);
			if (message.size !== "0") writer.tag(5, runtime_1.WireType.Varint).int64(message.size);
			if (message.createdAt) timestamp_1.Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
			if (message.digest) wrappers_2.StringValue.internalBinaryWrite(message.digest, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.ListArtifactsResponse_MonolithArtifact = new ListArtifactsResponse_MonolithArtifact$Type();
	var GetSignedArtifactURLRequest$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.GetSignedArtifactURLRequest", [
				{
					no: 1,
					name: "workflow_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 2,
					name: "workflow_job_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 3,
					name: "name",
					kind: "scalar",
					T: 9
				}
			]);
		}
		create(value$1) {
			const message = {
				workflowRunBackendId: "",
				workflowJobRunBackendId: "",
				name: ""
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.workflowRunBackendId = reader.string();
						break;
					case 2:
						message.workflowJobRunBackendId = reader.string();
						break;
					case 3:
						message.name = reader.string();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.workflowRunBackendId !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
			if (message.workflowJobRunBackendId !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
			if (message.name !== "") writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.GetSignedArtifactURLRequest = new GetSignedArtifactURLRequest$Type();
	var GetSignedArtifactURLResponse$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.GetSignedArtifactURLResponse", [{
				no: 1,
				name: "signed_url",
				kind: "scalar",
				T: 9
			}]);
		}
		create(value$1) {
			const message = { signedUrl: "" };
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.signedUrl = reader.string();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.signedUrl !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.signedUrl);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.GetSignedArtifactURLResponse = new GetSignedArtifactURLResponse$Type();
	var DeleteArtifactRequest$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.DeleteArtifactRequest", [
				{
					no: 1,
					name: "workflow_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 2,
					name: "workflow_job_run_backend_id",
					kind: "scalar",
					T: 9
				},
				{
					no: 3,
					name: "name",
					kind: "scalar",
					T: 9
				}
			]);
		}
		create(value$1) {
			const message = {
				workflowRunBackendId: "",
				workflowJobRunBackendId: "",
				name: ""
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.workflowRunBackendId = reader.string();
						break;
					case 2:
						message.workflowJobRunBackendId = reader.string();
						break;
					case 3:
						message.name = reader.string();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.workflowRunBackendId !== "") writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
			if (message.workflowJobRunBackendId !== "") writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
			if (message.name !== "") writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.DeleteArtifactRequest = new DeleteArtifactRequest$Type();
	var DeleteArtifactResponse$Type = class extends runtime_5.MessageType {
		constructor() {
			super("github.actions.results.api.v1.DeleteArtifactResponse", [{
				no: 1,
				name: "ok",
				kind: "scalar",
				T: 8
			}, {
				no: 2,
				name: "artifact_id",
				kind: "scalar",
				T: 3
			}]);
		}
		create(value$1) {
			const message = {
				ok: false,
				artifactId: "0"
			};
			globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, {
				enumerable: false,
				value: this
			});
			if (value$1 !== void 0) (0, runtime_3.reflectionMergePartial)(this, message, value$1);
			return message;
		}
		internalBinaryRead(reader, length, options, target) {
			let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
			while (reader.pos < end) {
				let [fieldNo, wireType] = reader.tag();
				switch (fieldNo) {
					case 1:
						message.ok = reader.bool();
						break;
					case 2:
						message.artifactId = reader.int64().toString();
						break;
					default:
						let u = options.readUnknownField;
						if (u === "throw") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
						let d = reader.skip(wireType);
						if (u !== false) (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
				}
			}
			return message;
		}
		internalBinaryWrite(message, writer, options) {
			if (message.ok !== false) writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
			if (message.artifactId !== "0") writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
			let u = options.writeUnknownFields;
			if (u !== false) (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
			return writer;
		}
	};
	exports.DeleteArtifactResponse = new DeleteArtifactResponse$Type();
	exports.ArtifactService = new runtime_rpc_1.ServiceType("github.actions.results.api.v1.ArtifactService", [
		{
			name: "CreateArtifact",
			options: {},
			I: exports.CreateArtifactRequest,
			O: exports.CreateArtifactResponse
		},
		{
			name: "FinalizeArtifact",
			options: {},
			I: exports.FinalizeArtifactRequest,
			O: exports.FinalizeArtifactResponse
		},
		{
			name: "ListArtifacts",
			options: {},
			I: exports.ListArtifactsRequest,
			O: exports.ListArtifactsResponse
		},
		{
			name: "GetSignedArtifactURL",
			options: {},
			I: exports.GetSignedArtifactURLRequest,
			O: exports.GetSignedArtifactURLResponse
		},
		{
			name: "DeleteArtifact",
			options: {},
			I: exports.DeleteArtifactRequest,
			O: exports.DeleteArtifactResponse
		},
		{
			name: "MigrateArtifact",
			options: {},
			I: exports.MigrateArtifactRequest,
			O: exports.MigrateArtifactResponse
		},
		{
			name: "FinalizeMigratedArtifact",
			options: {},
			I: exports.FinalizeMigratedArtifactRequest,
			O: exports.FinalizeMigratedArtifactResponse
		}
	]);
}));
var require_artifact_twirp_client$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ArtifactServiceClientProtobuf = exports.ArtifactServiceClientJSON = void 0;
	var artifact_1 = require_artifact$1();
	var ArtifactServiceClientJSON = class {
		constructor(rpc) {
			this.rpc = rpc;
			this.CreateArtifact.bind(this);
			this.FinalizeArtifact.bind(this);
			this.ListArtifacts.bind(this);
			this.GetSignedArtifactURL.bind(this);
			this.DeleteArtifact.bind(this);
		}
		CreateArtifact(request$1) {
			const data = artifact_1.CreateArtifactRequest.toJson(request$1, {
				useProtoFieldName: true,
				emitDefaultValues: false
			});
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "CreateArtifact", "application/json", data).then((data$1) => artifact_1.CreateArtifactResponse.fromJson(data$1, { ignoreUnknownFields: true }));
		}
		FinalizeArtifact(request$1) {
			const data = artifact_1.FinalizeArtifactRequest.toJson(request$1, {
				useProtoFieldName: true,
				emitDefaultValues: false
			});
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "FinalizeArtifact", "application/json", data).then((data$1) => artifact_1.FinalizeArtifactResponse.fromJson(data$1, { ignoreUnknownFields: true }));
		}
		ListArtifacts(request$1) {
			const data = artifact_1.ListArtifactsRequest.toJson(request$1, {
				useProtoFieldName: true,
				emitDefaultValues: false
			});
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "ListArtifacts", "application/json", data).then((data$1) => artifact_1.ListArtifactsResponse.fromJson(data$1, { ignoreUnknownFields: true }));
		}
		GetSignedArtifactURL(request$1) {
			const data = artifact_1.GetSignedArtifactURLRequest.toJson(request$1, {
				useProtoFieldName: true,
				emitDefaultValues: false
			});
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "GetSignedArtifactURL", "application/json", data).then((data$1) => artifact_1.GetSignedArtifactURLResponse.fromJson(data$1, { ignoreUnknownFields: true }));
		}
		DeleteArtifact(request$1) {
			const data = artifact_1.DeleteArtifactRequest.toJson(request$1, {
				useProtoFieldName: true,
				emitDefaultValues: false
			});
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "DeleteArtifact", "application/json", data).then((data$1) => artifact_1.DeleteArtifactResponse.fromJson(data$1, { ignoreUnknownFields: true }));
		}
	};
	exports.ArtifactServiceClientJSON = ArtifactServiceClientJSON;
	var ArtifactServiceClientProtobuf = class {
		constructor(rpc) {
			this.rpc = rpc;
			this.CreateArtifact.bind(this);
			this.FinalizeArtifact.bind(this);
			this.ListArtifacts.bind(this);
			this.GetSignedArtifactURL.bind(this);
			this.DeleteArtifact.bind(this);
		}
		CreateArtifact(request$1) {
			const data = artifact_1.CreateArtifactRequest.toBinary(request$1);
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "CreateArtifact", "application/protobuf", data).then((data$1) => artifact_1.CreateArtifactResponse.fromBinary(data$1));
		}
		FinalizeArtifact(request$1) {
			const data = artifact_1.FinalizeArtifactRequest.toBinary(request$1);
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "FinalizeArtifact", "application/protobuf", data).then((data$1) => artifact_1.FinalizeArtifactResponse.fromBinary(data$1));
		}
		ListArtifacts(request$1) {
			const data = artifact_1.ListArtifactsRequest.toBinary(request$1);
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "ListArtifacts", "application/protobuf", data).then((data$1) => artifact_1.ListArtifactsResponse.fromBinary(data$1));
		}
		GetSignedArtifactURL(request$1) {
			const data = artifact_1.GetSignedArtifactURLRequest.toBinary(request$1);
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "GetSignedArtifactURL", "application/protobuf", data).then((data$1) => artifact_1.GetSignedArtifactURLResponse.fromBinary(data$1));
		}
		DeleteArtifact(request$1) {
			const data = artifact_1.DeleteArtifactRequest.toBinary(request$1);
			return this.rpc.request("github.actions.results.api.v1.ArtifactService", "DeleteArtifact", "application/protobuf", data).then((data$1) => artifact_1.DeleteArtifactResponse.fromBinary(data$1));
		}
	};
	exports.ArtifactServiceClientProtobuf = ArtifactServiceClientProtobuf;
}));
var require_generated = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __exportStar = exports && exports.__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(require_timestamp$1(), exports);
	__exportStar(require_wrappers(), exports);
	__exportStar(require_artifact$1(), exports);
	__exportStar(require_artifact_twirp_client$1(), exports);
}));
var require_retention = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getExpiration = getExpiration;
	var generated_1 = require_generated();
	var core = __importStar(require_core$1());
	function getExpiration(retentionDays) {
		if (!retentionDays) return;
		const maxRetentionDays = getRetentionDays();
		if (maxRetentionDays && maxRetentionDays < retentionDays) {
			core.warning(`Retention days cannot be greater than the maximum allowed retention set within the repository. Using ${maxRetentionDays} instead.`);
			retentionDays = maxRetentionDays;
		}
		const expirationDate = /* @__PURE__ */ new Date();
		expirationDate.setDate(expirationDate.getDate() + retentionDays);
		return generated_1.Timestamp.fromDate(expirationDate);
	}
	function getRetentionDays() {
		const retentionDays = process.env["GITHUB_RETENTION_DAYS"];
		if (!retentionDays) return;
		const days = parseInt(retentionDays);
		if (isNaN(days)) return;
		return days;
	}
}));
var require_path_and_artifact_name_validation = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateArtifactName = validateArtifactName;
	exports.validateFilePath = validateFilePath;
	var core_1 = require_core$1();
	var invalidArtifactFilePathCharacters = new Map([
		["\"", " Double quote \""],
		[":", " Colon :"],
		["<", " Less than <"],
		[">", " Greater than >"],
		["|", " Vertical bar |"],
		["*", " Asterisk *"],
		["?", " Question mark ?"],
		["\r", " Carriage return \\r"],
		["\n", " Line feed \\n"]
	]);
	var invalidArtifactNameCharacters = new Map([
		...invalidArtifactFilePathCharacters,
		["\\", " Backslash \\"],
		["/", " Forward slash /"]
	]);
	function validateArtifactName(name$1) {
		if (!name$1) throw new Error(`Provided artifact name input during validation is empty`);
		for (const [invalidCharacterKey, errorMessageForCharacter] of invalidArtifactNameCharacters) if (name$1.includes(invalidCharacterKey)) throw new Error(`The artifact name is not valid: ${name$1}. Contains the following character: ${errorMessageForCharacter}
          
Invalid characters include: ${Array.from(invalidArtifactNameCharacters.values()).toString()}
          
These characters are not allowed in the artifact name due to limitations with certain file systems such as NTFS. To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential problems with downloads on different file systems.`);
		(0, core_1.info)(`Artifact name is valid!`);
	}
	function validateFilePath(path$5) {
		if (!path$5) throw new Error(`Provided file path input during validation is empty`);
		for (const [invalidCharacterKey, errorMessageForCharacter] of invalidArtifactFilePathCharacters) if (path$5.includes(invalidCharacterKey)) throw new Error(`The path for one of the files in artifact is not valid: ${path$5}. Contains the following character: ${errorMessageForCharacter}
          
Invalid characters include: ${Array.from(invalidArtifactFilePathCharacters.values()).toString()}
          
The following characters are not allowed in files that are uploaded due to limitations with certain file systems such as NTFS. To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential problems with downloads on different file systems.
          `);
	}
}));
var package_exports = /* @__PURE__ */ __export({
	bugs: () => bugs,
	default: () => package_default,
	dependencies: () => dependencies,
	description: () => description,
	devDependencies: () => devDependencies,
	directories: () => directories,
	files: () => files,
	homepage: () => homepage,
	keywords: () => keywords,
	license: () => "MIT",
	main: () => main,
	name: () => name,
	overrides: () => overrides,
	preview: () => true,
	publishConfig: () => publishConfig,
	repository: () => repository,
	scripts: () => scripts,
	types: () => types,
	version: () => version
}, 1), name, version, description, keywords, homepage, main, types, directories, files, publishConfig, repository, scripts, bugs, dependencies, devDependencies, overrides, package_default;
var init_package = __esmMin((() => {
	name = "@actions/artifact";
	version = "5.0.1";
	description = "Actions artifact lib";
	keywords = [
		"github",
		"actions",
		"artifact"
	];
	homepage = "https://github.com/actions/toolkit/tree/main/packages/artifact";
	main = "lib/artifact.js";
	types = "lib/artifact.d.ts";
	directories = {
		"lib": "lib",
		"test": "__tests__"
	};
	files = ["lib", "!.DS_Store"];
	publishConfig = { "access": "public" };
	repository = {
		"type": "git",
		"url": "git+https://github.com/actions/toolkit.git",
		"directory": "packages/artifact"
	};
	scripts = {
		"audit-moderate": "npm install && npm audit --json --audit-level=moderate > audit.json",
		"test": "cd ../../ && npm run test ./packages/artifact",
		"bootstrap": "cd ../../ && npm run bootstrap",
		"tsc-run": "tsc",
		"tsc": "npm run bootstrap && npm run tsc-run",
		"gen:docs": "typedoc --plugin typedoc-plugin-markdown --out docs/generated src/artifact.ts --githubPages false --readme none"
	};
	bugs = { "url": "https://github.com/actions/toolkit/issues" };
	dependencies = {
		"@actions/core": "^2.0.0",
		"@actions/github": "^6.0.1",
		"@actions/http-client": "^3.0.0",
		"@azure/storage-blob": "^12.29.1",
		"@octokit/core": "^5.2.1",
		"@octokit/plugin-request-log": "^1.0.4",
		"@octokit/plugin-retry": "^3.0.9",
		"@octokit/request": "^8.4.1",
		"@octokit/request-error": "^5.1.1",
		"@protobuf-ts/plugin": "^2.2.3-alpha.1",
		"archiver": "^7.0.1",
		"jwt-decode": "^3.1.2",
		"unzip-stream": "^0.3.1"
	};
	devDependencies = {
		"@types/archiver": "^5.3.2",
		"@types/unzip-stream": "^0.3.4",
		"typedoc": "^0.28.13",
		"typedoc-plugin-markdown": "^3.17.1",
		"typescript": "^5.2.2"
	};
	overrides = {
		"uri-js": "npm:uri-js-replace@^1.0.1",
		"node-fetch": "^3.3.2"
	};
	package_default = {
		name,
		version,
		preview: true,
		description,
		keywords,
		homepage,
		license: "MIT",
		main,
		types,
		directories,
		files,
		publishConfig,
		repository,
		scripts,
		bugs,
		dependencies,
		devDependencies,
		overrides
	};
}));
var require_user_agent = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getUserAgentString = getUserAgentString;
	var packageJson = (init_package(), __toCommonJS(package_exports).default);
	function getUserAgentString() {
		return `@actions/artifact-${packageJson.version}`;
	}
}));
var require_errors$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.UsageError = exports.NetworkError = exports.GHESNotSupportedError = exports.ArtifactNotFoundError = exports.InvalidResponseError = exports.FilesNotFoundError = void 0;
	var FilesNotFoundError = class extends Error {
		constructor(files$1 = []) {
			let message = "No files were found to upload";
			if (files$1.length > 0) message += `: ${files$1.join(", ")}`;
			super(message);
			this.files = files$1;
			this.name = "FilesNotFoundError";
		}
	};
	exports.FilesNotFoundError = FilesNotFoundError;
	var InvalidResponseError = class extends Error {
		constructor(message) {
			super(message);
			this.name = "InvalidResponseError";
		}
	};
	exports.InvalidResponseError = InvalidResponseError;
	var ArtifactNotFoundError = class extends Error {
		constructor(message = "Artifact not found") {
			super(message);
			this.name = "ArtifactNotFoundError";
		}
	};
	exports.ArtifactNotFoundError = ArtifactNotFoundError;
	var GHESNotSupportedError = class extends Error {
		constructor(message = "@actions/artifact v2.0.0+, upload-artifact@v4+ and download-artifact@v4+ are not currently supported on GHES.") {
			super(message);
			this.name = "GHESNotSupportedError";
		}
	};
	exports.GHESNotSupportedError = GHESNotSupportedError;
	var NetworkError = class extends Error {
		constructor(code) {
			const message = `Unable to make request: ${code}\nIf you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
			super(message);
			this.code = code;
			this.name = "NetworkError";
		}
	};
	exports.NetworkError = NetworkError;
	NetworkError.isNetworkErrorCode = (code) => {
		if (!code) return false;
		return [
			"ECONNRESET",
			"ENOTFOUND",
			"ETIMEDOUT",
			"ECONNREFUSED",
			"EHOSTUNREACH"
		].includes(code);
	};
	var UsageError = class extends Error {
		constructor() {
			super(`Artifact storage quota has been hit. Unable to upload any new artifacts. Usage is recalculated every 6-12 hours.\nMore info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`);
			this.name = "UsageError";
		}
	};
	exports.UsageError = UsageError;
	UsageError.isUsageErrorMessage = (msg) => {
		if (!msg) return false;
		return msg.includes("insufficient usage");
	};
}));
var jwt_decode_esm_exports = /* @__PURE__ */ __export({
	InvalidTokenError: () => n,
	default: () => jwt_decode_esm_default
}, 1);
function e(e$1) {
	this.message = e$1;
}
function t(e$1) {
	var t$1 = e$1.replace(/-/g, "+").replace(/_/g, "/");
	switch (t$1.length % 4) {
		case 0: break;
		case 2:
			t$1 += "==";
			break;
		case 3:
			t$1 += "=";
			break;
		default: throw "Illegal base64url string!";
	}
	try {
		return function(e$2) {
			return decodeURIComponent(r(e$2).replace(/(.)/g, (function(e$3, r$1) {
				var t$2 = r$1.charCodeAt(0).toString(16).toUpperCase();
				return t$2.length < 2 && (t$2 = "0" + t$2), "%" + t$2;
			})));
		}(t$1);
	} catch (e$2) {
		return r(t$1);
	}
}
function n(e$1) {
	this.message = e$1;
}
function o(e$1, r$1) {
	if ("string" != typeof e$1) throw new n("Invalid token specified");
	var o$1 = !0 === (r$1 = r$1 || {}).header ? 0 : 1;
	try {
		return JSON.parse(t(e$1.split(".")[o$1]));
	} catch (e$2) {
		throw new n("Invalid token specified: " + e$2.message);
	}
}
var r, jwt_decode_esm_default;
var init_jwt_decode_esm = __esmMin((() => {
	e.prototype = /* @__PURE__ */ new Error(), e.prototype.name = "InvalidCharacterError";
	r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r$1) {
		var t$1 = String(r$1).replace(/=+$/, "");
		if (t$1.length % 4 == 1) throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
		for (var n$1, o$1, a = 0, i = 0, c = ""; o$1 = t$1.charAt(i++); ~o$1 && (n$1 = a % 4 ? 64 * n$1 + o$1 : o$1, a++ % 4) && (c += String.fromCharCode(255 & n$1 >> (-2 * a & 6)))) o$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o$1);
		return c;
	};
	n.prototype = /* @__PURE__ */ new Error(), n.prototype.name = "InvalidTokenError";
	jwt_decode_esm_default = o;
}));
var require_util$5 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getBackendIdsFromToken = getBackendIdsFromToken;
	exports.maskSigUrl = maskSigUrl;
	exports.maskSecretUrls = maskSecretUrls;
	var core = __importStar(require_core$1());
	var config_1 = require_config();
	var jwt_decode_1 = __importDefault((init_jwt_decode_esm(), __toCommonJS(jwt_decode_esm_exports)));
	var core_1 = require_core$1();
	var InvalidJwtError = /* @__PURE__ */ new Error("Failed to get backend IDs: The provided JWT token is invalid and/or missing claims");
	function getBackendIdsFromToken() {
		const token = (0, config_1.getRuntimeToken)();
		const decoded = (0, jwt_decode_1.default)(token);
		if (!decoded.scp) throw InvalidJwtError;
		const scpParts = decoded.scp.split(" ");
		if (scpParts.length === 0) throw InvalidJwtError;
		for (const scopes of scpParts) {
			const scopeParts = scopes.split(":");
			if ((scopeParts === null || scopeParts === void 0 ? void 0 : scopeParts[0]) !== "Actions.Results") continue;
			if (scopeParts.length !== 3) throw InvalidJwtError;
			const ids = {
				workflowRunBackendId: scopeParts[1],
				workflowJobRunBackendId: scopeParts[2]
			};
			core.debug(`Workflow Run Backend ID: ${ids.workflowRunBackendId}`);
			core.debug(`Workflow Job Run Backend ID: ${ids.workflowJobRunBackendId}`);
			return ids;
		}
		throw InvalidJwtError;
	}
	function maskSigUrl(url) {
		if (!url) return;
		try {
			const signature = new URL(url).searchParams.get("sig");
			if (signature) {
				(0, core_1.setSecret)(signature);
				(0, core_1.setSecret)(encodeURIComponent(signature));
			}
		} catch (error) {
			(0, core_1.debug)(`Failed to parse URL: ${url} ${error instanceof Error ? error.message : String(error)}`);
		}
	}
	function maskSecretUrls(body) {
		if (typeof body !== "object" || body === null) {
			(0, core_1.debug)("body is not an object or is null");
			return;
		}
		if ("signed_upload_url" in body && typeof body.signed_upload_url === "string") maskSigUrl(body.signed_upload_url);
		if ("signed_url" in body && typeof body.signed_url === "string") maskSigUrl(body.signed_url);
	}
}));
var require_artifact_twirp_client = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.internalArtifactTwirpClient = internalArtifactTwirpClient;
	var http_client_1 = require_lib$2();
	var auth_1 = require_auth();
	var core_1 = require_core$1();
	var generated_1 = require_generated();
	var config_1 = require_config();
	var user_agent_1 = require_user_agent();
	var errors_1 = require_errors$2();
	var util_1 = require_util$5();
	var ArtifactHttpClient = class {
		constructor(userAgent$1, maxAttempts, baseRetryIntervalMilliseconds, retryMultiplier) {
			this.maxAttempts = 5;
			this.baseRetryIntervalMilliseconds = 3e3;
			this.retryMultiplier = 1.5;
			const token = (0, config_1.getRuntimeToken)();
			this.baseUrl = (0, config_1.getResultsServiceUrl)();
			if (maxAttempts) this.maxAttempts = maxAttempts;
			if (baseRetryIntervalMilliseconds) this.baseRetryIntervalMilliseconds = baseRetryIntervalMilliseconds;
			if (retryMultiplier) this.retryMultiplier = retryMultiplier;
			this.httpClient = new http_client_1.HttpClient(userAgent$1, [new auth_1.BearerCredentialHandler(token)]);
		}
		request(service$2, method, contentType, data) {
			return __awaiter(this, void 0, void 0, function* () {
				const url = new URL(`/twirp/${service$2}/${method}`, this.baseUrl).href;
				(0, core_1.debug)(`[Request] ${method} ${url}`);
				const headers = { "Content-Type": contentType };
				try {
					const { body } = yield this.retryableRequest(() => __awaiter(this, void 0, void 0, function* () {
						return this.httpClient.post(url, JSON.stringify(data), headers);
					}));
					return body;
				} catch (error) {
					throw new Error(`Failed to ${method}: ${error.message}`);
				}
			});
		}
		retryableRequest(operation) {
			return __awaiter(this, void 0, void 0, function* () {
				let attempt = 0;
				let errorMessage = "";
				let rawBody = "";
				while (attempt < this.maxAttempts) {
					let isRetryable = false;
					try {
						const response = yield operation();
						const statusCode = response.message.statusCode;
						rawBody = yield response.readBody();
						(0, core_1.debug)(`[Response] - ${response.message.statusCode}`);
						(0, core_1.debug)(`Headers: ${JSON.stringify(response.message.headers, null, 2)}`);
						const body = JSON.parse(rawBody);
						(0, util_1.maskSecretUrls)(body);
						(0, core_1.debug)(`Body: ${JSON.stringify(body, null, 2)}`);
						if (this.isSuccessStatusCode(statusCode)) return {
							response,
							body
						};
						isRetryable = this.isRetryableHttpStatusCode(statusCode);
						errorMessage = `Failed request: (${statusCode}) ${response.message.statusMessage}`;
						if (body.msg) {
							if (errors_1.UsageError.isUsageErrorMessage(body.msg)) throw new errors_1.UsageError();
							errorMessage = `${errorMessage}: ${body.msg}`;
						}
					} catch (error) {
						if (error instanceof SyntaxError) (0, core_1.debug)(`Raw Body: ${rawBody}`);
						if (error instanceof errors_1.UsageError) throw error;
						if (errors_1.NetworkError.isNetworkErrorCode(error === null || error === void 0 ? void 0 : error.code)) throw new errors_1.NetworkError(error === null || error === void 0 ? void 0 : error.code);
						isRetryable = true;
						errorMessage = error.message;
					}
					if (!isRetryable) throw new Error(`Received non-retryable error: ${errorMessage}`);
					if (attempt + 1 === this.maxAttempts) throw new Error(`Failed to make request after ${this.maxAttempts} attempts: ${errorMessage}`);
					const retryTimeMilliseconds = this.getExponentialRetryTimeMilliseconds(attempt);
					(0, core_1.info)(`Attempt ${attempt + 1} of ${this.maxAttempts} failed with error: ${errorMessage}. Retrying request in ${retryTimeMilliseconds} ms...`);
					yield this.sleep(retryTimeMilliseconds);
					attempt++;
				}
				throw new Error(`Request failed`);
			});
		}
		isSuccessStatusCode(statusCode) {
			if (!statusCode) return false;
			return statusCode >= 200 && statusCode < 300;
		}
		isRetryableHttpStatusCode(statusCode) {
			if (!statusCode) return false;
			return [
				http_client_1.HttpCodes.BadGateway,
				http_client_1.HttpCodes.GatewayTimeout,
				http_client_1.HttpCodes.InternalServerError,
				http_client_1.HttpCodes.ServiceUnavailable,
				http_client_1.HttpCodes.TooManyRequests
			].includes(statusCode);
		}
		sleep(milliseconds) {
			return __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve$1) => setTimeout(resolve$1, milliseconds));
			});
		}
		getExponentialRetryTimeMilliseconds(attempt) {
			if (attempt < 0) throw new Error("attempt should be a positive integer");
			if (attempt === 0) return this.baseRetryIntervalMilliseconds;
			const minTime = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, attempt);
			const maxTime = minTime * this.retryMultiplier;
			return Math.trunc(Math.random() * (maxTime - minTime) + minTime);
		}
	};
	function internalArtifactTwirpClient(options) {
		const client = new ArtifactHttpClient((0, user_agent_1.getUserAgentString)(), options === null || options === void 0 ? void 0 : options.maxAttempts, options === null || options === void 0 ? void 0 : options.retryIntervalMs, options === null || options === void 0 ? void 0 : options.retryMultiplier);
		return new generated_1.ArtifactServiceClientJSON(client);
	}
}));
var require_upload_zip_specification = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateRootDirectory = validateRootDirectory;
	exports.getUploadZipSpecification = getUploadZipSpecification;
	var fs$6 = __importStar(__require("fs"));
	var core_1 = require_core$1();
	var path_1 = __require("path");
	var path_and_artifact_name_validation_1 = require_path_and_artifact_name_validation();
	function validateRootDirectory(rootDirectory) {
		if (!fs$6.existsSync(rootDirectory)) throw new Error(`The provided rootDirectory ${rootDirectory} does not exist`);
		if (!fs$6.statSync(rootDirectory).isDirectory()) throw new Error(`The provided rootDirectory ${rootDirectory} is not a valid directory`);
		(0, core_1.info)(`Root directory input is valid!`);
	}
	function getUploadZipSpecification(filesToZip, rootDirectory) {
		const specification = [];
		rootDirectory = (0, path_1.normalize)(rootDirectory);
		rootDirectory = (0, path_1.resolve)(rootDirectory);
		for (let file of filesToZip) {
			const stats = fs$6.lstatSync(file, { throwIfNoEntry: false });
			if (!stats) throw new Error(`File ${file} does not exist`);
			if (!stats.isDirectory()) {
				file = (0, path_1.normalize)(file);
				file = (0, path_1.resolve)(file);
				if (!file.startsWith(rootDirectory)) throw new Error(`The rootDirectory: ${rootDirectory} is not a parent directory of the file: ${file}`);
				const uploadPath = file.replace(rootDirectory, "");
				(0, path_and_artifact_name_validation_1.validateFilePath)(uploadPath);
				specification.push({
					sourcePath: file,
					destinationPath: uploadPath,
					stats
				});
			} else {
				const directoryPath = file.replace(rootDirectory, "");
				(0, path_and_artifact_name_validation_1.validateFilePath)(directoryPath);
				specification.push({
					sourcePath: null,
					destinationPath: directoryPath,
					stats
				});
			}
		}
		return specification;
	}
}));
var tslib_es6_exports = /* @__PURE__ */ __export({
	__addDisposableResource: () => __addDisposableResource,
	__assign: () => __assign,
	__asyncDelegator: () => __asyncDelegator,
	__asyncGenerator: () => __asyncGenerator,
	__asyncValues: () => __asyncValues,
	__await: () => __await,
	__awaiter: () => __awaiter,
	__classPrivateFieldGet: () => __classPrivateFieldGet,
	__classPrivateFieldIn: () => __classPrivateFieldIn,
	__classPrivateFieldSet: () => __classPrivateFieldSet,
	__createBinding: () => __createBinding,
	__decorate: () => __decorate,
	__disposeResources: () => __disposeResources,
	__esDecorate: () => __esDecorate,
	__exportStar: () => __exportStar,
	__extends: () => __extends,
	__generator: () => __generator,
	__importDefault: () => __importDefault,
	__importStar: () => __importStar,
	__makeTemplateObject: () => __makeTemplateObject,
	__metadata: () => __metadata,
	__param: () => __param,
	__propKey: () => __propKey,
	__read: () => __read,
	__rest: () => __rest,
	__rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
	__runInitializers: () => __runInitializers,
	__setFunctionName: () => __setFunctionName,
	__spread: () => __spread,
	__spreadArray: () => __spreadArray,
	__spreadArrays: () => __spreadArrays,
	__values: () => __values,
	default: () => tslib_es6_default
}, 1);
function __extends(d, b) {
	if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	extendStatics(d, b);
	function __() {
		this.constructor = d;
	}
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e$1) {
	var t$1 = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$1.indexOf(p) < 0) t$1[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$1.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
	}
	return t$1;
}
function __decorate(decorators, target, key, desc) {
	var c = arguments.length, r$1 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r$1 = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r$1 = (c < 3 ? d(r$1) : c > 3 ? d(target, key, r$1) : d(target, key)) || r$1;
	return c > 3 && r$1 && Object.defineProperty(target, key, r$1), r$1;
}
function __param(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	function accept(f) {
		if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
		return f;
	}
	var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	var _$1, done = false;
	for (var i = decorators.length - 1; i >= 0; i--) {
		var context$2 = {};
		for (var p in contextIn) context$2[p] = p === "access" ? {} : contextIn[p];
		for (var p in contextIn.access) context$2.access[p] = contextIn.access[p];
		context$2.addInitializer = function(f) {
			if (done) throw new TypeError("Cannot add initializers after decoration has completed");
			extraInitializers.push(accept(f || null));
		};
		var result = (0, decorators[i])(kind === "accessor" ? {
			get: descriptor.get,
			set: descriptor.set
		} : descriptor[key], context$2);
		if (kind === "accessor") {
			if (result === void 0) continue;
			if (result === null || typeof result !== "object") throw new TypeError("Object expected");
			if (_$1 = accept(result.get)) descriptor.get = _$1;
			if (_$1 = accept(result.set)) descriptor.set = _$1;
			if (_$1 = accept(result.init)) initializers.unshift(_$1);
		} else if (_$1 = accept(result)) if (kind === "field") initializers.unshift(_$1);
		else descriptor[key] = _$1;
	}
	if (target) Object.defineProperty(target, contextIn.name, descriptor);
	done = true;
}
function __runInitializers(thisArg, initializers, value$1) {
	var useValue = arguments.length > 2;
	for (var i = 0; i < initializers.length; i++) value$1 = useValue ? initializers[i].call(thisArg, value$1) : initializers[i].call(thisArg);
	return useValue ? value$1 : void 0;
}
function __propKey(x) {
	return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name$1, prefix) {
	if (typeof name$1 === "symbol") name$1 = name$1.description ? "[".concat(name$1.description, "]") : "";
	return Object.defineProperty(f, "name", {
		configurable: true,
		value: prefix ? "".concat(prefix, " ", name$1) : name$1
	});
}
function __metadata(metadataKey, metadataValue) {
	if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
	function adopt(value$1) {
		return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
			resolve$1(value$1);
		});
	}
	return new (P || (P = Promise))(function(resolve$1, reject$3) {
		function fulfilled(value$1) {
			try {
				step(generator.next(value$1));
			} catch (e$1) {
				reject$3(e$1);
			}
		}
		function rejected(value$1) {
			try {
				step(generator["throw"](value$1));
			} catch (e$1) {
				reject$3(e$1);
			}
		}
		function step(result) {
			result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
}
function __generator(thisArg, body) {
	var _$1 = {
		label: 0,
		sent: function() {
			if (t$1[0] & 1) throw t$1[1];
			return t$1[1];
		},
		trys: [],
		ops: []
	}, f, y, t$1, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
	return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
		return this;
	}), g;
	function verb(n$1) {
		return function(v) {
			return step([n$1, v]);
		};
	}
	function step(op) {
		if (f) throw new TypeError("Generator is already executing.");
		while (g && (g = 0, op[0] && (_$1 = 0)), _$1) try {
			if (f = 1, y && (t$1 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t$1 = y["return"]) && t$1.call(y), 0) : y.next) && !(t$1 = t$1.call(y, op[1])).done) return t$1;
			if (y = 0, t$1) op = [op[0] & 2, t$1.value];
			switch (op[0]) {
				case 0:
				case 1:
					t$1 = op;
					break;
				case 4:
					_$1.label++;
					return {
						value: op[1],
						done: false
					};
				case 5:
					_$1.label++;
					y = op[1];
					op = [0];
					continue;
				case 7:
					op = _$1.ops.pop();
					_$1.trys.pop();
					continue;
				default:
					if (!(t$1 = _$1.trys, t$1 = t$1.length > 0 && t$1[t$1.length - 1]) && (op[0] === 6 || op[0] === 2)) {
						_$1 = 0;
						continue;
					}
					if (op[0] === 3 && (!t$1 || op[1] > t$1[0] && op[1] < t$1[3])) {
						_$1.label = op[1];
						break;
					}
					if (op[0] === 6 && _$1.label < t$1[1]) {
						_$1.label = t$1[1];
						t$1 = op;
						break;
					}
					if (t$1 && _$1.label < t$1[2]) {
						_$1.label = t$1[2];
						_$1.ops.push(op);
						break;
					}
					if (t$1[2]) _$1.ops.pop();
					_$1.trys.pop();
					continue;
			}
			op = body.call(thisArg, _$1);
		} catch (e$1) {
			op = [6, e$1];
			y = 0;
		} finally {
			f = t$1 = 0;
		}
		if (op[0] & 5) throw op[1];
		return {
			value: op[0] ? op[1] : void 0,
			done: true
		};
	}
}
function __exportStar(m, o$1) {
	for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o$1, p)) __createBinding(o$1, m, p);
}
function __values(o$1) {
	var s = typeof Symbol === "function" && Symbol.iterator, m = s && o$1[s], i = 0;
	if (m) return m.call(o$1);
	if (o$1 && typeof o$1.length === "number") return { next: function() {
		if (o$1 && i >= o$1.length) o$1 = void 0;
		return {
			value: o$1 && o$1[i++],
			done: !o$1
		};
	} };
	throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o$1, n$1) {
	var m = typeof Symbol === "function" && o$1[Symbol.iterator];
	if (!m) return o$1;
	var i = m.call(o$1), r$1, ar = [], e$1;
	try {
		while ((n$1 === void 0 || n$1-- > 0) && !(r$1 = i.next()).done) ar.push(r$1.value);
	} catch (error) {
		e$1 = { error };
	} finally {
		try {
			if (r$1 && !r$1.done && (m = i["return"])) m.call(i);
		} finally {
			if (e$1) throw e$1.error;
		}
	}
	return ar;
}
function __spread() {
	for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
	return ar;
}
function __spreadArrays() {
	for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	for (var r$1 = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r$1[k] = a[j];
	return r$1;
}
function __spreadArray(to, from, pack) {
	if (pack || arguments.length === 2) {
		for (var i = 0, l = from.length, ar; i < l; i++) if (ar || !(i in from)) {
			if (!ar) ar = Array.prototype.slice.call(from, 0, i);
			ar[i] = from[i];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
	return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var g = generator.apply(thisArg, _arguments || []), i, q = [];
	return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
		return this;
	}, i;
	function awaitReturn(f) {
		return function(v) {
			return Promise.resolve(v).then(f, reject$3);
		};
	}
	function verb(n$1, f) {
		if (g[n$1]) {
			i[n$1] = function(v) {
				return new Promise(function(a, b) {
					q.push([
						n$1,
						v,
						a,
						b
					]) > 1 || resume(n$1, v);
				});
			};
			if (f) i[n$1] = f(i[n$1]);
		}
	}
	function resume(n$1, v) {
		try {
			step(g[n$1](v));
		} catch (e$1) {
			settle(q[0][3], e$1);
		}
	}
	function step(r$1) {
		r$1.value instanceof __await ? Promise.resolve(r$1.value.v).then(fulfill, reject$3) : settle(q[0][2], r$1);
	}
	function fulfill(value$1) {
		resume("next", value$1);
	}
	function reject$3(value$1) {
		resume("throw", value$1);
	}
	function settle(f, v) {
		if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
	}
}
function __asyncDelegator(o$1) {
	var i, p;
	return i = {}, verb("next"), verb("throw", function(e$1) {
		throw e$1;
	}), verb("return"), i[Symbol.iterator] = function() {
		return this;
	}, i;
	function verb(n$1, f) {
		i[n$1] = o$1[n$1] ? function(v) {
			return (p = !p) ? {
				value: __await(o$1[n$1](v)),
				done: false
			} : f ? f(v) : v;
		} : f;
	}
}
function __asyncValues(o$1) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m = o$1[Symbol.asyncIterator], i;
	return m ? m.call(o$1) : (o$1 = typeof __values === "function" ? __values(o$1) : o$1[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
		return this;
	}, i);
	function verb(n$1) {
		i[n$1] = o$1[n$1] && function(v) {
			return new Promise(function(resolve$1, reject$3) {
				v = o$1[n$1](v), settle(resolve$1, reject$3, v.done, v.value);
			});
		};
	}
	function settle(resolve$1, reject$3, d, v) {
		Promise.resolve(v).then(function(v$1) {
			resolve$1({
				value: v$1,
				done: d
			});
		}, reject$3);
	}
}
function __makeTemplateObject(cooked, raw) {
	if (Object.defineProperty) Object.defineProperty(cooked, "raw", { value: raw });
	else cooked.raw = raw;
	return cooked;
}
function __importStar(mod) {
	if (mod && mod.__esModule) return mod;
	var result = {};
	if (mod != null) {
		for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	}
	__setModuleDefault(result, mod);
	return result;
}
function __importDefault(mod) {
	return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value$1, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f.call(receiver, value$1) : f ? f.value = value$1 : state.set(receiver, value$1), value$1;
}
function __classPrivateFieldIn(state, receiver) {
	if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
	return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value$1, async) {
	if (value$1 !== null && value$1 !== void 0) {
		if (typeof value$1 !== "object" && typeof value$1 !== "function") throw new TypeError("Object expected.");
		var dispose, inner;
		if (async) {
			if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
			dispose = value$1[Symbol.asyncDispose];
		}
		if (dispose === void 0) {
			if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
			dispose = value$1[Symbol.dispose];
			if (async) inner = dispose;
		}
		if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e$1) {
				return Promise.reject(e$1);
			}
		};
		env.stack.push({
			value: value$1,
			dispose,
			async
		});
	} else if (async) env.stack.push({ async: true });
	return value$1;
}
function __disposeResources(env) {
	function fail$3(e$1) {
		env.error = env.hasError ? new _SuppressedError(e$1, env.error, "An error was suppressed during disposal.") : e$1;
		env.hasError = true;
	}
	var r$1, s = 0;
	function next() {
		while (r$1 = env.stack.pop()) try {
			if (!r$1.async && s === 1) return s = 0, env.stack.push(r$1), Promise.resolve().then(next);
			if (r$1.dispose) {
				var result = r$1.dispose.call(r$1.value);
				if (r$1.async) return s |= 2, Promise.resolve(result).then(next, function(e$1) {
					fail$3(e$1);
					return next();
				});
			} else s |= 1;
		} catch (e$1) {
			fail$3(e$1);
		}
		if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
		if (env.hasError) throw env.error;
	}
	return next();
}
function __rewriteRelativeImportExtension(path$5, preserveJsx) {
	if (typeof path$5 === "string" && /^\.\.?\//.test(path$5)) return path$5.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
		return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
	});
	return path$5;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esmMin((() => {
	extendStatics = function(d, b) {
		extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$1, b$1) {
			d$1.__proto__ = b$1;
		} || function(d$1, b$1) {
			for (var p in b$1) if (Object.prototype.hasOwnProperty.call(b$1, p)) d$1[p] = b$1[p];
		};
		return extendStatics(d, b);
	};
	__assign = function() {
		__assign = Object.assign || function __assign$1(t$1) {
			for (var s, i = 1, n$1 = arguments.length; i < n$1; i++) {
				s = arguments[i];
				for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t$1[p] = s[p];
			}
			return t$1;
		};
		return __assign.apply(this, arguments);
	};
	__createBinding = Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	});
	__setModuleDefault = Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	};
	ownKeys = function(o$1) {
		ownKeys = Object.getOwnPropertyNames || function(o$2) {
			var ar = [];
			for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
			return ar;
		};
		return ownKeys(o$1);
	};
	_SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
		var e$1 = new Error(message);
		return e$1.name = "SuppressedError", e$1.error = error, e$1.suppressed = suppressed, e$1;
	};
	tslib_es6_default = {
		__extends,
		__assign,
		__rest,
		__decorate,
		__param,
		__esDecorate,
		__runInitializers,
		__propKey,
		__setFunctionName,
		__metadata,
		__awaiter,
		__generator,
		__createBinding,
		__exportStar,
		__values,
		__read,
		__spread,
		__spreadArrays,
		__spreadArray,
		__await,
		__asyncGenerator,
		__asyncDelegator,
		__asyncValues,
		__makeTemplateObject,
		__importStar,
		__importDefault,
		__classPrivateFieldGet,
		__classPrivateFieldSet,
		__classPrivateFieldIn,
		__addDisposableResource,
		__disposeResources,
		__rewriteRelativeImportExtension
	};
}));
var require_AbortError$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AbortError = void 0;
	var AbortError = class extends Error {
		constructor(message) {
			super(message);
			this.name = "AbortError";
		}
	};
	exports.AbortError = AbortError;
}));
var require_log$6 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.log = log;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var node_os_1$2 = __require("node:os");
	var node_util_1$2 = tslib_1.__importDefault(__require("node:util"));
	var node_process_1$2 = tslib_1.__importDefault(__require("node:process"));
	function log(message, ...args) {
		node_process_1$2.default.stderr.write(`${node_util_1$2.default.format(message, ...args)}${node_os_1$2.EOL}`);
	}
}));
var require_debug = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var log_js_1 = require_log$6();
	var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
	var enabledString;
	var enabledNamespaces = [];
	var skippedNamespaces = [];
	var debuggers = [];
	if (debugEnvVariable) enable(debugEnvVariable);
	var debugObj = Object.assign((namespace) => {
		return createDebugger(namespace);
	}, {
		enable,
		enabled,
		disable,
		log: log_js_1.log
	});
	function enable(namespaces) {
		enabledString = namespaces;
		enabledNamespaces = [];
		skippedNamespaces = [];
		const namespaceList = namespaces.split(",").map((ns) => ns.trim());
		for (const ns of namespaceList) if (ns.startsWith("-")) skippedNamespaces.push(ns.substring(1));
		else enabledNamespaces.push(ns);
		for (const instance of debuggers) instance.enabled = enabled(instance.namespace);
	}
	function enabled(namespace) {
		if (namespace.endsWith("*")) return true;
		for (const skipped of skippedNamespaces) if (namespaceMatches(namespace, skipped)) return false;
		for (const enabledNamespace of enabledNamespaces) if (namespaceMatches(namespace, enabledNamespace)) return true;
		return false;
	}
	function namespaceMatches(namespace, patternToMatch) {
		if (patternToMatch.indexOf("*") === -1) return namespace === patternToMatch;
		let pattern$1 = patternToMatch;
		if (patternToMatch.indexOf("**") !== -1) {
			const patternParts = [];
			let lastCharacter = "";
			for (const character of patternToMatch) if (character === "*" && lastCharacter === "*") continue;
			else {
				lastCharacter = character;
				patternParts.push(character);
			}
			pattern$1 = patternParts.join("");
		}
		let namespaceIndex = 0;
		let patternIndex = 0;
		const patternLength = pattern$1.length;
		const namespaceLength = namespace.length;
		let lastWildcard = -1;
		let lastWildcardNamespace = -1;
		while (namespaceIndex < namespaceLength && patternIndex < patternLength) if (pattern$1[patternIndex] === "*") {
			lastWildcard = patternIndex;
			patternIndex++;
			if (patternIndex === patternLength) return true;
			while (namespace[namespaceIndex] !== pattern$1[patternIndex]) {
				namespaceIndex++;
				if (namespaceIndex === namespaceLength) return false;
			}
			lastWildcardNamespace = namespaceIndex;
			namespaceIndex++;
			patternIndex++;
			continue;
		} else if (pattern$1[patternIndex] === namespace[namespaceIndex]) {
			patternIndex++;
			namespaceIndex++;
		} else if (lastWildcard >= 0) {
			patternIndex = lastWildcard + 1;
			namespaceIndex = lastWildcardNamespace + 1;
			if (namespaceIndex === namespaceLength) return false;
			while (namespace[namespaceIndex] !== pattern$1[patternIndex]) {
				namespaceIndex++;
				if (namespaceIndex === namespaceLength) return false;
			}
			lastWildcardNamespace = namespaceIndex;
			namespaceIndex++;
			patternIndex++;
			continue;
		} else return false;
		const namespaceDone = namespaceIndex === namespace.length;
		const patternDone = patternIndex === pattern$1.length;
		const trailingWildCard = patternIndex === pattern$1.length - 1 && pattern$1[patternIndex] === "*";
		return namespaceDone && (patternDone || trailingWildCard);
	}
	function disable() {
		const result = enabledString || "";
		enable("");
		return result;
	}
	function createDebugger(namespace) {
		const newDebugger = Object.assign(debug, {
			enabled: enabled(namespace),
			destroy,
			log: debugObj.log,
			namespace,
			extend
		});
		function debug(...args) {
			if (!newDebugger.enabled) return;
			if (args.length > 0) args[0] = `${namespace} ${args[0]}`;
			newDebugger.log(...args);
		}
		debuggers.push(newDebugger);
		return newDebugger;
	}
	function destroy() {
		const index$1 = debuggers.indexOf(this);
		if (index$1 >= 0) {
			debuggers.splice(index$1, 1);
			return true;
		}
		return false;
	}
	function extend(namespace) {
		const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
		newDebugger.log = this.log;
		return newDebugger;
	}
	exports.default = debugObj;
}));
var require_logger$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TypeSpecRuntimeLogger = void 0;
	exports.createLoggerContext = createLoggerContext;
	exports.setLogLevel = setLogLevel;
	exports.getLogLevel = getLogLevel;
	exports.createClientLogger = createClientLogger;
	var debug_js_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault(require_debug());
	var TYPESPEC_RUNTIME_LOG_LEVELS = [
		"verbose",
		"info",
		"warning",
		"error"
	];
	var levelMap = {
		verbose: 400,
		info: 300,
		warning: 200,
		error: 100
	};
	function patchLogMethod(parent$1, child) {
		child.log = (...args) => {
			parent$1.log(...args);
		};
	}
	function isTypeSpecRuntimeLogLevel(level) {
		return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
	}
	function createLoggerContext(options) {
		const registeredLoggers = /* @__PURE__ */ new Set();
		const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName] || void 0;
		let logLevel;
		const clientLogger = (0, debug_js_1.default)(options.namespace);
		clientLogger.log = (...args) => {
			debug_js_1.default.log(...args);
		};
		function contextSetLogLevel(level) {
			if (level && !isTypeSpecRuntimeLogLevel(level)) throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
			logLevel = level;
			const enabledNamespaces = [];
			for (const logger of registeredLoggers) if (shouldEnable(logger)) enabledNamespaces.push(logger.namespace);
			debug_js_1.default.enable(enabledNamespaces.join(","));
		}
		if (logLevelFromEnv) if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) contextSetLogLevel(logLevelFromEnv);
		else console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
		function shouldEnable(logger) {
			return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);
		}
		function createLogger$1(parent$1, level) {
			const logger = Object.assign(parent$1.extend(level), { level });
			patchLogMethod(parent$1, logger);
			if (shouldEnable(logger)) {
				const enabledNamespaces = debug_js_1.default.disable();
				debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
			}
			registeredLoggers.add(logger);
			return logger;
		}
		function contextGetLogLevel() {
			return logLevel;
		}
		function contextCreateClientLogger(namespace) {
			const clientRootLogger = clientLogger.extend(namespace);
			patchLogMethod(clientLogger, clientRootLogger);
			return {
				error: createLogger$1(clientRootLogger, "error"),
				warning: createLogger$1(clientRootLogger, "warning"),
				info: createLogger$1(clientRootLogger, "info"),
				verbose: createLogger$1(clientRootLogger, "verbose")
			};
		}
		return {
			setLogLevel: contextSetLogLevel,
			getLogLevel: contextGetLogLevel,
			createClientLogger: contextCreateClientLogger,
			logger: clientLogger
		};
	}
	var context = createLoggerContext({
		logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
		namespace: "typeSpecRuntime"
	});
	exports.TypeSpecRuntimeLogger = context.logger;
	function setLogLevel(logLevel) {
		context.setLogLevel(logLevel);
	}
	function getLogLevel() {
		return context.getLogLevel();
	}
	function createClientLogger(namespace) {
		return context.createClientLogger(namespace);
	}
}));
var require_httpHeaders$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createHttpHeaders = createHttpHeaders;
	function normalizeName(name$1) {
		return name$1.toLowerCase();
	}
	function* headerIterator(map$6) {
		for (const entry of map$6.values()) yield [entry.name, entry.value];
	}
	var HttpHeadersImpl = class {
		_headersMap;
		constructor(rawHeaders) {
			this._headersMap = /* @__PURE__ */ new Map();
			if (rawHeaders) for (const headerName of Object.keys(rawHeaders)) this.set(headerName, rawHeaders[headerName]);
		}
		set(name$1, value$1) {
			this._headersMap.set(normalizeName(name$1), {
				name: name$1,
				value: String(value$1).trim()
			});
		}
		get(name$1) {
			return this._headersMap.get(normalizeName(name$1))?.value;
		}
		has(name$1) {
			return this._headersMap.has(normalizeName(name$1));
		}
		delete(name$1) {
			this._headersMap.delete(normalizeName(name$1));
		}
		toJSON(options = {}) {
			const result = {};
			if (options.preserveCase) for (const entry of this._headersMap.values()) result[entry.name] = entry.value;
			else for (const [normalizedName, entry] of this._headersMap) result[normalizedName] = entry.value;
			return result;
		}
		toString() {
			return JSON.stringify(this.toJSON({ preserveCase: true }));
		}
		[Symbol.iterator]() {
			return headerIterator(this._headersMap);
		}
	};
	function createHttpHeaders(rawHeaders) {
		return new HttpHeadersImpl(rawHeaders);
	}
}));
var require_schemes = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_oauth2Flows = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_uuidUtils = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.randomUUID = randomUUID;
	function randomUUID() {
		return crypto.randomUUID();
	}
}));
var require_pipelineRequest$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createPipelineRequest = createPipelineRequest;
	var httpHeaders_js_1 = require_httpHeaders$1();
	var uuidUtils_js_1 = require_uuidUtils();
	var PipelineRequestImpl = class {
		url;
		method;
		headers;
		timeout;
		withCredentials;
		body;
		multipartBody;
		formData;
		streamResponseStatusCodes;
		enableBrowserStreams;
		proxySettings;
		disableKeepAlive;
		abortSignal;
		requestId;
		allowInsecureConnection;
		onUploadProgress;
		onDownloadProgress;
		requestOverrides;
		authSchemes;
		constructor(options) {
			this.url = options.url;
			this.body = options.body;
			this.headers = options.headers ?? (0, httpHeaders_js_1.createHttpHeaders)();
			this.method = options.method ?? "GET";
			this.timeout = options.timeout ?? 0;
			this.multipartBody = options.multipartBody;
			this.formData = options.formData;
			this.disableKeepAlive = options.disableKeepAlive ?? false;
			this.proxySettings = options.proxySettings;
			this.streamResponseStatusCodes = options.streamResponseStatusCodes;
			this.withCredentials = options.withCredentials ?? false;
			this.abortSignal = options.abortSignal;
			this.onUploadProgress = options.onUploadProgress;
			this.onDownloadProgress = options.onDownloadProgress;
			this.requestId = options.requestId || (0, uuidUtils_js_1.randomUUID)();
			this.allowInsecureConnection = options.allowInsecureConnection ?? false;
			this.enableBrowserStreams = options.enableBrowserStreams ?? false;
			this.requestOverrides = options.requestOverrides;
			this.authSchemes = options.authSchemes;
		}
	};
	function createPipelineRequest(options) {
		return new PipelineRequestImpl(options);
	}
}));
var require_pipeline$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createEmptyPipeline = createEmptyPipeline;
	var ValidPhaseNames = new Set([
		"Deserialize",
		"Serialize",
		"Retry",
		"Sign"
	]);
	var HttpPipeline = class HttpPipeline {
		_policies = [];
		_orderedPolicies;
		constructor(policies) {
			this._policies = policies?.slice(0) ?? [];
			this._orderedPolicies = void 0;
		}
		addPolicy(policy, options = {}) {
			if (options.phase && options.afterPhase) throw new Error("Policies inside a phase cannot specify afterPhase.");
			if (options.phase && !ValidPhaseNames.has(options.phase)) throw new Error(`Invalid phase name: ${options.phase}`);
			if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
			this._policies.push({
				policy,
				options
			});
			this._orderedPolicies = void 0;
		}
		removePolicy(options) {
			const removedPolicies = [];
			this._policies = this._policies.filter((policyDescriptor) => {
				if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
					removedPolicies.push(policyDescriptor.policy);
					return false;
				} else return true;
			});
			this._orderedPolicies = void 0;
			return removedPolicies;
		}
		sendRequest(httpClient, request$1) {
			return this.getOrderedPolicies().reduceRight((next, policy) => {
				return (req) => {
					return policy.sendRequest(req, next);
				};
			}, (req) => httpClient.sendRequest(req))(request$1);
		}
		getOrderedPolicies() {
			if (!this._orderedPolicies) this._orderedPolicies = this.orderPolicies();
			return this._orderedPolicies;
		}
		clone() {
			return new HttpPipeline(this._policies);
		}
		static create() {
			return new HttpPipeline();
		}
		orderPolicies() {
			const result = [];
			const policyMap = /* @__PURE__ */ new Map();
			function createPhase(name$1) {
				return {
					name: name$1,
					policies: /* @__PURE__ */ new Set(),
					hasRun: false,
					hasAfterPolicies: false
				};
			}
			const serializePhase = createPhase("Serialize");
			const noPhase = createPhase("None");
			const deserializePhase = createPhase("Deserialize");
			const retryPhase = createPhase("Retry");
			const signPhase = createPhase("Sign");
			const orderedPhases = [
				serializePhase,
				noPhase,
				deserializePhase,
				retryPhase,
				signPhase
			];
			function getPhase(phase) {
				if (phase === "Retry") return retryPhase;
				else if (phase === "Serialize") return serializePhase;
				else if (phase === "Deserialize") return deserializePhase;
				else if (phase === "Sign") return signPhase;
				else return noPhase;
			}
			for (const descriptor of this._policies) {
				const policy = descriptor.policy;
				const options = descriptor.options;
				const policyName = policy.name;
				if (policyMap.has(policyName)) throw new Error("Duplicate policy names not allowed in pipeline");
				const node = {
					policy,
					dependsOn: /* @__PURE__ */ new Set(),
					dependants: /* @__PURE__ */ new Set()
				};
				if (options.afterPhase) {
					node.afterPhase = getPhase(options.afterPhase);
					node.afterPhase.hasAfterPolicies = true;
				}
				policyMap.set(policyName, node);
				getPhase(options.phase).policies.add(node);
			}
			for (const descriptor of this._policies) {
				const { policy, options } = descriptor;
				const policyName = policy.name;
				const node = policyMap.get(policyName);
				if (!node) throw new Error(`Missing node for policy ${policyName}`);
				if (options.afterPolicies) for (const afterPolicyName of options.afterPolicies) {
					const afterNode = policyMap.get(afterPolicyName);
					if (afterNode) {
						node.dependsOn.add(afterNode);
						afterNode.dependants.add(node);
					}
				}
				if (options.beforePolicies) for (const beforePolicyName of options.beforePolicies) {
					const beforeNode = policyMap.get(beforePolicyName);
					if (beforeNode) {
						beforeNode.dependsOn.add(node);
						node.dependants.add(beforeNode);
					}
				}
			}
			function walkPhase(phase) {
				phase.hasRun = true;
				for (const node of phase.policies) {
					if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) continue;
					if (node.dependsOn.size === 0) {
						result.push(node.policy);
						for (const dependant of node.dependants) dependant.dependsOn.delete(node);
						policyMap.delete(node.policy.name);
						phase.policies.delete(node);
					}
				}
			}
			function walkPhases() {
				for (const phase of orderedPhases) {
					walkPhase(phase);
					if (phase.policies.size > 0 && phase !== noPhase) {
						if (!noPhase.hasRun) walkPhase(noPhase);
						return;
					}
					if (phase.hasAfterPolicies) walkPhase(noPhase);
				}
			}
			let iteration = 0;
			while (policyMap.size > 0) {
				iteration++;
				const initialResultLength = result.length;
				walkPhases();
				if (result.length <= initialResultLength && iteration > 1) throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
			}
			return result;
		}
	};
	function createEmptyPipeline() {
		return HttpPipeline.create();
	}
}));
var require_object = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isObject = isObject;
	function isObject(input) {
		return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
	}
}));
var require_error$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isError = isError;
	var object_js_1 = require_object();
	function isError(e$1) {
		if ((0, object_js_1.isObject)(e$1)) {
			const hasName = typeof e$1.name === "string";
			const hasMessage = typeof e$1.message === "string";
			return hasName && hasMessage;
		}
		return false;
	}
}));
var require_inspect$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.custom = void 0;
	exports.custom = __require("node:util").inspect.custom;
}));
var require_sanitizer = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Sanitizer = void 0;
	var object_js_1 = require_object();
	var RedactedString = "REDACTED";
	var defaultAllowedHeaderNames = [
		"x-ms-client-request-id",
		"x-ms-return-client-request-id",
		"x-ms-useragent",
		"x-ms-correlation-request-id",
		"x-ms-request-id",
		"client-request-id",
		"ms-cv",
		"return-client-request-id",
		"traceparent",
		"Access-Control-Allow-Credentials",
		"Access-Control-Allow-Headers",
		"Access-Control-Allow-Methods",
		"Access-Control-Allow-Origin",
		"Access-Control-Expose-Headers",
		"Access-Control-Max-Age",
		"Access-Control-Request-Headers",
		"Access-Control-Request-Method",
		"Origin",
		"Accept",
		"Accept-Encoding",
		"Cache-Control",
		"Connection",
		"Content-Length",
		"Content-Type",
		"Date",
		"ETag",
		"Expires",
		"If-Match",
		"If-Modified-Since",
		"If-None-Match",
		"If-Unmodified-Since",
		"Last-Modified",
		"Pragma",
		"Request-Id",
		"Retry-After",
		"Server",
		"Transfer-Encoding",
		"User-Agent",
		"WWW-Authenticate"
	];
	var defaultAllowedQueryParameters = ["api-version"];
	var Sanitizer = class {
		allowedHeaderNames;
		allowedQueryParameters;
		constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
			allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
			allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
			this.allowedHeaderNames = new Set(allowedHeaderNames.map((n$1) => n$1.toLowerCase()));
			this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
		}
		sanitize(obj) {
			const seen = /* @__PURE__ */ new Set();
			return JSON.stringify(obj, (key, value$1) => {
				if (value$1 instanceof Error) return {
					...value$1,
					name: value$1.name,
					message: value$1.message
				};
				if (key === "headers") return this.sanitizeHeaders(value$1);
				else if (key === "url") return this.sanitizeUrl(value$1);
				else if (key === "query") return this.sanitizeQuery(value$1);
				else if (key === "body") return;
				else if (key === "response") return;
				else if (key === "operationSpec") return;
				else if (Array.isArray(value$1) || (0, object_js_1.isObject)(value$1)) {
					if (seen.has(value$1)) return "[Circular]";
					seen.add(value$1);
				}
				return value$1;
			}, 2);
		}
		sanitizeUrl(value$1) {
			if (typeof value$1 !== "string" || value$1 === null || value$1 === "") return value$1;
			const url = new URL(value$1);
			if (!url.search) return value$1;
			for (const [key] of url.searchParams) if (!this.allowedQueryParameters.has(key.toLowerCase())) url.searchParams.set(key, RedactedString);
			return url.toString();
		}
		sanitizeHeaders(obj) {
			const sanitized = {};
			for (const key of Object.keys(obj)) if (this.allowedHeaderNames.has(key.toLowerCase())) sanitized[key] = obj[key];
			else sanitized[key] = RedactedString;
			return sanitized;
		}
		sanitizeQuery(value$1) {
			if (typeof value$1 !== "object" || value$1 === null) return value$1;
			const sanitized = {};
			for (const k of Object.keys(value$1)) if (this.allowedQueryParameters.has(k.toLowerCase())) sanitized[k] = value$1[k];
			else sanitized[k] = RedactedString;
			return sanitized;
		}
	};
	exports.Sanitizer = Sanitizer;
}));
var require_restError$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.RestError = void 0;
	exports.isRestError = isRestError;
	var error_js_1 = require_error$2();
	var inspect_js_1 = require_inspect$1();
	var errorSanitizer = new (require_sanitizer()).Sanitizer();
	var RestError = class RestError extends Error {
		static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
		static PARSE_ERROR = "PARSE_ERROR";
		code;
		statusCode;
		request;
		response;
		details;
		constructor(message, options = {}) {
			super(message);
			this.name = "RestError";
			this.code = options.code;
			this.statusCode = options.statusCode;
			Object.defineProperty(this, "request", {
				value: options.request,
				enumerable: false
			});
			Object.defineProperty(this, "response", {
				value: options.response,
				enumerable: false
			});
			const agent = this.request?.agent ? {
				maxFreeSockets: this.request.agent.maxFreeSockets,
				maxSockets: this.request.agent.maxSockets
			} : void 0;
			Object.defineProperty(this, inspect_js_1.custom, {
				value: () => {
					return `RestError: ${this.message} \n ${errorSanitizer.sanitize({
						...this,
						request: {
							...this.request,
							agent
						},
						response: this.response
					})}`;
				},
				enumerable: false
			});
			Object.setPrototypeOf(this, RestError.prototype);
		}
	};
	exports.RestError = RestError;
	function isRestError(e$1) {
		if (e$1 instanceof RestError) return true;
		return (0, error_js_1.isError)(e$1) && e$1.name === "RestError";
	}
}));
var require_bytesEncoding = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.uint8ArrayToString = uint8ArrayToString;
	exports.stringToUint8Array = stringToUint8Array;
	function uint8ArrayToString(bytes, format) {
		return Buffer.from(bytes).toString(format);
	}
	function stringToUint8Array(value$1, format) {
		return Buffer.from(value$1, format);
	}
}));
var require_log$5 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logger = void 0;
	exports.logger = (0, require_logger$1().createClientLogger)("ts-http-runtime");
}));
var require_nodeHttpClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getBodyLength = getBodyLength;
	exports.createNodeHttpClient = createNodeHttpClient;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var node_http_1 = tslib_1.__importDefault(__require("node:http"));
	var node_https_1 = tslib_1.__importDefault(__require("node:https"));
	var node_zlib_1 = tslib_1.__importDefault(__require("node:zlib"));
	var node_stream_1$4 = __require("node:stream");
	var AbortError_js_1 = require_AbortError$1();
	var httpHeaders_js_1 = require_httpHeaders$1();
	var restError_js_1 = require_restError$2();
	var log_js_1 = require_log$5();
	var sanitizer_js_1 = require_sanitizer();
	var DEFAULT_TLS_SETTINGS = {};
	function isReadableStream(body) {
		return body && typeof body.pipe === "function";
	}
	function isStreamComplete(stream$5) {
		if (stream$5.readable === false) return Promise.resolve();
		return new Promise((resolve$1) => {
			const handler$1 = () => {
				resolve$1();
				stream$5.removeListener("close", handler$1);
				stream$5.removeListener("end", handler$1);
				stream$5.removeListener("error", handler$1);
			};
			stream$5.on("close", handler$1);
			stream$5.on("end", handler$1);
			stream$5.on("error", handler$1);
		});
	}
	function isArrayBuffer(body) {
		return body && typeof body.byteLength === "number";
	}
	var ReportTransform = class extends node_stream_1$4.Transform {
		loadedBytes = 0;
		progressCallback;
		_transform(chunk, _encoding, callback) {
			this.push(chunk);
			this.loadedBytes += chunk.length;
			try {
				this.progressCallback({ loadedBytes: this.loadedBytes });
				callback();
			} catch (e$1) {
				callback(e$1);
			}
		}
		constructor(progressCallback) {
			super();
			this.progressCallback = progressCallback;
		}
	};
	var NodeHttpClient = class {
		cachedHttpAgent;
		cachedHttpsAgents = /* @__PURE__ */ new WeakMap();
		async sendRequest(request$1) {
			const abortController = new AbortController();
			let abortListener;
			if (request$1.abortSignal) {
				if (request$1.abortSignal.aborted) throw new AbortError_js_1.AbortError("The operation was aborted. Request has already been canceled.");
				abortListener = (event) => {
					if (event.type === "abort") abortController.abort();
				};
				request$1.abortSignal.addEventListener("abort", abortListener);
			}
			let timeoutId;
			if (request$1.timeout > 0) timeoutId = setTimeout(() => {
				const sanitizer = new sanitizer_js_1.Sanitizer();
				log_js_1.logger.info(`request to '${sanitizer.sanitizeUrl(request$1.url)}' timed out. canceling...`);
				abortController.abort();
			}, request$1.timeout);
			const acceptEncoding = request$1.headers.get("Accept-Encoding");
			const shouldDecompress = acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate");
			let body = typeof request$1.body === "function" ? request$1.body() : request$1.body;
			if (body && !request$1.headers.has("Content-Length")) {
				const bodyLength = getBodyLength(body);
				if (bodyLength !== null) request$1.headers.set("Content-Length", bodyLength);
			}
			let responseStream;
			try {
				if (body && request$1.onUploadProgress) {
					const onUploadProgress = request$1.onUploadProgress;
					const uploadReportStream = new ReportTransform(onUploadProgress);
					uploadReportStream.on("error", (e$1) => {
						log_js_1.logger.error("Error in upload progress", e$1);
					});
					if (isReadableStream(body)) body.pipe(uploadReportStream);
					else uploadReportStream.end(body);
					body = uploadReportStream;
				}
				const res = await this.makeRequest(request$1, abortController, body);
				if (timeoutId !== void 0) clearTimeout(timeoutId);
				const headers = getResponseHeaders(res);
				const response = {
					status: res.statusCode ?? 0,
					headers,
					request: request$1
				};
				if (request$1.method === "HEAD") {
					res.resume();
					return response;
				}
				responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
				const onDownloadProgress = request$1.onDownloadProgress;
				if (onDownloadProgress) {
					const downloadReportStream = new ReportTransform(onDownloadProgress);
					downloadReportStream.on("error", (e$1) => {
						log_js_1.logger.error("Error in download progress", e$1);
					});
					responseStream.pipe(downloadReportStream);
					responseStream = downloadReportStream;
				}
				if (request$1.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) || request$1.streamResponseStatusCodes?.has(response.status)) response.readableStreamBody = responseStream;
				else response.bodyAsText = await streamToText(responseStream);
				return response;
			} finally {
				if (request$1.abortSignal && abortListener) {
					let uploadStreamDone = Promise.resolve();
					if (isReadableStream(body)) uploadStreamDone = isStreamComplete(body);
					let downloadStreamDone = Promise.resolve();
					if (isReadableStream(responseStream)) downloadStreamDone = isStreamComplete(responseStream);
					Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
						if (abortListener) request$1.abortSignal?.removeEventListener("abort", abortListener);
					}).catch((e$1) => {
						log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e$1);
					});
				}
			}
		}
		makeRequest(request$1, abortController, body) {
			const url = new URL(request$1.url);
			const isInsecure = url.protocol !== "https:";
			if (isInsecure && !request$1.allowInsecureConnection) throw new Error(`Cannot connect to ${request$1.url} while allowInsecureConnection is false.`);
			const options = {
				agent: request$1.agent ?? this.getOrCreateAgent(request$1, isInsecure),
				hostname: url.hostname,
				path: `${url.pathname}${url.search}`,
				port: url.port,
				method: request$1.method,
				headers: request$1.headers.toJSON({ preserveCase: true }),
				...request$1.requestOverrides
			};
			return new Promise((resolve$1, reject$3) => {
				const req = isInsecure ? node_http_1.default.request(options, resolve$1) : node_https_1.default.request(options, resolve$1);
				req.once("error", (err) => {
					reject$3(new restError_js_1.RestError(err.message, {
						code: err.code ?? restError_js_1.RestError.REQUEST_SEND_ERROR,
						request: request$1
					}));
				});
				abortController.signal.addEventListener("abort", () => {
					const abortError = new AbortError_js_1.AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
					req.destroy(abortError);
					reject$3(abortError);
				});
				if (body && isReadableStream(body)) body.pipe(req);
				else if (body) if (typeof body === "string" || Buffer.isBuffer(body)) req.end(body);
				else if (isArrayBuffer(body)) req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
				else {
					log_js_1.logger.error("Unrecognized body type", body);
					reject$3(new restError_js_1.RestError("Unrecognized body type"));
				}
				else req.end();
			});
		}
		getOrCreateAgent(request$1, isInsecure) {
			const disableKeepAlive = request$1.disableKeepAlive;
			if (isInsecure) {
				if (disableKeepAlive) return node_http_1.default.globalAgent;
				if (!this.cachedHttpAgent) this.cachedHttpAgent = new node_http_1.default.Agent({ keepAlive: true });
				return this.cachedHttpAgent;
			} else {
				if (disableKeepAlive && !request$1.tlsSettings) return node_https_1.default.globalAgent;
				const tlsSettings = request$1.tlsSettings ?? DEFAULT_TLS_SETTINGS;
				let agent = this.cachedHttpsAgents.get(tlsSettings);
				if (agent && agent.options.keepAlive === !disableKeepAlive) return agent;
				log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
				agent = new node_https_1.default.Agent({
					keepAlive: !disableKeepAlive,
					...tlsSettings
				});
				this.cachedHttpsAgents.set(tlsSettings, agent);
				return agent;
			}
		}
	};
	function getResponseHeaders(res) {
		const headers = (0, httpHeaders_js_1.createHttpHeaders)();
		for (const header of Object.keys(res.headers)) {
			const value$1 = res.headers[header];
			if (Array.isArray(value$1)) {
				if (value$1.length > 0) headers.set(header, value$1[0]);
			} else if (value$1) headers.set(header, value$1);
		}
		return headers;
	}
	function getDecodedResponseStream(stream$5, headers) {
		const contentEncoding = headers.get("Content-Encoding");
		if (contentEncoding === "gzip") {
			const unzip = node_zlib_1.default.createGunzip();
			stream$5.pipe(unzip);
			return unzip;
		} else if (contentEncoding === "deflate") {
			const inflate = node_zlib_1.default.createInflate();
			stream$5.pipe(inflate);
			return inflate;
		}
		return stream$5;
	}
	function streamToText(stream$5) {
		return new Promise((resolve$1, reject$3) => {
			const buffer$2 = [];
			stream$5.on("data", (chunk) => {
				if (Buffer.isBuffer(chunk)) buffer$2.push(chunk);
				else buffer$2.push(Buffer.from(chunk));
			});
			stream$5.on("end", () => {
				resolve$1(Buffer.concat(buffer$2).toString("utf8"));
			});
			stream$5.on("error", (e$1) => {
				if (e$1 && e$1?.name === "AbortError") reject$3(e$1);
				else reject$3(new restError_js_1.RestError(`Error reading response as text: ${e$1.message}`, { code: restError_js_1.RestError.PARSE_ERROR }));
			});
		});
	}
	function getBodyLength(body) {
		if (!body) return 0;
		else if (Buffer.isBuffer(body)) return body.length;
		else if (isReadableStream(body)) return null;
		else if (isArrayBuffer(body)) return body.byteLength;
		else if (typeof body === "string") return Buffer.from(body).length;
		else return null;
	}
	function createNodeHttpClient() {
		return new NodeHttpClient();
	}
}));
var require_defaultHttpClient$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createDefaultHttpClient = createDefaultHttpClient;
	var nodeHttpClient_js_1 = require_nodeHttpClient();
	function createDefaultHttpClient() {
		return (0, nodeHttpClient_js_1.createNodeHttpClient)();
	}
}));
var require_logPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logPolicyName = void 0;
	exports.logPolicy = logPolicy;
	var log_js_1 = require_log$5();
	var sanitizer_js_1 = require_sanitizer();
	exports.logPolicyName = "logPolicy";
	function logPolicy(options = {}) {
		const logger = options.logger ?? log_js_1.logger.info;
		const sanitizer = new sanitizer_js_1.Sanitizer({
			additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
			additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
		});
		return {
			name: exports.logPolicyName,
			async sendRequest(request$1, next) {
				if (!logger.enabled) return next(request$1);
				logger(`Request: ${sanitizer.sanitize(request$1)}`);
				const response = await next(request$1);
				logger(`Response status code: ${response.status}`);
				logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
				return response;
			}
		};
	}
}));
var require_redirectPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.redirectPolicyName = void 0;
	exports.redirectPolicy = redirectPolicy;
	exports.redirectPolicyName = "redirectPolicy";
	var allowedRedirect = ["GET", "HEAD"];
	function redirectPolicy(options = {}) {
		const { maxRetries = 20 } = options;
		return {
			name: exports.redirectPolicyName,
			async sendRequest(request$1, next) {
				return handleRedirect(next, await next(request$1), maxRetries);
			}
		};
	}
	async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
		const { request: request$1, status, headers } = response;
		const locationHeader = headers.get("location");
		if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request$1.method) || status === 302 && allowedRedirect.includes(request$1.method) || status === 303 && request$1.method === "POST" || status === 307) && currentRetries < maxRetries) {
			request$1.url = new URL(locationHeader, request$1.url).toString();
			if (status === 303) {
				request$1.method = "GET";
				request$1.headers.delete("Content-Length");
				delete request$1.body;
			}
			request$1.headers.delete("Authorization");
			return handleRedirect(next, await next(request$1), maxRetries, currentRetries + 1);
		}
		return response;
	}
}));
var require_userAgentPlatform$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getHeaderName = getHeaderName;
	exports.setPlatformSpecificData = setPlatformSpecificData;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var node_os_1$1 = tslib_1.__importDefault(__require("node:os"));
	var node_process_1$1 = tslib_1.__importDefault(__require("node:process"));
	function getHeaderName() {
		return "User-Agent";
	}
	async function setPlatformSpecificData(map$6) {
		if (node_process_1$1.default && node_process_1$1.default.versions) {
			const osInfo = `${node_os_1$1.default.type()} ${node_os_1$1.default.release()}; ${node_os_1$1.default.arch()}`;
			const versions = node_process_1$1.default.versions;
			if (versions.bun) map$6.set("Bun", `${versions.bun} (${osInfo})`);
			else if (versions.deno) map$6.set("Deno", `${versions.deno} (${osInfo})`);
			else if (versions.node) map$6.set("Node", `${versions.node} (${osInfo})`);
		}
	}
}));
var require_constants$6 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = void 0;
	exports.SDK_VERSION = "0.3.2";
	exports.DEFAULT_RETRY_POLICY_COUNT = 3;
}));
var require_userAgent$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getUserAgentHeaderName = getUserAgentHeaderName;
	exports.getUserAgentValue = getUserAgentValue;
	var userAgentPlatform_js_1 = require_userAgentPlatform$1();
	var constants_js_1 = require_constants$6();
	function getUserAgentString(telemetryInfo) {
		const parts = [];
		for (const [key, value$1] of telemetryInfo) {
			const token = value$1 ? `${key}/${value$1}` : key;
			parts.push(token);
		}
		return parts.join(" ");
	}
	function getUserAgentHeaderName() {
		return (0, userAgentPlatform_js_1.getHeaderName)();
	}
	async function getUserAgentValue(prefix) {
		const runtimeInfo = /* @__PURE__ */ new Map();
		runtimeInfo.set("ts-http-runtime", constants_js_1.SDK_VERSION);
		await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
		const defaultAgent = getUserAgentString(runtimeInfo);
		return prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
	}
}));
var require_userAgentPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.userAgentPolicyName = void 0;
	exports.userAgentPolicy = userAgentPolicy;
	var userAgent_js_1 = require_userAgent$1();
	var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
	exports.userAgentPolicyName = "userAgentPolicy";
	function userAgentPolicy(options = {}) {
		const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
		return {
			name: exports.userAgentPolicyName,
			async sendRequest(request$1, next) {
				if (!request$1.headers.has(UserAgentHeaderName)) request$1.headers.set(UserAgentHeaderName, await userAgentValue);
				return next(request$1);
			}
		};
	}
}));
var require_decompressResponsePolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.decompressResponsePolicyName = void 0;
	exports.decompressResponsePolicy = decompressResponsePolicy;
	exports.decompressResponsePolicyName = "decompressResponsePolicy";
	function decompressResponsePolicy() {
		return {
			name: exports.decompressResponsePolicyName,
			async sendRequest(request$1, next) {
				if (request$1.method !== "HEAD") request$1.headers.set("Accept-Encoding", "gzip,deflate");
				return next(request$1);
			}
		};
	}
}));
var require_random = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
	function getRandomIntegerInclusive(min, max) {
		min = Math.ceil(min);
		max = Math.floor(max);
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}
}));
var require_delay$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.calculateRetryDelay = calculateRetryDelay;
	var random_js_1 = require_random();
	function calculateRetryDelay(retryAttempt, config) {
		const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
		const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
		return { retryAfterInMs: clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2) };
	}
}));
var require_helpers$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.delay = delay;
	exports.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
	var AbortError_js_1 = require_AbortError$1();
	var StandardAbortMessage = "The operation was aborted.";
	function delay(delayInMs, value$1, options) {
		return new Promise((resolve$1, reject$3) => {
			let timer = void 0;
			let onAborted = void 0;
			const rejectOnAbort = () => {
				return reject$3(new AbortError_js_1.AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage));
			};
			const removeListeners = () => {
				if (options?.abortSignal && onAborted) options.abortSignal.removeEventListener("abort", onAborted);
			};
			onAborted = () => {
				if (timer) clearTimeout(timer);
				removeListeners();
				return rejectOnAbort();
			};
			if (options?.abortSignal && options.abortSignal.aborted) return rejectOnAbort();
			timer = setTimeout(() => {
				removeListeners();
				resolve$1(value$1);
			}, delayInMs);
			if (options?.abortSignal) options.abortSignal.addEventListener("abort", onAborted);
		});
	}
	function parseHeaderValueAsNumber(response, headerName) {
		const value$1 = response.headers.get(headerName);
		if (!value$1) return;
		const valueAsNum = Number(value$1);
		if (Number.isNaN(valueAsNum)) return;
		return valueAsNum;
	}
}));
var require_throttlingRetryStrategy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isThrottlingRetryResponse = isThrottlingRetryResponse;
	exports.throttlingRetryStrategy = throttlingRetryStrategy;
	var helpers_js_1 = require_helpers$1();
	var RetryAfterHeader = "Retry-After";
	var AllRetryAfterHeaders = [
		"retry-after-ms",
		"x-ms-retry-after-ms",
		RetryAfterHeader
	];
	function getRetryAfterInMs(response) {
		if (!(response && [429, 503].includes(response.status))) return void 0;
		try {
			for (const header of AllRetryAfterHeaders) {
				const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
				if (retryAfterValue === 0 || retryAfterValue) return retryAfterValue * (header === RetryAfterHeader ? 1e3 : 1);
			}
			const retryAfterHeader = response.headers.get(RetryAfterHeader);
			if (!retryAfterHeader) return;
			const diff = Date.parse(retryAfterHeader) - Date.now();
			return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
		} catch {
			return;
		}
	}
	function isThrottlingRetryResponse(response) {
		return Number.isFinite(getRetryAfterInMs(response));
	}
	function throttlingRetryStrategy() {
		return {
			name: "throttlingRetryStrategy",
			retry({ response }) {
				const retryAfterInMs = getRetryAfterInMs(response);
				if (!Number.isFinite(retryAfterInMs)) return { skipStrategy: true };
				return { retryAfterInMs };
			}
		};
	}
}));
var require_exponentialRetryStrategy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.exponentialRetryStrategy = exponentialRetryStrategy;
	exports.isExponentialRetryResponse = isExponentialRetryResponse;
	exports.isSystemError = isSystemError;
	var delay_js_1 = require_delay$1();
	var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
	var DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
	var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
	function exponentialRetryStrategy(options = {}) {
		const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;
		const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
		return {
			name: "exponentialRetryStrategy",
			retry({ retryCount, response, responseError }) {
				const matchedSystemError = isSystemError(responseError);
				const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
				const isExponential = isExponentialRetryResponse(response);
				const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
				if (response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential) || ignoreExponentialResponse || ignoreSystemErrors) return { skipStrategy: true };
				if (responseError && !matchedSystemError && !isExponential) return { errorToThrow: responseError };
				return (0, delay_js_1.calculateRetryDelay)(retryCount, {
					retryDelayInMs: retryInterval,
					maxRetryDelayInMs: maxRetryInterval
				});
			}
		};
	}
	function isExponentialRetryResponse(response) {
		return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
	}
	function isSystemError(err) {
		if (!err) return false;
		return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
	}
}));
var require_retryPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.retryPolicy = retryPolicy;
	var helpers_js_1 = require_helpers$1();
	var AbortError_js_1 = require_AbortError$1();
	var logger_js_1 = require_logger$1();
	var constants_js_1 = require_constants$6();
	var retryPolicyLogger = (0, logger_js_1.createClientLogger)("ts-http-runtime retryPolicy");
	var retryPolicyName = "retryPolicy";
	function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
		const logger = options.logger || retryPolicyLogger;
		return {
			name: retryPolicyName,
			async sendRequest(request$1, next) {
				let response;
				let responseError;
				let retryCount = -1;
				retryRequest: while (true) {
					retryCount += 1;
					response = void 0;
					responseError = void 0;
					try {
						logger.info(`Retry ${retryCount}: Attempting to send request`, request$1.requestId);
						response = await next(request$1);
						logger.info(`Retry ${retryCount}: Received a response from request`, request$1.requestId);
					} catch (e$1) {
						logger.error(`Retry ${retryCount}: Received an error from request`, request$1.requestId);
						responseError = e$1;
						if (!e$1 || responseError.name !== "RestError") throw e$1;
						response = responseError.response;
					}
					if (request$1.abortSignal?.aborted) {
						logger.error(`Retry ${retryCount}: Request aborted.`);
						throw new AbortError_js_1.AbortError();
					}
					if (retryCount >= (options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
						logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
						if (responseError) throw responseError;
						else if (response) return response;
						else throw new Error("Maximum retries reached with no response or error to throw");
					}
					logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
					strategiesLoop: for (const strategy of strategies) {
						const strategyLogger = strategy.logger || logger;
						strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
						const modifiers = strategy.retry({
							retryCount,
							response,
							responseError
						});
						if (modifiers.skipStrategy) {
							strategyLogger.info(`Retry ${retryCount}: Skipped.`);
							continue strategiesLoop;
						}
						const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
						if (errorToThrow) {
							strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
							throw errorToThrow;
						}
						if (retryAfterInMs || retryAfterInMs === 0) {
							strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
							await (0, helpers_js_1.delay)(retryAfterInMs, void 0, { abortSignal: request$1.abortSignal });
							continue retryRequest;
						}
						if (redirectTo) {
							strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
							request$1.url = redirectTo;
							continue retryRequest;
						}
					}
					if (responseError) {
						logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
						throw responseError;
					}
					if (response) {
						logger.info(`None of the retry strategies could work with the received response. Returning it.`);
						return response;
					}
				}
			}
		};
	}
}));
var require_defaultRetryPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.defaultRetryPolicyName = void 0;
	exports.defaultRetryPolicy = defaultRetryPolicy;
	var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
	var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
	var retryPolicy_js_1 = require_retryPolicy$1();
	var constants_js_1 = require_constants$6();
	exports.defaultRetryPolicyName = "defaultRetryPolicy";
	function defaultRetryPolicy(options = {}) {
		return {
			name: exports.defaultRetryPolicyName,
			sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options)], { maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT }).sendRequest
		};
	}
}));
var require_checkEnvironment = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = void 0;
	exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
	exports.isWebWorker = typeof self === "object" && typeof self?.importScripts === "function" && (self.constructor?.name === "DedicatedWorkerGlobalScope" || self.constructor?.name === "ServiceWorkerGlobalScope" || self.constructor?.name === "SharedWorkerGlobalScope");
	exports.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
	exports.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
	exports.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean(globalThis.process.versions?.node);
	exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
	exports.isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
}));
var require_formDataPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.formDataPolicyName = void 0;
	exports.formDataPolicy = formDataPolicy;
	var bytesEncoding_js_1 = require_bytesEncoding();
	var checkEnvironment_js_1 = require_checkEnvironment();
	var httpHeaders_js_1 = require_httpHeaders$1();
	exports.formDataPolicyName = "formDataPolicy";
	function formDataToFormDataMap(formData) {
		const formDataMap = {};
		for (const [key, value$1] of formData.entries()) {
			formDataMap[key] ??= [];
			formDataMap[key].push(value$1);
		}
		return formDataMap;
	}
	function formDataPolicy() {
		return {
			name: exports.formDataPolicyName,
			async sendRequest(request$1, next) {
				if (checkEnvironment_js_1.isNodeLike && typeof FormData !== "undefined" && request$1.body instanceof FormData) {
					request$1.formData = formDataToFormDataMap(request$1.body);
					request$1.body = void 0;
				}
				if (request$1.formData) {
					const contentType = request$1.headers.get("Content-Type");
					if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) request$1.body = wwwFormUrlEncode(request$1.formData);
					else await prepareFormData(request$1.formData, request$1);
					request$1.formData = void 0;
				}
				return next(request$1);
			}
		};
	}
	function wwwFormUrlEncode(formData) {
		const urlSearchParams = new URLSearchParams();
		for (const [key, value$1] of Object.entries(formData)) if (Array.isArray(value$1)) for (const subValue of value$1) urlSearchParams.append(key, subValue.toString());
		else urlSearchParams.append(key, value$1.toString());
		return urlSearchParams.toString();
	}
	async function prepareFormData(formData, request$1) {
		const contentType = request$1.headers.get("Content-Type");
		if (contentType && !contentType.startsWith("multipart/form-data")) return;
		request$1.headers.set("Content-Type", contentType ?? "multipart/form-data");
		const parts = [];
		for (const [fieldName, values] of Object.entries(formData)) for (const value$1 of Array.isArray(values) ? values : [values]) if (typeof value$1 === "string") parts.push({
			headers: (0, httpHeaders_js_1.createHttpHeaders)({ "Content-Disposition": `form-data; name="${fieldName}"` }),
			body: (0, bytesEncoding_js_1.stringToUint8Array)(value$1, "utf-8")
		});
		else if (value$1 === void 0 || value$1 === null || typeof value$1 !== "object") throw new Error(`Unexpected value for key ${fieldName}: ${value$1}. Value should be serialized to string first.`);
		else {
			const fileName = value$1.name || "blob";
			const headers = (0, httpHeaders_js_1.createHttpHeaders)();
			headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
			headers.set("Content-Type", value$1.type || "application/octet-stream");
			parts.push({
				headers,
				body: value$1
			});
		}
		request$1.multipartBody = { parts };
	}
}));
var require_ms = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match$3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match$3) return;
		var n$1 = parseFloat(match$3[1]);
		switch ((match$3[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n$1 * y;
			case "weeks":
			case "week":
			case "w": return n$1 * w;
			case "days":
			case "day":
			case "d": return n$1 * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n$1 * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n$1 * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n$1 * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n$1;
			default: return;
		}
	}
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h) return Math.round(ms / h) + "h";
		if (msAbs >= m) return Math.round(ms / m) + "m";
		if (msAbs >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h) return plural(ms, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms, msAbs, s, "second");
		return ms + " ms";
	}
	function plural(ms, msAbs, n$1, name$1) {
		var isPlural = msAbs >= n$1 * 1.5;
		return Math.round(ms / n$1) + " " + name$1 + (isPlural ? "s" : "");
	}
}));
var require_common = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable$1;
		createDebug.enable = enable$1;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy;
		Object.keys(env).forEach((key) => {
			createDebug[key] = env[key];
		});
		createDebug.names = [];
		createDebug.skips = [];
		createDebug.formatters = {};
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug(...args) {
				if (!debug.enabled) return;
				const self$1 = debug;
				const curr = Number(/* @__PURE__ */ new Date());
				self$1.diff = curr - (prevTime || curr);
				self$1.prev = prevTime;
				self$1.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index$1 = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match$3, format) => {
					if (match$3 === "%%") return "%";
					index$1++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index$1];
						match$3 = formatter.call(self$1, val);
						args.splice(index$1, 1);
						index$1--;
					}
					return match$3;
				});
				createDebug.formatArgs.call(self$1, args);
				(self$1.log || createDebug.log).apply(self$1, args);
			}
			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy;
			Object.defineProperty(debug, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug);
			return debug;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		function enable$1(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		function disable$1() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		function enabled(name$1) {
			for (const skip of createDebug.skips) if (matchesTemplate(name$1, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name$1, ns)) return true;
			return false;
		}
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		function destroy() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
}));
var require_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	function useColors() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	function formatArgs(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index$1 = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match$3) => {
			if (match$3 === "%%") return;
			index$1++;
			if (match$3 === "%c") lastC = index$1;
		});
		args.splice(lastC, 0, c);
	}
	exports.log = console.debug || console.log || (() => {});
	function save(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error) {}
	}
	function load() {
		let r$1;
		try {
			r$1 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch (error) {}
		if (!r$1 && typeof process !== "undefined" && "env" in process) r$1 = process.env.DEBUG;
		return r$1;
	}
	function localstorage() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common()(exports);
	var { formatters } = module.exports;
	formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
}));
var require_node$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var tty = __require("tty");
	var util$9 = __require("util");
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util$9.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor = __require("supports-color");
		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error) {}
	exports.inspectOpts = Object.keys(process.env).filter((key) => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_$1, k) => {
			return k.toUpperCase();
		});
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
	}
	function formatArgs(args) {
		const { namespace: name$1, useColors } = this;
		if (useColors) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name$1} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name$1 + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return (/* @__PURE__ */ new Date()).toISOString() + " ";
	}
	function log(...args) {
		return process.stderr.write(util$9.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	function save(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	function load() {
		return process.env.DEBUG;
	}
	function init(debug) {
		debug.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
	module.exports = require_common()(exports);
	var { formatters } = module.exports;
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$9.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$9.inspect(v, this.inspectOpts);
	};
}));
var require_src$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module.exports = require_browser();
	else module.exports = require_node$1();
}));
var require_helpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.req = exports.json = exports.toBuffer = void 0;
	var http$1 = __importStar(__require("http"));
	var https = __importStar(__require("https"));
	async function toBuffer(stream$5) {
		let length = 0;
		const chunks = [];
		for await (const chunk of stream$5) {
			length += chunk.length;
			chunks.push(chunk);
		}
		return Buffer.concat(chunks, length);
	}
	exports.toBuffer = toBuffer;
	async function json(stream$5) {
		const str = (await toBuffer(stream$5)).toString("utf8");
		try {
			return JSON.parse(str);
		} catch (_err) {
			const err = _err;
			err.message += ` (input: ${str})`;
			throw err;
		}
	}
	exports.json = json;
	function req(url, opts = {}) {
		const req = ((typeof url === "string" ? url : url.href).startsWith("https:") ? https : http$1).request(url, opts);
		const promise = new Promise((resolve$1, reject$3) => {
			req.once("response", resolve$1).once("error", reject$3).end();
		});
		req.then = promise.then.bind(promise);
		return req;
	}
	exports.req = req;
}));
var require_dist$4 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __exportStar = exports && exports.__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Agent = void 0;
	var net$2 = __importStar(__require("net"));
	var http = __importStar(__require("http"));
	var https_1 = __require("https");
	__exportStar(require_helpers(), exports);
	var INTERNAL = Symbol("AgentBaseInternalState");
	var Agent = class extends http.Agent {
		constructor(opts) {
			super(opts);
			this[INTERNAL] = {};
		}
		isSecureEndpoint(options) {
			if (options) {
				if (typeof options.secureEndpoint === "boolean") return options.secureEndpoint;
				if (typeof options.protocol === "string") return options.protocol === "https:";
			}
			const { stack } = /* @__PURE__ */ new Error();
			if (typeof stack !== "string") return false;
			return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
		}
		incrementSockets(name$1) {
			if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) return null;
			if (!this.sockets[name$1]) this.sockets[name$1] = [];
			const fakeSocket = new net$2.Socket({ writable: false });
			this.sockets[name$1].push(fakeSocket);
			this.totalSocketCount++;
			return fakeSocket;
		}
		decrementSockets(name$1, socket) {
			if (!this.sockets[name$1] || socket === null) return;
			const sockets = this.sockets[name$1];
			const index$1 = sockets.indexOf(socket);
			if (index$1 !== -1) {
				sockets.splice(index$1, 1);
				this.totalSocketCount--;
				if (sockets.length === 0) delete this.sockets[name$1];
			}
		}
		getName(options) {
			if (this.isSecureEndpoint(options)) return https_1.Agent.prototype.getName.call(this, options);
			return super.getName(options);
		}
		createSocket(req, options, cb) {
			const connectOpts = {
				...options,
				secureEndpoint: this.isSecureEndpoint(options)
			};
			const name$1 = this.getName(connectOpts);
			const fakeSocket = this.incrementSockets(name$1);
			Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
				this.decrementSockets(name$1, fakeSocket);
				if (socket instanceof http.Agent) try {
					return socket.addRequest(req, connectOpts);
				} catch (err) {
					return cb(err);
				}
				this[INTERNAL].currentSocket = socket;
				super.createSocket(req, options, cb);
			}, (err) => {
				this.decrementSockets(name$1, fakeSocket);
				cb(err);
			});
		}
		createConnection() {
			const socket = this[INTERNAL].currentSocket;
			this[INTERNAL].currentSocket = void 0;
			if (!socket) throw new Error("No socket was returned in the `connect()` function");
			return socket;
		}
		get defaultPort() {
			return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
		}
		set defaultPort(v) {
			if (this[INTERNAL]) this[INTERNAL].defaultPort = v;
		}
		get protocol() {
			return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
		}
		set protocol(v) {
			if (this[INTERNAL]) this[INTERNAL].protocol = v;
		}
	};
	exports.Agent = Agent;
}));
var require_parse_proxy_response = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseProxyResponse = void 0;
	var debug = (0, __importDefault(require_src$1()).default)("https-proxy-agent:parse-proxy-response");
	function parseProxyResponse(socket) {
		return new Promise((resolve$1, reject$3) => {
			let buffersLength = 0;
			const buffers = [];
			function read() {
				const b = socket.read();
				if (b) ondata(b);
				else socket.once("readable", read);
			}
			function cleanup() {
				socket.removeListener("end", onend);
				socket.removeListener("error", onerror);
				socket.removeListener("readable", read);
			}
			function onend() {
				cleanup();
				debug("onend");
				reject$3(/* @__PURE__ */ new Error("Proxy connection ended before receiving CONNECT response"));
			}
			function onerror(err) {
				cleanup();
				debug("onerror %o", err);
				reject$3(err);
			}
			function ondata(b) {
				buffers.push(b);
				buffersLength += b.length;
				const buffered = Buffer.concat(buffers, buffersLength);
				const endOfHeaders = buffered.indexOf("\r\n\r\n");
				if (endOfHeaders === -1) {
					debug("have not received end of HTTP headers yet...");
					read();
					return;
				}
				const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
				const firstLine = headerParts.shift();
				if (!firstLine) {
					socket.destroy();
					return reject$3(/* @__PURE__ */ new Error("No header received from proxy CONNECT response"));
				}
				const firstLineParts = firstLine.split(" ");
				const statusCode = +firstLineParts[1];
				const statusText = firstLineParts.slice(2).join(" ");
				const headers = {};
				for (const header of headerParts) {
					if (!header) continue;
					const firstColon = header.indexOf(":");
					if (firstColon === -1) {
						socket.destroy();
						return reject$3(/* @__PURE__ */ new Error(`Invalid header from proxy CONNECT response: "${header}"`));
					}
					const key = header.slice(0, firstColon).toLowerCase();
					const value$1 = header.slice(firstColon + 1).trimStart();
					const current = headers[key];
					if (typeof current === "string") headers[key] = [current, value$1];
					else if (Array.isArray(current)) current.push(value$1);
					else headers[key] = value$1;
				}
				debug("got proxy server response: %o %o", firstLine, headers);
				cleanup();
				resolve$1({
					connect: {
						statusCode,
						statusText,
						headers
					},
					buffered
				});
			}
			socket.on("error", onerror);
			socket.on("end", onend);
			read();
		});
	}
	exports.parseProxyResponse = parseProxyResponse;
}));
var require_dist$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpsProxyAgent = void 0;
	var net$1 = __importStar(__require("net"));
	var tls$1 = __importStar(__require("tls"));
	var assert_1 = __importDefault(__require("assert"));
	var debug_1 = __importDefault(require_src$1());
	var agent_base_1 = require_dist$4();
	var url_1$1 = __require("url");
	var parse_proxy_response_1 = require_parse_proxy_response();
	var debug = (0, debug_1.default)("https-proxy-agent");
	var setServernameFromNonIpHost = (options) => {
		if (options.servername === void 0 && options.host && !net$1.isIP(options.host)) return {
			...options,
			servername: options.host
		};
		return options;
	};
	var HttpsProxyAgent = class extends agent_base_1.Agent {
		constructor(proxy, opts) {
			super(opts);
			this.options = { path: void 0 };
			this.proxy = typeof proxy === "string" ? new url_1$1.URL(proxy) : proxy;
			this.proxyHeaders = opts?.headers ?? {};
			debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
			const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
			const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
			this.connectOpts = {
				ALPNProtocols: ["http/1.1"],
				...opts ? omit(opts, "headers") : null,
				host,
				port
			};
		}
		async connect(req, opts) {
			const { proxy } = this;
			if (!opts.host) throw new TypeError("No \"host\" provided");
			let socket;
			if (proxy.protocol === "https:") {
				debug("Creating `tls.Socket`: %o", this.connectOpts);
				socket = tls$1.connect(setServernameFromNonIpHost(this.connectOpts));
			} else {
				debug("Creating `net.Socket`: %o", this.connectOpts);
				socket = net$1.connect(this.connectOpts);
			}
			const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
			const host = net$1.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
			let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
			if (proxy.username || proxy.password) {
				const auth$1 = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
				headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth$1).toString("base64")}`;
			}
			headers.Host = `${host}:${opts.port}`;
			if (!headers["Proxy-Connection"]) headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
			for (const name$1 of Object.keys(headers)) payload += `${name$1}: ${headers[name$1]}\r\n`;
			const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
			socket.write(`${payload}\r\n`);
			const { connect, buffered } = await proxyResponsePromise;
			req.emit("proxyConnect", connect);
			this.emit("proxyConnect", connect, req);
			if (connect.statusCode === 200) {
				req.once("socket", resume);
				if (opts.secureEndpoint) {
					debug("Upgrading socket connection to TLS");
					return tls$1.connect({
						...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
						socket
					});
				}
				return socket;
			}
			socket.destroy();
			const fakeSocket = new net$1.Socket({ writable: false });
			fakeSocket.readable = true;
			req.once("socket", (s) => {
				debug("Replaying proxy buffer for failed request");
				(0, assert_1.default)(s.listenerCount("data") > 0);
				s.push(buffered);
				s.push(null);
			});
			return fakeSocket;
		}
	};
	HttpsProxyAgent.protocols = ["http", "https"];
	exports.HttpsProxyAgent = HttpsProxyAgent;
	function resume(socket) {
		socket.resume();
	}
	function omit(obj, ...keys) {
		const ret = {};
		let key;
		for (key in obj) if (!keys.includes(key)) ret[key] = obj[key];
		return ret;
	}
}));
var require_dist$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpProxyAgent = void 0;
	var net = __importStar(__require("net"));
	var tls = __importStar(__require("tls"));
	var debug_1 = __importDefault(require_src$1());
	var events_1$2 = __require("events");
	var agent_base_1 = require_dist$4();
	var url_1 = __require("url");
	var debug = (0, debug_1.default)("http-proxy-agent");
	var HttpProxyAgent = class extends agent_base_1.Agent {
		constructor(proxy, opts) {
			super(opts);
			this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
			this.proxyHeaders = opts?.headers ?? {};
			debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
			const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
			const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
			this.connectOpts = {
				...opts ? omit(opts, "headers") : null,
				host,
				port
			};
		}
		addRequest(req, opts) {
			req._header = null;
			this.setRequestProps(req, opts);
			super.addRequest(req, opts);
		}
		setRequestProps(req, opts) {
			const { proxy } = this;
			const base = `${opts.secureEndpoint ? "https:" : "http:"}//${req.getHeader("host") || "localhost"}`;
			const url = new url_1.URL(req.path, base);
			if (opts.port !== 80) url.port = String(opts.port);
			req.path = String(url);
			const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
			if (proxy.username || proxy.password) {
				const auth$1 = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
				headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth$1).toString("base64")}`;
			}
			if (!headers["Proxy-Connection"]) headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
			for (const name$1 of Object.keys(headers)) {
				const value$1 = headers[name$1];
				if (value$1) req.setHeader(name$1, value$1);
			}
		}
		async connect(req, opts) {
			req._header = null;
			if (!req.path.includes("://")) this.setRequestProps(req, opts);
			let first;
			let endOfHeaders;
			debug("Regenerating stored HTTP header string for request");
			req._implicitHeader();
			if (req.outputData && req.outputData.length > 0) {
				debug("Patching connection write() output buffer with updated header");
				first = req.outputData[0].data;
				endOfHeaders = first.indexOf("\r\n\r\n") + 4;
				req.outputData[0].data = req._header + first.substring(endOfHeaders);
				debug("Output buffer: %o", req.outputData[0].data);
			}
			let socket;
			if (this.proxy.protocol === "https:") {
				debug("Creating `tls.Socket`: %o", this.connectOpts);
				socket = tls.connect(this.connectOpts);
			} else {
				debug("Creating `net.Socket`: %o", this.connectOpts);
				socket = net.connect(this.connectOpts);
			}
			await (0, events_1$2.once)(socket, "connect");
			return socket;
		}
	};
	HttpProxyAgent.protocols = ["http", "https"];
	exports.HttpProxyAgent = HttpProxyAgent;
	function omit(obj, ...keys) {
		const ret = {};
		let key;
		for (key in obj) if (!keys.includes(key)) ret[key] = obj[key];
		return ret;
	}
}));
var require_proxyPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.globalNoProxyList = exports.proxyPolicyName = void 0;
	exports.loadNoProxy = loadNoProxy;
	exports.getDefaultProxySettings = getDefaultProxySettings;
	exports.proxyPolicy = proxyPolicy;
	var https_proxy_agent_1 = require_dist$3();
	var http_proxy_agent_1 = require_dist$2();
	var log_js_1 = require_log$5();
	var HTTPS_PROXY = "HTTPS_PROXY";
	var HTTP_PROXY = "HTTP_PROXY";
	var ALL_PROXY = "ALL_PROXY";
	var NO_PROXY = "NO_PROXY";
	exports.proxyPolicyName = "proxyPolicy";
	exports.globalNoProxyList = [];
	var noProxyListLoaded = false;
	var globalBypassedMap = /* @__PURE__ */ new Map();
	function getEnvironmentValue(name$1) {
		if (process.env[name$1]) return process.env[name$1];
		else if (process.env[name$1.toLowerCase()]) return process.env[name$1.toLowerCase()];
	}
	function loadEnvironmentProxyValue() {
		if (!process) return;
		const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
		const allProxy = getEnvironmentValue(ALL_PROXY);
		const httpProxy = getEnvironmentValue(HTTP_PROXY);
		return httpsProxy || allProxy || httpProxy;
	}
	function isBypassed(uri, noProxyList, bypassedMap) {
		if (noProxyList.length === 0) return false;
		const host = new URL(uri).hostname;
		if (bypassedMap?.has(host)) return bypassedMap.get(host);
		let isBypassedFlag = false;
		for (const pattern$1 of noProxyList) if (pattern$1[0] === ".") {
			if (host.endsWith(pattern$1)) isBypassedFlag = true;
			else if (host.length === pattern$1.length - 1 && host === pattern$1.slice(1)) isBypassedFlag = true;
		} else if (host === pattern$1) isBypassedFlag = true;
		bypassedMap?.set(host, isBypassedFlag);
		return isBypassedFlag;
	}
	function loadNoProxy() {
		const noProxy = getEnvironmentValue(NO_PROXY);
		noProxyListLoaded = true;
		if (noProxy) return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
		return [];
	}
	function getDefaultProxySettings(proxyUrl) {
		if (!proxyUrl) {
			proxyUrl = loadEnvironmentProxyValue();
			if (!proxyUrl) return;
		}
		const parsedUrl = new URL(proxyUrl);
		return {
			host: (parsedUrl.protocol ? parsedUrl.protocol + "//" : "") + parsedUrl.hostname,
			port: Number.parseInt(parsedUrl.port || "80"),
			username: parsedUrl.username,
			password: parsedUrl.password
		};
	}
	function getDefaultProxySettingsInternal() {
		const envProxy = loadEnvironmentProxyValue();
		return envProxy ? new URL(envProxy) : void 0;
	}
	function getUrlFromProxySettings(settings) {
		let parsedProxyUrl;
		try {
			parsedProxyUrl = new URL(settings.host);
		} catch {
			throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
		}
		parsedProxyUrl.port = String(settings.port);
		if (settings.username) parsedProxyUrl.username = settings.username;
		if (settings.password) parsedProxyUrl.password = settings.password;
		return parsedProxyUrl;
	}
	function setProxyAgentOnRequest(request$1, cachedAgents, proxyUrl) {
		if (request$1.agent) return;
		const isInsecure = new URL(request$1.url).protocol !== "https:";
		if (request$1.tlsSettings) log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
		const headers = request$1.headers.toJSON();
		if (isInsecure) {
			if (!cachedAgents.httpProxyAgent) cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
			request$1.agent = cachedAgents.httpProxyAgent;
		} else {
			if (!cachedAgents.httpsProxyAgent) cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
			request$1.agent = cachedAgents.httpsProxyAgent;
		}
	}
	function proxyPolicy(proxySettings, options) {
		if (!noProxyListLoaded) exports.globalNoProxyList.push(...loadNoProxy());
		const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
		const cachedAgents = {};
		return {
			name: exports.proxyPolicyName,
			async sendRequest(request$1, next) {
				if (!request$1.proxySettings && defaultProxy && !isBypassed(request$1.url, options?.customNoProxyList ?? exports.globalNoProxyList, options?.customNoProxyList ? void 0 : globalBypassedMap)) setProxyAgentOnRequest(request$1, cachedAgents, defaultProxy);
				else if (request$1.proxySettings) setProxyAgentOnRequest(request$1, cachedAgents, getUrlFromProxySettings(request$1.proxySettings));
				return next(request$1);
			}
		};
	}
}));
var require_agentPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.agentPolicyName = void 0;
	exports.agentPolicy = agentPolicy;
	exports.agentPolicyName = "agentPolicy";
	function agentPolicy(agent) {
		return {
			name: exports.agentPolicyName,
			sendRequest: async (req, next) => {
				if (!req.agent) req.agent = agent;
				return next(req);
			}
		};
	}
}));
var require_tlsPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.tlsPolicyName = void 0;
	exports.tlsPolicy = tlsPolicy;
	exports.tlsPolicyName = "tlsPolicy";
	function tlsPolicy(tlsSettings) {
		return {
			name: exports.tlsPolicyName,
			sendRequest: async (req, next) => {
				if (!req.tlsSettings) req.tlsSettings = tlsSettings;
				return next(req);
			}
		};
	}
}));
var require_typeGuards$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isNodeReadableStream = isNodeReadableStream;
	exports.isWebReadableStream = isWebReadableStream;
	exports.isBinaryBody = isBinaryBody;
	exports.isReadableStream = isReadableStream;
	exports.isBlob = isBlob;
	function isNodeReadableStream(x) {
		return Boolean(x && typeof x["pipe"] === "function");
	}
	function isWebReadableStream(x) {
		return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
	}
	function isBinaryBody(body) {
		return body !== void 0 && (body instanceof Uint8Array || isReadableStream(body) || typeof body === "function" || body instanceof Blob);
	}
	function isReadableStream(x) {
		return isNodeReadableStream(x) || isWebReadableStream(x);
	}
	function isBlob(x) {
		return typeof x.stream === "function";
	}
}));
var require_concat = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.concat = concat;
	var stream_1 = __require("stream");
	var typeGuards_js_1 = require_typeGuards$1();
	async function* streamAsyncIterator() {
		const reader = this.getReader();
		try {
			while (true) {
				const { done, value: value$1 } = await reader.read();
				if (done) return;
				yield value$1;
			}
		} finally {
			reader.releaseLock();
		}
	}
	function makeAsyncIterable(webStream) {
		if (!webStream[Symbol.asyncIterator]) webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
		if (!webStream.values) webStream.values = streamAsyncIterator.bind(webStream);
	}
	function ensureNodeStream(stream$5) {
		if (stream$5 instanceof ReadableStream) {
			makeAsyncIterable(stream$5);
			return stream_1.Readable.fromWeb(stream$5);
		} else return stream$5;
	}
	function toStream(source) {
		if (source instanceof Uint8Array) return stream_1.Readable.from(Buffer.from(source));
		else if ((0, typeGuards_js_1.isBlob)(source)) return ensureNodeStream(source.stream());
		else return ensureNodeStream(source);
	}
	async function concat(sources) {
		return function() {
			const streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
			return stream_1.Readable.from((async function* () {
				for (const stream$5 of streams) for await (const chunk of stream$5) yield chunk;
			})());
		};
	}
}));
var require_multipartPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.multipartPolicyName = void 0;
	exports.multipartPolicy = multipartPolicy;
	var bytesEncoding_js_1 = require_bytesEncoding();
	var typeGuards_js_1 = require_typeGuards$1();
	var uuidUtils_js_1 = require_uuidUtils();
	var concat_js_1 = require_concat();
	function generateBoundary() {
		return `----AzSDKFormBoundary${(0, uuidUtils_js_1.randomUUID)()}`;
	}
	function encodeHeaders(headers) {
		let result = "";
		for (const [key, value$1] of headers) result += `${key}: ${value$1}\r\n`;
		return result;
	}
	function getLength(source) {
		if (source instanceof Uint8Array) return source.byteLength;
		else if ((0, typeGuards_js_1.isBlob)(source)) return source.size === -1 ? void 0 : source.size;
		else return;
	}
	function getTotalLength(sources) {
		let total = 0;
		for (const source of sources) {
			const partLength = getLength(source);
			if (partLength === void 0) return;
			else total += partLength;
		}
		return total;
	}
	async function buildRequestBody(request$1, parts, boundary) {
		const sources = [
			(0, bytesEncoding_js_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
			...parts.flatMap((part) => [
				(0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
				(0, bytesEncoding_js_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
				(0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
				part.body,
				(0, bytesEncoding_js_1.stringToUint8Array)(`\r\n--${boundary}`, "utf-8")
			]),
			(0, bytesEncoding_js_1.stringToUint8Array)("--\r\n\r\n", "utf-8")
		];
		const contentLength = getTotalLength(sources);
		if (contentLength) request$1.headers.set("Content-Length", contentLength);
		request$1.body = await (0, concat_js_1.concat)(sources);
	}
	exports.multipartPolicyName = "multipartPolicy";
	var maxBoundaryLength = 70;
	var validBoundaryCharacters = /* @__PURE__ */ new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
	function assertValidBoundary(boundary) {
		if (boundary.length > maxBoundaryLength) throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
		if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
	}
	function multipartPolicy() {
		return {
			name: exports.multipartPolicyName,
			async sendRequest(request$1, next) {
				if (!request$1.multipartBody) return next(request$1);
				if (request$1.body) throw new Error("multipartBody and regular body cannot be set at the same time");
				let boundary = request$1.multipartBody.boundary;
				const contentTypeHeader = request$1.headers.get("Content-Type") ?? "multipart/mixed";
				const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
				if (!parsedHeader) throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
				const [, contentType, parsedBoundary] = parsedHeader;
				if (parsedBoundary && boundary && parsedBoundary !== boundary) throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
				boundary ??= parsedBoundary;
				if (boundary) assertValidBoundary(boundary);
				else boundary = generateBoundary();
				request$1.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
				await buildRequestBody(request$1, request$1.multipartBody.parts, boundary);
				request$1.multipartBody = void 0;
				return next(request$1);
			}
		};
	}
}));
var require_createPipelineFromOptions$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createPipelineFromOptions = createPipelineFromOptions;
	var logPolicy_js_1 = require_logPolicy$1();
	var pipeline_js_1 = require_pipeline$3();
	var redirectPolicy_js_1 = require_redirectPolicy$1();
	var userAgentPolicy_js_1 = require_userAgentPolicy$1();
	var decompressResponsePolicy_js_1 = require_decompressResponsePolicy$1();
	var defaultRetryPolicy_js_1 = require_defaultRetryPolicy$1();
	var formDataPolicy_js_1 = require_formDataPolicy$1();
	var checkEnvironment_js_1 = require_checkEnvironment();
	var proxyPolicy_js_1 = require_proxyPolicy$1();
	var agentPolicy_js_1 = require_agentPolicy$1();
	var tlsPolicy_js_1 = require_tlsPolicy$1();
	var multipartPolicy_js_1 = require_multipartPolicy$1();
	function createPipelineFromOptions(options) {
		const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
		if (checkEnvironment_js_1.isNodeLike) {
			if (options.agent) pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
			if (options.tlsOptions) pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
			pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
			pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
		}
		pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
		pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
		pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
		pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
		if (checkEnvironment_js_1.isNodeLike) pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
		pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
		return pipeline;
	}
}));
var require_apiVersionPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.apiVersionPolicyName = void 0;
	exports.apiVersionPolicy = apiVersionPolicy;
	exports.apiVersionPolicyName = "ApiVersionPolicy";
	function apiVersionPolicy(options) {
		return {
			name: exports.apiVersionPolicyName,
			sendRequest: (req, next) => {
				const url = new URL(req.url);
				if (!url.searchParams.get("api-version") && options.apiVersion) req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
				return next(req);
			}
		};
	}
}));
var require_credentials = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isOAuth2TokenCredential = isOAuth2TokenCredential;
	exports.isBearerTokenCredential = isBearerTokenCredential;
	exports.isBasicCredential = isBasicCredential;
	exports.isApiKeyCredential = isApiKeyCredential;
	function isOAuth2TokenCredential(credential) {
		return "getOAuth2Token" in credential;
	}
	function isBearerTokenCredential(credential) {
		return "getBearerToken" in credential;
	}
	function isBasicCredential(credential) {
		return "username" in credential && "password" in credential;
	}
	function isApiKeyCredential(credential) {
		return "key" in credential;
	}
}));
var require_checkInsecureConnection = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ensureSecureConnection = ensureSecureConnection;
	var log_js_1 = require_log$5();
	var insecureConnectionWarningEmmitted = false;
	function allowInsecureConnection(request$1, options) {
		if (options.allowInsecureConnection && request$1.allowInsecureConnection) {
			const url = new URL(request$1.url);
			if (url.hostname === "localhost" || url.hostname === "127.0.0.1") return true;
		}
		return false;
	}
	function emitInsecureConnectionWarning() {
		const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
		log_js_1.logger.warning(warning);
		if (typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted) {
			insecureConnectionWarningEmmitted = true;
			process.emitWarning(warning);
		}
	}
	function ensureSecureConnection(request$1, options) {
		if (!request$1.url.toLowerCase().startsWith("https://")) if (allowInsecureConnection(request$1, options)) emitInsecureConnectionWarning();
		else throw new Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
	}
}));
var require_apiKeyAuthenticationPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.apiKeyAuthenticationPolicyName = void 0;
	exports.apiKeyAuthenticationPolicy = apiKeyAuthenticationPolicy;
	var checkInsecureConnection_js_1 = require_checkInsecureConnection();
	exports.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
	function apiKeyAuthenticationPolicy(options) {
		return {
			name: exports.apiKeyAuthenticationPolicyName,
			async sendRequest(request$1, next) {
				(0, checkInsecureConnection_js_1.ensureSecureConnection)(request$1, options);
				const scheme = (request$1.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "apiKey");
				if (!scheme) return next(request$1);
				if (scheme.apiKeyLocation !== "header") throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
				request$1.headers.set(scheme.name, options.credential.key);
				return next(request$1);
			}
		};
	}
}));
var require_basicAuthenticationPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.basicAuthenticationPolicyName = void 0;
	exports.basicAuthenticationPolicy = basicAuthenticationPolicy;
	var bytesEncoding_js_1 = require_bytesEncoding();
	var checkInsecureConnection_js_1 = require_checkInsecureConnection();
	exports.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
	function basicAuthenticationPolicy(options) {
		return {
			name: exports.basicAuthenticationPolicyName,
			async sendRequest(request$1, next) {
				(0, checkInsecureConnection_js_1.ensureSecureConnection)(request$1, options);
				if (!(request$1.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "basic")) return next(request$1);
				const { username, password } = options.credential;
				const headerValue = (0, bytesEncoding_js_1.uint8ArrayToString)((0, bytesEncoding_js_1.stringToUint8Array)(`${username}:${password}`, "utf-8"), "base64");
				request$1.headers.set("Authorization", `Basic ${headerValue}`);
				return next(request$1);
			}
		};
	}
}));
var require_bearerAuthenticationPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.bearerAuthenticationPolicyName = void 0;
	exports.bearerAuthenticationPolicy = bearerAuthenticationPolicy;
	var checkInsecureConnection_js_1 = require_checkInsecureConnection();
	exports.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
	function bearerAuthenticationPolicy(options) {
		return {
			name: exports.bearerAuthenticationPolicyName,
			async sendRequest(request$1, next) {
				(0, checkInsecureConnection_js_1.ensureSecureConnection)(request$1, options);
				if (!(request$1.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "bearer")) return next(request$1);
				const token = await options.credential.getBearerToken({ abortSignal: request$1.abortSignal });
				request$1.headers.set("Authorization", `Bearer ${token}`);
				return next(request$1);
			}
		};
	}
}));
var require_oauth2AuthenticationPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.oauth2AuthenticationPolicyName = void 0;
	exports.oauth2AuthenticationPolicy = oauth2AuthenticationPolicy;
	var checkInsecureConnection_js_1 = require_checkInsecureConnection();
	exports.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
	function oauth2AuthenticationPolicy(options) {
		return {
			name: exports.oauth2AuthenticationPolicyName,
			async sendRequest(request$1, next) {
				(0, checkInsecureConnection_js_1.ensureSecureConnection)(request$1, options);
				const scheme = (request$1.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "oauth2");
				if (!scheme) return next(request$1);
				const token = await options.credential.getOAuth2Token(scheme.flows, { abortSignal: request$1.abortSignal });
				request$1.headers.set("Authorization", `Bearer ${token}`);
				return next(request$1);
			}
		};
	}
}));
var require_clientHelpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createDefaultPipeline = createDefaultPipeline;
	exports.getCachedDefaultHttpsClient = getCachedDefaultHttpsClient;
	var defaultHttpClient_js_1 = require_defaultHttpClient$1();
	var createPipelineFromOptions_js_1 = require_createPipelineFromOptions$1();
	var apiVersionPolicy_js_1 = require_apiVersionPolicy();
	var credentials_js_1 = require_credentials();
	var apiKeyAuthenticationPolicy_js_1 = require_apiKeyAuthenticationPolicy();
	var basicAuthenticationPolicy_js_1 = require_basicAuthenticationPolicy();
	var bearerAuthenticationPolicy_js_1 = require_bearerAuthenticationPolicy();
	var oauth2AuthenticationPolicy_js_1 = require_oauth2AuthenticationPolicy();
	var cachedHttpClient;
	function createDefaultPipeline(options = {}) {
		const pipeline = (0, createPipelineFromOptions_js_1.createPipelineFromOptions)(options);
		pipeline.addPolicy((0, apiVersionPolicy_js_1.apiVersionPolicy)(options));
		const { credential, authSchemes, allowInsecureConnection } = options;
		if (credential) {
			if ((0, credentials_js_1.isApiKeyCredential)(credential)) pipeline.addPolicy((0, apiKeyAuthenticationPolicy_js_1.apiKeyAuthenticationPolicy)({
				authSchemes,
				credential,
				allowInsecureConnection
			}));
			else if ((0, credentials_js_1.isBasicCredential)(credential)) pipeline.addPolicy((0, basicAuthenticationPolicy_js_1.basicAuthenticationPolicy)({
				authSchemes,
				credential,
				allowInsecureConnection
			}));
			else if ((0, credentials_js_1.isBearerTokenCredential)(credential)) pipeline.addPolicy((0, bearerAuthenticationPolicy_js_1.bearerAuthenticationPolicy)({
				authSchemes,
				credential,
				allowInsecureConnection
			}));
			else if ((0, credentials_js_1.isOAuth2TokenCredential)(credential)) pipeline.addPolicy((0, oauth2AuthenticationPolicy_js_1.oauth2AuthenticationPolicy)({
				authSchemes,
				credential,
				allowInsecureConnection
			}));
		}
		return pipeline;
	}
	function getCachedDefaultHttpsClient() {
		if (!cachedHttpClient) cachedHttpClient = (0, defaultHttpClient_js_1.createDefaultHttpClient)();
		return cachedHttpClient;
	}
}));
var require_multipart = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.buildBodyPart = buildBodyPart;
	exports.buildMultipartBody = buildMultipartBody;
	var restError_js_1 = require_restError$2();
	var httpHeaders_js_1 = require_httpHeaders$1();
	var bytesEncoding_js_1 = require_bytesEncoding();
	var typeGuards_js_1 = require_typeGuards$1();
	function getHeaderValue(descriptor, headerName) {
		if (descriptor.headers) {
			const actualHeaderName = Object.keys(descriptor.headers).find((x) => x.toLowerCase() === headerName.toLowerCase());
			if (actualHeaderName) return descriptor.headers[actualHeaderName];
		}
	}
	function getPartContentType(descriptor) {
		const contentTypeHeader = getHeaderValue(descriptor, "content-type");
		if (contentTypeHeader) return contentTypeHeader;
		if (descriptor.contentType === null) return;
		if (descriptor.contentType) return descriptor.contentType;
		const { body } = descriptor;
		if (body === null || body === void 0) return;
		if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") return "text/plain; charset=UTF-8";
		if (body instanceof Blob) return body.type || "application/octet-stream";
		if ((0, typeGuards_js_1.isBinaryBody)(body)) return "application/octet-stream";
		return "application/json";
	}
	function escapeDispositionField(value$1) {
		return JSON.stringify(value$1);
	}
	function getContentDisposition(descriptor) {
		const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
		if (contentDispositionHeader) return contentDispositionHeader;
		if (descriptor.dispositionType === void 0 && descriptor.name === void 0 && descriptor.filename === void 0) return;
		let disposition = descriptor.dispositionType ?? "form-data";
		if (descriptor.name) disposition += `; name=${escapeDispositionField(descriptor.name)}`;
		let filename = void 0;
		if (descriptor.filename) filename = descriptor.filename;
		else if (typeof File !== "undefined" && descriptor.body instanceof File) {
			const filenameFromFile = descriptor.body.name;
			if (filenameFromFile !== "") filename = filenameFromFile;
		}
		if (filename) disposition += `; filename=${escapeDispositionField(filename)}`;
		return disposition;
	}
	function normalizeBody(body, contentType) {
		if (body === void 0) return new Uint8Array([]);
		if ((0, typeGuards_js_1.isBinaryBody)(body)) return body;
		if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") return (0, bytesEncoding_js_1.stringToUint8Array)(String(body), "utf-8");
		if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) return (0, bytesEncoding_js_1.stringToUint8Array)(JSON.stringify(body), "utf-8");
		throw new restError_js_1.RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
	}
	function buildBodyPart(descriptor) {
		const contentType = getPartContentType(descriptor);
		const contentDisposition = getContentDisposition(descriptor);
		const headers = (0, httpHeaders_js_1.createHttpHeaders)(descriptor.headers ?? {});
		if (contentType) headers.set("content-type", contentType);
		if (contentDisposition) headers.set("content-disposition", contentDisposition);
		return {
			headers,
			body: normalizeBody(descriptor.body, contentType)
		};
	}
	function buildMultipartBody(parts) {
		return { parts: parts.map(buildBodyPart) };
	}
}));
var require_sendRequest = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sendRequest = sendRequest;
	var restError_js_1 = require_restError$2();
	var httpHeaders_js_1 = require_httpHeaders$1();
	var pipelineRequest_js_1 = require_pipelineRequest$1();
	var clientHelpers_js_1 = require_clientHelpers();
	var typeGuards_js_1 = require_typeGuards$1();
	var multipart_js_1 = require_multipart();
	async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
		const httpClient = customHttpClient ?? (0, clientHelpers_js_1.getCachedDefaultHttpsClient)();
		const request$1 = buildPipelineRequest(method, url, options);
		try {
			const response = await pipeline.sendRequest(httpClient, request$1);
			const headers = response.headers.toJSON();
			const stream$5 = response.readableStreamBody ?? response.browserStreamBody;
			const parsedBody = options.responseAsStream || stream$5 !== void 0 ? void 0 : getResponseBody(response);
			const body = stream$5 ?? parsedBody;
			if (options?.onResponse) options.onResponse({
				...response,
				request: request$1,
				rawHeaders: headers,
				parsedBody
			});
			return {
				request: request$1,
				headers,
				status: `${response.status}`,
				body
			};
		} catch (e$1) {
			if ((0, restError_js_1.isRestError)(e$1) && e$1.response && options.onResponse) {
				const { response } = e$1;
				const rawHeaders = response.headers.toJSON();
				options?.onResponse({
					...response,
					request: request$1,
					rawHeaders
				}, e$1);
			}
			throw e$1;
		}
	}
	function getRequestContentType(options = {}) {
		return options.contentType ?? options.headers?.["content-type"] ?? getContentType(options.body);
	}
	function getContentType(body) {
		if (ArrayBuffer.isView(body)) return "application/octet-stream";
		if (typeof body === "string") try {
			JSON.parse(body);
			return "application/json";
		} catch (error) {
			return;
		}
		return "application/json";
	}
	function buildPipelineRequest(method, url, options = {}) {
		const requestContentType = getRequestContentType(options);
		const { body, multipartBody } = getRequestBody(options.body, requestContentType);
		const hasContent = body !== void 0 || multipartBody !== void 0;
		const headers = (0, httpHeaders_js_1.createHttpHeaders)({
			...options.headers ? options.headers : {},
			accept: options.accept ?? options.headers?.accept ?? "application/json",
			...hasContent && requestContentType && { "content-type": requestContentType }
		});
		return (0, pipelineRequest_js_1.createPipelineRequest)({
			url,
			method,
			body,
			multipartBody,
			headers,
			allowInsecureConnection: options.allowInsecureConnection,
			abortSignal: options.abortSignal,
			onUploadProgress: options.onUploadProgress,
			onDownloadProgress: options.onDownloadProgress,
			timeout: options.timeout,
			enableBrowserStreams: true,
			streamResponseStatusCodes: options.responseAsStream ? new Set([Number.POSITIVE_INFINITY]) : void 0
		});
	}
	function getRequestBody(body, contentType = "") {
		if (body === void 0) return { body: void 0 };
		if (typeof FormData !== "undefined" && body instanceof FormData) return { body };
		if ((0, typeGuards_js_1.isReadableStream)(body)) return { body };
		if (ArrayBuffer.isView(body)) return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
		switch (contentType.split(";")[0]) {
			case "application/json": return { body: JSON.stringify(body) };
			case "multipart/form-data":
				if (Array.isArray(body)) return { multipartBody: (0, multipart_js_1.buildMultipartBody)(body) };
				return { body: JSON.stringify(body) };
			case "text/plain": return { body: String(body) };
			default:
				if (typeof body === "string") return { body };
				return { body: JSON.stringify(body) };
		}
	}
	function getResponseBody(response) {
		const firstType = (response.headers.get("content-type") ?? "").split(";")[0];
		const bodyToParse = response.bodyAsText ?? "";
		if (firstType === "text/plain") return String(bodyToParse);
		try {
			return bodyToParse ? JSON.parse(bodyToParse) : void 0;
		} catch (error) {
			if (firstType === "application/json") throw createParseError(response, error);
			return String(bodyToParse);
		}
	}
	function createParseError(response, err) {
		const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
		const errCode = err.code ?? restError_js_1.RestError.PARSE_ERROR;
		return new restError_js_1.RestError(msg, {
			code: errCode,
			statusCode: response.status,
			request: response.request,
			response
		});
	}
}));
var require_urlHelpers$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.buildRequestUrl = buildRequestUrl;
	exports.buildBaseUrl = buildBaseUrl;
	exports.replaceAll = replaceAll;
	function isQueryParameterWithOptions(x) {
		const value$1 = x.value;
		return value$1 !== void 0 && value$1.toString !== void 0 && typeof value$1.toString === "function";
	}
	function buildRequestUrl(endpoint$1, routePath, pathParameters, options = {}) {
		if (routePath.startsWith("https://") || routePath.startsWith("http://")) return routePath;
		endpoint$1 = buildBaseUrl(endpoint$1, options);
		routePath = buildRoutePath(routePath, pathParameters, options);
		const requestUrl = appendQueryParams(`${endpoint$1}/${routePath}`, options);
		return new URL(requestUrl).toString().replace(/([^:]\/)\/+/g, "$1");
	}
	function getQueryParamValue(key, allowReserved, style, param) {
		let separator;
		if (style === "pipeDelimited") separator = "|";
		else if (style === "spaceDelimited") separator = "%20";
		else separator = ",";
		let paramValues;
		if (Array.isArray(param)) paramValues = param;
		else if (typeof param === "object" && param.toString === Object.prototype.toString) paramValues = Object.entries(param).flat();
		else paramValues = [param];
		const value$1 = paramValues.map((p) => {
			if (p === null || p === void 0) return "";
			if (!p.toString || typeof p.toString !== "function") throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
			const rawValue = p.toISOString !== void 0 ? p.toISOString() : p.toString();
			return allowReserved ? rawValue : encodeURIComponent(rawValue);
		}).join(separator);
		return `${allowReserved ? key : encodeURIComponent(key)}=${value$1}`;
	}
	function appendQueryParams(url, options = {}) {
		if (!options.queryParameters) return url;
		const parsedUrl = new URL(url);
		const queryParams = options.queryParameters;
		const paramStrings = [];
		for (const key of Object.keys(queryParams)) {
			const param = queryParams[key];
			if (param === void 0 || param === null) continue;
			const hasMetadata = isQueryParameterWithOptions(param);
			const rawValue = hasMetadata ? param.value : param;
			const explode = hasMetadata ? param.explode ?? false : false;
			const style = hasMetadata && param.style ? param.style : "form";
			if (explode) if (Array.isArray(rawValue)) for (const item of rawValue) paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, item));
			else if (typeof rawValue === "object") for (const [actualKey, value$1] of Object.entries(rawValue)) paramStrings.push(getQueryParamValue(actualKey, options.skipUrlEncoding ?? false, style, value$1));
			else throw new Error("explode can only be set to true for objects and arrays");
			else paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, rawValue));
		}
		if (parsedUrl.search !== "") parsedUrl.search += "&";
		parsedUrl.search += paramStrings.join("&");
		return parsedUrl.toString();
	}
	function buildBaseUrl(endpoint$1, options) {
		if (!options.pathParameters) return endpoint$1;
		const pathParams = options.pathParameters;
		for (const [key, param] of Object.entries(pathParams)) {
			if (param === void 0 || param === null) throw new Error(`Path parameters ${key} must not be undefined or null`);
			if (!param.toString || typeof param.toString !== "function") throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
			let value$1 = param.toISOString !== void 0 ? param.toISOString() : String(param);
			if (!options.skipUrlEncoding) value$1 = encodeURIComponent(param);
			endpoint$1 = replaceAll(endpoint$1, `{${key}}`, value$1) ?? "";
		}
		return endpoint$1;
	}
	function buildRoutePath(routePath, pathParameters, options = {}) {
		for (const pathParam of pathParameters) {
			const allowReserved = typeof pathParam === "object" && (pathParam.allowReserved ?? false);
			let value$1 = typeof pathParam === "object" ? pathParam.value : pathParam;
			if (!options.skipUrlEncoding && !allowReserved) value$1 = encodeURIComponent(value$1);
			routePath = routePath.replace(/\{[\w-]+\}/, String(value$1));
		}
		return routePath;
	}
	function replaceAll(value$1, searchValue, replaceValue) {
		return !value$1 || !searchValue ? value$1 : value$1.split(searchValue).join(replaceValue || "");
	}
}));
var require_getClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getClient = getClient;
	var clientHelpers_js_1 = require_clientHelpers();
	var sendRequest_js_1 = require_sendRequest();
	var urlHelpers_js_1 = require_urlHelpers$1();
	var checkEnvironment_js_1 = require_checkEnvironment();
	function getClient(endpoint$1, clientOptions = {}) {
		const pipeline = clientOptions.pipeline ?? (0, clientHelpers_js_1.createDefaultPipeline)(clientOptions);
		if (clientOptions.additionalPolicies?.length) for (const { policy, position } of clientOptions.additionalPolicies) {
			const afterPhase = position === "perRetry" ? "Sign" : void 0;
			pipeline.addPolicy(policy, { afterPhase });
		}
		const { allowInsecureConnection, httpClient } = clientOptions;
		const endpointUrl = clientOptions.endpoint ?? endpoint$1;
		const client = (path$5, ...args) => {
			const getUrl = (requestOptions) => (0, urlHelpers_js_1.buildRequestUrl)(endpointUrl, path$5, args, {
				allowInsecureConnection,
				...requestOptions
			});
			return {
				get: (requestOptions = {}) => {
					return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
				},
				post: (requestOptions = {}) => {
					return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
				},
				put: (requestOptions = {}) => {
					return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
				},
				patch: (requestOptions = {}) => {
					return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
				},
				delete: (requestOptions = {}) => {
					return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
				},
				head: (requestOptions = {}) => {
					return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
				},
				options: (requestOptions = {}) => {
					return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
				},
				trace: (requestOptions = {}) => {
					return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
				}
			};
		};
		return {
			path: client,
			pathUnchecked: client,
			pipeline
		};
	}
	function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
		allowInsecureConnection = options.allowInsecureConnection ?? allowInsecureConnection;
		return {
			then: function(onFulfilled, onrejected) {
				return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, {
					...options,
					allowInsecureConnection
				}, httpClient).then(onFulfilled, onrejected);
			},
			async asBrowserStream() {
				if (checkEnvironment_js_1.isNodeLike) throw new Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
				else return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, {
					...options,
					allowInsecureConnection,
					responseAsStream: true
				}, httpClient);
			},
			async asNodeStream() {
				if (checkEnvironment_js_1.isNodeLike) return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, {
					...options,
					allowInsecureConnection,
					responseAsStream: true
				}, httpClient);
				else throw new Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
			}
		};
	}
}));
var require_operationOptionHelpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.operationOptionsToRequestParameters = operationOptionsToRequestParameters;
	function operationOptionsToRequestParameters(options) {
		return {
			allowInsecureConnection: options.requestOptions?.allowInsecureConnection,
			timeout: options.requestOptions?.timeout,
			skipUrlEncoding: options.requestOptions?.skipUrlEncoding,
			abortSignal: options.abortSignal,
			onUploadProgress: options.requestOptions?.onUploadProgress,
			onDownloadProgress: options.requestOptions?.onDownloadProgress,
			headers: { ...options.requestOptions?.headers },
			onResponse: options.onResponse
		};
	}
}));
var require_restError$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createRestError = createRestError;
	var restError_js_1 = require_restError$2();
	var httpHeaders_js_1 = require_httpHeaders$1();
	function createRestError(messageOrResponse, response) {
		const resp = typeof messageOrResponse === "string" ? response : messageOrResponse;
		const internalError = resp.body?.error ?? resp.body;
		const message = typeof messageOrResponse === "string" ? messageOrResponse : internalError?.message ?? `Unexpected status code: ${resp.status}`;
		return new restError_js_1.RestError(message, {
			statusCode: statusCodeToNumber(resp.status),
			code: internalError?.code,
			request: resp.request,
			response: toPipelineResponse(resp)
		});
	}
	function toPipelineResponse(response) {
		return {
			headers: (0, httpHeaders_js_1.createHttpHeaders)(response.headers),
			request: response.request,
			status: statusCodeToNumber(response.status) ?? -1
		};
	}
	function statusCodeToNumber(statusCode) {
		const status = Number.parseInt(statusCode);
		return Number.isNaN(status) ? void 0 : status;
	}
}));
var require_commonjs$17 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createRestError = exports.operationOptionsToRequestParameters = exports.getClient = exports.createDefaultHttpClient = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isRestError = exports.RestError = exports.createEmptyPipeline = exports.createPipelineRequest = exports.createHttpHeaders = exports.TypeSpecRuntimeLogger = exports.setLogLevel = exports.getLogLevel = exports.createClientLogger = exports.AbortError = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var AbortError_js_1 = require_AbortError$1();
	Object.defineProperty(exports, "AbortError", {
		enumerable: true,
		get: function() {
			return AbortError_js_1.AbortError;
		}
	});
	var logger_js_1 = require_logger$1();
	Object.defineProperty(exports, "createClientLogger", {
		enumerable: true,
		get: function() {
			return logger_js_1.createClientLogger;
		}
	});
	Object.defineProperty(exports, "getLogLevel", {
		enumerable: true,
		get: function() {
			return logger_js_1.getLogLevel;
		}
	});
	Object.defineProperty(exports, "setLogLevel", {
		enumerable: true,
		get: function() {
			return logger_js_1.setLogLevel;
		}
	});
	Object.defineProperty(exports, "TypeSpecRuntimeLogger", {
		enumerable: true,
		get: function() {
			return logger_js_1.TypeSpecRuntimeLogger;
		}
	});
	var httpHeaders_js_1 = require_httpHeaders$1();
	Object.defineProperty(exports, "createHttpHeaders", {
		enumerable: true,
		get: function() {
			return httpHeaders_js_1.createHttpHeaders;
		}
	});
	tslib_1.__exportStar(require_schemes(), exports);
	tslib_1.__exportStar(require_oauth2Flows(), exports);
	var pipelineRequest_js_1 = require_pipelineRequest$1();
	Object.defineProperty(exports, "createPipelineRequest", {
		enumerable: true,
		get: function() {
			return pipelineRequest_js_1.createPipelineRequest;
		}
	});
	var pipeline_js_1 = require_pipeline$3();
	Object.defineProperty(exports, "createEmptyPipeline", {
		enumerable: true,
		get: function() {
			return pipeline_js_1.createEmptyPipeline;
		}
	});
	var restError_js_1 = require_restError$2();
	Object.defineProperty(exports, "RestError", {
		enumerable: true,
		get: function() {
			return restError_js_1.RestError;
		}
	});
	Object.defineProperty(exports, "isRestError", {
		enumerable: true,
		get: function() {
			return restError_js_1.isRestError;
		}
	});
	var bytesEncoding_js_1 = require_bytesEncoding();
	Object.defineProperty(exports, "stringToUint8Array", {
		enumerable: true,
		get: function() {
			return bytesEncoding_js_1.stringToUint8Array;
		}
	});
	Object.defineProperty(exports, "uint8ArrayToString", {
		enumerable: true,
		get: function() {
			return bytesEncoding_js_1.uint8ArrayToString;
		}
	});
	var defaultHttpClient_js_1 = require_defaultHttpClient$1();
	Object.defineProperty(exports, "createDefaultHttpClient", {
		enumerable: true,
		get: function() {
			return defaultHttpClient_js_1.createDefaultHttpClient;
		}
	});
	var getClient_js_1 = require_getClient();
	Object.defineProperty(exports, "getClient", {
		enumerable: true,
		get: function() {
			return getClient_js_1.getClient;
		}
	});
	var operationOptionHelpers_js_1 = require_operationOptionHelpers();
	Object.defineProperty(exports, "operationOptionsToRequestParameters", {
		enumerable: true,
		get: function() {
			return operationOptionHelpers_js_1.operationOptionsToRequestParameters;
		}
	});
	var restError_js_2 = require_restError$1();
	Object.defineProperty(exports, "createRestError", {
		enumerable: true,
		get: function() {
			return restError_js_2.createRestError;
		}
	});
}));
var require_pipeline$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createEmptyPipeline = createEmptyPipeline;
	var ts_http_runtime_1 = require_commonjs$17();
	function createEmptyPipeline() {
		return (0, ts_http_runtime_1.createEmptyPipeline)();
	}
}));
var require_internal$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createLoggerContext = void 0;
	var logger_js_1 = require_logger$1();
	Object.defineProperty(exports, "createLoggerContext", {
		enumerable: true,
		get: function() {
			return logger_js_1.createLoggerContext;
		}
	});
}));
var require_commonjs$16 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AzureLogger = void 0;
	exports.setLogLevel = setLogLevel;
	exports.getLogLevel = getLogLevel;
	exports.createClientLogger = createClientLogger;
	var context = (0, require_internal$2().createLoggerContext)({
		logLevelEnvVarName: "AZURE_LOG_LEVEL",
		namespace: "azure"
	});
	exports.AzureLogger = context.logger;
	function setLogLevel(level) {
		context.setLogLevel(level);
	}
	function getLogLevel() {
		return context.getLogLevel();
	}
	function createClientLogger(namespace) {
		return context.createClientLogger(namespace);
	}
}));
var require_log$4 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logger = void 0;
	exports.logger = (0, require_commonjs$16().createClientLogger)("core-rest-pipeline");
}));
var require_exponentialRetryPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.exponentialRetryPolicyName = void 0;
	exports.exponentialRetryPolicy = exponentialRetryPolicy;
	var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
	var retryPolicy_js_1 = require_retryPolicy$1();
	var constants_js_1 = require_constants$6();
	exports.exponentialRetryPolicyName = "exponentialRetryPolicy";
	function exponentialRetryPolicy(options = {}) {
		return (0, retryPolicy_js_1.retryPolicy)([(0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
			...options,
			ignoreSystemErrors: true
		})], { maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT });
	}
}));
var require_systemErrorRetryPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.systemErrorRetryPolicyName = void 0;
	exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
	var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
	var retryPolicy_js_1 = require_retryPolicy$1();
	var constants_js_1 = require_constants$6();
	exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
	function systemErrorRetryPolicy(options = {}) {
		return {
			name: exports.systemErrorRetryPolicyName,
			sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
				...options,
				ignoreHttpStatusCodes: true
			})], { maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT }).sendRequest
		};
	}
}));
var require_throttlingRetryPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.throttlingRetryPolicyName = void 0;
	exports.throttlingRetryPolicy = throttlingRetryPolicy;
	var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
	var retryPolicy_js_1 = require_retryPolicy$1();
	var constants_js_1 = require_constants$6();
	exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
	function throttlingRetryPolicy(options = {}) {
		return {
			name: exports.throttlingRetryPolicyName,
			sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], { maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT }).sendRequest
		};
	}
}));
var require_internal$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.userAgentPolicyName = exports.userAgentPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.retryPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.defaultRetryPolicyName = exports.defaultRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.agentPolicyName = exports.agentPolicy = void 0;
	var agentPolicy_js_1 = require_agentPolicy$1();
	Object.defineProperty(exports, "agentPolicy", {
		enumerable: true,
		get: function() {
			return agentPolicy_js_1.agentPolicy;
		}
	});
	Object.defineProperty(exports, "agentPolicyName", {
		enumerable: true,
		get: function() {
			return agentPolicy_js_1.agentPolicyName;
		}
	});
	var decompressResponsePolicy_js_1 = require_decompressResponsePolicy$1();
	Object.defineProperty(exports, "decompressResponsePolicy", {
		enumerable: true,
		get: function() {
			return decompressResponsePolicy_js_1.decompressResponsePolicy;
		}
	});
	Object.defineProperty(exports, "decompressResponsePolicyName", {
		enumerable: true,
		get: function() {
			return decompressResponsePolicy_js_1.decompressResponsePolicyName;
		}
	});
	var defaultRetryPolicy_js_1 = require_defaultRetryPolicy$1();
	Object.defineProperty(exports, "defaultRetryPolicy", {
		enumerable: true,
		get: function() {
			return defaultRetryPolicy_js_1.defaultRetryPolicy;
		}
	});
	Object.defineProperty(exports, "defaultRetryPolicyName", {
		enumerable: true,
		get: function() {
			return defaultRetryPolicy_js_1.defaultRetryPolicyName;
		}
	});
	var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy$1();
	Object.defineProperty(exports, "exponentialRetryPolicy", {
		enumerable: true,
		get: function() {
			return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
		}
	});
	Object.defineProperty(exports, "exponentialRetryPolicyName", {
		enumerable: true,
		get: function() {
			return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
		}
	});
	var retryPolicy_js_1 = require_retryPolicy$1();
	Object.defineProperty(exports, "retryPolicy", {
		enumerable: true,
		get: function() {
			return retryPolicy_js_1.retryPolicy;
		}
	});
	var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy$1();
	Object.defineProperty(exports, "systemErrorRetryPolicy", {
		enumerable: true,
		get: function() {
			return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
		}
	});
	Object.defineProperty(exports, "systemErrorRetryPolicyName", {
		enumerable: true,
		get: function() {
			return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
		}
	});
	var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy$1();
	Object.defineProperty(exports, "throttlingRetryPolicy", {
		enumerable: true,
		get: function() {
			return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
		}
	});
	Object.defineProperty(exports, "throttlingRetryPolicyName", {
		enumerable: true,
		get: function() {
			return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
		}
	});
	var formDataPolicy_js_1 = require_formDataPolicy$1();
	Object.defineProperty(exports, "formDataPolicy", {
		enumerable: true,
		get: function() {
			return formDataPolicy_js_1.formDataPolicy;
		}
	});
	Object.defineProperty(exports, "formDataPolicyName", {
		enumerable: true,
		get: function() {
			return formDataPolicy_js_1.formDataPolicyName;
		}
	});
	var logPolicy_js_1 = require_logPolicy$1();
	Object.defineProperty(exports, "logPolicy", {
		enumerable: true,
		get: function() {
			return logPolicy_js_1.logPolicy;
		}
	});
	Object.defineProperty(exports, "logPolicyName", {
		enumerable: true,
		get: function() {
			return logPolicy_js_1.logPolicyName;
		}
	});
	var multipartPolicy_js_1 = require_multipartPolicy$1();
	Object.defineProperty(exports, "multipartPolicy", {
		enumerable: true,
		get: function() {
			return multipartPolicy_js_1.multipartPolicy;
		}
	});
	Object.defineProperty(exports, "multipartPolicyName", {
		enumerable: true,
		get: function() {
			return multipartPolicy_js_1.multipartPolicyName;
		}
	});
	var proxyPolicy_js_1 = require_proxyPolicy$1();
	Object.defineProperty(exports, "proxyPolicy", {
		enumerable: true,
		get: function() {
			return proxyPolicy_js_1.proxyPolicy;
		}
	});
	Object.defineProperty(exports, "proxyPolicyName", {
		enumerable: true,
		get: function() {
			return proxyPolicy_js_1.proxyPolicyName;
		}
	});
	Object.defineProperty(exports, "getDefaultProxySettings", {
		enumerable: true,
		get: function() {
			return proxyPolicy_js_1.getDefaultProxySettings;
		}
	});
	var redirectPolicy_js_1 = require_redirectPolicy$1();
	Object.defineProperty(exports, "redirectPolicy", {
		enumerable: true,
		get: function() {
			return redirectPolicy_js_1.redirectPolicy;
		}
	});
	Object.defineProperty(exports, "redirectPolicyName", {
		enumerable: true,
		get: function() {
			return redirectPolicy_js_1.redirectPolicyName;
		}
	});
	var tlsPolicy_js_1 = require_tlsPolicy$1();
	Object.defineProperty(exports, "tlsPolicy", {
		enumerable: true,
		get: function() {
			return tlsPolicy_js_1.tlsPolicy;
		}
	});
	Object.defineProperty(exports, "tlsPolicyName", {
		enumerable: true,
		get: function() {
			return tlsPolicy_js_1.tlsPolicyName;
		}
	});
	var userAgentPolicy_js_1 = require_userAgentPolicy$1();
	Object.defineProperty(exports, "userAgentPolicy", {
		enumerable: true,
		get: function() {
			return userAgentPolicy_js_1.userAgentPolicy;
		}
	});
	Object.defineProperty(exports, "userAgentPolicyName", {
		enumerable: true,
		get: function() {
			return userAgentPolicy_js_1.userAgentPolicyName;
		}
	});
}));
var require_logPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logPolicyName = void 0;
	exports.logPolicy = logPolicy;
	var log_js_1 = require_log$4();
	var policies_1 = require_internal$1();
	exports.logPolicyName = policies_1.logPolicyName;
	function logPolicy(options = {}) {
		return (0, policies_1.logPolicy)({
			logger: log_js_1.logger.info,
			...options
		});
	}
}));
var require_redirectPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.redirectPolicyName = void 0;
	exports.redirectPolicy = redirectPolicy;
	var policies_1 = require_internal$1();
	exports.redirectPolicyName = policies_1.redirectPolicyName;
	function redirectPolicy(options = {}) {
		return (0, policies_1.redirectPolicy)(options);
	}
}));
var require_userAgentPlatform = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getHeaderName = getHeaderName;
	exports.setPlatformSpecificData = setPlatformSpecificData;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var node_os_1 = tslib_1.__importDefault(__require("node:os"));
	var node_process_1 = tslib_1.__importDefault(__require("node:process"));
	function getHeaderName() {
		return "User-Agent";
	}
	async function setPlatformSpecificData(map$6) {
		if (node_process_1.default && node_process_1.default.versions) {
			const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
			const versions = node_process_1.default.versions;
			if (versions.bun) map$6.set("Bun", `${versions.bun} (${osInfo})`);
			else if (versions.deno) map$6.set("Deno", `${versions.deno} (${osInfo})`);
			else if (versions.node) map$6.set("Node", `${versions.node} (${osInfo})`);
		}
	}
}));
var require_constants$5 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = void 0;
	exports.SDK_VERSION = "1.22.2";
	exports.DEFAULT_RETRY_POLICY_COUNT = 3;
}));
var require_userAgent = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getUserAgentHeaderName = getUserAgentHeaderName;
	exports.getUserAgentValue = getUserAgentValue;
	var userAgentPlatform_js_1 = require_userAgentPlatform();
	var constants_js_1 = require_constants$5();
	function getUserAgentString(telemetryInfo) {
		const parts = [];
		for (const [key, value$1] of telemetryInfo) {
			const token = value$1 ? `${key}/${value$1}` : key;
			parts.push(token);
		}
		return parts.join(" ");
	}
	function getUserAgentHeaderName() {
		return (0, userAgentPlatform_js_1.getHeaderName)();
	}
	async function getUserAgentValue(prefix) {
		const runtimeInfo = /* @__PURE__ */ new Map();
		runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
		await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
		const defaultAgent = getUserAgentString(runtimeInfo);
		return prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
	}
}));
var require_userAgentPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.userAgentPolicyName = void 0;
	exports.userAgentPolicy = userAgentPolicy;
	var userAgent_js_1 = require_userAgent();
	var UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
	exports.userAgentPolicyName = "userAgentPolicy";
	function userAgentPolicy(options = {}) {
		const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
		return {
			name: exports.userAgentPolicyName,
			async sendRequest(request$1, next) {
				if (!request$1.headers.has(UserAgentHeaderName)) request$1.headers.set(UserAgentHeaderName, await userAgentValue);
				return next(request$1);
			}
		};
	}
}));
var require_sha256 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.computeSha256Hmac = computeSha256Hmac;
	exports.computeSha256Hash = computeSha256Hash;
	var node_crypto_1$5 = __require("node:crypto");
	async function computeSha256Hmac(key, stringToSign, encoding) {
		const decodedKey = Buffer.from(key, "base64");
		return (0, node_crypto_1$5.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
	}
	async function computeSha256Hash(content, encoding) {
		return (0, node_crypto_1$5.createHash)("sha256").update(content).digest(encoding);
	}
}));
var require_internal = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Sanitizer = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isBrowser = exports.randomUUID = exports.computeSha256Hmac = exports.computeSha256Hash = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.calculateRetryDelay = void 0;
	var delay_js_1 = require_delay$1();
	Object.defineProperty(exports, "calculateRetryDelay", {
		enumerable: true,
		get: function() {
			return delay_js_1.calculateRetryDelay;
		}
	});
	var random_js_1 = require_random();
	Object.defineProperty(exports, "getRandomIntegerInclusive", {
		enumerable: true,
		get: function() {
			return random_js_1.getRandomIntegerInclusive;
		}
	});
	var object_js_1 = require_object();
	Object.defineProperty(exports, "isObject", {
		enumerable: true,
		get: function() {
			return object_js_1.isObject;
		}
	});
	var error_js_1 = require_error$2();
	Object.defineProperty(exports, "isError", {
		enumerable: true,
		get: function() {
			return error_js_1.isError;
		}
	});
	var sha256_js_1 = require_sha256();
	Object.defineProperty(exports, "computeSha256Hash", {
		enumerable: true,
		get: function() {
			return sha256_js_1.computeSha256Hash;
		}
	});
	Object.defineProperty(exports, "computeSha256Hmac", {
		enumerable: true,
		get: function() {
			return sha256_js_1.computeSha256Hmac;
		}
	});
	var uuidUtils_js_1 = require_uuidUtils();
	Object.defineProperty(exports, "randomUUID", {
		enumerable: true,
		get: function() {
			return uuidUtils_js_1.randomUUID;
		}
	});
	var checkEnvironment_js_1 = require_checkEnvironment();
	Object.defineProperty(exports, "isBrowser", {
		enumerable: true,
		get: function() {
			return checkEnvironment_js_1.isBrowser;
		}
	});
	Object.defineProperty(exports, "isBun", {
		enumerable: true,
		get: function() {
			return checkEnvironment_js_1.isBun;
		}
	});
	Object.defineProperty(exports, "isNodeLike", {
		enumerable: true,
		get: function() {
			return checkEnvironment_js_1.isNodeLike;
		}
	});
	Object.defineProperty(exports, "isNodeRuntime", {
		enumerable: true,
		get: function() {
			return checkEnvironment_js_1.isNodeRuntime;
		}
	});
	Object.defineProperty(exports, "isDeno", {
		enumerable: true,
		get: function() {
			return checkEnvironment_js_1.isDeno;
		}
	});
	Object.defineProperty(exports, "isReactNative", {
		enumerable: true,
		get: function() {
			return checkEnvironment_js_1.isReactNative;
		}
	});
	Object.defineProperty(exports, "isWebWorker", {
		enumerable: true,
		get: function() {
			return checkEnvironment_js_1.isWebWorker;
		}
	});
	var bytesEncoding_js_1 = require_bytesEncoding();
	Object.defineProperty(exports, "stringToUint8Array", {
		enumerable: true,
		get: function() {
			return bytesEncoding_js_1.stringToUint8Array;
		}
	});
	Object.defineProperty(exports, "uint8ArrayToString", {
		enumerable: true,
		get: function() {
			return bytesEncoding_js_1.uint8ArrayToString;
		}
	});
	var sanitizer_js_1 = require_sanitizer();
	Object.defineProperty(exports, "Sanitizer", {
		enumerable: true,
		get: function() {
			return sanitizer_js_1.Sanitizer;
		}
	});
}));
var require_aborterUtils = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cancelablePromiseRace = cancelablePromiseRace;
	async function cancelablePromiseRace(abortablePromiseBuilders, options) {
		const aborter = new AbortController();
		function abortHandler() {
			aborter.abort();
		}
		options?.abortSignal?.addEventListener("abort", abortHandler);
		try {
			return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
		} finally {
			aborter.abort();
			options?.abortSignal?.removeEventListener("abort", abortHandler);
		}
	}
}));
var require_AbortError = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AbortError = void 0;
	var AbortError = class extends Error {
		constructor(message) {
			super(message);
			this.name = "AbortError";
		}
	};
	exports.AbortError = AbortError;
}));
var require_commonjs$15 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AbortError = void 0;
	var AbortError_js_1 = require_AbortError();
	Object.defineProperty(exports, "AbortError", {
		enumerable: true,
		get: function() {
			return AbortError_js_1.AbortError;
		}
	});
}));
var require_createAbortablePromise = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createAbortablePromise = createAbortablePromise;
	var abort_controller_1 = require_commonjs$15();
	function createAbortablePromise(buildPromise, options) {
		const { cleanupBeforeAbort, abortSignal: abortSignal$1, abortErrorMsg } = options ?? {};
		return new Promise((resolve$1, reject$3) => {
			function rejectOnAbort() {
				reject$3(new abort_controller_1.AbortError(abortErrorMsg ?? "The operation was aborted."));
			}
			function removeListeners() {
				abortSignal$1?.removeEventListener("abort", onAbort);
			}
			function onAbort() {
				cleanupBeforeAbort?.();
				removeListeners();
				rejectOnAbort();
			}
			if (abortSignal$1?.aborted) return rejectOnAbort();
			try {
				buildPromise((x) => {
					removeListeners();
					resolve$1(x);
				}, (x) => {
					removeListeners();
					reject$3(x);
				});
			} catch (err) {
				reject$3(err);
			}
			abortSignal$1?.addEventListener("abort", onAbort);
		});
	}
}));
var require_delay = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.delay = delay;
	exports.calculateRetryDelay = calculateRetryDelay;
	var createAbortablePromise_js_1 = require_createAbortablePromise();
	var util_1 = require_internal();
	var StandardAbortMessage = "The delay was aborted.";
	function delay(timeInMs, options) {
		let token;
		const { abortSignal: abortSignal$1, abortErrorMsg } = options ?? {};
		return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve$1) => {
			token = setTimeout(resolve$1, timeInMs);
		}, {
			cleanupBeforeAbort: () => clearTimeout(token),
			abortSignal: abortSignal$1,
			abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
		});
	}
	function calculateRetryDelay(retryAttempt, config) {
		const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
		const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
		return { retryAfterInMs: clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2) };
	}
}));
var require_error$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getErrorMessage = getErrorMessage;
	var util_1 = require_internal();
	function getErrorMessage(e$1) {
		if ((0, util_1.isError)(e$1)) return e$1.message;
		else {
			let stringified;
			try {
				if (typeof e$1 === "object" && e$1) stringified = JSON.stringify(e$1);
				else stringified = String(e$1);
			} catch (err) {
				stringified = "[unable to stringify input]";
			}
			return `Unknown error ${stringified}`;
		}
	}
}));
var require_typeGuards = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isDefined = isDefined;
	exports.isObjectWithProperties = isObjectWithProperties;
	exports.objectHasProperty = objectHasProperty;
	function isDefined(thing) {
		return typeof thing !== "undefined" && thing !== null;
	}
	function isObjectWithProperties(thing, properties) {
		if (!isDefined(thing) || typeof thing !== "object") return false;
		for (const property of properties) if (!objectHasProperty(thing, property)) return false;
		return true;
	}
	function objectHasProperty(thing, property) {
		return isDefined(thing) && typeof thing === "object" && property in thing;
	}
}));
var require_commonjs$14 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isWebWorker = exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isDeno = exports.isBun = exports.isBrowser = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.getErrorMessage = exports.delay = exports.createAbortablePromise = exports.cancelablePromiseRace = void 0;
	exports.calculateRetryDelay = calculateRetryDelay;
	exports.computeSha256Hash = computeSha256Hash;
	exports.computeSha256Hmac = computeSha256Hmac;
	exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
	exports.isError = isError;
	exports.isObject = isObject;
	exports.randomUUID = randomUUID;
	exports.uint8ArrayToString = uint8ArrayToString;
	exports.stringToUint8Array = stringToUint8Array;
	var tspRuntime = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importStar(require_internal());
	var aborterUtils_js_1 = require_aborterUtils();
	Object.defineProperty(exports, "cancelablePromiseRace", {
		enumerable: true,
		get: function() {
			return aborterUtils_js_1.cancelablePromiseRace;
		}
	});
	var createAbortablePromise_js_1 = require_createAbortablePromise();
	Object.defineProperty(exports, "createAbortablePromise", {
		enumerable: true,
		get: function() {
			return createAbortablePromise_js_1.createAbortablePromise;
		}
	});
	var delay_js_1 = require_delay();
	Object.defineProperty(exports, "delay", {
		enumerable: true,
		get: function() {
			return delay_js_1.delay;
		}
	});
	var error_js_1 = require_error$1();
	Object.defineProperty(exports, "getErrorMessage", {
		enumerable: true,
		get: function() {
			return error_js_1.getErrorMessage;
		}
	});
	var typeGuards_js_1 = require_typeGuards();
	Object.defineProperty(exports, "isDefined", {
		enumerable: true,
		get: function() {
			return typeGuards_js_1.isDefined;
		}
	});
	Object.defineProperty(exports, "isObjectWithProperties", {
		enumerable: true,
		get: function() {
			return typeGuards_js_1.isObjectWithProperties;
		}
	});
	Object.defineProperty(exports, "objectHasProperty", {
		enumerable: true,
		get: function() {
			return typeGuards_js_1.objectHasProperty;
		}
	});
	function calculateRetryDelay(retryAttempt, config) {
		return tspRuntime.calculateRetryDelay(retryAttempt, config);
	}
	function computeSha256Hash(content, encoding) {
		return tspRuntime.computeSha256Hash(content, encoding);
	}
	function computeSha256Hmac(key, stringToSign, encoding) {
		return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
	}
	function getRandomIntegerInclusive(min, max) {
		return tspRuntime.getRandomIntegerInclusive(min, max);
	}
	function isError(e$1) {
		return tspRuntime.isError(e$1);
	}
	function isObject(input) {
		return tspRuntime.isObject(input);
	}
	function randomUUID() {
		return tspRuntime.randomUUID();
	}
	exports.isBrowser = tspRuntime.isBrowser;
	exports.isBun = tspRuntime.isBun;
	exports.isDeno = tspRuntime.isDeno;
	exports.isNode = tspRuntime.isNodeLike;
	exports.isNodeLike = tspRuntime.isNodeLike;
	exports.isNodeRuntime = tspRuntime.isNodeRuntime;
	exports.isReactNative = tspRuntime.isReactNative;
	exports.isWebWorker = tspRuntime.isWebWorker;
	function uint8ArrayToString(bytes, format) {
		return tspRuntime.uint8ArrayToString(bytes, format);
	}
	function stringToUint8Array(value$1, format) {
		return tspRuntime.stringToUint8Array(value$1, format);
	}
}));
var require_file$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hasRawContent = hasRawContent;
	exports.getRawContent = getRawContent;
	exports.createFileFromStream = createFileFromStream;
	exports.createFile = createFile;
	var core_util_1 = require_commonjs$14();
	function isNodeReadableStream(x) {
		return Boolean(x && typeof x["pipe"] === "function");
	}
	var unimplementedMethods = {
		arrayBuffer: () => {
			throw new Error("Not implemented");
		},
		bytes: () => {
			throw new Error("Not implemented");
		},
		slice: () => {
			throw new Error("Not implemented");
		},
		text: () => {
			throw new Error("Not implemented");
		}
	};
	var rawContent = Symbol("rawContent");
	function hasRawContent(x) {
		return typeof x[rawContent] === "function";
	}
	function getRawContent(blob) {
		if (hasRawContent(blob)) return blob[rawContent]();
		else return blob;
	}
	function createFileFromStream(stream$5, name$1, options = {}) {
		return {
			...unimplementedMethods,
			type: options.type ?? "",
			lastModified: options.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
			webkitRelativePath: options.webkitRelativePath ?? "",
			size: options.size ?? -1,
			name: name$1,
			stream: () => {
				const s = stream$5();
				if (isNodeReadableStream(s)) throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
				return s;
			},
			[rawContent]: stream$5
		};
	}
	function createFile(content, name$1, options = {}) {
		if (core_util_1.isNodeLike) return {
			...unimplementedMethods,
			type: options.type ?? "",
			lastModified: options.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
			webkitRelativePath: options.webkitRelativePath ?? "",
			size: content.byteLength,
			name: name$1,
			arrayBuffer: async () => content.buffer,
			stream: () => new Blob([toArrayBuffer(content)]).stream(),
			[rawContent]: () => content
		};
		else return new File([toArrayBuffer(content)], name$1, options);
	}
	function toArrayBuffer(source) {
		if ("resize" in source.buffer) return source;
		return source.map((x) => x);
	}
}));
var require_multipartPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.multipartPolicyName = void 0;
	exports.multipartPolicy = multipartPolicy;
	var policies_1 = require_internal$1();
	var file_js_1 = require_file$1();
	exports.multipartPolicyName = policies_1.multipartPolicyName;
	function multipartPolicy() {
		const tspPolicy = (0, policies_1.multipartPolicy)();
		return {
			name: exports.multipartPolicyName,
			sendRequest: async (request$1, next) => {
				if (request$1.multipartBody) {
					for (const part of request$1.multipartBody.parts) if ((0, file_js_1.hasRawContent)(part.body)) part.body = (0, file_js_1.getRawContent)(part.body);
				}
				return tspPolicy.sendRequest(request$1, next);
			}
		};
	}
}));
var require_decompressResponsePolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.decompressResponsePolicyName = void 0;
	exports.decompressResponsePolicy = decompressResponsePolicy;
	var policies_1 = require_internal$1();
	exports.decompressResponsePolicyName = policies_1.decompressResponsePolicyName;
	function decompressResponsePolicy() {
		return (0, policies_1.decompressResponsePolicy)();
	}
}));
var require_defaultRetryPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.defaultRetryPolicyName = void 0;
	exports.defaultRetryPolicy = defaultRetryPolicy;
	var policies_1 = require_internal$1();
	exports.defaultRetryPolicyName = policies_1.defaultRetryPolicyName;
	function defaultRetryPolicy(options = {}) {
		return (0, policies_1.defaultRetryPolicy)(options);
	}
}));
var require_formDataPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.formDataPolicyName = void 0;
	exports.formDataPolicy = formDataPolicy;
	var policies_1 = require_internal$1();
	exports.formDataPolicyName = policies_1.formDataPolicyName;
	function formDataPolicy() {
		return (0, policies_1.formDataPolicy)();
	}
}));
var require_proxyPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.proxyPolicyName = void 0;
	exports.getDefaultProxySettings = getDefaultProxySettings;
	exports.proxyPolicy = proxyPolicy;
	var policies_1 = require_internal$1();
	exports.proxyPolicyName = policies_1.proxyPolicyName;
	function getDefaultProxySettings(proxyUrl) {
		return (0, policies_1.getDefaultProxySettings)(proxyUrl);
	}
	function proxyPolicy(proxySettings, options) {
		return (0, policies_1.proxyPolicy)(proxySettings, options);
	}
}));
var require_setClientRequestIdPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.setClientRequestIdPolicyName = void 0;
	exports.setClientRequestIdPolicy = setClientRequestIdPolicy;
	exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
	function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
		return {
			name: exports.setClientRequestIdPolicyName,
			async sendRequest(request$1, next) {
				if (!request$1.headers.has(requestIdHeaderName)) request$1.headers.set(requestIdHeaderName, request$1.requestId);
				return next(request$1);
			}
		};
	}
}));
var require_agentPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.agentPolicyName = void 0;
	exports.agentPolicy = agentPolicy;
	var policies_1 = require_internal$1();
	exports.agentPolicyName = policies_1.agentPolicyName;
	function agentPolicy(agent) {
		return (0, policies_1.agentPolicy)(agent);
	}
}));
var require_tlsPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.tlsPolicyName = void 0;
	exports.tlsPolicy = tlsPolicy;
	var policies_1 = require_internal$1();
	exports.tlsPolicyName = policies_1.tlsPolicyName;
	function tlsPolicy(tlsSettings) {
		return (0, policies_1.tlsPolicy)(tlsSettings);
	}
}));
var require_tracingContext = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TracingContextImpl = exports.knownContextKeys = void 0;
	exports.createTracingContext = createTracingContext;
	exports.knownContextKeys = {
		span: Symbol.for("@azure/core-tracing span"),
		namespace: Symbol.for("@azure/core-tracing namespace")
	};
	function createTracingContext(options = {}) {
		let context$2 = new TracingContextImpl(options.parentContext);
		if (options.span) context$2 = context$2.setValue(exports.knownContextKeys.span, options.span);
		if (options.namespace) context$2 = context$2.setValue(exports.knownContextKeys.namespace, options.namespace);
		return context$2;
	}
	var TracingContextImpl = class TracingContextImpl {
		_contextMap;
		constructor(initialContext) {
			this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
		}
		setValue(key, value$1) {
			const newContext = new TracingContextImpl(this);
			newContext._contextMap.set(key, value$1);
			return newContext;
		}
		getValue(key) {
			return this._contextMap.get(key);
		}
		deleteValue(key) {
			const newContext = new TracingContextImpl(this);
			newContext._contextMap.delete(key);
			return newContext;
		}
	};
	exports.TracingContextImpl = TracingContextImpl;
}));
var require_state$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.state = void 0;
	exports.state = { instrumenterImplementation: void 0 };
}));
var require_instrumenter = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createDefaultTracingSpan = createDefaultTracingSpan;
	exports.createDefaultInstrumenter = createDefaultInstrumenter;
	exports.useInstrumenter = useInstrumenter;
	exports.getInstrumenter = getInstrumenter;
	var tracingContext_js_1 = require_tracingContext();
	var state_js_1 = require_state$2();
	function createDefaultTracingSpan() {
		return {
			end: () => {},
			isRecording: () => false,
			recordException: () => {},
			setAttribute: () => {},
			setStatus: () => {},
			addEvent: () => {}
		};
	}
	function createDefaultInstrumenter() {
		return {
			createRequestHeaders: () => {
				return {};
			},
			parseTraceparentHeader: () => {},
			startSpan: (_name, spanOptions) => {
				return {
					span: createDefaultTracingSpan(),
					tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
				};
			},
			withContext(_context, callback, ...callbackArgs) {
				return callback(...callbackArgs);
			}
		};
	}
	function useInstrumenter(instrumenter) {
		state_js_1.state.instrumenterImplementation = instrumenter;
	}
	function getInstrumenter() {
		if (!state_js_1.state.instrumenterImplementation) state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
		return state_js_1.state.instrumenterImplementation;
	}
}));
var require_tracingClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createTracingClient = createTracingClient;
	var instrumenter_js_1 = require_instrumenter();
	var tracingContext_js_1 = require_tracingContext();
	function createTracingClient(options) {
		const { namespace, packageName, packageVersion } = options;
		function startSpan(name$1, operationOptions, spanOptions) {
			const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name$1, {
				...spanOptions,
				packageName,
				packageVersion,
				tracingContext: operationOptions?.tracingOptions?.tracingContext
			});
			let tracingContext = startSpanResult.tracingContext;
			const span$2 = startSpanResult.span;
			if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace)) tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
			span$2.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
			return {
				span: span$2,
				updatedOptions: Object.assign({}, operationOptions, { tracingOptions: {
					...operationOptions?.tracingOptions,
					tracingContext
				} })
			};
		}
		async function withSpan$2(name$1, operationOptions, callback, spanOptions) {
			const { span: span$2, updatedOptions } = startSpan(name$1, operationOptions, spanOptions);
			try {
				const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span$2)));
				span$2.setStatus({ status: "success" });
				return result;
			} catch (err) {
				span$2.setStatus({
					status: "error",
					error: err
				});
				throw err;
			} finally {
				span$2.end();
			}
		}
		function withContext(context$2, callback, ...callbackArgs) {
			return (0, instrumenter_js_1.getInstrumenter)().withContext(context$2, callback, ...callbackArgs);
		}
		function parseTraceparentHeader(traceparentHeader) {
			return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
		}
		function createRequestHeaders(tracingContext) {
			return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
		}
		return {
			startSpan,
			withSpan: withSpan$2,
			withContext,
			parseTraceparentHeader,
			createRequestHeaders
		};
	}
}));
var require_commonjs$13 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createTracingClient = exports.useInstrumenter = void 0;
	var instrumenter_js_1 = require_instrumenter();
	Object.defineProperty(exports, "useInstrumenter", {
		enumerable: true,
		get: function() {
			return instrumenter_js_1.useInstrumenter;
		}
	});
	var tracingClient_js_1 = require_tracingClient();
	Object.defineProperty(exports, "createTracingClient", {
		enumerable: true,
		get: function() {
			return tracingClient_js_1.createTracingClient;
		}
	});
}));
var require_restError = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.RestError = void 0;
	exports.isRestError = isRestError;
	var ts_http_runtime_1 = require_commonjs$17();
	exports.RestError = ts_http_runtime_1.RestError;
	function isRestError(e$1) {
		return (0, ts_http_runtime_1.isRestError)(e$1);
	}
}));
var require_tracingPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.tracingPolicyName = void 0;
	exports.tracingPolicy = tracingPolicy;
	var core_tracing_1 = require_commonjs$13();
	var constants_js_1 = require_constants$5();
	var userAgent_js_1 = require_userAgent();
	var log_js_1 = require_log$4();
	var core_util_1 = require_commonjs$14();
	var restError_js_1 = require_restError();
	var util_1 = require_internal();
	exports.tracingPolicyName = "tracingPolicy";
	function tracingPolicy(options = {}) {
		const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
		const sanitizer = new util_1.Sanitizer({ additionalAllowedQueryParameters: options.additionalAllowedQueryParameters });
		const tracingClient = tryCreateTracingClient();
		return {
			name: exports.tracingPolicyName,
			async sendRequest(request$1, next) {
				if (!tracingClient) return next(request$1);
				const userAgent$1 = await userAgentPromise;
				const spanAttributes = {
					"http.url": sanitizer.sanitizeUrl(request$1.url),
					"http.method": request$1.method,
					"http.user_agent": userAgent$1,
					requestId: request$1.requestId
				};
				if (userAgent$1) spanAttributes["http.user_agent"] = userAgent$1;
				const { span: span$2, tracingContext } = tryCreateSpan(tracingClient, request$1, spanAttributes) ?? {};
				if (!span$2 || !tracingContext) return next(request$1);
				try {
					const response = await tracingClient.withContext(tracingContext, next, request$1);
					tryProcessResponse(span$2, response);
					return response;
				} catch (err) {
					tryProcessError(span$2, err);
					throw err;
				}
			}
		};
	}
	function tryCreateTracingClient() {
		try {
			return (0, core_tracing_1.createTracingClient)({
				namespace: "",
				packageName: "@azure/core-rest-pipeline",
				packageVersion: constants_js_1.SDK_VERSION
			});
		} catch (e$1) {
			log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e$1)}`);
			return;
		}
	}
	function tryCreateSpan(tracingClient, request$1, spanAttributes) {
		try {
			const { span: span$2, updatedOptions } = tracingClient.startSpan(`HTTP ${request$1.method}`, { tracingOptions: request$1.tracingOptions }, {
				spanKind: "client",
				spanAttributes
			});
			if (!span$2.isRecording()) {
				span$2.end();
				return;
			}
			const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
			for (const [key, value$1] of Object.entries(headers)) request$1.headers.set(key, value$1);
			return {
				span: span$2,
				tracingContext: updatedOptions.tracingOptions.tracingContext
			};
		} catch (e$1) {
			log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e$1)}`);
			return;
		}
	}
	function tryProcessError(span$2, error) {
		try {
			span$2.setStatus({
				status: "error",
				error: (0, core_util_1.isError)(error) ? error : void 0
			});
			if ((0, restError_js_1.isRestError)(error) && error.statusCode) span$2.setAttribute("http.status_code", error.statusCode);
			span$2.end();
		} catch (e$1) {
			log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e$1)}`);
		}
	}
	function tryProcessResponse(span$2, response) {
		try {
			span$2.setAttribute("http.status_code", response.status);
			const serviceRequestId = response.headers.get("x-ms-request-id");
			if (serviceRequestId) span$2.setAttribute("serviceRequestId", serviceRequestId);
			if (response.status >= 400) span$2.setStatus({ status: "error" });
			span$2.end();
		} catch (e$1) {
			log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e$1)}`);
		}
	}
}));
var require_wrapAbortSignal = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.wrapAbortSignalLike = wrapAbortSignalLike;
	function wrapAbortSignalLike(abortSignalLike) {
		if (abortSignalLike instanceof AbortSignal) return { abortSignal: abortSignalLike };
		if (abortSignalLike.aborted) return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
		const controller = new AbortController();
		let needsCleanup = true;
		function cleanup() {
			if (needsCleanup) {
				abortSignalLike.removeEventListener("abort", listener);
				needsCleanup = false;
			}
		}
		function listener() {
			controller.abort(abortSignalLike.reason);
			cleanup();
		}
		abortSignalLike.addEventListener("abort", listener);
		return {
			abortSignal: controller.signal,
			cleanup
		};
	}
}));
var require_wrapAbortSignalLikePolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.wrapAbortSignalLikePolicyName = void 0;
	exports.wrapAbortSignalLikePolicy = wrapAbortSignalLikePolicy;
	var wrapAbortSignal_js_1 = require_wrapAbortSignal();
	exports.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
	function wrapAbortSignalLikePolicy() {
		return {
			name: exports.wrapAbortSignalLikePolicyName,
			sendRequest: async (request$1, next) => {
				if (!request$1.abortSignal) return next(request$1);
				const { abortSignal: abortSignal$1, cleanup } = (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request$1.abortSignal);
				request$1.abortSignal = abortSignal$1;
				try {
					return await next(request$1);
				} finally {
					cleanup?.();
				}
			}
		};
	}
}));
var require_createPipelineFromOptions = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createPipelineFromOptions = createPipelineFromOptions;
	var logPolicy_js_1 = require_logPolicy();
	var pipeline_js_1 = require_pipeline$2();
	var redirectPolicy_js_1 = require_redirectPolicy();
	var userAgentPolicy_js_1 = require_userAgentPolicy();
	var multipartPolicy_js_1 = require_multipartPolicy();
	var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
	var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
	var formDataPolicy_js_1 = require_formDataPolicy();
	var core_util_1 = require_commonjs$14();
	var proxyPolicy_js_1 = require_proxyPolicy();
	var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
	var agentPolicy_js_1 = require_agentPolicy();
	var tlsPolicy_js_1 = require_tlsPolicy();
	var tracingPolicy_js_1 = require_tracingPolicy();
	var wrapAbortSignalLikePolicy_js_1 = require_wrapAbortSignalLikePolicy();
	function createPipelineFromOptions(options) {
		const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
		if (core_util_1.isNodeLike) {
			if (options.agent) pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
			if (options.tlsOptions) pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
			pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
			pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
		}
		pipeline.addPolicy((0, wrapAbortSignalLikePolicy_js_1.wrapAbortSignalLikePolicy)());
		pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
		pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
		pipeline.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)(options.telemetryOptions?.clientRequestIdHeaderName));
		pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
		pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
		pipeline.addPolicy((0, tracingPolicy_js_1.tracingPolicy)({
			...options.userAgentOptions,
			...options.loggingOptions
		}), { afterPhase: "Retry" });
		if (core_util_1.isNodeLike) pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
		pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
		return pipeline;
	}
}));
var require_defaultHttpClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createDefaultHttpClient = createDefaultHttpClient;
	var ts_http_runtime_1 = require_commonjs$17();
	var wrapAbortSignal_js_1 = require_wrapAbortSignal();
	function createDefaultHttpClient() {
		const client = (0, ts_http_runtime_1.createDefaultHttpClient)();
		return { async sendRequest(request$1) {
			const { abortSignal: abortSignal$1, cleanup } = request$1.abortSignal ? (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request$1.abortSignal) : {};
			try {
				request$1.abortSignal = abortSignal$1;
				return await client.sendRequest(request$1);
			} finally {
				cleanup?.();
			}
		} };
	}
}));
var require_httpHeaders = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createHttpHeaders = createHttpHeaders;
	var ts_http_runtime_1 = require_commonjs$17();
	function createHttpHeaders(rawHeaders) {
		return (0, ts_http_runtime_1.createHttpHeaders)(rawHeaders);
	}
}));
var require_pipelineRequest = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createPipelineRequest = createPipelineRequest;
	var ts_http_runtime_1 = require_commonjs$17();
	function createPipelineRequest(options) {
		return (0, ts_http_runtime_1.createPipelineRequest)(options);
	}
}));
var require_exponentialRetryPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.exponentialRetryPolicyName = void 0;
	exports.exponentialRetryPolicy = exponentialRetryPolicy;
	var policies_1 = require_internal$1();
	exports.exponentialRetryPolicyName = policies_1.exponentialRetryPolicyName;
	function exponentialRetryPolicy(options = {}) {
		return (0, policies_1.exponentialRetryPolicy)(options);
	}
}));
var require_systemErrorRetryPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.systemErrorRetryPolicyName = void 0;
	exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
	var policies_1 = require_internal$1();
	exports.systemErrorRetryPolicyName = policies_1.systemErrorRetryPolicyName;
	function systemErrorRetryPolicy(options = {}) {
		return (0, policies_1.systemErrorRetryPolicy)(options);
	}
}));
var require_throttlingRetryPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.throttlingRetryPolicyName = void 0;
	exports.throttlingRetryPolicy = throttlingRetryPolicy;
	var policies_1 = require_internal$1();
	exports.throttlingRetryPolicyName = policies_1.throttlingRetryPolicyName;
	function throttlingRetryPolicy(options = {}) {
		return (0, policies_1.throttlingRetryPolicy)(options);
	}
}));
var require_retryPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.retryPolicy = retryPolicy;
	var logger_1 = require_commonjs$16();
	var constants_js_1 = require_constants$5();
	var policies_1 = require_internal$1();
	var retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
	function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
		return (0, policies_1.retryPolicy)(strategies, {
			logger: retryPolicyLogger,
			...options
		});
	}
}));
var require_tokenCycler = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DEFAULT_CYCLER_OPTIONS = void 0;
	exports.createTokenCycler = createTokenCycler;
	var core_util_1 = require_commonjs$14();
	exports.DEFAULT_CYCLER_OPTIONS = {
		forcedRefreshWindowInMs: 1e3,
		retryIntervalInMs: 3e3,
		refreshWindowInMs: 1e3 * 60 * 2
	};
	async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
		async function tryGetAccessToken() {
			if (Date.now() < refreshTimeout) try {
				return await getAccessToken();
			} catch {
				return null;
			}
			else {
				const finalToken = await getAccessToken();
				if (finalToken === null) throw new Error("Failed to refresh access token.");
				return finalToken;
			}
		}
		let token = await tryGetAccessToken();
		while (token === null) {
			await (0, core_util_1.delay)(retryIntervalInMs);
			token = await tryGetAccessToken();
		}
		return token;
	}
	function createTokenCycler(credential, tokenCyclerOptions) {
		let refreshWorker = null;
		let token = null;
		let tenantId;
		const options = {
			...exports.DEFAULT_CYCLER_OPTIONS,
			...tokenCyclerOptions
		};
		const cycler = {
			get isRefreshing() {
				return refreshWorker !== null;
			},
			get shouldRefresh() {
				if (cycler.isRefreshing) return false;
				if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) return true;
				return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();
			},
			get mustRefresh() {
				return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
			}
		};
		function refresh(scopes, getTokenOptions) {
			if (!cycler.isRefreshing) {
				const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
				refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, token?.expiresOnTimestamp ?? Date.now()).then((_token) => {
					refreshWorker = null;
					token = _token;
					tenantId = getTokenOptions.tenantId;
					return token;
				}).catch((reason) => {
					refreshWorker = null;
					token = null;
					tenantId = void 0;
					throw reason;
				});
			}
			return refreshWorker;
		}
		return async (scopes, tokenOptions) => {
			const hasClaimChallenge = Boolean(tokenOptions.claims);
			const tenantIdChanged = tenantId !== tokenOptions.tenantId;
			if (hasClaimChallenge) token = null;
			if (tenantIdChanged || hasClaimChallenge || cycler.mustRefresh) return refresh(scopes, tokenOptions);
			if (cycler.shouldRefresh) refresh(scopes, tokenOptions);
			return token;
		};
	}
}));
var require_bearerTokenAuthenticationPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.bearerTokenAuthenticationPolicyName = void 0;
	exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
	exports.parseChallenges = parseChallenges;
	var tokenCycler_js_1 = require_tokenCycler();
	var log_js_1 = require_log$4();
	var restError_js_1 = require_restError();
	exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
	async function trySendRequest(request$1, next) {
		try {
			return [await next(request$1), void 0];
		} catch (e$1) {
			if ((0, restError_js_1.isRestError)(e$1) && e$1.response) return [e$1.response, e$1];
			else throw e$1;
		}
	}
	async function defaultAuthorizeRequest(options) {
		const { scopes, getAccessToken, request: request$1 } = options;
		const accessToken = await getAccessToken(scopes, {
			abortSignal: request$1.abortSignal,
			tracingOptions: request$1.tracingOptions,
			enableCae: true
		});
		if (accessToken) options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
	}
	function isChallengeResponse(response) {
		return response.status === 401 && response.headers.has("WWW-Authenticate");
	}
	async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
		const { scopes } = onChallengeOptions;
		const accessToken = await onChallengeOptions.getAccessToken(scopes, {
			enableCae: true,
			claims: caeClaims
		});
		if (!accessToken) return false;
		onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
		return true;
	}
	function bearerTokenAuthenticationPolicy(options) {
		const { credential, scopes, challengeCallbacks } = options;
		const logger = options.logger || log_js_1.logger;
		const callbacks = {
			authorizeRequest: challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
			authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks)
		};
		const getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(credential) : () => Promise.resolve(null);
		return {
			name: exports.bearerTokenAuthenticationPolicyName,
			async sendRequest(request$1, next) {
				if (!request$1.url.toLowerCase().startsWith("https://")) throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
				await callbacks.authorizeRequest({
					scopes: Array.isArray(scopes) ? scopes : [scopes],
					request: request$1,
					getAccessToken,
					logger
				});
				let response;
				let error;
				let shouldSendRequest;
				[response, error] = await trySendRequest(request$1, next);
				if (isChallengeResponse(response)) {
					let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
					if (claims) {
						let parsedClaim;
						try {
							parsedClaim = atob(claims);
						} catch (e$1) {
							logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
							return response;
						}
						shouldSendRequest = await authorizeRequestOnCaeChallenge({
							scopes: Array.isArray(scopes) ? scopes : [scopes],
							response,
							request: request$1,
							getAccessToken,
							logger
						}, parsedClaim);
						if (shouldSendRequest) [response, error] = await trySendRequest(request$1, next);
					} else if (callbacks.authorizeRequestOnChallenge) {
						shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
							scopes: Array.isArray(scopes) ? scopes : [scopes],
							request: request$1,
							response,
							getAccessToken,
							logger
						});
						if (shouldSendRequest) [response, error] = await trySendRequest(request$1, next);
						if (isChallengeResponse(response)) {
							claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
							if (claims) {
								let parsedClaim;
								try {
									parsedClaim = atob(claims);
								} catch (e$1) {
									logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
									return response;
								}
								shouldSendRequest = await authorizeRequestOnCaeChallenge({
									scopes: Array.isArray(scopes) ? scopes : [scopes],
									response,
									request: request$1,
									getAccessToken,
									logger
								}, parsedClaim);
								if (shouldSendRequest) [response, error] = await trySendRequest(request$1, next);
							}
						}
					}
				}
				if (error) throw error;
				else return response;
			}
		};
	}
	function parseChallenges(challenges) {
		const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
		const paramRegex = /(\w+)="([^"]*)"/g;
		const parsedChallenges = [];
		let match$3;
		while ((match$3 = challengeRegex.exec(challenges)) !== null) {
			const scheme = match$3[1];
			const paramsString = match$3[2];
			const params = {};
			let paramMatch;
			while ((paramMatch = paramRegex.exec(paramsString)) !== null) params[paramMatch[1]] = paramMatch[2];
			parsedChallenges.push({
				scheme,
				params
			});
		}
		return parsedChallenges;
	}
	function getCaeChallengeClaims(challenges) {
		if (!challenges) return;
		return parseChallenges(challenges).find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")?.params.claims;
	}
}));
var require_ndJsonPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ndJsonPolicyName = void 0;
	exports.ndJsonPolicy = ndJsonPolicy;
	exports.ndJsonPolicyName = "ndJsonPolicy";
	function ndJsonPolicy() {
		return {
			name: exports.ndJsonPolicyName,
			async sendRequest(request$1, next) {
				if (typeof request$1.body === "string" && request$1.body.startsWith("[")) {
					const body = JSON.parse(request$1.body);
					if (Array.isArray(body)) request$1.body = body.map((item) => JSON.stringify(item) + "\n").join("");
				}
				return next(request$1);
			}
		};
	}
}));
var require_auxiliaryAuthenticationHeaderPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.auxiliaryAuthenticationHeaderPolicyName = void 0;
	exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
	var tokenCycler_js_1 = require_tokenCycler();
	var log_js_1 = require_log$4();
	exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
	var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
	async function sendAuthorizeRequest(options) {
		const { scopes, getAccessToken, request: request$1 } = options;
		return (await getAccessToken(scopes, {
			abortSignal: request$1.abortSignal,
			tracingOptions: request$1.tracingOptions
		}))?.token ?? "";
	}
	function auxiliaryAuthenticationHeaderPolicy(options) {
		const { credentials, scopes } = options;
		const logger = options.logger || log_js_1.logger;
		const tokenCyclerMap = /* @__PURE__ */ new WeakMap();
		return {
			name: exports.auxiliaryAuthenticationHeaderPolicyName,
			async sendRequest(request$1, next) {
				if (!request$1.url.toLowerCase().startsWith("https://")) throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
				if (!credentials || credentials.length === 0) {
					logger.info(`${exports.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
					return next(request$1);
				}
				const tokenPromises = [];
				for (const credential of credentials) {
					let getAccessToken = tokenCyclerMap.get(credential);
					if (!getAccessToken) {
						getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
						tokenCyclerMap.set(credential, getAccessToken);
					}
					tokenPromises.push(sendAuthorizeRequest({
						scopes: Array.isArray(scopes) ? scopes : [scopes],
						request: request$1,
						getAccessToken,
						logger
					}));
				}
				const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
				if (auxiliaryTokens.length === 0) {
					logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
					return next(request$1);
				}
				request$1.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
				return next(request$1);
			}
		};
	}
}));
var require_commonjs$12 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createFileFromStream = exports.createFile = exports.agentPolicyName = exports.agentPolicy = exports.auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicy = exports.ndJsonPolicyName = exports.ndJsonPolicy = exports.bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.userAgentPolicyName = exports.userAgentPolicy = exports.defaultRetryPolicy = exports.tracingPolicyName = exports.tracingPolicy = exports.retryPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.setClientRequestIdPolicyName = exports.setClientRequestIdPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.isRestError = exports.RestError = exports.createPipelineRequest = exports.createHttpHeaders = exports.createDefaultHttpClient = exports.createPipelineFromOptions = exports.createEmptyPipeline = void 0;
	var pipeline_js_1 = require_pipeline$2();
	Object.defineProperty(exports, "createEmptyPipeline", {
		enumerable: true,
		get: function() {
			return pipeline_js_1.createEmptyPipeline;
		}
	});
	var createPipelineFromOptions_js_1 = require_createPipelineFromOptions();
	Object.defineProperty(exports, "createPipelineFromOptions", {
		enumerable: true,
		get: function() {
			return createPipelineFromOptions_js_1.createPipelineFromOptions;
		}
	});
	var defaultHttpClient_js_1 = require_defaultHttpClient();
	Object.defineProperty(exports, "createDefaultHttpClient", {
		enumerable: true,
		get: function() {
			return defaultHttpClient_js_1.createDefaultHttpClient;
		}
	});
	var httpHeaders_js_1 = require_httpHeaders();
	Object.defineProperty(exports, "createHttpHeaders", {
		enumerable: true,
		get: function() {
			return httpHeaders_js_1.createHttpHeaders;
		}
	});
	var pipelineRequest_js_1 = require_pipelineRequest();
	Object.defineProperty(exports, "createPipelineRequest", {
		enumerable: true,
		get: function() {
			return pipelineRequest_js_1.createPipelineRequest;
		}
	});
	var restError_js_1 = require_restError();
	Object.defineProperty(exports, "RestError", {
		enumerable: true,
		get: function() {
			return restError_js_1.RestError;
		}
	});
	Object.defineProperty(exports, "isRestError", {
		enumerable: true,
		get: function() {
			return restError_js_1.isRestError;
		}
	});
	var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
	Object.defineProperty(exports, "decompressResponsePolicy", {
		enumerable: true,
		get: function() {
			return decompressResponsePolicy_js_1.decompressResponsePolicy;
		}
	});
	Object.defineProperty(exports, "decompressResponsePolicyName", {
		enumerable: true,
		get: function() {
			return decompressResponsePolicy_js_1.decompressResponsePolicyName;
		}
	});
	var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy();
	Object.defineProperty(exports, "exponentialRetryPolicy", {
		enumerable: true,
		get: function() {
			return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
		}
	});
	Object.defineProperty(exports, "exponentialRetryPolicyName", {
		enumerable: true,
		get: function() {
			return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
		}
	});
	var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
	Object.defineProperty(exports, "setClientRequestIdPolicy", {
		enumerable: true,
		get: function() {
			return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
		}
	});
	Object.defineProperty(exports, "setClientRequestIdPolicyName", {
		enumerable: true,
		get: function() {
			return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
		}
	});
	var logPolicy_js_1 = require_logPolicy();
	Object.defineProperty(exports, "logPolicy", {
		enumerable: true,
		get: function() {
			return logPolicy_js_1.logPolicy;
		}
	});
	Object.defineProperty(exports, "logPolicyName", {
		enumerable: true,
		get: function() {
			return logPolicy_js_1.logPolicyName;
		}
	});
	var multipartPolicy_js_1 = require_multipartPolicy();
	Object.defineProperty(exports, "multipartPolicy", {
		enumerable: true,
		get: function() {
			return multipartPolicy_js_1.multipartPolicy;
		}
	});
	Object.defineProperty(exports, "multipartPolicyName", {
		enumerable: true,
		get: function() {
			return multipartPolicy_js_1.multipartPolicyName;
		}
	});
	var proxyPolicy_js_1 = require_proxyPolicy();
	Object.defineProperty(exports, "proxyPolicy", {
		enumerable: true,
		get: function() {
			return proxyPolicy_js_1.proxyPolicy;
		}
	});
	Object.defineProperty(exports, "proxyPolicyName", {
		enumerable: true,
		get: function() {
			return proxyPolicy_js_1.proxyPolicyName;
		}
	});
	Object.defineProperty(exports, "getDefaultProxySettings", {
		enumerable: true,
		get: function() {
			return proxyPolicy_js_1.getDefaultProxySettings;
		}
	});
	var redirectPolicy_js_1 = require_redirectPolicy();
	Object.defineProperty(exports, "redirectPolicy", {
		enumerable: true,
		get: function() {
			return redirectPolicy_js_1.redirectPolicy;
		}
	});
	Object.defineProperty(exports, "redirectPolicyName", {
		enumerable: true,
		get: function() {
			return redirectPolicy_js_1.redirectPolicyName;
		}
	});
	var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy();
	Object.defineProperty(exports, "systemErrorRetryPolicy", {
		enumerable: true,
		get: function() {
			return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
		}
	});
	Object.defineProperty(exports, "systemErrorRetryPolicyName", {
		enumerable: true,
		get: function() {
			return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
		}
	});
	var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy();
	Object.defineProperty(exports, "throttlingRetryPolicy", {
		enumerable: true,
		get: function() {
			return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
		}
	});
	Object.defineProperty(exports, "throttlingRetryPolicyName", {
		enumerable: true,
		get: function() {
			return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
		}
	});
	var retryPolicy_js_1 = require_retryPolicy();
	Object.defineProperty(exports, "retryPolicy", {
		enumerable: true,
		get: function() {
			return retryPolicy_js_1.retryPolicy;
		}
	});
	var tracingPolicy_js_1 = require_tracingPolicy();
	Object.defineProperty(exports, "tracingPolicy", {
		enumerable: true,
		get: function() {
			return tracingPolicy_js_1.tracingPolicy;
		}
	});
	Object.defineProperty(exports, "tracingPolicyName", {
		enumerable: true,
		get: function() {
			return tracingPolicy_js_1.tracingPolicyName;
		}
	});
	var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
	Object.defineProperty(exports, "defaultRetryPolicy", {
		enumerable: true,
		get: function() {
			return defaultRetryPolicy_js_1.defaultRetryPolicy;
		}
	});
	var userAgentPolicy_js_1 = require_userAgentPolicy();
	Object.defineProperty(exports, "userAgentPolicy", {
		enumerable: true,
		get: function() {
			return userAgentPolicy_js_1.userAgentPolicy;
		}
	});
	Object.defineProperty(exports, "userAgentPolicyName", {
		enumerable: true,
		get: function() {
			return userAgentPolicy_js_1.userAgentPolicyName;
		}
	});
	var tlsPolicy_js_1 = require_tlsPolicy();
	Object.defineProperty(exports, "tlsPolicy", {
		enumerable: true,
		get: function() {
			return tlsPolicy_js_1.tlsPolicy;
		}
	});
	Object.defineProperty(exports, "tlsPolicyName", {
		enumerable: true,
		get: function() {
			return tlsPolicy_js_1.tlsPolicyName;
		}
	});
	var formDataPolicy_js_1 = require_formDataPolicy();
	Object.defineProperty(exports, "formDataPolicy", {
		enumerable: true,
		get: function() {
			return formDataPolicy_js_1.formDataPolicy;
		}
	});
	Object.defineProperty(exports, "formDataPolicyName", {
		enumerable: true,
		get: function() {
			return formDataPolicy_js_1.formDataPolicyName;
		}
	});
	var bearerTokenAuthenticationPolicy_js_1 = require_bearerTokenAuthenticationPolicy();
	Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", {
		enumerable: true,
		get: function() {
			return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
		}
	});
	Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", {
		enumerable: true,
		get: function() {
			return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
		}
	});
	var ndJsonPolicy_js_1 = require_ndJsonPolicy();
	Object.defineProperty(exports, "ndJsonPolicy", {
		enumerable: true,
		get: function() {
			return ndJsonPolicy_js_1.ndJsonPolicy;
		}
	});
	Object.defineProperty(exports, "ndJsonPolicyName", {
		enumerable: true,
		get: function() {
			return ndJsonPolicy_js_1.ndJsonPolicyName;
		}
	});
	var auxiliaryAuthenticationHeaderPolicy_js_1 = require_auxiliaryAuthenticationHeaderPolicy();
	Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", {
		enumerable: true,
		get: function() {
			return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
		}
	});
	Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", {
		enumerable: true,
		get: function() {
			return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
		}
	});
	var agentPolicy_js_1 = require_agentPolicy();
	Object.defineProperty(exports, "agentPolicy", {
		enumerable: true,
		get: function() {
			return agentPolicy_js_1.agentPolicy;
		}
	});
	Object.defineProperty(exports, "agentPolicyName", {
		enumerable: true,
		get: function() {
			return agentPolicy_js_1.agentPolicyName;
		}
	});
	var file_js_1 = require_file$1();
	Object.defineProperty(exports, "createFile", {
		enumerable: true,
		get: function() {
			return file_js_1.createFile;
		}
	});
	Object.defineProperty(exports, "createFileFromStream", {
		enumerable: true,
		get: function() {
			return file_js_1.createFileFromStream;
		}
	});
}));
var require_azureKeyCredential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AzureKeyCredential = void 0;
	var AzureKeyCredential = class {
		_key;
		get key() {
			return this._key;
		}
		constructor(key) {
			if (!key) throw new Error("key must be a non-empty string");
			this._key = key;
		}
		update(newKey) {
			this._key = newKey;
		}
	};
	exports.AzureKeyCredential = AzureKeyCredential;
}));
var require_keyCredential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isKeyCredential = isKeyCredential;
	var core_util_1 = require_commonjs$14();
	function isKeyCredential(credential) {
		return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
	}
}));
var require_azureNamedKeyCredential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AzureNamedKeyCredential = void 0;
	exports.isNamedKeyCredential = isNamedKeyCredential;
	var core_util_1 = require_commonjs$14();
	var AzureNamedKeyCredential = class {
		_key;
		_name;
		get key() {
			return this._key;
		}
		get name() {
			return this._name;
		}
		constructor(name$1, key) {
			if (!name$1 || !key) throw new TypeError("name and key must be non-empty strings");
			this._name = name$1;
			this._key = key;
		}
		update(newName, newKey) {
			if (!newName || !newKey) throw new TypeError("newName and newKey must be non-empty strings");
			this._name = newName;
			this._key = newKey;
		}
	};
	exports.AzureNamedKeyCredential = AzureNamedKeyCredential;
	function isNamedKeyCredential(credential) {
		return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
	}
}));
var require_azureSASCredential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AzureSASCredential = void 0;
	exports.isSASCredential = isSASCredential;
	var core_util_1 = require_commonjs$14();
	var AzureSASCredential = class {
		_signature;
		get signature() {
			return this._signature;
		}
		constructor(signature) {
			if (!signature) throw new Error("shared access signature must be a non-empty string");
			this._signature = signature;
		}
		update(newSignature) {
			if (!newSignature) throw new Error("shared access signature must be a non-empty string");
			this._signature = newSignature;
		}
	};
	exports.AzureSASCredential = AzureSASCredential;
	function isSASCredential(credential) {
		return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
	}
}));
var require_tokenCredential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isBearerToken = isBearerToken;
	exports.isPopToken = isPopToken;
	exports.isTokenCredential = isTokenCredential;
	function isBearerToken(accessToken) {
		return !accessToken.tokenType || accessToken.tokenType === "Bearer";
	}
	function isPopToken(accessToken) {
		return accessToken.tokenType === "pop";
	}
	function isTokenCredential(credential) {
		const castCredential = credential;
		return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
	}
}));
var require_commonjs$11 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isTokenCredential = exports.isSASCredential = exports.AzureSASCredential = exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = exports.isKeyCredential = exports.AzureKeyCredential = void 0;
	var azureKeyCredential_js_1 = require_azureKeyCredential();
	Object.defineProperty(exports, "AzureKeyCredential", {
		enumerable: true,
		get: function() {
			return azureKeyCredential_js_1.AzureKeyCredential;
		}
	});
	var keyCredential_js_1 = require_keyCredential();
	Object.defineProperty(exports, "isKeyCredential", {
		enumerable: true,
		get: function() {
			return keyCredential_js_1.isKeyCredential;
		}
	});
	var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
	Object.defineProperty(exports, "AzureNamedKeyCredential", {
		enumerable: true,
		get: function() {
			return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
		}
	});
	Object.defineProperty(exports, "isNamedKeyCredential", {
		enumerable: true,
		get: function() {
			return azureNamedKeyCredential_js_1.isNamedKeyCredential;
		}
	});
	var azureSASCredential_js_1 = require_azureSASCredential();
	Object.defineProperty(exports, "AzureSASCredential", {
		enumerable: true,
		get: function() {
			return azureSASCredential_js_1.AzureSASCredential;
		}
	});
	Object.defineProperty(exports, "isSASCredential", {
		enumerable: true,
		get: function() {
			return azureSASCredential_js_1.isSASCredential;
		}
	});
	var tokenCredential_js_1 = require_tokenCredential();
	Object.defineProperty(exports, "isTokenCredential", {
		enumerable: true,
		get: function() {
			return tokenCredential_js_1.isTokenCredential;
		}
	});
}));
var require_disableKeepAlivePolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.disableKeepAlivePolicyName = void 0;
	exports.createDisableKeepAlivePolicy = createDisableKeepAlivePolicy;
	exports.pipelineContainsDisableKeepAlivePolicy = pipelineContainsDisableKeepAlivePolicy;
	exports.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
	function createDisableKeepAlivePolicy() {
		return {
			name: exports.disableKeepAlivePolicyName,
			async sendRequest(request$1, next) {
				request$1.disableKeepAlive = true;
				return next(request$1);
			}
		};
	}
	function pipelineContainsDisableKeepAlivePolicy(pipeline) {
		return pipeline.getOrderedPolicies().some((policy) => policy.name === exports.disableKeepAlivePolicyName);
	}
}));
var require_base64 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.encodeString = encodeString;
	exports.encodeByteArray = encodeByteArray;
	exports.decodeString = decodeString;
	exports.decodeStringToString = decodeStringToString;
	function encodeString(value$1) {
		return Buffer.from(value$1).toString("base64");
	}
	function encodeByteArray(value$1) {
		return (value$1 instanceof Buffer ? value$1 : Buffer.from(value$1.buffer)).toString("base64");
	}
	function decodeString(value$1) {
		return Buffer.from(value$1, "base64");
	}
	function decodeStringToString(value$1) {
		return Buffer.from(value$1, "base64").toString();
	}
}));
var require_interfaces$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XML_CHARKEY = exports.XML_ATTRKEY = void 0;
	exports.XML_ATTRKEY = "$";
	exports.XML_CHARKEY = "_";
}));
var require_utils$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isPrimitiveBody = isPrimitiveBody;
	exports.isDuration = isDuration;
	exports.isValidUuid = isValidUuid;
	exports.flattenResponse = flattenResponse;
	function isPrimitiveBody(value$1, mapperTypeName) {
		return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean" || mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || value$1 === void 0 || value$1 === null);
	}
	var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
	function isDuration(value$1) {
		return validateISODuration.test(value$1);
	}
	var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
	function isValidUuid(uuid) {
		return validUuidRegex.test(uuid);
	}
	function handleNullableResponseAndWrappableBody(responseObject) {
		const combinedHeadersAndBody = {
			...responseObject.headers,
			...responseObject.body
		};
		if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) return responseObject.shouldWrapBody ? { body: null } : null;
		else return responseObject.shouldWrapBody ? {
			...responseObject.headers,
			body: responseObject.body
		} : combinedHeadersAndBody;
	}
	function flattenResponse(fullResponse, responseSpec) {
		const parsedHeaders = fullResponse.parsedHeaders;
		if (fullResponse.request.method === "HEAD") return {
			...parsedHeaders,
			body: fullResponse.parsedBody
		};
		const bodyMapper = responseSpec && responseSpec.bodyMapper;
		const isNullable = Boolean(bodyMapper?.nullable);
		const expectedBodyTypeName = bodyMapper?.type.name;
		if (expectedBodyTypeName === "Stream") return {
			...parsedHeaders,
			blobBody: fullResponse.blobBody,
			readableStreamBody: fullResponse.readableStreamBody
		};
		const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
		const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
		if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
			const arrayResponse = fullResponse.parsedBody ?? [];
			for (const key of Object.keys(modelProperties)) if (modelProperties[key].serializedName) arrayResponse[key] = fullResponse.parsedBody?.[key];
			if (parsedHeaders) for (const key of Object.keys(parsedHeaders)) arrayResponse[key] = parsedHeaders[key];
			return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
		}
		return handleNullableResponseAndWrappableBody({
			body: fullResponse.parsedBody,
			headers: parsedHeaders,
			hasNullableType: isNullable,
			shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
		});
	}
}));
var require_serializer = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MapperTypeNames = void 0;
	exports.createSerializer = createSerializer;
	var base64 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importStar(require_base64());
	var interfaces_js_1 = require_interfaces$1();
	var utils_js_1 = require_utils$2();
	var SerializerImpl = class {
		modelMappers;
		isXML;
		constructor(modelMappers = {}, isXML = false) {
			this.modelMappers = modelMappers;
			this.isXML = isXML;
		}
		validateConstraints(mapper, value$1, objectName) {
			const failValidation = (constraintName, constraintValue) => {
				throw new Error(`"${objectName}" with value "${value$1}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
			};
			if (mapper.constraints && value$1 !== void 0 && value$1 !== null) {
				const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
				if (ExclusiveMaximum !== void 0 && value$1 >= ExclusiveMaximum) failValidation("ExclusiveMaximum", ExclusiveMaximum);
				if (ExclusiveMinimum !== void 0 && value$1 <= ExclusiveMinimum) failValidation("ExclusiveMinimum", ExclusiveMinimum);
				if (InclusiveMaximum !== void 0 && value$1 > InclusiveMaximum) failValidation("InclusiveMaximum", InclusiveMaximum);
				if (InclusiveMinimum !== void 0 && value$1 < InclusiveMinimum) failValidation("InclusiveMinimum", InclusiveMinimum);
				if (MaxItems !== void 0 && value$1.length > MaxItems) failValidation("MaxItems", MaxItems);
				if (MaxLength !== void 0 && value$1.length > MaxLength) failValidation("MaxLength", MaxLength);
				if (MinItems !== void 0 && value$1.length < MinItems) failValidation("MinItems", MinItems);
				if (MinLength !== void 0 && value$1.length < MinLength) failValidation("MinLength", MinLength);
				if (MultipleOf !== void 0 && value$1 % MultipleOf !== 0) failValidation("MultipleOf", MultipleOf);
				if (Pattern) {
					const pattern$1 = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
					if (typeof value$1 !== "string" || value$1.match(pattern$1) === null) failValidation("Pattern", Pattern);
				}
				if (UniqueItems && value$1.some((item, i, ar) => ar.indexOf(item) !== i)) failValidation("UniqueItems", UniqueItems);
			}
		}
		serialize(mapper, object, objectName, options = { xml: {} }) {
			const updatedOptions = { xml: {
				rootName: options.xml.rootName ?? "",
				includeRoot: options.xml.includeRoot ?? false,
				xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
			} };
			let payload = {};
			const mapperType = mapper.type.name;
			if (!objectName) objectName = mapper.serializedName;
			if (mapperType.match(/^Sequence$/i) !== null) payload = [];
			if (mapper.isConstant) object = mapper.defaultValue;
			const { required, nullable } = mapper;
			if (required && nullable && object === void 0) throw new Error(`${objectName} cannot be undefined.`);
			if (required && !nullable && (object === void 0 || object === null)) throw new Error(`${objectName} cannot be null or undefined.`);
			if (!required && nullable === false && object === null) throw new Error(`${objectName} cannot be null.`);
			if (object === void 0 || object === null) payload = object;
			else if (mapperType.match(/^any$/i) !== null) payload = object;
			else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) payload = serializeBasicTypes(mapperType, objectName, object);
			else if (mapperType.match(/^Enum$/i) !== null) payload = serializeEnumType(objectName, mapper.type.allowedValues, object);
			else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) payload = serializeDateTypes(mapperType, object, objectName);
			else if (mapperType.match(/^ByteArray$/i) !== null) payload = serializeByteArrayType(objectName, object);
			else if (mapperType.match(/^Base64Url$/i) !== null) payload = serializeBase64UrlType(objectName, object);
			else if (mapperType.match(/^Sequence$/i) !== null) payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
			else if (mapperType.match(/^Dictionary$/i) !== null) payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
			else if (mapperType.match(/^Composite$/i) !== null) payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
			return payload;
		}
		deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
			const updatedOptions = {
				xml: {
					rootName: options.xml.rootName ?? "",
					includeRoot: options.xml.includeRoot ?? false,
					xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
				},
				ignoreUnknownProperties: options.ignoreUnknownProperties ?? false
			};
			if (responseBody === void 0 || responseBody === null) {
				if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) responseBody = [];
				if (mapper.defaultValue !== void 0) responseBody = mapper.defaultValue;
				return responseBody;
			}
			let payload;
			const mapperType = mapper.type.name;
			if (!objectName) objectName = mapper.serializedName;
			if (mapperType.match(/^Composite$/i) !== null) payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
			else {
				if (this.isXML) {
					const xmlCharKey = updatedOptions.xml.xmlCharKey;
					if (responseBody[interfaces_js_1.XML_ATTRKEY] !== void 0 && responseBody[xmlCharKey] !== void 0) responseBody = responseBody[xmlCharKey];
				}
				if (mapperType.match(/^Number$/i) !== null) {
					payload = parseFloat(responseBody);
					if (isNaN(payload)) payload = responseBody;
				} else if (mapperType.match(/^Boolean$/i) !== null) if (responseBody === "true") payload = true;
				else if (responseBody === "false") payload = false;
				else payload = responseBody;
				else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) payload = responseBody;
				else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) payload = new Date(responseBody);
				else if (mapperType.match(/^UnixTime$/i) !== null) payload = unixTimeToDate(responseBody);
				else if (mapperType.match(/^ByteArray$/i) !== null) payload = base64.decodeString(responseBody);
				else if (mapperType.match(/^Base64Url$/i) !== null) payload = base64UrlToByteArray(responseBody);
				else if (mapperType.match(/^Sequence$/i) !== null) payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
				else if (mapperType.match(/^Dictionary$/i) !== null) payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
			}
			if (mapper.isConstant) payload = mapper.defaultValue;
			return payload;
		}
	};
	function createSerializer(modelMappers = {}, isXML = false) {
		return new SerializerImpl(modelMappers, isXML);
	}
	function trimEnd(str, ch) {
		let len = str.length;
		while (len - 1 >= 0 && str[len - 1] === ch) --len;
		return str.substr(0, len);
	}
	function bufferToBase64Url(buffer$2) {
		if (!buffer$2) return;
		if (!(buffer$2 instanceof Uint8Array)) throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
		return trimEnd(base64.encodeByteArray(buffer$2), "=").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function base64UrlToByteArray(str) {
		if (!str) return;
		if (str && typeof str.valueOf() !== "string") throw new Error("Please provide an input of type string for converting to Uint8Array");
		str = str.replace(/-/g, "+").replace(/_/g, "/");
		return base64.decodeString(str);
	}
	function splitSerializeName(prop) {
		const classes = [];
		let partialclass = "";
		if (prop) {
			const subwords = prop.split(".");
			for (const item of subwords) if (item.charAt(item.length - 1) === "\\") partialclass += item.substr(0, item.length - 1) + ".";
			else {
				partialclass += item;
				classes.push(partialclass);
				partialclass = "";
			}
		}
		return classes;
	}
	function dateToUnixTime(d) {
		if (!d) return;
		if (typeof d.valueOf() === "string") d = new Date(d);
		return Math.floor(d.getTime() / 1e3);
	}
	function unixTimeToDate(n$1) {
		if (!n$1) return;
		return /* @__PURE__ */ new Date(n$1 * 1e3);
	}
	function serializeBasicTypes(typeName, objectName, value$1) {
		if (value$1 !== null && value$1 !== void 0) {
			if (typeName.match(/^Number$/i) !== null) {
				if (typeof value$1 !== "number") throw new Error(`${objectName} with value ${value$1} must be of type number.`);
			} else if (typeName.match(/^String$/i) !== null) {
				if (typeof value$1.valueOf() !== "string") throw new Error(`${objectName} with value "${value$1}" must be of type string.`);
			} else if (typeName.match(/^Uuid$/i) !== null) {
				if (!(typeof value$1.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value$1))) throw new Error(`${objectName} with value "${value$1}" must be of type string and a valid uuid.`);
			} else if (typeName.match(/^Boolean$/i) !== null) {
				if (typeof value$1 !== "boolean") throw new Error(`${objectName} with value ${value$1} must be of type boolean.`);
			} else if (typeName.match(/^Stream$/i) !== null) {
				const objectType = typeof value$1;
				if (objectType !== "string" && typeof value$1.pipe !== "function" && typeof value$1.tee !== "function" && !(value$1 instanceof ArrayBuffer) && !ArrayBuffer.isView(value$1) && !((typeof Blob === "function" || typeof Blob === "object") && value$1 instanceof Blob) && objectType !== "function") throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
			}
		}
		return value$1;
	}
	function serializeEnumType(objectName, allowedValues, value$1) {
		if (!allowedValues) throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
		if (!allowedValues.some((item) => {
			if (typeof item.valueOf() === "string") return item.toLowerCase() === value$1.toLowerCase();
			return item === value$1;
		})) throw new Error(`${value$1} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
		return value$1;
	}
	function serializeByteArrayType(objectName, value$1) {
		if (value$1 !== void 0 && value$1 !== null) {
			if (!(value$1 instanceof Uint8Array)) throw new Error(`${objectName} must be of type Uint8Array.`);
			value$1 = base64.encodeByteArray(value$1);
		}
		return value$1;
	}
	function serializeBase64UrlType(objectName, value$1) {
		if (value$1 !== void 0 && value$1 !== null) {
			if (!(value$1 instanceof Uint8Array)) throw new Error(`${objectName} must be of type Uint8Array.`);
			value$1 = bufferToBase64Url(value$1);
		}
		return value$1;
	}
	function serializeDateTypes(typeName, value$1, objectName) {
		if (value$1 !== void 0 && value$1 !== null) {
			if (typeName.match(/^Date$/i) !== null) {
				if (!(value$1 instanceof Date || typeof value$1.valueOf() === "string" && !isNaN(Date.parse(value$1)))) throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
				value$1 = value$1 instanceof Date ? value$1.toISOString().substring(0, 10) : new Date(value$1).toISOString().substring(0, 10);
			} else if (typeName.match(/^DateTime$/i) !== null) {
				if (!(value$1 instanceof Date || typeof value$1.valueOf() === "string" && !isNaN(Date.parse(value$1)))) throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
				value$1 = value$1 instanceof Date ? value$1.toISOString() : new Date(value$1).toISOString();
			} else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
				if (!(value$1 instanceof Date || typeof value$1.valueOf() === "string" && !isNaN(Date.parse(value$1)))) throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
				value$1 = value$1 instanceof Date ? value$1.toUTCString() : new Date(value$1).toUTCString();
			} else if (typeName.match(/^UnixTime$/i) !== null) {
				if (!(value$1 instanceof Date || typeof value$1.valueOf() === "string" && !isNaN(Date.parse(value$1)))) throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
				value$1 = dateToUnixTime(value$1);
			} else if (typeName.match(/^TimeSpan$/i) !== null) {
				if (!(0, utils_js_1.isDuration)(value$1)) throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value$1}".`);
			}
		}
		return value$1;
	}
	function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
		if (!Array.isArray(object)) throw new Error(`${objectName} must be of type Array.`);
		let elementType = mapper.type.element;
		if (!elementType || typeof elementType !== "object") throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
		if (elementType.type.name === "Composite" && elementType.type.className) elementType = serializer.modelMappers[elementType.type.className] ?? elementType;
		const tempArray = [];
		for (let i = 0; i < object.length; i++) {
			const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
			if (isXml && elementType.xmlNamespace) {
				const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
				if (elementType.type.name === "Composite") {
					tempArray[i] = { ...serializedValue };
					tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
				} else {
					tempArray[i] = {};
					tempArray[i][options.xml.xmlCharKey] = serializedValue;
					tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
				}
			} else tempArray[i] = serializedValue;
		}
		return tempArray;
	}
	function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
		if (typeof object !== "object") throw new Error(`${objectName} must be of type object.`);
		const valueType = mapper.type.value;
		if (!valueType || typeof valueType !== "object") throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
		const tempDictionary = {};
		for (const key of Object.keys(object)) tempDictionary[key] = getXmlObjectValue(valueType, serializer.serialize(valueType, object[key], objectName, options), isXml, options);
		if (isXml && mapper.xmlNamespace) {
			const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
			const result = tempDictionary;
			result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
			return result;
		}
		return tempDictionary;
	}
	function resolveAdditionalProperties(serializer, mapper, objectName) {
		const additionalProperties = mapper.type.additionalProperties;
		if (!additionalProperties && mapper.type.className) return resolveReferencedMapper(serializer, mapper, objectName)?.type.additionalProperties;
		return additionalProperties;
	}
	function resolveReferencedMapper(serializer, mapper, objectName) {
		const className = mapper.type.className;
		if (!className) throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
		return serializer.modelMappers[className];
	}
	function resolveModelProperties(serializer, mapper, objectName) {
		let modelProps = mapper.type.modelProperties;
		if (!modelProps) {
			const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
			if (!modelMapper) throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
			modelProps = modelMapper?.type.modelProperties;
			if (!modelProps) throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
		}
		return modelProps;
	}
	function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
		if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
		if (object !== void 0 && object !== null) {
			const payload = {};
			const modelProps = resolveModelProperties(serializer, mapper, objectName);
			for (const key of Object.keys(modelProps)) {
				const propertyMapper = modelProps[key];
				if (propertyMapper.readOnly) continue;
				let propName;
				let parentObject = payload;
				if (serializer.isXML) if (propertyMapper.xmlIsWrapped) propName = propertyMapper.xmlName;
				else propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
				else {
					const paths = splitSerializeName(propertyMapper.serializedName);
					propName = paths.pop();
					for (const pathName of paths) {
						const childObject = parentObject[pathName];
						if ((childObject === void 0 || childObject === null) && (object[key] !== void 0 && object[key] !== null || propertyMapper.defaultValue !== void 0)) parentObject[pathName] = {};
						parentObject = parentObject[pathName];
					}
				}
				if (parentObject !== void 0 && parentObject !== null) {
					if (isXml && mapper.xmlNamespace) {
						const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
						parentObject[interfaces_js_1.XML_ATTRKEY] = {
							...parentObject[interfaces_js_1.XML_ATTRKEY],
							[xmlnsKey]: mapper.xmlNamespace
						};
					}
					const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
					let toSerialize = object[key];
					const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
					if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === void 0 || toSerialize === null)) toSerialize = mapper.serializedName;
					const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
					if (serializedValue !== void 0 && propName !== void 0 && propName !== null) {
						const value$1 = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
						if (isXml && propertyMapper.xmlIsAttribute) {
							parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
							parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
						} else if (isXml && propertyMapper.xmlIsWrapped) parentObject[propName] = { [propertyMapper.xmlElementName]: value$1 };
						else parentObject[propName] = value$1;
					}
				}
			}
			const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
			if (additionalPropertiesMapper) {
				const propNames = Object.keys(modelProps);
				for (const clientPropName in object) if (propNames.every((pn) => pn !== clientPropName)) payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + "[\"" + clientPropName + "\"]", options);
			}
			return payload;
		}
		return object;
	}
	function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
		if (!isXml || !propertyMapper.xmlNamespace) return serializedValue;
		const xmlNamespace = { [propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns"]: propertyMapper.xmlNamespace };
		if (["Composite"].includes(propertyMapper.type.name)) if (serializedValue[interfaces_js_1.XML_ATTRKEY]) return serializedValue;
		else {
			const result$1 = { ...serializedValue };
			result$1[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
			return result$1;
		}
		const result = {};
		result[options.xml.xmlCharKey] = serializedValue;
		result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
		return result;
	}
	function isSpecialXmlProperty(propertyName, options) {
		return [interfaces_js_1.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
	}
	function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
		const xmlCharKey = options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY;
		if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
		const modelProps = resolveModelProperties(serializer, mapper, objectName);
		let instance = {};
		const handledPropertyNames = [];
		for (const key of Object.keys(modelProps)) {
			const propertyMapper = modelProps[key];
			const paths = splitSerializeName(modelProps[key].serializedName);
			handledPropertyNames.push(paths[0]);
			const { serializedName, xmlName, xmlElementName } = propertyMapper;
			let propertyObjectName = objectName;
			if (serializedName !== "" && serializedName !== void 0) propertyObjectName = objectName + "." + serializedName;
			const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
			if (headerCollectionPrefix) {
				const dictionary = {};
				for (const headerKey of Object.keys(responseBody)) {
					if (headerKey.startsWith(headerCollectionPrefix)) dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
					handledPropertyNames.push(headerKey);
				}
				instance[key] = dictionary;
			} else if (serializer.isXML) if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options);
			else if (propertyMapper.xmlIsMsText) {
				if (responseBody[xmlCharKey] !== void 0) instance[key] = responseBody[xmlCharKey];
				else if (typeof responseBody === "string") instance[key] = responseBody;
			} else {
				const propertyName = xmlElementName || xmlName || serializedName;
				if (propertyMapper.xmlIsWrapped) {
					const elementList = responseBody[xmlName]?.[xmlElementName] ?? [];
					instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
					handledPropertyNames.push(xmlName);
				} else {
					const property = responseBody[propertyName];
					instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
					handledPropertyNames.push(propertyName);
				}
			}
			else {
				let propertyInstance;
				let res = responseBody;
				let steps = 0;
				for (const item of paths) {
					if (!res) break;
					steps++;
					res = res[item];
				}
				if (res === null && steps < paths.length) res = void 0;
				propertyInstance = res;
				const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
				if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === void 0 || propertyInstance === null)) propertyInstance = mapper.serializedName;
				let serializedValue;
				if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
					propertyInstance = responseBody[key];
					const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
					for (const [k, v] of Object.entries(instance)) if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) arrayInstance[k] = v;
					instance = arrayInstance;
				} else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
					serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
					instance[key] = serializedValue;
				}
			}
		}
		const additionalPropertiesMapper = mapper.type.additionalProperties;
		if (additionalPropertiesMapper) {
			const isAdditionalProperty = (responsePropName) => {
				for (const clientPropName in modelProps) if (splitSerializeName(modelProps[clientPropName].serializedName)[0] === responsePropName) return false;
				return true;
			};
			for (const responsePropName in responseBody) if (isAdditionalProperty(responsePropName)) instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + "[\"" + responsePropName + "\"]", options);
		} else if (responseBody && !options.ignoreUnknownProperties) {
			for (const key of Object.keys(responseBody)) if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) instance[key] = responseBody[key];
		}
		return instance;
	}
	function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
		const value$1 = mapper.type.value;
		if (!value$1 || typeof value$1 !== "object") throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
		if (responseBody) {
			const tempDictionary = {};
			for (const key of Object.keys(responseBody)) tempDictionary[key] = serializer.deserialize(value$1, responseBody[key], objectName, options);
			return tempDictionary;
		}
		return responseBody;
	}
	function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
		let element = mapper.type.element;
		if (!element || typeof element !== "object") throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
		if (responseBody) {
			if (!Array.isArray(responseBody)) responseBody = [responseBody];
			if (element.type.name === "Composite" && element.type.className) element = serializer.modelMappers[element.type.className] ?? element;
			const tempArray = [];
			for (let i = 0; i < responseBody.length; i++) tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
			return tempArray;
		}
		return responseBody;
	}
	function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
		const typeNamesToCheck = [typeName];
		while (typeNamesToCheck.length) {
			const currentName = typeNamesToCheck.shift();
			const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
			if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) return discriminators[indexDiscriminator];
			else for (const [name$1, mapper] of Object.entries(discriminators)) if (name$1.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) typeNamesToCheck.push(mapper.type.className);
		}
	}
	function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
		const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
		if (polymorphicDiscriminator) {
			let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
			if (discriminatorName) {
				if (polymorphicPropertyName === "serializedName") discriminatorName = discriminatorName.replace(/\\/gi, "");
				const discriminatorValue = object[discriminatorName];
				const typeName = mapper.type.uberParent ?? mapper.type.className;
				if (typeof discriminatorValue === "string" && typeName) {
					const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
					if (polymorphicMapper) mapper = polymorphicMapper;
				}
			}
		}
		return mapper;
	}
	function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
		return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
	}
	function getPolymorphicDiscriminatorSafely(serializer, typeName) {
		return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
	}
	exports.MapperTypeNames = {
		Base64Url: "Base64Url",
		Boolean: "Boolean",
		ByteArray: "ByteArray",
		Composite: "Composite",
		Date: "Date",
		DateTime: "DateTime",
		DateTimeRfc1123: "DateTimeRfc1123",
		Dictionary: "Dictionary",
		Enum: "Enum",
		Number: "Number",
		Object: "Object",
		Sequence: "Sequence",
		String: "String",
		Stream: "Stream",
		TimeSpan: "TimeSpan",
		UnixTime: "UnixTime"
	};
}));
var require_state$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.state = void 0;
	exports.state = { operationRequestMap: /* @__PURE__ */ new WeakMap() };
}));
var require_operationHelpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
	exports.getOperationRequestInfo = getOperationRequestInfo;
	var state_js_1 = require_state$1();
	function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
		let parameterPath = parameter.parameterPath;
		const parameterMapper = parameter.mapper;
		let value$1;
		if (typeof parameterPath === "string") parameterPath = [parameterPath];
		if (Array.isArray(parameterPath)) {
			if (parameterPath.length > 0) if (parameterMapper.isConstant) value$1 = parameterMapper.defaultValue;
			else {
				let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
				if (!propertySearchResult.propertyFound && fallbackObject) propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
				let useDefaultValue = false;
				if (!propertySearchResult.propertyFound) useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
				value$1 = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
			}
		} else {
			if (parameterMapper.required) value$1 = {};
			for (const propertyName in parameterPath) {
				const propertyMapper = parameterMapper.type.modelProperties[propertyName];
				const propertyPath = parameterPath[propertyName];
				const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
					parameterPath: propertyPath,
					mapper: propertyMapper
				}, fallbackObject);
				if (propertyValue !== void 0) {
					if (!value$1) value$1 = {};
					value$1[propertyName] = propertyValue;
				}
			}
		}
		return value$1;
	}
	function getPropertyFromParameterPath(parent$1, parameterPath) {
		const result = { propertyFound: false };
		let i = 0;
		for (; i < parameterPath.length; ++i) {
			const parameterPathPart = parameterPath[i];
			if (parent$1 && parameterPathPart in parent$1) parent$1 = parent$1[parameterPathPart];
			else break;
		}
		if (i === parameterPath.length) {
			result.propertyValue = parent$1;
			result.propertyFound = true;
		}
		return result;
	}
	var originalRequestSymbol = Symbol.for("@azure/core-client original request");
	function hasOriginalRequest(request$1) {
		return originalRequestSymbol in request$1;
	}
	function getOperationRequestInfo(request$1) {
		if (hasOriginalRequest(request$1)) return getOperationRequestInfo(request$1[originalRequestSymbol]);
		let info = state_js_1.state.operationRequestMap.get(request$1);
		if (!info) {
			info = {};
			state_js_1.state.operationRequestMap.set(request$1, info);
		}
		return info;
	}
}));
var require_deserializationPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.deserializationPolicyName = void 0;
	exports.deserializationPolicy = deserializationPolicy;
	var interfaces_js_1 = require_interfaces$1();
	var core_rest_pipeline_1 = require_commonjs$12();
	var serializer_js_1 = require_serializer();
	var operationHelpers_js_1 = require_operationHelpers();
	var defaultJsonContentTypes = ["application/json", "text/json"];
	var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
	exports.deserializationPolicyName = "deserializationPolicy";
	function deserializationPolicy(options = {}) {
		const jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes;
		const xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes;
		const parseXML = options.parseXML;
		const serializerOptions = options.serializerOptions;
		const updatedOptions = { xml: {
			rootName: serializerOptions?.xml.rootName ?? "",
			includeRoot: serializerOptions?.xml.includeRoot ?? false,
			xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
		} };
		return {
			name: exports.deserializationPolicyName,
			async sendRequest(request$1, next) {
				return deserializeResponseBody(jsonContentTypes, xmlContentTypes, await next(request$1), updatedOptions, parseXML);
			}
		};
	}
	function getOperationResponseMap(parsedResponse) {
		let result;
		const request$1 = parsedResponse.request;
		const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request$1);
		const operationSpec = operationInfo?.operationSpec;
		if (operationSpec) if (!operationInfo?.operationResponseGetter) result = operationSpec.responses[parsedResponse.status];
		else result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);
		return result;
	}
	function shouldDeserializeResponse(parsedResponse) {
		const request$1 = parsedResponse.request;
		const shouldDeserialize = (0, operationHelpers_js_1.getOperationRequestInfo)(request$1)?.shouldDeserialize;
		let result;
		if (shouldDeserialize === void 0) result = true;
		else if (typeof shouldDeserialize === "boolean") result = shouldDeserialize;
		else result = shouldDeserialize(parsedResponse);
		return result;
	}
	async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
		const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
		if (!shouldDeserializeResponse(parsedResponse)) return parsedResponse;
		const operationSpec = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request)?.operationSpec;
		if (!operationSpec || !operationSpec.responses) return parsedResponse;
		const responseSpec = getOperationResponseMap(parsedResponse);
		const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
		if (error) throw error;
		else if (shouldReturnResponse) return parsedResponse;
		if (responseSpec) {
			if (responseSpec.bodyMapper) {
				let valueToDeserialize = parsedResponse.parsedBody;
				if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
				try {
					parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
				} catch (deserializeError) {
					throw new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
						statusCode: parsedResponse.status,
						request: parsedResponse.request,
						response: parsedResponse
					});
				}
			} else if (operationSpec.httpMethod === "HEAD") parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
			if (responseSpec.headersMapper) parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", {
				xml: {},
				ignoreUnknownProperties: true
			});
		}
		return parsedResponse;
	}
	function isOperationSpecEmpty(operationSpec) {
		const expectedStatusCodes = Object.keys(operationSpec.responses);
		return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
	}
	function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
		const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
		if (isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec) if (responseSpec) {
			if (!responseSpec.isError) return {
				error: null,
				shouldReturnResponse: false
			};
		} else return {
			error: null,
			shouldReturnResponse: false
		};
		const errorResponseSpec = responseSpec ?? operationSpec.responses.default;
		const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(parsedResponse.status) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
		const error = new core_rest_pipeline_1.RestError(initialErrorMessage, {
			statusCode: parsedResponse.status,
			request: parsedResponse.request,
			response: parsedResponse
		});
		if (!errorResponseSpec && !(parsedResponse.parsedBody?.error?.code && parsedResponse.parsedBody?.error?.message)) throw error;
		const defaultBodyMapper = errorResponseSpec?.bodyMapper;
		const defaultHeadersMapper = errorResponseSpec?.headersMapper;
		try {
			if (parsedResponse.parsedBody) {
				const parsedBody = parsedResponse.parsedBody;
				let deserializedError;
				if (defaultBodyMapper) {
					let valueToDeserialize = parsedBody;
					if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
						valueToDeserialize = [];
						const elementName = defaultBodyMapper.xmlElementName;
						if (typeof parsedBody === "object" && elementName) valueToDeserialize = parsedBody[elementName];
					}
					deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
				}
				const internalError = parsedBody.error || deserializedError || parsedBody;
				error.code = internalError.code;
				if (internalError.message) error.message = internalError.message;
				if (defaultBodyMapper) error.response.parsedBody = deserializedError;
			}
			if (parsedResponse.headers && defaultHeadersMapper) error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
		} catch (defaultError) {
			error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
		}
		return {
			error,
			shouldReturnResponse: false
		};
	}
	async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
		if (!operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) && operationResponse.bodyAsText) {
			const text = operationResponse.bodyAsText;
			const contentType = operationResponse.headers.get("Content-Type") || "";
			const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
			try {
				if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
					operationResponse.parsedBody = JSON.parse(text);
					return operationResponse;
				} else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
					if (!parseXML) throw new Error("Parsing XML not supported.");
					operationResponse.parsedBody = await parseXML(text, opts.xml);
					return operationResponse;
				}
			} catch (err) {
				const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
				const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
				throw new core_rest_pipeline_1.RestError(msg, {
					code: errCode,
					statusCode: operationResponse.status,
					request: operationResponse.request,
					response: operationResponse
				});
			}
		}
		return operationResponse;
	}
}));
var require_interfaceHelpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
	exports.getPathStringFromParameter = getPathStringFromParameter;
	var serializer_js_1 = require_serializer();
	function getStreamingResponseStatusCodes(operationSpec) {
		const result = /* @__PURE__ */ new Set();
		for (const statusCode in operationSpec.responses) {
			const operationResponse = operationSpec.responses[statusCode];
			if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) result.add(Number(statusCode));
		}
		return result;
	}
	function getPathStringFromParameter(parameter) {
		const { parameterPath, mapper } = parameter;
		let result;
		if (typeof parameterPath === "string") result = parameterPath;
		else if (Array.isArray(parameterPath)) result = parameterPath.join(".");
		else result = mapper.serializedName;
		return result;
	}
}));
var require_serializationPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.serializationPolicyName = void 0;
	exports.serializationPolicy = serializationPolicy;
	exports.serializeHeaders = serializeHeaders;
	exports.serializeRequestBody = serializeRequestBody;
	var interfaces_js_1 = require_interfaces$1();
	var operationHelpers_js_1 = require_operationHelpers();
	var serializer_js_1 = require_serializer();
	var interfaceHelpers_js_1 = require_interfaceHelpers();
	exports.serializationPolicyName = "serializationPolicy";
	function serializationPolicy(options = {}) {
		const stringifyXML = options.stringifyXML;
		return {
			name: exports.serializationPolicyName,
			async sendRequest(request$1, next) {
				const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request$1);
				const operationSpec = operationInfo?.operationSpec;
				const operationArguments = operationInfo?.operationArguments;
				if (operationSpec && operationArguments) {
					serializeHeaders(request$1, operationArguments, operationSpec);
					serializeRequestBody(request$1, operationArguments, operationSpec, stringifyXML);
				}
				return next(request$1);
			}
		};
	}
	function serializeHeaders(request$1, operationArguments, operationSpec) {
		if (operationSpec.headerParameters) for (const headerParameter of operationSpec.headerParameters) {
			let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
			if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
				headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
				const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
				if (headerCollectionPrefix) for (const key of Object.keys(headerValue)) request$1.headers.set(headerCollectionPrefix + key, headerValue[key]);
				else request$1.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
			}
		}
		const customHeaders = operationArguments.options?.requestOptions?.customHeaders;
		if (customHeaders) for (const customHeaderName of Object.keys(customHeaders)) request$1.headers.set(customHeaderName, customHeaders[customHeaderName]);
	}
	function serializeRequestBody(request$1, operationArguments, operationSpec, stringifyXML = function() {
		throw new Error("XML serialization unsupported!");
	}) {
		const serializerOptions = operationArguments.options?.serializerOptions;
		const updatedOptions = { xml: {
			rootName: serializerOptions?.xml.rootName ?? "",
			includeRoot: serializerOptions?.xml.includeRoot ?? false,
			xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
		} };
		const xmlCharKey = updatedOptions.xml.xmlCharKey;
		if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
			request$1.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
			const bodyMapper = operationSpec.requestBody.mapper;
			const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
			const typeName = bodyMapper.type.name;
			try {
				if (request$1.body !== void 0 && request$1.body !== null || nullable && request$1.body === null || required) {
					const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
					request$1.body = operationSpec.serializer.serialize(bodyMapper, request$1.body, requestBodyParameterPathString, updatedOptions);
					const isStream = typeName === serializer_js_1.MapperTypeNames.Stream;
					if (operationSpec.isXML) {
						const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
						const value$1 = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request$1.body, updatedOptions);
						if (typeName === serializer_js_1.MapperTypeNames.Sequence) request$1.body = stringifyXML(prepareXMLRootList(value$1, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
							rootName: xmlName || serializedName,
							xmlCharKey
						});
						else if (!isStream) request$1.body = stringifyXML(value$1, {
							rootName: xmlName || serializedName,
							xmlCharKey
						});
					} else if (typeName === serializer_js_1.MapperTypeNames.String && (operationSpec.contentType?.match("text/plain") || operationSpec.mediaType === "text")) return;
					else if (!isStream) request$1.body = JSON.stringify(request$1.body);
				}
			} catch (error) {
				throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
			}
		} else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
			request$1.formData = {};
			for (const formDataParameter of operationSpec.formDataParameters) {
				const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
				if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
					const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
					request$1.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
				}
			}
		}
	}
	function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
		if (xmlNamespace && ![
			"Composite",
			"Sequence",
			"Dictionary"
		].includes(typeName)) {
			const result = {};
			result[options.xml.xmlCharKey] = serializedValue;
			result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
			return result;
		}
		return serializedValue;
	}
	function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
		if (!Array.isArray(obj)) obj = [obj];
		if (!xmlNamespaceKey || !xmlNamespace) return { [elementName]: obj };
		const result = { [elementName]: obj };
		result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
		return result;
	}
}));
var require_pipeline$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createClientPipeline = createClientPipeline;
	var deserializationPolicy_js_1 = require_deserializationPolicy();
	var core_rest_pipeline_1 = require_commonjs$12();
	var serializationPolicy_js_1 = require_serializationPolicy();
	function createClientPipeline(options = {}) {
		const pipeline = (0, core_rest_pipeline_1.createPipelineFromOptions)(options ?? {});
		if (options.credentialOptions) pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
			credential: options.credentialOptions.credential,
			scopes: options.credentialOptions.credentialScopes
		}));
		pipeline.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options.serializationOptions), { phase: "Serialize" });
		pipeline.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options.deserializationOptions), { phase: "Deserialize" });
		return pipeline;
	}
}));
var require_httpClientCache = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
	var core_rest_pipeline_1 = require_commonjs$12();
	var cachedHttpClient;
	function getCachedDefaultHttpClient() {
		if (!cachedHttpClient) cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
		return cachedHttpClient;
	}
}));
var require_urlHelpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRequestUrl = getRequestUrl;
	exports.appendQueryParams = appendQueryParams;
	var operationHelpers_js_1 = require_operationHelpers();
	var interfaceHelpers_js_1 = require_interfaceHelpers();
	var CollectionFormatToDelimiterMap = {
		CSV: ",",
		SSV: " ",
		Multi: "Multi",
		TSV: "	",
		Pipes: "|"
	};
	function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
		const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
		let isAbsolutePath = false;
		let requestUrl = replaceAll(baseUri, urlReplacements);
		if (operationSpec.path) {
			let path$5 = replaceAll(operationSpec.path, urlReplacements);
			if (operationSpec.path === "/{nextLink}" && path$5.startsWith("/")) path$5 = path$5.substring(1);
			if (isAbsoluteUrl(path$5)) {
				requestUrl = path$5;
				isAbsolutePath = true;
			} else requestUrl = appendPath(requestUrl, path$5);
		}
		const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
		requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
		return requestUrl;
	}
	function replaceAll(input, replacements) {
		let result = input;
		for (const [searchValue, replaceValue] of replacements) result = result.split(searchValue).join(replaceValue);
		return result;
	}
	function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
		const result = /* @__PURE__ */ new Map();
		if (operationSpec.urlParameters?.length) for (const urlParameter of operationSpec.urlParameters) {
			let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
			const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
			urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
			if (!urlParameter.skipEncoding) urlParameterValue = encodeURIComponent(urlParameterValue);
			result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
		}
		return result;
	}
	function isAbsoluteUrl(url) {
		return url.includes("://");
	}
	function appendPath(url, pathToAppend) {
		if (!pathToAppend) return url;
		const parsedUrl = new URL(url);
		let newPath = parsedUrl.pathname;
		if (!newPath.endsWith("/")) newPath = `${newPath}/`;
		if (pathToAppend.startsWith("/")) pathToAppend = pathToAppend.substring(1);
		const searchStart = pathToAppend.indexOf("?");
		if (searchStart !== -1) {
			const path$5 = pathToAppend.substring(0, searchStart);
			const search = pathToAppend.substring(searchStart + 1);
			newPath = newPath + path$5;
			if (search) parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
		} else newPath = newPath + pathToAppend;
		parsedUrl.pathname = newPath;
		return parsedUrl.toString();
	}
	function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
		const result = /* @__PURE__ */ new Map();
		const sequenceParams = /* @__PURE__ */ new Set();
		if (operationSpec.queryParameters?.length) for (const queryParameter of operationSpec.queryParameters) {
			if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) sequenceParams.add(queryParameter.mapper.serializedName);
			let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
			if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
				queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
				const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
				if (Array.isArray(queryParameterValue)) queryParameterValue = queryParameterValue.map((item) => {
					if (item === null || item === void 0) return "";
					return item;
				});
				if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) continue;
				else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) queryParameterValue = queryParameterValue.join(delimiter);
				if (!queryParameter.skipEncoding) if (Array.isArray(queryParameterValue)) queryParameterValue = queryParameterValue.map((item) => {
					return encodeURIComponent(item);
				});
				else queryParameterValue = encodeURIComponent(queryParameterValue);
				if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) queryParameterValue = queryParameterValue.join(delimiter);
				result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
			}
		}
		return {
			queryParams: result,
			sequenceParams
		};
	}
	function simpleParseQueryParams(queryString) {
		const result = /* @__PURE__ */ new Map();
		if (!queryString || queryString[0] !== "?") return result;
		queryString = queryString.slice(1);
		const pairs = queryString.split("&");
		for (const pair of pairs) {
			const [name$1, value$1] = pair.split("=", 2);
			const existingValue = result.get(name$1);
			if (existingValue) if (Array.isArray(existingValue)) existingValue.push(value$1);
			else result.set(name$1, [existingValue, value$1]);
			else result.set(name$1, value$1);
		}
		return result;
	}
	function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
		if (queryParams.size === 0) return url;
		const parsedUrl = new URL(url);
		const combinedParams = simpleParseQueryParams(parsedUrl.search);
		for (const [name$1, value$1] of queryParams) {
			const existingValue = combinedParams.get(name$1);
			if (Array.isArray(existingValue)) if (Array.isArray(value$1)) {
				existingValue.push(...value$1);
				const valueSet = new Set(existingValue);
				combinedParams.set(name$1, Array.from(valueSet));
			} else existingValue.push(value$1);
			else if (existingValue) {
				if (Array.isArray(value$1)) value$1.unshift(existingValue);
				else if (sequenceParams.has(name$1)) combinedParams.set(name$1, [existingValue, value$1]);
				if (!noOverwrite) combinedParams.set(name$1, value$1);
			} else combinedParams.set(name$1, value$1);
		}
		const searchPieces = [];
		for (const [name$1, value$1] of combinedParams) if (typeof value$1 === "string") searchPieces.push(`${name$1}=${value$1}`);
		else if (Array.isArray(value$1)) for (const subValue of value$1) searchPieces.push(`${name$1}=${subValue}`);
		else searchPieces.push(`${name$1}=${value$1}`);
		parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
		return parsedUrl.toString();
	}
}));
var require_log$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logger = void 0;
	exports.logger = (0, require_commonjs$16().createClientLogger)("core-client");
}));
var require_serviceClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ServiceClient = void 0;
	var core_rest_pipeline_1 = require_commonjs$12();
	var pipeline_js_1 = require_pipeline$1();
	var utils_js_1 = require_utils$2();
	var httpClientCache_js_1 = require_httpClientCache();
	var operationHelpers_js_1 = require_operationHelpers();
	var urlHelpers_js_1 = require_urlHelpers();
	var interfaceHelpers_js_1 = require_interfaceHelpers();
	var log_js_1 = require_log$3();
	var ServiceClient = class {
		_endpoint;
		_requestContentType;
		_allowInsecureConnection;
		_httpClient;
		pipeline;
		constructor(options = {}) {
			this._requestContentType = options.requestContentType;
			this._endpoint = options.endpoint ?? options.baseUri;
			if (options.baseUri) log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
			this._allowInsecureConnection = options.allowInsecureConnection;
			this._httpClient = options.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
			this.pipeline = options.pipeline || createDefaultPipeline(options);
			if (options.additionalPolicies?.length) for (const { policy, position } of options.additionalPolicies) {
				const afterPhase = position === "perRetry" ? "Sign" : void 0;
				this.pipeline.addPolicy(policy, { afterPhase });
			}
		}
		async sendRequest(request$1) {
			return this.pipeline.sendRequest(this._httpClient, request$1);
		}
		async sendOperationRequest(operationArguments, operationSpec) {
			const endpoint$1 = operationSpec.baseUrl || this._endpoint;
			if (!endpoint$1) throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
			const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint$1, operationSpec, operationArguments, this);
			const request$1 = (0, core_rest_pipeline_1.createPipelineRequest)({ url });
			request$1.method = operationSpec.httpMethod;
			const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request$1);
			operationInfo.operationSpec = operationSpec;
			operationInfo.operationArguments = operationArguments;
			const contentType = operationSpec.contentType || this._requestContentType;
			if (contentType && operationSpec.requestBody) request$1.headers.set("Content-Type", contentType);
			const options = operationArguments.options;
			if (options) {
				const requestOptions = options.requestOptions;
				if (requestOptions) {
					if (requestOptions.timeout) request$1.timeout = requestOptions.timeout;
					if (requestOptions.onUploadProgress) request$1.onUploadProgress = requestOptions.onUploadProgress;
					if (requestOptions.onDownloadProgress) request$1.onDownloadProgress = requestOptions.onDownloadProgress;
					if (requestOptions.shouldDeserialize !== void 0) operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
					if (requestOptions.allowInsecureConnection) request$1.allowInsecureConnection = true;
				}
				if (options.abortSignal) request$1.abortSignal = options.abortSignal;
				if (options.tracingOptions) request$1.tracingOptions = options.tracingOptions;
			}
			if (this._allowInsecureConnection) request$1.allowInsecureConnection = true;
			if (request$1.streamResponseStatusCodes === void 0) request$1.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
			try {
				const rawResponse = await this.sendRequest(request$1);
				const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
				if (options?.onResponse) options.onResponse(rawResponse, flatResponse);
				return flatResponse;
			} catch (error) {
				if (typeof error === "object" && error?.response) {
					const rawResponse = error.response;
					const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
					error.details = flatResponse;
					if (options?.onResponse) options.onResponse(rawResponse, flatResponse, error);
				}
				throw error;
			}
		}
	};
	exports.ServiceClient = ServiceClient;
	function createDefaultPipeline(options) {
		const credentialScopes = getCredentialScopes(options);
		const credentialOptions = options.credential && credentialScopes ? {
			credentialScopes,
			credential: options.credential
		} : void 0;
		return (0, pipeline_js_1.createClientPipeline)({
			...options,
			credentialOptions
		});
	}
	function getCredentialScopes(options) {
		if (options.credentialScopes) return options.credentialScopes;
		if (options.endpoint) return `${options.endpoint}/.default`;
		if (options.baseUri) return `${options.baseUri}/.default`;
		if (options.credential && !options.credentialScopes) throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
	}
}));
var require_authorizeRequestOnClaimChallenge = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseCAEChallenge = parseCAEChallenge;
	exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
	var log_js_1 = require_log$3();
	var base64_js_1 = require_base64();
	function parseCAEChallenge(challenges) {
		return `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x).map((challenge) => {
			return `${challenge.trim()}, `.split("\", ").filter((x) => x).map((keyValue) => (([key, value$1]) => ({ [key]: value$1 }))(keyValue.trim().split("=\""))).reduce((a, b) => ({
				...a,
				...b
			}), {});
		});
	}
	async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
		const { scopes, response } = onChallengeOptions;
		const logger = onChallengeOptions.logger || log_js_1.logger;
		const challenge = response.headers.get("WWW-Authenticate");
		if (!challenge) {
			logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
			return false;
		}
		const parsedChallenge = (parseCAEChallenge(challenge) || []).find((x) => x.claims);
		if (!parsedChallenge) {
			logger.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
			return false;
		}
		const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, { claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims) });
		if (!accessToken) return false;
		onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
		return true;
	}
}));
var require_authorizeRequestOnTenantChallenge = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.authorizeRequestOnTenantChallenge = void 0;
	var Constants = {
		DefaultScope: "/.default",
		HeaderConstants: { AUTHORIZATION: "authorization" }
	};
	function isUuid(text) {
		return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
	}
	var authorizeRequestOnTenantChallenge = async (challengeOptions) => {
		const requestOptions = requestToOptions(challengeOptions.request);
		const challenge = getChallenge(challengeOptions.response);
		if (challenge) {
			const challengeInfo = parseChallenge(challenge);
			const challengeScopes = buildScopes(challengeOptions, challengeInfo);
			const tenantId = extractTenantId(challengeInfo);
			if (!tenantId) return false;
			const accessToken = await challengeOptions.getAccessToken(challengeScopes, {
				...requestOptions,
				tenantId
			});
			if (!accessToken) return false;
			challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
			return true;
		}
		return false;
	};
	exports.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
	function extractTenantId(challengeInfo) {
		const tenantId = new URL(challengeInfo.authorization_uri).pathname.split("/")[1];
		if (tenantId && isUuid(tenantId)) return tenantId;
	}
	function buildScopes(challengeOptions, challengeInfo) {
		if (!challengeInfo.resource_id) return challengeOptions.scopes;
		const challengeScopes = new URL(challengeInfo.resource_id);
		challengeScopes.pathname = Constants.DefaultScope;
		let scope$2 = challengeScopes.toString();
		if (scope$2 === "https://disk.azure.com/.default") scope$2 = "https://disk.azure.com//.default";
		return [scope$2];
	}
	function getChallenge(response) {
		const challenge = response.headers.get("WWW-Authenticate");
		if (response.status === 401 && challenge) return challenge;
	}
	function parseChallenge(challenge) {
		return `${challenge.slice(7).trim()} `.split(" ").filter((x) => x).map((keyValue) => (([key, value$1]) => ({ [key]: value$1 }))(keyValue.trim().split("="))).reduce((a, b) => ({
			...a,
			...b
		}), {});
	}
	function requestToOptions(request$1) {
		return {
			abortSignal: request$1.abortSignal,
			requestOptions: { timeout: request$1.timeout },
			tracingOptions: request$1.tracingOptions
		};
	}
}));
var require_commonjs$10 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.authorizeRequestOnTenantChallenge = exports.authorizeRequestOnClaimChallenge = exports.serializationPolicyName = exports.serializationPolicy = exports.deserializationPolicyName = exports.deserializationPolicy = exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.createClientPipeline = exports.ServiceClient = exports.MapperTypeNames = exports.createSerializer = void 0;
	var serializer_js_1 = require_serializer();
	Object.defineProperty(exports, "createSerializer", {
		enumerable: true,
		get: function() {
			return serializer_js_1.createSerializer;
		}
	});
	Object.defineProperty(exports, "MapperTypeNames", {
		enumerable: true,
		get: function() {
			return serializer_js_1.MapperTypeNames;
		}
	});
	var serviceClient_js_1 = require_serviceClient();
	Object.defineProperty(exports, "ServiceClient", {
		enumerable: true,
		get: function() {
			return serviceClient_js_1.ServiceClient;
		}
	});
	var pipeline_js_1 = require_pipeline$1();
	Object.defineProperty(exports, "createClientPipeline", {
		enumerable: true,
		get: function() {
			return pipeline_js_1.createClientPipeline;
		}
	});
	var interfaces_js_1 = require_interfaces$1();
	Object.defineProperty(exports, "XML_ATTRKEY", {
		enumerable: true,
		get: function() {
			return interfaces_js_1.XML_ATTRKEY;
		}
	});
	Object.defineProperty(exports, "XML_CHARKEY", {
		enumerable: true,
		get: function() {
			return interfaces_js_1.XML_CHARKEY;
		}
	});
	var deserializationPolicy_js_1 = require_deserializationPolicy();
	Object.defineProperty(exports, "deserializationPolicy", {
		enumerable: true,
		get: function() {
			return deserializationPolicy_js_1.deserializationPolicy;
		}
	});
	Object.defineProperty(exports, "deserializationPolicyName", {
		enumerable: true,
		get: function() {
			return deserializationPolicy_js_1.deserializationPolicyName;
		}
	});
	var serializationPolicy_js_1 = require_serializationPolicy();
	Object.defineProperty(exports, "serializationPolicy", {
		enumerable: true,
		get: function() {
			return serializationPolicy_js_1.serializationPolicy;
		}
	});
	Object.defineProperty(exports, "serializationPolicyName", {
		enumerable: true,
		get: function() {
			return serializationPolicy_js_1.serializationPolicyName;
		}
	});
	var authorizeRequestOnClaimChallenge_js_1 = require_authorizeRequestOnClaimChallenge();
	Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", {
		enumerable: true,
		get: function() {
			return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
		}
	});
	var authorizeRequestOnTenantChallenge_js_1 = require_authorizeRequestOnTenantChallenge();
	Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", {
		enumerable: true,
		get: function() {
			return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
		}
	});
}));
var require_util$4 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpHeaders = void 0;
	exports.toPipelineRequest = toPipelineRequest;
	exports.toWebResourceLike = toWebResourceLike;
	exports.toHttpHeadersLike = toHttpHeadersLike;
	var core_rest_pipeline_1 = require_commonjs$12();
	var originalRequestSymbol = Symbol("Original PipelineRequest");
	var originalClientRequestSymbol = Symbol.for("@azure/core-client original request");
	function toPipelineRequest(webResource, options = {}) {
		const request$1 = webResource[originalRequestSymbol];
		const headers = (0, core_rest_pipeline_1.createHttpHeaders)(webResource.headers.toJson({ preserveCase: true }));
		if (request$1) {
			request$1.headers = headers;
			return request$1;
		} else {
			const newRequest = (0, core_rest_pipeline_1.createPipelineRequest)({
				url: webResource.url,
				method: webResource.method,
				headers,
				withCredentials: webResource.withCredentials,
				timeout: webResource.timeout,
				requestId: webResource.requestId,
				abortSignal: webResource.abortSignal,
				body: webResource.body,
				formData: webResource.formData,
				disableKeepAlive: !!webResource.keepAlive,
				onDownloadProgress: webResource.onDownloadProgress,
				onUploadProgress: webResource.onUploadProgress,
				proxySettings: webResource.proxySettings,
				streamResponseStatusCodes: webResource.streamResponseStatusCodes,
				agent: webResource.agent,
				requestOverrides: webResource.requestOverrides
			});
			if (options.originalRequest) newRequest[originalClientRequestSymbol] = options.originalRequest;
			return newRequest;
		}
	}
	function toWebResourceLike(request$1, options) {
		const originalRequest = options?.originalRequest ?? request$1;
		const webResource = {
			url: request$1.url,
			method: request$1.method,
			headers: toHttpHeadersLike(request$1.headers),
			withCredentials: request$1.withCredentials,
			timeout: request$1.timeout,
			requestId: request$1.headers.get("x-ms-client-request-id") || request$1.requestId,
			abortSignal: request$1.abortSignal,
			body: request$1.body,
			formData: request$1.formData,
			keepAlive: !!request$1.disableKeepAlive,
			onDownloadProgress: request$1.onDownloadProgress,
			onUploadProgress: request$1.onUploadProgress,
			proxySettings: request$1.proxySettings,
			streamResponseStatusCodes: request$1.streamResponseStatusCodes,
			agent: request$1.agent,
			requestOverrides: request$1.requestOverrides,
			clone() {
				throw new Error("Cannot clone a non-proxied WebResourceLike");
			},
			prepare() {
				throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
			},
			validateRequestProperties() {}
		};
		if (options?.createProxy) return new Proxy(webResource, {
			get(target, prop, receiver) {
				if (prop === originalRequestSymbol) return request$1;
				else if (prop === "clone") return () => {
					return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {
						createProxy: true,
						originalRequest
					});
				};
				return Reflect.get(target, prop, receiver);
			},
			set(target, prop, value$1, receiver) {
				if (prop === "keepAlive") request$1.disableKeepAlive = !value$1;
				if (typeof prop === "string" && [
					"url",
					"method",
					"withCredentials",
					"timeout",
					"requestId",
					"abortSignal",
					"body",
					"formData",
					"onDownloadProgress",
					"onUploadProgress",
					"proxySettings",
					"streamResponseStatusCodes",
					"agent",
					"requestOverrides"
				].includes(prop)) request$1[prop] = value$1;
				return Reflect.set(target, prop, value$1, receiver);
			}
		});
		else return webResource;
	}
	function toHttpHeadersLike(headers) {
		return new HttpHeaders(headers.toJSON({ preserveCase: true }));
	}
	function getHeaderKey(headerName) {
		return headerName.toLowerCase();
	}
	var HttpHeaders = class HttpHeaders {
		_headersMap;
		constructor(rawHeaders) {
			this._headersMap = {};
			if (rawHeaders) for (const headerName in rawHeaders) this.set(headerName, rawHeaders[headerName]);
		}
		set(headerName, headerValue) {
			this._headersMap[getHeaderKey(headerName)] = {
				name: headerName,
				value: headerValue.toString()
			};
		}
		get(headerName) {
			const header = this._headersMap[getHeaderKey(headerName)];
			return !header ? void 0 : header.value;
		}
		contains(headerName) {
			return !!this._headersMap[getHeaderKey(headerName)];
		}
		remove(headerName) {
			const result = this.contains(headerName);
			delete this._headersMap[getHeaderKey(headerName)];
			return result;
		}
		rawHeaders() {
			return this.toJson({ preserveCase: true });
		}
		headersArray() {
			const headers = [];
			for (const headerKey in this._headersMap) headers.push(this._headersMap[headerKey]);
			return headers;
		}
		headerNames() {
			const headerNames = [];
			const headers = this.headersArray();
			for (let i = 0; i < headers.length; ++i) headerNames.push(headers[i].name);
			return headerNames;
		}
		headerValues() {
			const headerValues = [];
			const headers = this.headersArray();
			for (let i = 0; i < headers.length; ++i) headerValues.push(headers[i].value);
			return headerValues;
		}
		toJson(options = {}) {
			const result = {};
			if (options.preserveCase) for (const headerKey in this._headersMap) {
				const header = this._headersMap[headerKey];
				result[header.name] = header.value;
			}
			else for (const headerKey in this._headersMap) {
				const header = this._headersMap[headerKey];
				result[getHeaderKey(header.name)] = header.value;
			}
			return result;
		}
		toString() {
			return JSON.stringify(this.toJson({ preserveCase: true }));
		}
		clone() {
			const resultPreservingCasing = {};
			for (const headerKey in this._headersMap) {
				const header = this._headersMap[headerKey];
				resultPreservingCasing[header.name] = header.value;
			}
			return new HttpHeaders(resultPreservingCasing);
		}
	};
	exports.HttpHeaders = HttpHeaders;
}));
var require_response = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toCompatResponse = toCompatResponse;
	exports.toPipelineResponse = toPipelineResponse;
	var core_rest_pipeline_1 = require_commonjs$12();
	var util_js_1 = require_util$4();
	var originalResponse = Symbol("Original FullOperationResponse");
	function toCompatResponse(response, options) {
		let request$1 = (0, util_js_1.toWebResourceLike)(response.request);
		let headers = (0, util_js_1.toHttpHeadersLike)(response.headers);
		if (options?.createProxy) return new Proxy(response, {
			get(target, prop, receiver) {
				if (prop === "headers") return headers;
				else if (prop === "request") return request$1;
				else if (prop === originalResponse) return response;
				return Reflect.get(target, prop, receiver);
			},
			set(target, prop, value$1, receiver) {
				if (prop === "headers") headers = value$1;
				else if (prop === "request") request$1 = value$1;
				return Reflect.set(target, prop, value$1, receiver);
			}
		});
		else return {
			...response,
			request: request$1,
			headers
		};
	}
	function toPipelineResponse(compatResponse) {
		const response = compatResponse[originalResponse];
		const headers = (0, core_rest_pipeline_1.createHttpHeaders)(compatResponse.headers.toJson({ preserveCase: true }));
		if (response) {
			response.headers = headers;
			return response;
		} else return {
			...compatResponse,
			headers,
			request: (0, util_js_1.toPipelineRequest)(compatResponse.request)
		};
	}
}));
var require_extendedClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ExtendedServiceClient = void 0;
	var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_client_1 = require_commonjs$10();
	var response_js_1 = require_response();
	var ExtendedServiceClient = class extends core_client_1.ServiceClient {
		constructor(options) {
			super(options);
			if (options.keepAliveOptions?.enable === false && !(0, disableKeepAlivePolicy_js_1.pipelineContainsDisableKeepAlivePolicy)(this.pipeline)) this.pipeline.addPolicy((0, disableKeepAlivePolicy_js_1.createDisableKeepAlivePolicy)());
			if (options.redirectOptions?.handleRedirects === false) this.pipeline.removePolicy({ name: core_rest_pipeline_1.redirectPolicyName });
		}
		async sendOperationRequest(operationArguments, operationSpec) {
			const userProvidedCallBack = operationArguments?.options?.onResponse;
			let lastResponse;
			function onResponse(rawResponse, flatResponse, error) {
				lastResponse = rawResponse;
				if (userProvidedCallBack) userProvidedCallBack(rawResponse, flatResponse, error);
			}
			operationArguments.options = {
				...operationArguments.options,
				onResponse
			};
			const result = await super.sendOperationRequest(operationArguments, operationSpec);
			if (lastResponse) Object.defineProperty(result, "_response", { value: (0, response_js_1.toCompatResponse)(lastResponse) });
			return result;
		}
	};
	exports.ExtendedServiceClient = ExtendedServiceClient;
}));
var require_requestPolicyFactoryPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.requestPolicyFactoryPolicyName = exports.HttpPipelineLogLevel = void 0;
	exports.createRequestPolicyFactoryPolicy = createRequestPolicyFactoryPolicy;
	var util_js_1 = require_util$4();
	var response_js_1 = require_response();
	var HttpPipelineLogLevel;
	(function(HttpPipelineLogLevel) {
		HttpPipelineLogLevel[HttpPipelineLogLevel["ERROR"] = 1] = "ERROR";
		HttpPipelineLogLevel[HttpPipelineLogLevel["INFO"] = 3] = "INFO";
		HttpPipelineLogLevel[HttpPipelineLogLevel["OFF"] = 0] = "OFF";
		HttpPipelineLogLevel[HttpPipelineLogLevel["WARNING"] = 2] = "WARNING";
	})(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
	var mockRequestPolicyOptions = {
		log(_logLevel, _message) {},
		shouldLog(_logLevel) {
			return false;
		}
	};
	exports.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
	function createRequestPolicyFactoryPolicy(factories) {
		const orderedFactories = factories.slice().reverse();
		return {
			name: exports.requestPolicyFactoryPolicyName,
			async sendRequest(request$1, next) {
				let httpPipeline = { async sendRequest(httpRequest) {
					const response$1 = await next((0, util_js_1.toPipelineRequest)(httpRequest));
					return (0, response_js_1.toCompatResponse)(response$1, { createProxy: true });
				} };
				for (const factory of orderedFactories) httpPipeline = factory.create(httpPipeline, mockRequestPolicyOptions);
				const webResourceLike = (0, util_js_1.toWebResourceLike)(request$1, { createProxy: true });
				const response = await httpPipeline.sendRequest(webResourceLike);
				return (0, response_js_1.toPipelineResponse)(response);
			}
		};
	}
}));
var require_httpClientAdapter = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.convertHttpClient = convertHttpClient;
	var response_js_1 = require_response();
	var util_js_1 = require_util$4();
	function convertHttpClient(requestPolicyClient) {
		return { sendRequest: async (request$1) => {
			const response = await requestPolicyClient.sendRequest((0, util_js_1.toWebResourceLike)(request$1, { createProxy: true }));
			return (0, response_js_1.toPipelineResponse)(response);
		} };
	}
}));
var require_commonjs$9 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toHttpHeadersLike = exports.convertHttpClient = exports.disableKeepAlivePolicyName = exports.HttpPipelineLogLevel = exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.ExtendedServiceClient = void 0;
	var extendedClient_js_1 = require_extendedClient();
	Object.defineProperty(exports, "ExtendedServiceClient", {
		enumerable: true,
		get: function() {
			return extendedClient_js_1.ExtendedServiceClient;
		}
	});
	var requestPolicyFactoryPolicy_js_1 = require_requestPolicyFactoryPolicy();
	Object.defineProperty(exports, "requestPolicyFactoryPolicyName", {
		enumerable: true,
		get: function() {
			return requestPolicyFactoryPolicy_js_1.requestPolicyFactoryPolicyName;
		}
	});
	Object.defineProperty(exports, "createRequestPolicyFactoryPolicy", {
		enumerable: true,
		get: function() {
			return requestPolicyFactoryPolicy_js_1.createRequestPolicyFactoryPolicy;
		}
	});
	Object.defineProperty(exports, "HttpPipelineLogLevel", {
		enumerable: true,
		get: function() {
			return requestPolicyFactoryPolicy_js_1.HttpPipelineLogLevel;
		}
	});
	var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
	Object.defineProperty(exports, "disableKeepAlivePolicyName", {
		enumerable: true,
		get: function() {
			return disableKeepAlivePolicy_js_1.disableKeepAlivePolicyName;
		}
	});
	var httpClientAdapter_js_1 = require_httpClientAdapter();
	Object.defineProperty(exports, "convertHttpClient", {
		enumerable: true,
		get: function() {
			return httpClientAdapter_js_1.convertHttpClient;
		}
	});
	var util_js_1 = require_util$4();
	Object.defineProperty(exports, "toHttpHeadersLike", {
		enumerable: true,
		get: function() {
			return util_js_1.toHttpHeadersLike;
		}
	});
}));
var require_fxp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(() => {
		"use strict";
		var t$1 = {
			d: (e$2, i) => {
				for (var n$2 in i) t$1.o(i, n$2) && !t$1.o(e$2, n$2) && Object.defineProperty(e$2, n$2, {
					enumerable: !0,
					get: i[n$2]
				});
			},
			o: (t$2, e$2) => Object.prototype.hasOwnProperty.call(t$2, e$2),
			r: (t$2) => {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t$2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t$2, "__esModule", { value: !0 });
			}
		}, e$1 = {};
		t$1.r(e$1), t$1.d(e$1, {
			XMLBuilder: () => lt,
			XMLParser: () => tt,
			XMLValidator: () => pt
		});
		const n$1 = /* @__PURE__ */ new RegExp("^[:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
		function s(t$2, e$2) {
			const i = [];
			let n$2 = e$2.exec(t$2);
			for (; n$2;) {
				const s$1 = [];
				s$1.startIndex = e$2.lastIndex - n$2[0].length;
				const r$2 = n$2.length;
				for (let t$3 = 0; t$3 < r$2; t$3++) s$1.push(n$2[t$3]);
				i.push(s$1), n$2 = e$2.exec(t$2);
			}
			return i;
		}
		const r$1 = function(t$2) {
			return !(null == n$1.exec(t$2));
		}, o$1 = {
			allowBooleanAttributes: !1,
			unpairedTags: []
		};
		function a(t$2, e$2) {
			e$2 = Object.assign({}, o$1, e$2);
			const i = [];
			let n$2 = !1, s$1 = !1;
			"" === t$2[0] && (t$2 = t$2.substr(1));
			for (let o$2 = 0; o$2 < t$2.length; o$2++) if ("<" === t$2[o$2] && "?" === t$2[o$2 + 1]) {
				if (o$2 += 2, o$2 = u(t$2, o$2), o$2.err) return o$2;
			} else {
				if ("<" !== t$2[o$2]) {
					if (l(t$2[o$2])) continue;
					return x("InvalidChar", "char '" + t$2[o$2] + "' is not expected.", b(t$2, o$2));
				}
				{
					let a$1 = o$2;
					if (o$2++, "!" === t$2[o$2]) {
						o$2 = h(t$2, o$2);
						continue;
					}
					{
						let d$1 = !1;
						"/" === t$2[o$2] && (d$1 = !0, o$2++);
						let p$1 = "";
						for (; o$2 < t$2.length && ">" !== t$2[o$2] && " " !== t$2[o$2] && "	" !== t$2[o$2] && "\n" !== t$2[o$2] && "\r" !== t$2[o$2]; o$2++) p$1 += t$2[o$2];
						if (p$1 = p$1.trim(), "/" === p$1[p$1.length - 1] && (p$1 = p$1.substring(0, p$1.length - 1), o$2--), !r$1(p$1)) {
							let e$3;
							return e$3 = 0 === p$1.trim().length ? "Invalid space after '<'." : "Tag '" + p$1 + "' is an invalid name.", x("InvalidTag", e$3, b(t$2, o$2));
						}
						const c$1 = f(t$2, o$2);
						if (!1 === c$1) return x("InvalidAttr", "Attributes for '" + p$1 + "' have open quote.", b(t$2, o$2));
						let N$1 = c$1.value;
						if (o$2 = c$1.index, "/" === N$1[N$1.length - 1]) {
							const i$1 = o$2 - N$1.length;
							N$1 = N$1.substring(0, N$1.length - 1);
							const s$2 = g(N$1, e$2);
							if (!0 !== s$2) return x(s$2.err.code, s$2.err.msg, b(t$2, i$1 + s$2.err.line));
							n$2 = !0;
						} else if (d$1) {
							if (!c$1.tagClosed) return x("InvalidTag", "Closing tag '" + p$1 + "' doesn't have proper closing.", b(t$2, o$2));
							if (N$1.trim().length > 0) return x("InvalidTag", "Closing tag '" + p$1 + "' can't have attributes or invalid starting.", b(t$2, a$1));
							if (0 === i.length) return x("InvalidTag", "Closing tag '" + p$1 + "' has not been opened.", b(t$2, a$1));
							{
								const e$3 = i.pop();
								if (p$1 !== e$3.tagName) {
									let i$1 = b(t$2, e$3.tagStartPos);
									return x("InvalidTag", "Expected closing tag '" + e$3.tagName + "' (opened in line " + i$1.line + ", col " + i$1.col + ") instead of closing tag '" + p$1 + "'.", b(t$2, a$1));
								}
								0 == i.length && (s$1 = !0);
							}
						} else {
							const r$2 = g(N$1, e$2);
							if (!0 !== r$2) return x(r$2.err.code, r$2.err.msg, b(t$2, o$2 - N$1.length + r$2.err.line));
							if (!0 === s$1) return x("InvalidXml", "Multiple possible root nodes found.", b(t$2, o$2));
							-1 !== e$2.unpairedTags.indexOf(p$1) || i.push({
								tagName: p$1,
								tagStartPos: a$1
							}), n$2 = !0;
						}
						for (o$2++; o$2 < t$2.length; o$2++) if ("<" === t$2[o$2]) {
							if ("!" === t$2[o$2 + 1]) {
								o$2++, o$2 = h(t$2, o$2);
								continue;
							}
							if ("?" !== t$2[o$2 + 1]) break;
							if (o$2 = u(t$2, ++o$2), o$2.err) return o$2;
						} else if ("&" === t$2[o$2]) {
							const e$3 = m(t$2, o$2);
							if (-1 == e$3) return x("InvalidChar", "char '&' is not expected.", b(t$2, o$2));
							o$2 = e$3;
						} else if (!0 === s$1 && !l(t$2[o$2])) return x("InvalidXml", "Extra text at the end", b(t$2, o$2));
						"<" === t$2[o$2] && o$2--;
					}
				}
			}
			return n$2 ? 1 == i.length ? x("InvalidTag", "Unclosed tag '" + i[0].tagName + "'.", b(t$2, i[0].tagStartPos)) : !(i.length > 0) || x("InvalidXml", "Invalid '" + JSON.stringify(i.map(((t$3) => t$3.tagName)), null, 4).replace(/\r?\n/g, "") + "' found.", {
				line: 1,
				col: 1
			}) : x("InvalidXml", "Start tag expected.", 1);
		}
		function l(t$2) {
			return " " === t$2 || "	" === t$2 || "\n" === t$2 || "\r" === t$2;
		}
		function u(t$2, e$2) {
			const i = e$2;
			for (; e$2 < t$2.length; e$2++) if ("?" != t$2[e$2] && " " != t$2[e$2]);
			else {
				const n$2 = t$2.substr(i, e$2 - i);
				if (e$2 > 5 && "xml" === n$2) return x("InvalidXml", "XML declaration allowed only at the start of the document.", b(t$2, e$2));
				if ("?" == t$2[e$2] && ">" == t$2[e$2 + 1]) {
					e$2++;
					break;
				}
			}
			return e$2;
		}
		function h(t$2, e$2) {
			if (t$2.length > e$2 + 5 && "-" === t$2[e$2 + 1] && "-" === t$2[e$2 + 2]) {
				for (e$2 += 3; e$2 < t$2.length; e$2++) if ("-" === t$2[e$2] && "-" === t$2[e$2 + 1] && ">" === t$2[e$2 + 2]) {
					e$2 += 2;
					break;
				}
			} else if (t$2.length > e$2 + 8 && "D" === t$2[e$2 + 1] && "O" === t$2[e$2 + 2] && "C" === t$2[e$2 + 3] && "T" === t$2[e$2 + 4] && "Y" === t$2[e$2 + 5] && "P" === t$2[e$2 + 6] && "E" === t$2[e$2 + 7]) {
				let i = 1;
				for (e$2 += 8; e$2 < t$2.length; e$2++) if ("<" === t$2[e$2]) i++;
				else if (">" === t$2[e$2] && (i--, 0 === i)) break;
			} else if (t$2.length > e$2 + 9 && "[" === t$2[e$2 + 1] && "C" === t$2[e$2 + 2] && "D" === t$2[e$2 + 3] && "A" === t$2[e$2 + 4] && "T" === t$2[e$2 + 5] && "A" === t$2[e$2 + 6] && "[" === t$2[e$2 + 7]) {
				for (e$2 += 8; e$2 < t$2.length; e$2++) if ("]" === t$2[e$2] && "]" === t$2[e$2 + 1] && ">" === t$2[e$2 + 2]) {
					e$2 += 2;
					break;
				}
			}
			return e$2;
		}
		const d = "\"", p = "'";
		function f(t$2, e$2) {
			let i = "", n$2 = "", s$1 = !1;
			for (; e$2 < t$2.length; e$2++) {
				if (t$2[e$2] === d || t$2[e$2] === p) "" === n$2 ? n$2 = t$2[e$2] : n$2 !== t$2[e$2] || (n$2 = "");
				else if (">" === t$2[e$2] && "" === n$2) {
					s$1 = !0;
					break;
				}
				i += t$2[e$2];
			}
			return "" === n$2 && {
				value: i,
				index: e$2,
				tagClosed: s$1
			};
		}
		const c = new RegExp("(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?", "g");
		function g(t$2, e$2) {
			const i = s(t$2, c), n$2 = {};
			for (let t$3 = 0; t$3 < i.length; t$3++) {
				if (0 === i[t$3][1].length) return x("InvalidAttr", "Attribute '" + i[t$3][2] + "' has no space in starting.", E(i[t$3]));
				if (void 0 !== i[t$3][3] && void 0 === i[t$3][4]) return x("InvalidAttr", "Attribute '" + i[t$3][2] + "' is without value.", E(i[t$3]));
				if (void 0 === i[t$3][3] && !e$2.allowBooleanAttributes) return x("InvalidAttr", "boolean attribute '" + i[t$3][2] + "' is not allowed.", E(i[t$3]));
				const s$1 = i[t$3][2];
				if (!N(s$1)) return x("InvalidAttr", "Attribute '" + s$1 + "' is an invalid name.", E(i[t$3]));
				if (n$2.hasOwnProperty(s$1)) return x("InvalidAttr", "Attribute '" + s$1 + "' is repeated.", E(i[t$3]));
				n$2[s$1] = 1;
			}
			return !0;
		}
		function m(t$2, e$2) {
			if (";" === t$2[++e$2]) return -1;
			if ("#" === t$2[e$2]) return function(t$3, e$3) {
				let i$1 = /\d/;
				for ("x" === t$3[e$3] && (e$3++, i$1 = /[\da-fA-F]/); e$3 < t$3.length; e$3++) {
					if (";" === t$3[e$3]) return e$3;
					if (!t$3[e$3].match(i$1)) break;
				}
				return -1;
			}(t$2, ++e$2);
			let i = 0;
			for (; e$2 < t$2.length; e$2++, i++) if (!(t$2[e$2].match(/\w/) && i < 20)) {
				if (";" === t$2[e$2]) break;
				return -1;
			}
			return e$2;
		}
		function x(t$2, e$2, i) {
			return { err: {
				code: t$2,
				msg: e$2,
				line: i.line || i,
				col: i.col
			} };
		}
		function N(t$2) {
			return r$1(t$2);
		}
		function b(t$2, e$2) {
			const i = t$2.substring(0, e$2).split(/\r?\n/);
			return {
				line: i.length,
				col: i[i.length - 1].length + 1
			};
		}
		function E(t$2) {
			return t$2.startIndex + t$2[1].length;
		}
		const v = {
			preserveOrder: !1,
			attributeNamePrefix: "@_",
			attributesGroupName: !1,
			textNodeName: "#text",
			ignoreAttributes: !0,
			removeNSPrefix: !1,
			allowBooleanAttributes: !1,
			parseTagValue: !0,
			parseAttributeValue: !1,
			trimValues: !0,
			cdataPropName: !1,
			numberParseOptions: {
				hex: !0,
				leadingZeros: !0,
				eNotation: !0
			},
			tagValueProcessor: function(t$2, e$2) {
				return e$2;
			},
			attributeValueProcessor: function(t$2, e$2) {
				return e$2;
			},
			stopNodes: [],
			alwaysCreateTextNode: !1,
			isArray: () => !1,
			commentPropName: !1,
			unpairedTags: [],
			processEntities: !0,
			htmlEntities: !1,
			ignoreDeclaration: !1,
			ignorePiTags: !1,
			transformTagName: !1,
			transformAttributeName: !1,
			updateTag: function(t$2, e$2, i) {
				return t$2;
			},
			captureMetaData: !1
		};
		let T;
		T = "function" != typeof Symbol ? "@@xmlMetadata" : Symbol("XML Node Metadata");
		class y {
			constructor(t$2) {
				this.tagname = t$2, this.child = [], this[":@"] = {};
			}
			add(t$2, e$2) {
				"__proto__" === t$2 && (t$2 = "#__proto__"), this.child.push({ [t$2]: e$2 });
			}
			addChild(t$2, e$2) {
				"__proto__" === t$2.tagname && (t$2.tagname = "#__proto__"), t$2[":@"] && Object.keys(t$2[":@"]).length > 0 ? this.child.push({
					[t$2.tagname]: t$2.child,
					":@": t$2[":@"]
				}) : this.child.push({ [t$2.tagname]: t$2.child }), void 0 !== e$2 && (this.child[this.child.length - 1][T] = { startIndex: e$2 });
			}
			static getMetaDataSymbol() {
				return T;
			}
		}
		class w {
			constructor(t$2) {
				this.suppressValidationErr = !t$2;
			}
			readDocType(t$2, e$2) {
				const i = {};
				if ("O" !== t$2[e$2 + 3] || "C" !== t$2[e$2 + 4] || "T" !== t$2[e$2 + 5] || "Y" !== t$2[e$2 + 6] || "P" !== t$2[e$2 + 7] || "E" !== t$2[e$2 + 8]) throw new Error("Invalid Tag instead of DOCTYPE");
				{
					e$2 += 9;
					let n$2 = 1, s$1 = !1, r$2 = !1, o$2 = "";
					for (; e$2 < t$2.length; e$2++) if ("<" !== t$2[e$2] || r$2) if (">" === t$2[e$2]) {
						if (r$2 ? "-" === t$2[e$2 - 1] && "-" === t$2[e$2 - 2] && (r$2 = !1, n$2--) : n$2--, 0 === n$2) break;
					} else "[" === t$2[e$2] ? s$1 = !0 : o$2 += t$2[e$2];
					else {
						if (s$1 && P(t$2, "!ENTITY", e$2)) {
							let n$3, s$2;
							e$2 += 7, [n$3, s$2, e$2] = this.readEntityExp(t$2, e$2 + 1, this.suppressValidationErr), -1 === s$2.indexOf("&") && (i[n$3] = {
								regx: RegExp(`&${n$3};`, "g"),
								val: s$2
							});
						} else if (s$1 && P(t$2, "!ELEMENT", e$2)) {
							e$2 += 8;
							const { index: i$1 } = this.readElementExp(t$2, e$2 + 1);
							e$2 = i$1;
						} else if (s$1 && P(t$2, "!ATTLIST", e$2)) e$2 += 8;
						else if (s$1 && P(t$2, "!NOTATION", e$2)) {
							e$2 += 9;
							const { index: i$1 } = this.readNotationExp(t$2, e$2 + 1, this.suppressValidationErr);
							e$2 = i$1;
						} else {
							if (!P(t$2, "!--", e$2)) throw new Error("Invalid DOCTYPE");
							r$2 = !0;
						}
						n$2++, o$2 = "";
					}
					if (0 !== n$2) throw new Error("Unclosed DOCTYPE");
				}
				return {
					entities: i,
					i: e$2
				};
			}
			readEntityExp(t$2, e$2) {
				e$2 = I(t$2, e$2);
				let i = "";
				for (; e$2 < t$2.length && !/\s/.test(t$2[e$2]) && "\"" !== t$2[e$2] && "'" !== t$2[e$2];) i += t$2[e$2], e$2++;
				if (O(i), e$2 = I(t$2, e$2), !this.suppressValidationErr) {
					if ("SYSTEM" === t$2.substring(e$2, e$2 + 6).toUpperCase()) throw new Error("External entities are not supported");
					if ("%" === t$2[e$2]) throw new Error("Parameter entities are not supported");
				}
				let n$2 = "";
				return [e$2, n$2] = this.readIdentifierVal(t$2, e$2, "entity"), [
					i,
					n$2,
					--e$2
				];
			}
			readNotationExp(t$2, e$2) {
				e$2 = I(t$2, e$2);
				let i = "";
				for (; e$2 < t$2.length && !/\s/.test(t$2[e$2]);) i += t$2[e$2], e$2++;
				!this.suppressValidationErr && O(i), e$2 = I(t$2, e$2);
				const n$2 = t$2.substring(e$2, e$2 + 6).toUpperCase();
				if (!this.suppressValidationErr && "SYSTEM" !== n$2 && "PUBLIC" !== n$2) throw new Error(`Expected SYSTEM or PUBLIC, found "${n$2}"`);
				e$2 += n$2.length, e$2 = I(t$2, e$2);
				let s$1 = null, r$2 = null;
				if ("PUBLIC" === n$2) [e$2, s$1] = this.readIdentifierVal(t$2, e$2, "publicIdentifier"), "\"" !== t$2[e$2 = I(t$2, e$2)] && "'" !== t$2[e$2] || ([e$2, r$2] = this.readIdentifierVal(t$2, e$2, "systemIdentifier"));
				else if ("SYSTEM" === n$2 && ([e$2, r$2] = this.readIdentifierVal(t$2, e$2, "systemIdentifier"), !this.suppressValidationErr && !r$2)) throw new Error("Missing mandatory system identifier for SYSTEM notation");
				return {
					notationName: i,
					publicIdentifier: s$1,
					systemIdentifier: r$2,
					index: --e$2
				};
			}
			readIdentifierVal(t$2, e$2, i) {
				let n$2 = "";
				const s$1 = t$2[e$2];
				if ("\"" !== s$1 && "'" !== s$1) throw new Error(`Expected quoted string, found "${s$1}"`);
				for (e$2++; e$2 < t$2.length && t$2[e$2] !== s$1;) n$2 += t$2[e$2], e$2++;
				if (t$2[e$2] !== s$1) throw new Error(`Unterminated ${i} value`);
				return [++e$2, n$2];
			}
			readElementExp(t$2, e$2) {
				e$2 = I(t$2, e$2);
				let i = "";
				for (; e$2 < t$2.length && !/\s/.test(t$2[e$2]);) i += t$2[e$2], e$2++;
				if (!this.suppressValidationErr && !r$1(i)) throw new Error(`Invalid element name: "${i}"`);
				let n$2 = "";
				if ("E" === t$2[e$2 = I(t$2, e$2)] && P(t$2, "MPTY", e$2)) e$2 += 4;
				else if ("A" === t$2[e$2] && P(t$2, "NY", e$2)) e$2 += 2;
				else if ("(" === t$2[e$2]) {
					for (e$2++; e$2 < t$2.length && ")" !== t$2[e$2];) n$2 += t$2[e$2], e$2++;
					if (")" !== t$2[e$2]) throw new Error("Unterminated content model");
				} else if (!this.suppressValidationErr) throw new Error(`Invalid Element Expression, found "${t$2[e$2]}"`);
				return {
					elementName: i,
					contentModel: n$2.trim(),
					index: e$2
				};
			}
			readAttlistExp(t$2, e$2) {
				e$2 = I(t$2, e$2);
				let i = "";
				for (; e$2 < t$2.length && !/\s/.test(t$2[e$2]);) i += t$2[e$2], e$2++;
				O(i), e$2 = I(t$2, e$2);
				let n$2 = "";
				for (; e$2 < t$2.length && !/\s/.test(t$2[e$2]);) n$2 += t$2[e$2], e$2++;
				if (!O(n$2)) throw new Error(`Invalid attribute name: "${n$2}"`);
				e$2 = I(t$2, e$2);
				let s$1 = "";
				if ("NOTATION" === t$2.substring(e$2, e$2 + 8).toUpperCase()) {
					if (s$1 = "NOTATION", "(" !== t$2[e$2 = I(t$2, e$2 += 8)]) throw new Error(`Expected '(', found "${t$2[e$2]}"`);
					e$2++;
					let i$1 = [];
					for (; e$2 < t$2.length && ")" !== t$2[e$2];) {
						let n$3 = "";
						for (; e$2 < t$2.length && "|" !== t$2[e$2] && ")" !== t$2[e$2];) n$3 += t$2[e$2], e$2++;
						if (n$3 = n$3.trim(), !O(n$3)) throw new Error(`Invalid notation name: "${n$3}"`);
						i$1.push(n$3), "|" === t$2[e$2] && (e$2++, e$2 = I(t$2, e$2));
					}
					if (")" !== t$2[e$2]) throw new Error("Unterminated list of notations");
					e$2++, s$1 += " (" + i$1.join("|") + ")";
				} else {
					for (; e$2 < t$2.length && !/\s/.test(t$2[e$2]);) s$1 += t$2[e$2], e$2++;
					if (!this.suppressValidationErr && ![
						"CDATA",
						"ID",
						"IDREF",
						"IDREFS",
						"ENTITY",
						"ENTITIES",
						"NMTOKEN",
						"NMTOKENS"
					].includes(s$1.toUpperCase())) throw new Error(`Invalid attribute type: "${s$1}"`);
				}
				e$2 = I(t$2, e$2);
				let r$2 = "";
				return "#REQUIRED" === t$2.substring(e$2, e$2 + 8).toUpperCase() ? (r$2 = "#REQUIRED", e$2 += 8) : "#IMPLIED" === t$2.substring(e$2, e$2 + 7).toUpperCase() ? (r$2 = "#IMPLIED", e$2 += 7) : [e$2, r$2] = this.readIdentifierVal(t$2, e$2, "ATTLIST"), {
					elementName: i,
					attributeName: n$2,
					attributeType: s$1,
					defaultValue: r$2,
					index: e$2
				};
			}
		}
		const I = (t$2, e$2) => {
			for (; e$2 < t$2.length && /\s/.test(t$2[e$2]);) e$2++;
			return e$2;
		};
		function P(t$2, e$2, i) {
			for (let n$2 = 0; n$2 < e$2.length; n$2++) if (e$2[n$2] !== t$2[i + n$2 + 1]) return !1;
			return !0;
		}
		function O(t$2) {
			if (r$1(t$2)) return t$2;
			throw new Error(`Invalid entity name ${t$2}`);
		}
		const A = /^[-+]?0x[a-fA-F0-9]+$/, S = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, C = {
			hex: !0,
			leadingZeros: !0,
			decimalPoint: ".",
			eNotation: !0
		};
		const V = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
		function $(t$2) {
			return "function" == typeof t$2 ? t$2 : Array.isArray(t$2) ? (e$2) => {
				for (const i of t$2) {
					if ("string" == typeof i && e$2 === i) return !0;
					if (i instanceof RegExp && i.test(e$2)) return !0;
				}
			} : () => !1;
		}
		class D {
			constructor(t$2) {
				if (this.options = t$2, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
					apos: {
						regex: /&(apos|#39|#x27);/g,
						val: "'"
					},
					gt: {
						regex: /&(gt|#62|#x3E);/g,
						val: ">"
					},
					lt: {
						regex: /&(lt|#60|#x3C);/g,
						val: "<"
					},
					quot: {
						regex: /&(quot|#34|#x22);/g,
						val: "\""
					}
				}, this.ampEntity = {
					regex: /&(amp|#38|#x26);/g,
					val: "&"
				}, this.htmlEntities = {
					space: {
						regex: /&(nbsp|#160);/g,
						val: " "
					},
					cent: {
						regex: /&(cent|#162);/g,
						val: ""
					},
					pound: {
						regex: /&(pound|#163);/g,
						val: ""
					},
					yen: {
						regex: /&(yen|#165);/g,
						val: ""
					},
					euro: {
						regex: /&(euro|#8364);/g,
						val: ""
					},
					copyright: {
						regex: /&(copy|#169);/g,
						val: ""
					},
					reg: {
						regex: /&(reg|#174);/g,
						val: ""
					},
					inr: {
						regex: /&(inr|#8377);/g,
						val: ""
					},
					num_dec: {
						regex: /&#([0-9]{1,7});/g,
						val: (t$3, e$2) => String.fromCodePoint(Number.parseInt(e$2, 10))
					},
					num_hex: {
						regex: /&#x([0-9a-fA-F]{1,6});/g,
						val: (t$3, e$2) => String.fromCodePoint(Number.parseInt(e$2, 16))
					}
				}, this.addExternalEntities = j, this.parseXml = L, this.parseTextData = M, this.resolveNameSpace = F, this.buildAttributesMap = k, this.isItStopNode = Y, this.replaceEntitiesValue = B, this.readStopNodeData = W, this.saveTextToParentTag = R, this.addChild = U, this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.options.stopNodes && this.options.stopNodes.length > 0) {
					this.stopNodesExact = /* @__PURE__ */ new Set(), this.stopNodesWildcard = /* @__PURE__ */ new Set();
					for (let t$3 = 0; t$3 < this.options.stopNodes.length; t$3++) {
						const e$2 = this.options.stopNodes[t$3];
						"string" == typeof e$2 && (e$2.startsWith("*.") ? this.stopNodesWildcard.add(e$2.substring(2)) : this.stopNodesExact.add(e$2));
					}
				}
			}
		}
		function j(t$2) {
			const e$2 = Object.keys(t$2);
			for (let i = 0; i < e$2.length; i++) {
				const n$2 = e$2[i];
				this.lastEntities[n$2] = {
					regex: new RegExp("&" + n$2 + ";", "g"),
					val: t$2[n$2]
				};
			}
		}
		function M(t$2, e$2, i, n$2, s$1, r$2, o$2) {
			if (void 0 !== t$2 && (this.options.trimValues && !n$2 && (t$2 = t$2.trim()), t$2.length > 0)) {
				o$2 || (t$2 = this.replaceEntitiesValue(t$2));
				const n$3 = this.options.tagValueProcessor(e$2, t$2, i, s$1, r$2);
				return null == n$3 ? t$2 : typeof n$3 != typeof t$2 || n$3 !== t$2 ? n$3 : this.options.trimValues || t$2.trim() === t$2 ? q(t$2, this.options.parseTagValue, this.options.numberParseOptions) : t$2;
			}
		}
		function F(t$2) {
			if (this.options.removeNSPrefix) {
				const e$2 = t$2.split(":"), i = "/" === t$2.charAt(0) ? "/" : "";
				if ("xmlns" === e$2[0]) return "";
				2 === e$2.length && (t$2 = i + e$2[1]);
			}
			return t$2;
		}
		const _$1 = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm");
		function k(t$2, e$2) {
			if (!0 !== this.options.ignoreAttributes && "string" == typeof t$2) {
				const i = s(t$2, _$1), n$2 = i.length, r$2 = {};
				for (let t$3 = 0; t$3 < n$2; t$3++) {
					const n$3 = this.resolveNameSpace(i[t$3][1]);
					if (this.ignoreAttributesFn(n$3, e$2)) continue;
					let s$1 = i[t$3][4], o$2 = this.options.attributeNamePrefix + n$3;
					if (n$3.length) if (this.options.transformAttributeName && (o$2 = this.options.transformAttributeName(o$2)), "__proto__" === o$2 && (o$2 = "#__proto__"), void 0 !== s$1) {
						this.options.trimValues && (s$1 = s$1.trim()), s$1 = this.replaceEntitiesValue(s$1);
						const t$4 = this.options.attributeValueProcessor(n$3, s$1, e$2);
						r$2[o$2] = null == t$4 ? s$1 : typeof t$4 != typeof s$1 || t$4 !== s$1 ? t$4 : q(s$1, this.options.parseAttributeValue, this.options.numberParseOptions);
					} else this.options.allowBooleanAttributes && (r$2[o$2] = !0);
				}
				if (!Object.keys(r$2).length) return;
				if (this.options.attributesGroupName) {
					const t$3 = {};
					return t$3[this.options.attributesGroupName] = r$2, t$3;
				}
				return r$2;
			}
		}
		const L = function(t$2) {
			t$2 = t$2.replace(/\r\n?/g, "\n");
			const e$2 = new y("!xml");
			let i = e$2, n$2 = "", s$1 = "";
			const r$2 = new w(this.options.processEntities);
			for (let o$2 = 0; o$2 < t$2.length; o$2++) if ("<" === t$2[o$2]) if ("/" === t$2[o$2 + 1]) {
				const e$3 = G(t$2, ">", o$2, "Closing Tag is not closed.");
				let r$3 = t$2.substring(o$2 + 2, e$3).trim();
				if (this.options.removeNSPrefix) {
					const t$3 = r$3.indexOf(":");
					-1 !== t$3 && (r$3 = r$3.substr(t$3 + 1));
				}
				this.options.transformTagName && (r$3 = this.options.transformTagName(r$3)), i && (n$2 = this.saveTextToParentTag(n$2, i, s$1));
				const a$1 = s$1.substring(s$1.lastIndexOf(".") + 1);
				if (r$3 && -1 !== this.options.unpairedTags.indexOf(r$3)) throw new Error(`Unpaired tag can not be used as closing tag: </${r$3}>`);
				let l$1 = 0;
				a$1 && -1 !== this.options.unpairedTags.indexOf(a$1) ? (l$1 = s$1.lastIndexOf(".", s$1.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l$1 = s$1.lastIndexOf("."), s$1 = s$1.substring(0, l$1), i = this.tagsNodeStack.pop(), n$2 = "", o$2 = e$3;
			} else if ("?" === t$2[o$2 + 1]) {
				let e$3 = X(t$2, o$2, !1, "?>");
				if (!e$3) throw new Error("Pi Tag is not closed.");
				if (n$2 = this.saveTextToParentTag(n$2, i, s$1), this.options.ignoreDeclaration && "?xml" === e$3.tagName || this.options.ignorePiTags);
				else {
					const t$3 = new y(e$3.tagName);
					t$3.add(this.options.textNodeName, ""), e$3.tagName !== e$3.tagExp && e$3.attrExpPresent && (t$3[":@"] = this.buildAttributesMap(e$3.tagExp, s$1)), this.addChild(i, t$3, s$1, o$2);
				}
				o$2 = e$3.closeIndex + 1;
			} else if ("!--" === t$2.substr(o$2 + 1, 3)) {
				const e$3 = G(t$2, "-->", o$2 + 4, "Comment is not closed.");
				if (this.options.commentPropName) {
					const r$3 = t$2.substring(o$2 + 4, e$3 - 2);
					n$2 = this.saveTextToParentTag(n$2, i, s$1), i.add(this.options.commentPropName, [{ [this.options.textNodeName]: r$3 }]);
				}
				o$2 = e$3;
			} else if ("!D" === t$2.substr(o$2 + 1, 2)) {
				const e$3 = r$2.readDocType(t$2, o$2);
				this.docTypeEntities = e$3.entities, o$2 = e$3.i;
			} else if ("![" === t$2.substr(o$2 + 1, 2)) {
				const e$3 = G(t$2, "]]>", o$2, "CDATA is not closed.") - 2, r$3 = t$2.substring(o$2 + 9, e$3);
				n$2 = this.saveTextToParentTag(n$2, i, s$1);
				let a$1 = this.parseTextData(r$3, i.tagname, s$1, !0, !1, !0, !0);
				a$1 ??= "", this.options.cdataPropName ? i.add(this.options.cdataPropName, [{ [this.options.textNodeName]: r$3 }]) : i.add(this.options.textNodeName, a$1), o$2 = e$3 + 2;
			} else {
				let r$3 = X(t$2, o$2, this.options.removeNSPrefix), a$1 = r$3.tagName;
				const l$1 = r$3.rawTagName;
				let u$1 = r$3.tagExp, h$1 = r$3.attrExpPresent, d$1 = r$3.closeIndex;
				if (this.options.transformTagName) {
					const t$3 = this.options.transformTagName(a$1);
					u$1 === a$1 && (u$1 = t$3), a$1 = t$3;
				}
				i && n$2 && "!xml" !== i.tagname && (n$2 = this.saveTextToParentTag(n$2, i, s$1, !1));
				const p$1 = i;
				p$1 && -1 !== this.options.unpairedTags.indexOf(p$1.tagname) && (i = this.tagsNodeStack.pop(), s$1 = s$1.substring(0, s$1.lastIndexOf("."))), a$1 !== e$2.tagname && (s$1 += s$1 ? "." + a$1 : a$1);
				const f$1 = o$2;
				if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, s$1, a$1)) {
					let e$3 = "";
					if (u$1.length > 0 && u$1.lastIndexOf("/") === u$1.length - 1) "/" === a$1[a$1.length - 1] ? (a$1 = a$1.substr(0, a$1.length - 1), s$1 = s$1.substr(0, s$1.length - 1), u$1 = a$1) : u$1 = u$1.substr(0, u$1.length - 1), o$2 = r$3.closeIndex;
					else if (-1 !== this.options.unpairedTags.indexOf(a$1)) o$2 = r$3.closeIndex;
					else {
						const i$1 = this.readStopNodeData(t$2, l$1, d$1 + 1);
						if (!i$1) throw new Error(`Unexpected end of ${l$1}`);
						o$2 = i$1.i, e$3 = i$1.tagContent;
					}
					const n$3 = new y(a$1);
					a$1 !== u$1 && h$1 && (n$3[":@"] = this.buildAttributesMap(u$1, s$1)), e$3 && (e$3 = this.parseTextData(e$3, a$1, s$1, !0, h$1, !0, !0)), s$1 = s$1.substr(0, s$1.lastIndexOf(".")), n$3.add(this.options.textNodeName, e$3), this.addChild(i, n$3, s$1, f$1);
				} else {
					if (u$1.length > 0 && u$1.lastIndexOf("/") === u$1.length - 1) {
						if ("/" === a$1[a$1.length - 1] ? (a$1 = a$1.substr(0, a$1.length - 1), s$1 = s$1.substr(0, s$1.length - 1), u$1 = a$1) : u$1 = u$1.substr(0, u$1.length - 1), this.options.transformTagName) {
							const t$4 = this.options.transformTagName(a$1);
							u$1 === a$1 && (u$1 = t$4), a$1 = t$4;
						}
						const t$3 = new y(a$1);
						a$1 !== u$1 && h$1 && (t$3[":@"] = this.buildAttributesMap(u$1, s$1)), this.addChild(i, t$3, s$1, f$1), s$1 = s$1.substr(0, s$1.lastIndexOf("."));
					} else {
						const t$3 = new y(a$1);
						this.tagsNodeStack.push(i), a$1 !== u$1 && h$1 && (t$3[":@"] = this.buildAttributesMap(u$1, s$1)), this.addChild(i, t$3, s$1, f$1), i = t$3;
					}
					n$2 = "", o$2 = d$1;
				}
			}
			else n$2 += t$2[o$2];
			return e$2.child;
		};
		function U(t$2, e$2, i, n$2) {
			this.options.captureMetaData || (n$2 = void 0);
			const s$1 = this.options.updateTag(e$2.tagname, i, e$2[":@"]);
			!1 === s$1 || ("string" == typeof s$1 ? (e$2.tagname = s$1, t$2.addChild(e$2, n$2)) : t$2.addChild(e$2, n$2));
		}
		const B = function(t$2) {
			if (this.options.processEntities) {
				for (let e$2 in this.docTypeEntities) {
					const i = this.docTypeEntities[e$2];
					t$2 = t$2.replace(i.regx, i.val);
				}
				for (let e$2 in this.lastEntities) {
					const i = this.lastEntities[e$2];
					t$2 = t$2.replace(i.regex, i.val);
				}
				if (this.options.htmlEntities) for (let e$2 in this.htmlEntities) {
					const i = this.htmlEntities[e$2];
					t$2 = t$2.replace(i.regex, i.val);
				}
				t$2 = t$2.replace(this.ampEntity.regex, this.ampEntity.val);
			}
			return t$2;
		};
		function R(t$2, e$2, i, n$2) {
			return t$2 && (void 0 === n$2 && (n$2 = 0 === e$2.child.length), void 0 !== (t$2 = this.parseTextData(t$2, e$2.tagname, i, !1, !!e$2[":@"] && 0 !== Object.keys(e$2[":@"]).length, n$2)) && "" !== t$2 && e$2.add(this.options.textNodeName, t$2), t$2 = ""), t$2;
		}
		function Y(t$2, e$2, i, n$2) {
			return !(!e$2 || !e$2.has(n$2)) || !(!t$2 || !t$2.has(i));
		}
		function G(t$2, e$2, i, n$2) {
			const s$1 = t$2.indexOf(e$2, i);
			if (-1 === s$1) throw new Error(n$2);
			return s$1 + e$2.length - 1;
		}
		function X(t$2, e$2, i, n$2 = ">") {
			const s$1 = function(t$3, e$3, i$1 = ">") {
				let n$3, s$2 = "";
				for (let r$3 = e$3; r$3 < t$3.length; r$3++) {
					let e$4 = t$3[r$3];
					if (n$3) e$4 === n$3 && (n$3 = "");
					else if ("\"" === e$4 || "'" === e$4) n$3 = e$4;
					else if (e$4 === i$1[0]) {
						if (!i$1[1]) return {
							data: s$2,
							index: r$3
						};
						if (t$3[r$3 + 1] === i$1[1]) return {
							data: s$2,
							index: r$3
						};
					} else "	" === e$4 && (e$4 = " ");
					s$2 += e$4;
				}
			}(t$2, e$2 + 1, n$2);
			if (!s$1) return;
			let r$2 = s$1.data;
			const o$2 = s$1.index, a$1 = r$2.search(/\s/);
			let l$1 = r$2, u$1 = !0;
			-1 !== a$1 && (l$1 = r$2.substring(0, a$1), r$2 = r$2.substring(a$1 + 1).trimStart());
			const h$1 = l$1;
			if (i) {
				const t$3 = l$1.indexOf(":");
				-1 !== t$3 && (l$1 = l$1.substr(t$3 + 1), u$1 = l$1 !== s$1.data.substr(t$3 + 1));
			}
			return {
				tagName: l$1,
				tagExp: r$2,
				closeIndex: o$2,
				attrExpPresent: u$1,
				rawTagName: h$1
			};
		}
		function W(t$2, e$2, i) {
			const n$2 = i;
			let s$1 = 1;
			for (; i < t$2.length; i++) if ("<" === t$2[i]) if ("/" === t$2[i + 1]) {
				const r$2 = G(t$2, ">", i, `${e$2} is not closed`);
				if (t$2.substring(i + 2, r$2).trim() === e$2 && (s$1--, 0 === s$1)) return {
					tagContent: t$2.substring(n$2, i),
					i: r$2
				};
				i = r$2;
			} else if ("?" === t$2[i + 1]) i = G(t$2, "?>", i + 1, "StopNode is not closed.");
			else if ("!--" === t$2.substr(i + 1, 3)) i = G(t$2, "-->", i + 3, "StopNode is not closed.");
			else if ("![" === t$2.substr(i + 1, 2)) i = G(t$2, "]]>", i, "StopNode is not closed.") - 2;
			else {
				const n$3 = X(t$2, i, ">");
				n$3 && ((n$3 && n$3.tagName) === e$2 && "/" !== n$3.tagExp[n$3.tagExp.length - 1] && s$1++, i = n$3.closeIndex);
			}
		}
		function q(t$2, e$2, i) {
			if (e$2 && "string" == typeof t$2) {
				const e$3 = t$2.trim();
				return "true" === e$3 || "false" !== e$3 && function(t$3, e$4 = {}) {
					if (e$4 = Object.assign({}, C, e$4), !t$3 || "string" != typeof t$3) return t$3;
					let i$1 = t$3.trim();
					if (void 0 !== e$4.skipLike && e$4.skipLike.test(i$1)) return t$3;
					if ("0" === t$3) return 0;
					if (e$4.hex && A.test(i$1)) return function(t$4) {
						if (parseInt) return parseInt(t$4, 16);
						if (Number.parseInt) return Number.parseInt(t$4, 16);
						if (window && window.parseInt) return window.parseInt(t$4, 16);
						throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
					}(i$1);
					if (-1 !== i$1.search(/.+[eE].+/)) return function(t$4, e$5, i$2) {
						if (!i$2.eNotation) return t$4;
						const n$3 = e$5.match(V);
						if (n$3) {
							let s$1 = n$3[1] || "";
							const r$2 = -1 === n$3[3].indexOf("e") ? "E" : "e", o$2 = n$3[2], a$1 = s$1 ? t$4[o$2.length + 1] === r$2 : t$4[o$2.length] === r$2;
							return o$2.length > 1 && a$1 ? t$4 : 1 !== o$2.length || !n$3[3].startsWith(`.${r$2}`) && n$3[3][0] !== r$2 ? i$2.leadingZeros && !a$1 ? (e$5 = (n$3[1] || "") + n$3[3], Number(e$5)) : t$4 : Number(e$5);
						}
						return t$4;
					}(t$3, i$1, e$4);
					{
						const s$1 = S.exec(i$1);
						if (s$1) {
							const r$2 = s$1[1] || "", o$2 = s$1[2];
							let a$1 = (n$2 = s$1[3]) && -1 !== n$2.indexOf(".") ? ("." === (n$2 = n$2.replace(/0+$/, "")) ? n$2 = "0" : "." === n$2[0] ? n$2 = "0" + n$2 : "." === n$2[n$2.length - 1] && (n$2 = n$2.substring(0, n$2.length - 1)), n$2) : n$2;
							const l$1 = r$2 ? "." === t$3[o$2.length + 1] : "." === t$3[o$2.length];
							if (!e$4.leadingZeros && (o$2.length > 1 || 1 === o$2.length && !l$1)) return t$3;
							{
								const n$3 = Number(i$1), s$2 = String(n$3);
								if (0 === n$3 || -0 === n$3) return n$3;
								if (-1 !== s$2.search(/[eE]/)) return e$4.eNotation ? n$3 : t$3;
								if (-1 !== i$1.indexOf(".")) return "0" === s$2 || s$2 === a$1 || s$2 === `${r$2}${a$1}` ? n$3 : t$3;
								let l$2 = o$2 ? a$1 : i$1;
								return o$2 ? l$2 === s$2 || r$2 + l$2 === s$2 ? n$3 : t$3 : l$2 === s$2 || l$2 === r$2 + s$2 ? n$3 : t$3;
							}
						}
						return t$3;
					}
					var n$2;
				}(t$2, i);
			}
			return void 0 !== t$2 ? t$2 : "";
		}
		const Z = y.getMetaDataSymbol();
		function K(t$2, e$2) {
			return Q(t$2, e$2);
		}
		function Q(t$2, e$2, i) {
			let n$2;
			const s$1 = {};
			for (let r$2 = 0; r$2 < t$2.length; r$2++) {
				const o$2 = t$2[r$2], a$1 = z(o$2);
				let l$1 = "";
				if (l$1 = void 0 === i ? a$1 : i + "." + a$1, a$1 === e$2.textNodeName) void 0 === n$2 ? n$2 = o$2[a$1] : n$2 += "" + o$2[a$1];
				else {
					if (void 0 === a$1) continue;
					if (o$2[a$1]) {
						let t$3 = Q(o$2[a$1], e$2, l$1);
						const i$1 = H(t$3, e$2);
						void 0 !== o$2[Z] && (t$3[Z] = o$2[Z]), o$2[":@"] ? J(t$3, o$2[":@"], l$1, e$2) : 1 !== Object.keys(t$3).length || void 0 === t$3[e$2.textNodeName] || e$2.alwaysCreateTextNode ? 0 === Object.keys(t$3).length && (e$2.alwaysCreateTextNode ? t$3[e$2.textNodeName] = "" : t$3 = "") : t$3 = t$3[e$2.textNodeName], void 0 !== s$1[a$1] && s$1.hasOwnProperty(a$1) ? (Array.isArray(s$1[a$1]) || (s$1[a$1] = [s$1[a$1]]), s$1[a$1].push(t$3)) : e$2.isArray(a$1, l$1, i$1) ? s$1[a$1] = [t$3] : s$1[a$1] = t$3;
					}
				}
			}
			return "string" == typeof n$2 ? n$2.length > 0 && (s$1[e$2.textNodeName] = n$2) : void 0 !== n$2 && (s$1[e$2.textNodeName] = n$2), s$1;
		}
		function z(t$2) {
			const e$2 = Object.keys(t$2);
			for (let t$3 = 0; t$3 < e$2.length; t$3++) {
				const i = e$2[t$3];
				if (":@" !== i) return i;
			}
		}
		function J(t$2, e$2, i, n$2) {
			if (e$2) {
				const s$1 = Object.keys(e$2), r$2 = s$1.length;
				for (let o$2 = 0; o$2 < r$2; o$2++) {
					const r$3 = s$1[o$2];
					n$2.isArray(r$3, i + "." + r$3, !0, !0) ? t$2[r$3] = [e$2[r$3]] : t$2[r$3] = e$2[r$3];
				}
			}
		}
		function H(t$2, e$2) {
			const { textNodeName: i } = e$2, n$2 = Object.keys(t$2).length;
			return 0 === n$2 || !(1 !== n$2 || !t$2[i] && "boolean" != typeof t$2[i] && 0 !== t$2[i]);
		}
		class tt {
			constructor(t$2) {
				this.externalEntities = {}, this.options = function(t$3) {
					return Object.assign({}, v, t$3);
				}(t$2);
			}
			parse(t$2, e$2) {
				if ("string" != typeof t$2 && t$2.toString) t$2 = t$2.toString();
				else if ("string" != typeof t$2) throw new Error("XML data is accepted in String or Bytes[] form.");
				if (e$2) {
					!0 === e$2 && (e$2 = {});
					const i$1 = a(t$2, e$2);
					if (!0 !== i$1) throw Error(`${i$1.err.msg}:${i$1.err.line}:${i$1.err.col}`);
				}
				const i = new D(this.options);
				i.addExternalEntities(this.externalEntities);
				const n$2 = i.parseXml(t$2);
				return this.options.preserveOrder || void 0 === n$2 ? n$2 : K(n$2, this.options);
			}
			addEntity(t$2, e$2) {
				if (-1 !== e$2.indexOf("&")) throw new Error("Entity value can't have '&'");
				if (-1 !== t$2.indexOf("&") || -1 !== t$2.indexOf(";")) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
				if ("&" === e$2) throw new Error("An entity with value '&' is not permitted");
				this.externalEntities[t$2] = e$2;
			}
			static getMetaDataSymbol() {
				return y.getMetaDataSymbol();
			}
		}
		function et(t$2, e$2) {
			let i = "";
			return e$2.format && e$2.indentBy.length > 0 && (i = "\n"), it(t$2, e$2, "", i);
		}
		function it(t$2, e$2, i, n$2) {
			let s$1 = "", r$2 = !1;
			for (let o$2 = 0; o$2 < t$2.length; o$2++) {
				const a$1 = t$2[o$2], l$1 = nt(a$1);
				if (void 0 === l$1) continue;
				let u$1 = "";
				if (u$1 = 0 === i.length ? l$1 : `${i}.${l$1}`, l$1 === e$2.textNodeName) {
					let t$3 = a$1[l$1];
					rt(u$1, e$2) || (t$3 = e$2.tagValueProcessor(l$1, t$3), t$3 = ot(t$3, e$2)), r$2 && (s$1 += n$2), s$1 += t$3, r$2 = !1;
					continue;
				}
				if (l$1 === e$2.cdataPropName) {
					r$2 && (s$1 += n$2), s$1 += `<![CDATA[${a$1[l$1][0][e$2.textNodeName]}]]>`, r$2 = !1;
					continue;
				}
				if (l$1 === e$2.commentPropName) {
					s$1 += n$2 + `\x3c!--${a$1[l$1][0][e$2.textNodeName]}--\x3e`, r$2 = !0;
					continue;
				}
				if ("?" === l$1[0]) {
					const t$3 = st(a$1[":@"], e$2), i$1 = "?xml" === l$1 ? "" : n$2;
					let o$3 = a$1[l$1][0][e$2.textNodeName];
					o$3 = 0 !== o$3.length ? " " + o$3 : "", s$1 += i$1 + `<${l$1}${o$3}${t$3}?>`, r$2 = !0;
					continue;
				}
				let h$1 = n$2;
				"" !== h$1 && (h$1 += e$2.indentBy);
				const d$1 = n$2 + `<${l$1}${st(a$1[":@"], e$2)}`, p$1 = it(a$1[l$1], e$2, u$1, h$1);
				-1 !== e$2.unpairedTags.indexOf(l$1) ? e$2.suppressUnpairedNode ? s$1 += d$1 + ">" : s$1 += d$1 + "/>" : p$1 && 0 !== p$1.length || !e$2.suppressEmptyNode ? p$1 && p$1.endsWith(">") ? s$1 += d$1 + `>${p$1}${n$2}</${l$1}>` : (s$1 += d$1 + ">", p$1 && "" !== n$2 && (p$1.includes("/>") || p$1.includes("</")) ? s$1 += n$2 + e$2.indentBy + p$1 + n$2 : s$1 += p$1, s$1 += `</${l$1}>`) : s$1 += d$1 + "/>", r$2 = !0;
			}
			return s$1;
		}
		function nt(t$2) {
			const e$2 = Object.keys(t$2);
			for (let i = 0; i < e$2.length; i++) {
				const n$2 = e$2[i];
				if (t$2.hasOwnProperty(n$2) && ":@" !== n$2) return n$2;
			}
		}
		function st(t$2, e$2) {
			let i = "";
			if (t$2 && !e$2.ignoreAttributes) for (let n$2 in t$2) {
				if (!t$2.hasOwnProperty(n$2)) continue;
				let s$1 = e$2.attributeValueProcessor(n$2, t$2[n$2]);
				s$1 = ot(s$1, e$2), !0 === s$1 && e$2.suppressBooleanAttributes ? i += ` ${n$2.substr(e$2.attributeNamePrefix.length)}` : i += ` ${n$2.substr(e$2.attributeNamePrefix.length)}="${s$1}"`;
			}
			return i;
		}
		function rt(t$2, e$2) {
			let i = (t$2 = t$2.substr(0, t$2.length - e$2.textNodeName.length - 1)).substr(t$2.lastIndexOf(".") + 1);
			for (let n$2 in e$2.stopNodes) if (e$2.stopNodes[n$2] === t$2 || e$2.stopNodes[n$2] === "*." + i) return !0;
			return !1;
		}
		function ot(t$2, e$2) {
			if (t$2 && t$2.length > 0 && e$2.processEntities) for (let i = 0; i < e$2.entities.length; i++) {
				const n$2 = e$2.entities[i];
				t$2 = t$2.replace(n$2.regex, n$2.val);
			}
			return t$2;
		}
		const at = {
			attributeNamePrefix: "@_",
			attributesGroupName: !1,
			textNodeName: "#text",
			ignoreAttributes: !0,
			cdataPropName: !1,
			format: !1,
			indentBy: "  ",
			suppressEmptyNode: !1,
			suppressUnpairedNode: !0,
			suppressBooleanAttributes: !0,
			tagValueProcessor: function(t$2, e$2) {
				return e$2;
			},
			attributeValueProcessor: function(t$2, e$2) {
				return e$2;
			},
			preserveOrder: !1,
			commentPropName: !1,
			unpairedTags: [],
			entities: [
				{
					regex: new RegExp("&", "g"),
					val: "&amp;"
				},
				{
					regex: new RegExp(">", "g"),
					val: "&gt;"
				},
				{
					regex: new RegExp("<", "g"),
					val: "&lt;"
				},
				{
					regex: new RegExp("'", "g"),
					val: "&apos;"
				},
				{
					regex: new RegExp("\"", "g"),
					val: "&quot;"
				}
			],
			processEntities: !0,
			stopNodes: [],
			oneListGroup: !1
		};
		function lt(t$2) {
			this.options = Object.assign({}, at, t$2), !0 === this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
				return !1;
			} : (this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = dt), this.processTextOrObjNode = ut, this.options.format ? (this.indentate = ht, this.tagEndChar = ">\n", this.newLine = "\n") : (this.indentate = function() {
				return "";
			}, this.tagEndChar = ">", this.newLine = "");
		}
		function ut(t$2, e$2, i, n$2) {
			const s$1 = this.j2x(t$2, i + 1, n$2.concat(e$2));
			return void 0 !== t$2[this.options.textNodeName] && 1 === Object.keys(t$2).length ? this.buildTextValNode(t$2[this.options.textNodeName], e$2, s$1.attrStr, i) : this.buildObjectNode(s$1.val, e$2, s$1.attrStr, i);
		}
		function ht(t$2) {
			return this.options.indentBy.repeat(t$2);
		}
		function dt(t$2) {
			return !(!t$2.startsWith(this.options.attributeNamePrefix) || t$2 === this.options.textNodeName) && t$2.substr(this.attrPrefixLen);
		}
		lt.prototype.build = function(t$2) {
			return this.options.preserveOrder ? et(t$2, this.options) : (Array.isArray(t$2) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t$2 = { [this.options.arrayNodeName]: t$2 }), this.j2x(t$2, 0, []).val);
		}, lt.prototype.j2x = function(t$2, e$2, i) {
			let n$2 = "", s$1 = "";
			const r$2 = i.join(".");
			for (let o$2 in t$2) if (Object.prototype.hasOwnProperty.call(t$2, o$2)) if (void 0 === t$2[o$2]) this.isAttribute(o$2) && (s$1 += "");
			else if (null === t$2[o$2]) this.isAttribute(o$2) || o$2 === this.options.cdataPropName ? s$1 += "" : "?" === o$2[0] ? s$1 += this.indentate(e$2) + "<" + o$2 + "?" + this.tagEndChar : s$1 += this.indentate(e$2) + "<" + o$2 + "/" + this.tagEndChar;
			else if (t$2[o$2] instanceof Date) s$1 += this.buildTextValNode(t$2[o$2], o$2, "", e$2);
			else if ("object" != typeof t$2[o$2]) {
				const i$1 = this.isAttribute(o$2);
				if (i$1 && !this.ignoreAttributesFn(i$1, r$2)) n$2 += this.buildAttrPairStr(i$1, "" + t$2[o$2]);
				else if (!i$1) if (o$2 === this.options.textNodeName) {
					let e$3 = this.options.tagValueProcessor(o$2, "" + t$2[o$2]);
					s$1 += this.replaceEntitiesValue(e$3);
				} else s$1 += this.buildTextValNode(t$2[o$2], o$2, "", e$2);
			} else if (Array.isArray(t$2[o$2])) {
				const n$3 = t$2[o$2].length;
				let r$3 = "", a$1 = "";
				for (let l$1 = 0; l$1 < n$3; l$1++) {
					const n$4 = t$2[o$2][l$1];
					if (void 0 === n$4);
					else if (null === n$4) "?" === o$2[0] ? s$1 += this.indentate(e$2) + "<" + o$2 + "?" + this.tagEndChar : s$1 += this.indentate(e$2) + "<" + o$2 + "/" + this.tagEndChar;
					else if ("object" == typeof n$4) if (this.options.oneListGroup) {
						const t$3 = this.j2x(n$4, e$2 + 1, i.concat(o$2));
						r$3 += t$3.val, this.options.attributesGroupName && n$4.hasOwnProperty(this.options.attributesGroupName) && (a$1 += t$3.attrStr);
					} else r$3 += this.processTextOrObjNode(n$4, o$2, e$2, i);
					else if (this.options.oneListGroup) {
						let t$3 = this.options.tagValueProcessor(o$2, n$4);
						t$3 = this.replaceEntitiesValue(t$3), r$3 += t$3;
					} else r$3 += this.buildTextValNode(n$4, o$2, "", e$2);
				}
				this.options.oneListGroup && (r$3 = this.buildObjectNode(r$3, o$2, a$1, e$2)), s$1 += r$3;
			} else if (this.options.attributesGroupName && o$2 === this.options.attributesGroupName) {
				const e$3 = Object.keys(t$2[o$2]), i$1 = e$3.length;
				for (let s$2 = 0; s$2 < i$1; s$2++) n$2 += this.buildAttrPairStr(e$3[s$2], "" + t$2[o$2][e$3[s$2]]);
			} else s$1 += this.processTextOrObjNode(t$2[o$2], o$2, e$2, i);
			return {
				attrStr: n$2,
				val: s$1
			};
		}, lt.prototype.buildAttrPairStr = function(t$2, e$2) {
			return e$2 = this.options.attributeValueProcessor(t$2, "" + e$2), e$2 = this.replaceEntitiesValue(e$2), this.options.suppressBooleanAttributes && "true" === e$2 ? " " + t$2 : " " + t$2 + "=\"" + e$2 + "\"";
		}, lt.prototype.buildObjectNode = function(t$2, e$2, i, n$2) {
			if ("" === t$2) return "?" === e$2[0] ? this.indentate(n$2) + "<" + e$2 + i + "?" + this.tagEndChar : this.indentate(n$2) + "<" + e$2 + i + this.closeTag(e$2) + this.tagEndChar;
			{
				let s$1 = "</" + e$2 + this.tagEndChar, r$2 = "";
				return "?" === e$2[0] && (r$2 = "?", s$1 = ""), !i && "" !== i || -1 !== t$2.indexOf("<") ? !1 !== this.options.commentPropName && e$2 === this.options.commentPropName && 0 === r$2.length ? this.indentate(n$2) + `\x3c!--${t$2}--\x3e` + this.newLine : this.indentate(n$2) + "<" + e$2 + i + r$2 + this.tagEndChar + t$2 + this.indentate(n$2) + s$1 : this.indentate(n$2) + "<" + e$2 + i + r$2 + ">" + t$2 + s$1;
			}
		}, lt.prototype.closeTag = function(t$2) {
			let e$2 = "";
			return -1 !== this.options.unpairedTags.indexOf(t$2) ? this.options.suppressUnpairedNode || (e$2 = "/") : e$2 = this.options.suppressEmptyNode ? "/" : `></${t$2}`, e$2;
		}, lt.prototype.buildTextValNode = function(t$2, e$2, i, n$2) {
			if (!1 !== this.options.cdataPropName && e$2 === this.options.cdataPropName) return this.indentate(n$2) + `<![CDATA[${t$2}]]>` + this.newLine;
			if (!1 !== this.options.commentPropName && e$2 === this.options.commentPropName) return this.indentate(n$2) + `\x3c!--${t$2}--\x3e` + this.newLine;
			if ("?" === e$2[0]) return this.indentate(n$2) + "<" + e$2 + i + "?" + this.tagEndChar;
			{
				let s$1 = this.options.tagValueProcessor(e$2, t$2);
				return s$1 = this.replaceEntitiesValue(s$1), "" === s$1 ? this.indentate(n$2) + "<" + e$2 + i + this.closeTag(e$2) + this.tagEndChar : this.indentate(n$2) + "<" + e$2 + i + ">" + s$1 + "</" + e$2 + this.tagEndChar;
			}
		}, lt.prototype.replaceEntitiesValue = function(t$2) {
			if (t$2 && t$2.length > 0 && this.options.processEntities) for (let e$2 = 0; e$2 < this.options.entities.length; e$2++) {
				const i = this.options.entities[e$2];
				t$2 = t$2.replace(i.regex, i.val);
			}
			return t$2;
		};
		const pt = { validate: a };
		module.exports = e$1;
	})();
}));
var require_xml_common = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XML_CHARKEY = exports.XML_ATTRKEY = void 0;
	exports.XML_ATTRKEY = "$";
	exports.XML_CHARKEY = "_";
}));
var require_xml = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.stringifyXML = stringifyXML;
	exports.parseXML = parseXML;
	var fast_xml_parser_1 = require_fxp();
	var xml_common_js_1 = require_xml_common();
	function getCommonOptions(options) {
		var _a;
		return {
			attributesGroupName: xml_common_js_1.XML_ATTRKEY,
			textNodeName: (_a = options.xmlCharKey) !== null && _a !== void 0 ? _a : xml_common_js_1.XML_CHARKEY,
			ignoreAttributes: false,
			suppressBooleanAttributes: false
		};
	}
	function getSerializerOptions(options = {}) {
		var _a, _b;
		return Object.assign(Object.assign({}, getCommonOptions(options)), {
			attributeNamePrefix: "@_",
			format: true,
			suppressEmptyNode: true,
			indentBy: "",
			rootNodeName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "root",
			cdataPropName: (_b = options.cdataPropName) !== null && _b !== void 0 ? _b : "__cdata"
		});
	}
	function getParserOptions(options = {}) {
		return Object.assign(Object.assign({}, getCommonOptions(options)), {
			parseAttributeValue: false,
			parseTagValue: false,
			attributeNamePrefix: "",
			stopNodes: options.stopNodes,
			processEntities: true,
			trimValues: false
		});
	}
	function stringifyXML(obj, opts = {}) {
		const parserOptions = getSerializerOptions(opts);
		const j2x = new fast_xml_parser_1.XMLBuilder(parserOptions);
		const node = { [parserOptions.rootNodeName]: obj };
		return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${j2x.build(node)}`.replace(/\n/g, "");
	}
	async function parseXML(str, opts = {}) {
		if (!str) throw new Error("Document is empty");
		const validation = fast_xml_parser_1.XMLValidator.validate(str);
		if (validation !== true) throw validation;
		const parsedXml = new fast_xml_parser_1.XMLParser(getParserOptions(opts)).parse(str);
		if (parsedXml["?xml"]) delete parsedXml["?xml"];
		if (!opts.includeRoot) for (const key of Object.keys(parsedXml)) {
			const value$1 = parsedXml[key];
			return typeof value$1 === "object" ? Object.assign({}, value$1) : value$1;
		}
		return parsedXml;
	}
}));
var require_commonjs$8 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.parseXML = exports.stringifyXML = void 0;
	var xml_js_1 = require_xml();
	Object.defineProperty(exports, "stringifyXML", {
		enumerable: true,
		get: function() {
			return xml_js_1.stringifyXML;
		}
	});
	Object.defineProperty(exports, "parseXML", {
		enumerable: true,
		get: function() {
			return xml_js_1.parseXML;
		}
	});
	var xml_common_js_1 = require_xml_common();
	Object.defineProperty(exports, "XML_ATTRKEY", {
		enumerable: true,
		get: function() {
			return xml_common_js_1.XML_ATTRKEY;
		}
	});
	Object.defineProperty(exports, "XML_CHARKEY", {
		enumerable: true,
		get: function() {
			return xml_common_js_1.XML_CHARKEY;
		}
	});
}));
var require_log$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logger = void 0;
	exports.logger = (0, require_commonjs$16().createClientLogger)("storage-blob");
}));
var require_RequestPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BaseRequestPolicy = void 0;
	var BaseRequestPolicy = class {
		_nextPolicy;
		_options;
		constructor(_nextPolicy, _options) {
			this._nextPolicy = _nextPolicy;
			this._options = _options;
		}
		shouldLog(logLevel) {
			return this._options.shouldLog(logLevel);
		}
		log(logLevel, message) {
			this._options.log(logLevel, message);
		}
	};
	exports.BaseRequestPolicy = BaseRequestPolicy;
}));
var require_constants$4 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PathStylePorts = exports.BlobDoesNotUseCustomerSpecifiedEncryption = exports.BlobUsesCustomerSpecifiedEncryptionMsg = exports.StorageBlobLoggingAllowedQueryParameters = exports.StorageBlobLoggingAllowedHeaderNames = exports.DevelopmentConnectionString = exports.EncryptionAlgorithmAES25 = exports.HTTP_VERSION_1_1 = exports.HTTP_LINE_ENDING = exports.BATCH_MAX_PAYLOAD_IN_BYTES = exports.BATCH_MAX_REQUEST = exports.SIZE_1_MB = exports.ETagAny = exports.ETagNone = exports.HeaderConstants = exports.HTTPURLConnection = exports.URLConstants = exports.StorageOAuthScopes = exports.REQUEST_TIMEOUT = exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = exports.BLOCK_BLOB_MAX_BLOCKS = exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = exports.SERVICE_VERSION = exports.SDK_VERSION = void 0;
	exports.SDK_VERSION = "12.29.1";
	exports.SERVICE_VERSION = "2025-11-05";
	exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024;
	exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4e3 * 1024 * 1024;
	exports.BLOCK_BLOB_MAX_BLOCKS = 5e4;
	exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024;
	exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024;
	exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
	exports.REQUEST_TIMEOUT = 100 * 1e3;
	exports.StorageOAuthScopes = "https://storage.azure.com/.default";
	exports.URLConstants = { Parameters: {
		FORCE_BROWSER_NO_CACHE: "_",
		SIGNATURE: "sig",
		SNAPSHOT: "snapshot",
		VERSIONID: "versionid",
		TIMEOUT: "timeout"
	} };
	exports.HTTPURLConnection = {
		HTTP_ACCEPTED: 202,
		HTTP_CONFLICT: 409,
		HTTP_NOT_FOUND: 404,
		HTTP_PRECON_FAILED: 412,
		HTTP_RANGE_NOT_SATISFIABLE: 416
	};
	exports.HeaderConstants = {
		AUTHORIZATION: "Authorization",
		AUTHORIZATION_SCHEME: "Bearer",
		CONTENT_ENCODING: "Content-Encoding",
		CONTENT_ID: "Content-ID",
		CONTENT_LANGUAGE: "Content-Language",
		CONTENT_LENGTH: "Content-Length",
		CONTENT_MD5: "Content-Md5",
		CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
		CONTENT_TYPE: "Content-Type",
		COOKIE: "Cookie",
		DATE: "date",
		IF_MATCH: "if-match",
		IF_MODIFIED_SINCE: "if-modified-since",
		IF_NONE_MATCH: "if-none-match",
		IF_UNMODIFIED_SINCE: "if-unmodified-since",
		PREFIX_FOR_STORAGE: "x-ms-",
		RANGE: "Range",
		USER_AGENT: "User-Agent",
		X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
		X_MS_COPY_SOURCE: "x-ms-copy-source",
		X_MS_DATE: "x-ms-date",
		X_MS_ERROR_CODE: "x-ms-error-code",
		X_MS_VERSION: "x-ms-version",
		X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
	};
	exports.ETagNone = "";
	exports.ETagAny = "*";
	exports.SIZE_1_MB = 1 * 1024 * 1024;
	exports.BATCH_MAX_REQUEST = 256;
	exports.BATCH_MAX_PAYLOAD_IN_BYTES = 4 * exports.SIZE_1_MB;
	exports.HTTP_LINE_ENDING = "\r\n";
	exports.HTTP_VERSION_1_1 = "HTTP/1.1";
	exports.EncryptionAlgorithmAES25 = "AES256";
	exports.DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
	exports.StorageBlobLoggingAllowedHeaderNames = [
		"Access-Control-Allow-Origin",
		"Cache-Control",
		"Content-Length",
		"Content-Type",
		"Date",
		"Request-Id",
		"traceparent",
		"Transfer-Encoding",
		"User-Agent",
		"x-ms-client-request-id",
		"x-ms-date",
		"x-ms-error-code",
		"x-ms-request-id",
		"x-ms-return-client-request-id",
		"x-ms-version",
		"Accept-Ranges",
		"Content-Disposition",
		"Content-Encoding",
		"Content-Language",
		"Content-MD5",
		"Content-Range",
		"ETag",
		"Last-Modified",
		"Server",
		"Vary",
		"x-ms-content-crc64",
		"x-ms-copy-action",
		"x-ms-copy-completion-time",
		"x-ms-copy-id",
		"x-ms-copy-progress",
		"x-ms-copy-status",
		"x-ms-has-immutability-policy",
		"x-ms-has-legal-hold",
		"x-ms-lease-state",
		"x-ms-lease-status",
		"x-ms-range",
		"x-ms-request-server-encrypted",
		"x-ms-server-encrypted",
		"x-ms-snapshot",
		"x-ms-source-range",
		"If-Match",
		"If-Modified-Since",
		"If-None-Match",
		"If-Unmodified-Since",
		"x-ms-access-tier",
		"x-ms-access-tier-change-time",
		"x-ms-access-tier-inferred",
		"x-ms-account-kind",
		"x-ms-archive-status",
		"x-ms-blob-append-offset",
		"x-ms-blob-cache-control",
		"x-ms-blob-committed-block-count",
		"x-ms-blob-condition-appendpos",
		"x-ms-blob-condition-maxsize",
		"x-ms-blob-content-disposition",
		"x-ms-blob-content-encoding",
		"x-ms-blob-content-language",
		"x-ms-blob-content-length",
		"x-ms-blob-content-md5",
		"x-ms-blob-content-type",
		"x-ms-blob-public-access",
		"x-ms-blob-sequence-number",
		"x-ms-blob-type",
		"x-ms-copy-destination-snapshot",
		"x-ms-creation-time",
		"x-ms-default-encryption-scope",
		"x-ms-delete-snapshots",
		"x-ms-delete-type-permanent",
		"x-ms-deny-encryption-scope-override",
		"x-ms-encryption-algorithm",
		"x-ms-if-sequence-number-eq",
		"x-ms-if-sequence-number-le",
		"x-ms-if-sequence-number-lt",
		"x-ms-incremental-copy",
		"x-ms-lease-action",
		"x-ms-lease-break-period",
		"x-ms-lease-duration",
		"x-ms-lease-id",
		"x-ms-lease-time",
		"x-ms-page-write",
		"x-ms-proposed-lease-id",
		"x-ms-range-get-content-md5",
		"x-ms-rehydrate-priority",
		"x-ms-sequence-number-action",
		"x-ms-sku-name",
		"x-ms-source-content-md5",
		"x-ms-source-if-match",
		"x-ms-source-if-modified-since",
		"x-ms-source-if-none-match",
		"x-ms-source-if-unmodified-since",
		"x-ms-tag-count",
		"x-ms-encryption-key-sha256",
		"x-ms-copy-source-error-code",
		"x-ms-copy-source-status-code",
		"x-ms-if-tags",
		"x-ms-source-if-tags"
	];
	exports.StorageBlobLoggingAllowedQueryParameters = [
		"comp",
		"maxresults",
		"rscc",
		"rscd",
		"rsce",
		"rscl",
		"rsct",
		"se",
		"si",
		"sip",
		"sp",
		"spr",
		"sr",
		"srt",
		"ss",
		"st",
		"sv",
		"include",
		"marker",
		"prefix",
		"copyid",
		"restype",
		"blockid",
		"blocklisttype",
		"delimiter",
		"prevsnapshot",
		"ske",
		"skoid",
		"sks",
		"skt",
		"sktid",
		"skv",
		"snapshot"
	];
	exports.BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
	exports.BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
	exports.PathStylePorts = [
		"10000",
		"10001",
		"10002",
		"10003",
		"10004",
		"10100",
		"10101",
		"10102",
		"10103",
		"10104",
		"11000",
		"11001",
		"11002",
		"11003",
		"11004",
		"11100",
		"11101",
		"11102",
		"11103",
		"11104"
	];
}));
var require_utils_common$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.escapeURLPath = escapeURLPath;
	exports.getValueInConnString = getValueInConnString;
	exports.extractConnectionStringParts = extractConnectionStringParts;
	exports.appendToURLPath = appendToURLPath;
	exports.setURLParameter = setURLParameter;
	exports.getURLParameter = getURLParameter;
	exports.setURLHost = setURLHost;
	exports.getURLPath = getURLPath;
	exports.getURLScheme = getURLScheme;
	exports.getURLPathAndQuery = getURLPathAndQuery;
	exports.getURLQueries = getURLQueries;
	exports.appendToURLQuery = appendToURLQuery;
	exports.truncatedISO8061Date = truncatedISO8061Date;
	exports.base64encode = base64encode;
	exports.base64decode = base64decode;
	exports.generateBlockID = generateBlockID;
	exports.delay = delay;
	exports.padStart = padStart;
	exports.sanitizeURL = sanitizeURL;
	exports.sanitizeHeaders = sanitizeHeaders;
	exports.iEqual = iEqual;
	exports.getAccountNameFromUrl = getAccountNameFromUrl;
	exports.isIpEndpointStyle = isIpEndpointStyle;
	exports.toBlobTagsString = toBlobTagsString;
	exports.toBlobTags = toBlobTags;
	exports.toTags = toTags;
	exports.toQuerySerialization = toQuerySerialization;
	exports.parseObjectReplicationRecord = parseObjectReplicationRecord;
	exports.attachCredential = attachCredential;
	exports.httpAuthorizationToString = httpAuthorizationToString;
	exports.BlobNameToString = BlobNameToString;
	exports.ConvertInternalResponseOfListBlobFlat = ConvertInternalResponseOfListBlobFlat;
	exports.ConvertInternalResponseOfListBlobHierarchy = ConvertInternalResponseOfListBlobHierarchy;
	exports.ExtractPageRangeInfoItems = ExtractPageRangeInfoItems;
	exports.EscapePath = EscapePath;
	exports.assertResponse = assertResponse;
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_util_1 = require_commonjs$14();
	var constants_js_1 = require_constants$4();
	function escapeURLPath(url) {
		const urlParsed = new URL(url);
		let path$5 = urlParsed.pathname;
		path$5 = path$5 || "/";
		path$5 = escape(path$5);
		urlParsed.pathname = path$5;
		return urlParsed.toString();
	}
	function getProxyUriFromDevConnString(connectionString) {
		let proxyUri = "";
		if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
			const matchCredentials = connectionString.split(";");
			for (const element of matchCredentials) if (element.trim().startsWith("DevelopmentStorageProxyUri=")) proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
		}
		return proxyUri;
	}
	function getValueInConnString(connectionString, argument) {
		const elements = connectionString.split(";");
		for (const element of elements) if (element.trim().startsWith(argument)) return element.trim().match(argument + "=(.*)")[1];
		return "";
	}
	function extractConnectionStringParts(connectionString) {
		let proxyUri = "";
		if (connectionString.startsWith("UseDevelopmentStorage=true")) {
			proxyUri = getProxyUriFromDevConnString(connectionString);
			connectionString = constants_js_1.DevelopmentConnectionString;
		}
		let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
		blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
		if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
			let defaultEndpointsProtocol = "";
			let accountName = "";
			let accountKey = Buffer.from("accountKey", "base64");
			let endpointSuffix = "";
			accountName = getValueInConnString(connectionString, "AccountName");
			accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
			if (!blobEndpoint) {
				defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
				const protocol = defaultEndpointsProtocol.toLowerCase();
				if (protocol !== "https" && protocol !== "http") throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
				endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
				if (!endpointSuffix) throw new Error("Invalid EndpointSuffix in the provided Connection String");
				blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
			}
			if (!accountName) throw new Error("Invalid AccountName in the provided Connection String");
			else if (accountKey.length === 0) throw new Error("Invalid AccountKey in the provided Connection String");
			return {
				kind: "AccountConnString",
				url: blobEndpoint,
				accountName,
				accountKey,
				proxyUri
			};
		} else {
			let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
			let accountName = getValueInConnString(connectionString, "AccountName");
			if (!accountName) accountName = getAccountNameFromUrl(blobEndpoint);
			if (!blobEndpoint) throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
			else if (!accountSas) throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
			if (accountSas.startsWith("?")) accountSas = accountSas.substring(1);
			return {
				kind: "SASConnString",
				url: blobEndpoint,
				accountName,
				accountSas
			};
		}
	}
	function escape(text) {
		return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
	}
	function appendToURLPath(url, name$1) {
		const urlParsed = new URL(url);
		let path$5 = urlParsed.pathname;
		path$5 = path$5 ? path$5.endsWith("/") ? `${path$5}${name$1}` : `${path$5}/${name$1}` : name$1;
		urlParsed.pathname = path$5;
		return urlParsed.toString();
	}
	function setURLParameter(url, name$1, value$1) {
		const urlParsed = new URL(url);
		const encodedName = encodeURIComponent(name$1);
		const encodedValue = value$1 ? encodeURIComponent(value$1) : void 0;
		const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
		const searchPieces = [];
		for (const pair of searchString.slice(1).split("&")) if (pair) {
			const [key] = pair.split("=", 2);
			if (key !== encodedName) searchPieces.push(pair);
		}
		if (encodedValue) searchPieces.push(`${encodedName}=${encodedValue}`);
		urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
		return urlParsed.toString();
	}
	function getURLParameter(url, name$1) {
		return new URL(url).searchParams.get(name$1) ?? void 0;
	}
	function setURLHost(url, host) {
		const urlParsed = new URL(url);
		urlParsed.hostname = host;
		return urlParsed.toString();
	}
	function getURLPath(url) {
		try {
			return new URL(url).pathname;
		} catch (e$1) {
			return;
		}
	}
	function getURLScheme(url) {
		try {
			const urlParsed = new URL(url);
			return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
		} catch (e$1) {
			return;
		}
	}
	function getURLPathAndQuery(url) {
		const urlParsed = new URL(url);
		const pathString = urlParsed.pathname;
		if (!pathString) throw new RangeError("Invalid url without valid path.");
		let queryString = urlParsed.search || "";
		queryString = queryString.trim();
		if (queryString !== "") queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
		return `${pathString}${queryString}`;
	}
	function getURLQueries(url) {
		let queryString = new URL(url).search;
		if (!queryString) return {};
		queryString = queryString.trim();
		queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
		let querySubStrings = queryString.split("&");
		querySubStrings = querySubStrings.filter((value$1) => {
			const indexOfEqual = value$1.indexOf("=");
			const lastIndexOfEqual = value$1.lastIndexOf("=");
			return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value$1.length - 1;
		});
		const queries = {};
		for (const querySubString of querySubStrings) {
			const splitResults = querySubString.split("=");
			const key = splitResults[0];
			queries[key] = splitResults[1];
		}
		return queries;
	}
	function appendToURLQuery(url, queryParts) {
		const urlParsed = new URL(url);
		let query = urlParsed.search;
		if (query) query += "&" + queryParts;
		else query = queryParts;
		urlParsed.search = query;
		return urlParsed.toString();
	}
	function truncatedISO8061Date(date, withMilliseconds = true) {
		const dateString = date.toISOString();
		return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
	}
	function base64encode(content) {
		return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
	}
	function base64decode(encodedString) {
		return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
	}
	function generateBlockID(blockIDPrefix, blockIndex) {
		const maxSourceStringLength = 48;
		const maxAllowedBlockIDPrefixLength = maxSourceStringLength - 6;
		if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
		return base64encode(blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0"));
	}
	async function delay(timeInMs, aborter, abortError) {
		return new Promise((resolve$1, reject$3) => {
			let timeout$1;
			const abortHandler = () => {
				if (timeout$1 !== void 0) clearTimeout(timeout$1);
				reject$3(abortError);
			};
			const resolveHandler = () => {
				if (aborter !== void 0) aborter.removeEventListener("abort", abortHandler);
				resolve$1();
			};
			timeout$1 = setTimeout(resolveHandler, timeInMs);
			if (aborter !== void 0) aborter.addEventListener("abort", abortHandler);
		});
	}
	function padStart(currentString, targetLength, padString = " ") {
		if (String.prototype.padStart) return currentString.padStart(targetLength, padString);
		padString = padString || " ";
		if (currentString.length > targetLength) return currentString;
		else {
			targetLength = targetLength - currentString.length;
			if (targetLength > padString.length) padString += padString.repeat(targetLength / padString.length);
			return padString.slice(0, targetLength) + currentString;
		}
	}
	function sanitizeURL(url) {
		let safeURL = url;
		if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE)) safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
		return safeURL;
	}
	function sanitizeHeaders(originalHeader) {
		const headers = (0, core_rest_pipeline_1.createHttpHeaders)();
		for (const [name$1, value$1] of originalHeader) if (name$1.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase()) headers.set(name$1, "*****");
		else if (name$1.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE) headers.set(name$1, sanitizeURL(value$1));
		else headers.set(name$1, value$1);
		return headers;
	}
	function iEqual(str1, str2) {
		return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
	}
	function getAccountNameFromUrl(url) {
		const parsedUrl = new URL(url);
		let accountName;
		try {
			if (parsedUrl.hostname.split(".")[1] === "blob") accountName = parsedUrl.hostname.split(".")[0];
			else if (isIpEndpointStyle(parsedUrl)) accountName = parsedUrl.pathname.split("/")[1];
			else accountName = "";
			return accountName;
		} catch (error) {
			throw new Error("Unable to extract accountName with provided information.");
		}
	}
	function isIpEndpointStyle(parsedUrl) {
		const host = parsedUrl.host;
		return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
	}
	function toBlobTagsString(tags) {
		if (tags === void 0) return;
		const tagPairs = [];
		for (const key in tags) if (Object.prototype.hasOwnProperty.call(tags, key)) {
			const value$1 = tags[key];
			tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value$1)}`);
		}
		return tagPairs.join("&");
	}
	function toBlobTags(tags) {
		if (tags === void 0) return;
		const res = { blobTagSet: [] };
		for (const key in tags) if (Object.prototype.hasOwnProperty.call(tags, key)) {
			const value$1 = tags[key];
			res.blobTagSet.push({
				key,
				value: value$1
			});
		}
		return res;
	}
	function toTags(tags) {
		if (tags === void 0) return;
		const res = {};
		for (const blobTag of tags.blobTagSet) res[blobTag.key] = blobTag.value;
		return res;
	}
	function toQuerySerialization(textConfiguration) {
		if (textConfiguration === void 0) return;
		switch (textConfiguration.kind) {
			case "csv": return { format: {
				type: "delimited",
				delimitedTextConfiguration: {
					columnSeparator: textConfiguration.columnSeparator || ",",
					fieldQuote: textConfiguration.fieldQuote || "",
					recordSeparator: textConfiguration.recordSeparator,
					escapeChar: textConfiguration.escapeCharacter || "",
					headersPresent: textConfiguration.hasHeaders || false
				}
			} };
			case "json": return { format: {
				type: "json",
				jsonTextConfiguration: { recordSeparator: textConfiguration.recordSeparator }
			} };
			case "arrow": return { format: {
				type: "arrow",
				arrowConfiguration: { schema: textConfiguration.schema }
			} };
			case "parquet": return { format: { type: "parquet" } };
			default: throw Error("Invalid BlobQueryTextConfiguration.");
		}
	}
	function parseObjectReplicationRecord(objectReplicationRecord) {
		if (!objectReplicationRecord) return;
		if ("policy-id" in objectReplicationRecord) return;
		const orProperties = [];
		for (const key in objectReplicationRecord) {
			const ids = key.split("_");
			if (ids[0].startsWith("or-")) ids[0] = ids[0].substring(3);
			const rule = {
				ruleId: ids[1],
				replicationStatus: objectReplicationRecord[key]
			};
			const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);
			if (policyIndex > -1) orProperties[policyIndex].rules.push(rule);
			else orProperties.push({
				policyId: ids[0],
				rules: [rule]
			});
		}
		return orProperties;
	}
	function attachCredential(thing, credential) {
		thing.credential = credential;
		return thing;
	}
	function httpAuthorizationToString(httpAuthorization) {
		return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
	}
	function BlobNameToString(name$1) {
		if (name$1.encoded) return decodeURIComponent(name$1.content);
		else return name$1.content;
	}
	function ConvertInternalResponseOfListBlobFlat(internalResponse) {
		return {
			...internalResponse,
			segment: { blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
				return {
					...blobItemInteral,
					name: BlobNameToString(blobItemInteral.name)
				};
			}) }
		};
	}
	function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
		return {
			...internalResponse,
			segment: {
				blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal) => {
					return {
						...blobPrefixInternal,
						name: BlobNameToString(blobPrefixInternal.name)
					};
				}),
				blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
					return {
						...blobItemInteral,
						name: BlobNameToString(blobItemInteral.name)
					};
				})
			}
		};
	}
	function* ExtractPageRangeInfoItems(getPageRangesSegment) {
		let pageRange = [];
		let clearRange = [];
		if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;
		if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;
		let pageRangeIndex = 0;
		let clearRangeIndex = 0;
		while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
			yield {
				start: pageRange[pageRangeIndex].start,
				end: pageRange[pageRangeIndex].end,
				isClear: false
			};
			++pageRangeIndex;
		} else {
			yield {
				start: clearRange[clearRangeIndex].start,
				end: clearRange[clearRangeIndex].end,
				isClear: true
			};
			++clearRangeIndex;
		}
		for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) yield {
			start: pageRange[pageRangeIndex].start,
			end: pageRange[pageRangeIndex].end,
			isClear: false
		};
		for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) yield {
			start: clearRange[clearRangeIndex].start,
			end: clearRange[clearRangeIndex].end,
			isClear: true
		};
	}
	function EscapePath(blobName) {
		const split = blobName.split("/");
		for (let i = 0; i < split.length; i++) split[i] = encodeURIComponent(split[i]);
		return split.join("/");
	}
	function assertResponse(response) {
		if (`_response` in response) return response;
		throw new TypeError(`Unexpected response object ${response}`);
	}
}));
var require_StorageRetryPolicyType$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageRetryPolicyType = void 0;
	var StorageRetryPolicyType;
	(function(StorageRetryPolicyType) {
		StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
		StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
	})(StorageRetryPolicyType || (exports.StorageRetryPolicyType = StorageRetryPolicyType = {}));
}));
var require_StorageRetryPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageRetryPolicy = void 0;
	exports.NewRetryPolicyFactory = NewRetryPolicyFactory;
	var abort_controller_1 = require_commonjs$15();
	var RequestPolicy_js_1 = require_RequestPolicy$1();
	var constants_js_1 = require_constants$4();
	var utils_common_js_1 = require_utils_common$2();
	var log_js_1 = require_log$2();
	var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType$1();
	function NewRetryPolicyFactory(retryOptions) {
		return { create: (nextPolicy, options) => {
			return new StorageRetryPolicy(nextPolicy, options, retryOptions);
		} };
	}
	var DEFAULT_RETRY_OPTIONS = {
		maxRetryDelayInMs: 120 * 1e3,
		maxTries: 4,
		retryDelayInMs: 4 * 1e3,
		retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
		secondaryHost: "",
		tryTimeoutInMs: void 0
	};
	var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
	var StorageRetryPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
		retryOptions;
		constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS) {
			super(nextPolicy, options);
			this.retryOptions = {
				retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
				maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
				tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
				retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
				maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
				secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
			};
		}
		async sendRequest(request$1) {
			return this.attemptSendRequest(request$1, false, 1);
		}
		async attemptSendRequest(request$1, secondaryHas404, attempt) {
			const newRequest = request$1.clone();
			const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request$1.method === "GET" || request$1.method === "HEAD" || request$1.method === "OPTIONS") || attempt % 2 === 1;
			if (!isPrimaryRetry) newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
			if (this.retryOptions.tryTimeoutInMs) newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString());
			let response;
			try {
				log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
				response = await this._nextPolicy.sendRequest(newRequest);
				if (!this.shouldRetry(isPrimaryRetry, attempt, response)) return response;
				secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
			} catch (err) {
				log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
				if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) throw err;
			}
			await this.delay(isPrimaryRetry, attempt, request$1.abortSignal);
			return this.attemptSendRequest(request$1, secondaryHas404, ++attempt);
		}
		shouldRetry(isPrimaryRetry, attempt, response, err) {
			if (attempt >= this.retryOptions.maxTries) {
				log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
				return false;
			}
			const retriableErrors = [
				"ETIMEDOUT",
				"ESOCKETTIMEDOUT",
				"ECONNREFUSED",
				"ECONNRESET",
				"ENOENT",
				"ENOTFOUND",
				"TIMEOUT",
				"EPIPE",
				"REQUEST_SEND_ERROR"
			];
			if (err) {
				for (const retriableError of retriableErrors) if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
					log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
					return true;
				}
			}
			if (response || err) {
				const statusCode = response ? response.status : err ? err.statusCode : 0;
				if (!isPrimaryRetry && statusCode === 404) {
					log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
					return true;
				}
				if (statusCode === 503 || statusCode === 500) {
					log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
					return true;
				}
			}
			if (response) {
				if (response?.status >= 400) {
					const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
					if (copySourceError !== void 0) switch (copySourceError) {
						case "InternalError":
						case "OperationTimedOut":
						case "ServerBusy": return true;
					}
				}
			}
			if (err?.code === "PARSE_ERROR" && err?.message.startsWith(`Error "Error: Unclosed root tag`)) {
				log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
				return true;
			}
			return false;
		}
		async delay(isPrimaryRetry, attempt, abortSignal$1) {
			let delayTimeInMs = 0;
			if (isPrimaryRetry) switch (this.retryOptions.retryPolicyType) {
				case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
					delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
					break;
				case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
					delayTimeInMs = this.retryOptions.retryDelayInMs;
					break;
			}
			else delayTimeInMs = Math.random() * 1e3;
			log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
			return (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal$1, RETRY_ABORT_ERROR);
		}
	};
	exports.StorageRetryPolicy = StorageRetryPolicy;
}));
var require_StorageRetryPolicyFactory$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = void 0;
	var StorageRetryPolicy_js_1 = require_StorageRetryPolicy$1();
	Object.defineProperty(exports, "StorageRetryPolicy", {
		enumerable: true,
		get: function() {
			return StorageRetryPolicy_js_1.StorageRetryPolicy;
		}
	});
	var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType$1();
	Object.defineProperty(exports, "StorageRetryPolicyType", {
		enumerable: true,
		get: function() {
			return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
		}
	});
	var StorageRetryPolicyFactory = class {
		retryOptions;
		constructor(retryOptions) {
			this.retryOptions = retryOptions;
		}
		create(nextPolicy, options) {
			return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options, this.retryOptions);
		}
	};
	exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
}));
var require_CredentialPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CredentialPolicy = void 0;
	var RequestPolicy_js_1 = require_RequestPolicy$1();
	var CredentialPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
		sendRequest(request$1) {
			return this._nextPolicy.sendRequest(this.signRequest(request$1));
		}
		signRequest(request$1) {
			return request$1;
		}
	};
	exports.CredentialPolicy = CredentialPolicy;
}));
var require_SharedKeyComparator$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.compareHeader = compareHeader;
	var table_lv0 = new Uint32Array([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1820,
		0,
		1823,
		1825,
		1827,
		1829,
		0,
		0,
		0,
		1837,
		2051,
		0,
		0,
		1843,
		0,
		3331,
		3354,
		3356,
		3358,
		3360,
		3362,
		3364,
		3366,
		3368,
		3370,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		3586,
		3593,
		3594,
		3610,
		3617,
		3619,
		3621,
		3628,
		3634,
		3637,
		3638,
		3656,
		3665,
		3696,
		3708,
		3710,
		3721,
		3722,
		3729,
		3737,
		3743,
		3746,
		3748,
		3750,
		3751,
		3753,
		0,
		0,
		0,
		1859,
		1860,
		1864,
		3586,
		3593,
		3594,
		3610,
		3617,
		3619,
		3621,
		3628,
		3634,
		3637,
		3638,
		3656,
		3665,
		3696,
		3708,
		3710,
		3721,
		3722,
		3729,
		3737,
		3743,
		3746,
		3748,
		3750,
		3751,
		3753,
		0,
		1868,
		0,
		1872,
		0
	]);
	var table_lv2 = new Uint32Array([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	]);
	var table_lv4 = new Uint32Array([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		32786,
		0,
		0,
		0,
		0,
		0,
		33298,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	]);
	function compareHeader(lhs, rhs) {
		if (isLessThan(lhs, rhs)) return -1;
		return 1;
	}
	function isLessThan(lhs, rhs) {
		const tables = [
			table_lv0,
			table_lv2,
			table_lv4
		];
		let curr_level = 0;
		let i = 0;
		let j = 0;
		while (curr_level < tables.length) {
			if (curr_level === tables.length - 1 && i !== j) return i > j;
			const weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 1;
			const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
			if (weight1 === 1 && weight2 === 1) {
				i = 0;
				j = 0;
				++curr_level;
			} else if (weight1 === weight2) {
				++i;
				++j;
			} else if (weight1 === 0) ++i;
			else if (weight2 === 0) ++j;
			else return weight1 < weight2;
		}
		return false;
	}
}));
var require_StorageSharedKeyCredentialPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageSharedKeyCredentialPolicy = void 0;
	var constants_js_1 = require_constants$4();
	var utils_common_js_1 = require_utils_common$2();
	var CredentialPolicy_js_1 = require_CredentialPolicy$1();
	var SharedKeyComparator_js_1 = require_SharedKeyComparator$1();
	var StorageSharedKeyCredentialPolicy = class extends CredentialPolicy_js_1.CredentialPolicy {
		factory;
		constructor(nextPolicy, options, factory) {
			super(nextPolicy, options);
			this.factory = factory;
		}
		signRequest(request$1) {
			request$1.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
			if (request$1.body && (typeof request$1.body === "string" || request$1.body !== void 0) && request$1.body.length > 0) request$1.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request$1.body));
			const stringToSign = [
				request$1.method.toUpperCase(),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_ENCODING),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_LENGTH),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_MD5),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_TYPE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.DATE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_MATCH),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_NONE_MATCH),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.RANGE)
			].join("\n") + "\n" + this.getCanonicalizedHeadersString(request$1) + this.getCanonicalizedResourceString(request$1);
			const signature = this.factory.computeHMACSHA256(stringToSign);
			request$1.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
			return request$1;
		}
		getHeaderValueToSign(request$1, headerName) {
			const value$1 = request$1.headers.get(headerName);
			if (!value$1) return "";
			if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value$1 === "0") return "";
			return value$1;
		}
		getCanonicalizedHeadersString(request$1) {
			let headersArray = request$1.headers.headersArray().filter((value$1) => {
				return value$1.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
			});
			headersArray.sort((a, b) => {
				return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
			});
			headersArray = headersArray.filter((value$1, index$1, array) => {
				if (index$1 > 0 && value$1.name.toLowerCase() === array[index$1 - 1].name.toLowerCase()) return false;
				return true;
			});
			let canonicalizedHeadersStringToSign = "";
			headersArray.forEach((header) => {
				canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
			});
			return canonicalizedHeadersStringToSign;
		}
		getCanonicalizedResourceString(request$1) {
			const path$5 = (0, utils_common_js_1.getURLPath)(request$1.url) || "/";
			let canonicalizedResourceString = "";
			canonicalizedResourceString += `/${this.factory.accountName}${path$5}`;
			const queries = (0, utils_common_js_1.getURLQueries)(request$1.url);
			const lowercaseQueries = {};
			if (queries) {
				const queryKeys = [];
				for (const key in queries) if (Object.prototype.hasOwnProperty.call(queries, key)) {
					const lowercaseKey = key.toLowerCase();
					lowercaseQueries[lowercaseKey] = queries[key];
					queryKeys.push(lowercaseKey);
				}
				queryKeys.sort();
				for (const key of queryKeys) canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
			}
			return canonicalizedResourceString;
		}
	};
	exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
}));
var require_Credential$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Credential = void 0;
	var Credential = class {
		create(_nextPolicy, _options) {
			throw new Error("Method should be implemented in children classes.");
		}
	};
	exports.Credential = Credential;
}));
var require_StorageSharedKeyCredential$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageSharedKeyCredential = void 0;
	var node_crypto_1$4 = __require("node:crypto");
	var StorageSharedKeyCredentialPolicy_js_1 = require_StorageSharedKeyCredentialPolicy$1();
	var Credential_js_1 = require_Credential$1();
	var StorageSharedKeyCredential = class extends Credential_js_1.Credential {
		accountName;
		accountKey;
		constructor(accountName, accountKey) {
			super();
			this.accountName = accountName;
			this.accountKey = Buffer.from(accountKey, "base64");
		}
		create(nextPolicy, options) {
			return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
		}
		computeHMACSHA256(stringToSign) {
			return (0, node_crypto_1$4.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
		}
	};
	exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
}));
var require_AnonymousCredentialPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AnonymousCredentialPolicy = void 0;
	var CredentialPolicy_js_1 = require_CredentialPolicy$1();
	var AnonymousCredentialPolicy = class extends CredentialPolicy_js_1.CredentialPolicy {
		constructor(nextPolicy, options) {
			super(nextPolicy, options);
		}
	};
	exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
}));
var require_AnonymousCredential$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AnonymousCredential = void 0;
	var AnonymousCredentialPolicy_js_1 = require_AnonymousCredentialPolicy$1();
	var Credential_js_1 = require_Credential$1();
	var AnonymousCredential = class extends Credential_js_1.Credential {
		create(nextPolicy, options) {
			return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options);
		}
	};
	exports.AnonymousCredential = AnonymousCredential;
}));
var require_BuffersStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BuffersStream = void 0;
	var node_stream_1$3 = __require("node:stream");
	var BuffersStream = class extends node_stream_1$3.Readable {
		buffers;
		byteLength;
		byteOffsetInCurrentBuffer;
		bufferIndex;
		pushedBytesLength;
		constructor(buffers, byteLength, options) {
			super(options);
			this.buffers = buffers;
			this.byteLength = byteLength;
			this.byteOffsetInCurrentBuffer = 0;
			this.bufferIndex = 0;
			this.pushedBytesLength = 0;
			let buffersLength = 0;
			for (const buf of this.buffers) buffersLength += buf.byteLength;
			if (buffersLength < this.byteLength) throw new Error("Data size shouldn't be larger than the total length of buffers.");
		}
		_read(size) {
			if (this.pushedBytesLength >= this.byteLength) this.push(null);
			if (!size) size = this.readableHighWaterMark;
			const outBuffers = [];
			let i = 0;
			while (i < size && this.pushedBytesLength < this.byteLength) {
				const remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
				const remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
				const remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
				if (remaining > size - i) {
					const end = this.byteOffsetInCurrentBuffer + size - i;
					outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
					this.pushedBytesLength += size - i;
					this.byteOffsetInCurrentBuffer = end;
					i = size;
					break;
				} else {
					const end = this.byteOffsetInCurrentBuffer + remaining;
					outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
					if (remaining === remainingCapacityInThisBuffer) {
						this.byteOffsetInCurrentBuffer = 0;
						this.bufferIndex++;
					} else this.byteOffsetInCurrentBuffer = end;
					this.pushedBytesLength += remaining;
					i += remaining;
				}
			}
			if (outBuffers.length > 1) this.push(Buffer.concat(outBuffers));
			else if (outBuffers.length === 1) this.push(outBuffers[0]);
		}
	};
	exports.BuffersStream = BuffersStream;
}));
var require_PooledBuffer = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PooledBuffer = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var BuffersStream_js_1 = require_BuffersStream();
	var maxBufferLength = tslib_1.__importDefault(__require("node:buffer")).default.constants.MAX_LENGTH;
	var PooledBuffer = class {
		buffers = [];
		capacity;
		_size;
		get size() {
			return this._size;
		}
		constructor(capacity, buffers, totalLength) {
			this.capacity = capacity;
			this._size = 0;
			const bufferNum = Math.ceil(capacity / maxBufferLength);
			for (let i = 0; i < bufferNum; i++) {
				let len = i === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
				if (len === 0) len = maxBufferLength;
				this.buffers.push(Buffer.allocUnsafe(len));
			}
			if (buffers) this.fill(buffers, totalLength);
		}
		fill(buffers, totalLength) {
			this._size = Math.min(this.capacity, totalLength);
			let i = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
			while (totalCopiedNum < this._size) {
				const source = buffers[i];
				const target = this.buffers[j];
				const copiedNum = source.copy(target, targetOffset, sourceOffset);
				totalCopiedNum += copiedNum;
				sourceOffset += copiedNum;
				targetOffset += copiedNum;
				if (sourceOffset === source.length) {
					i++;
					sourceOffset = 0;
				}
				if (targetOffset === target.length) {
					j++;
					targetOffset = 0;
				}
			}
			buffers.splice(0, i);
			if (buffers.length > 0) buffers[0] = buffers[0].slice(sourceOffset);
		}
		getReadableStream() {
			return new BuffersStream_js_1.BuffersStream(this.buffers, this.size);
		}
	};
	exports.PooledBuffer = PooledBuffer;
}));
var require_BufferScheduler = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BufferScheduler = void 0;
	var events_1$1 = __require("events");
	var PooledBuffer_js_1 = require_PooledBuffer();
	var BufferScheduler = class {
		bufferSize;
		maxBuffers;
		readable;
		outgoingHandler;
		emitter = new events_1$1.EventEmitter();
		concurrency;
		offset = 0;
		isStreamEnd = false;
		isError = false;
		executingOutgoingHandlers = 0;
		encoding;
		numBuffers = 0;
		unresolvedDataArray = [];
		unresolvedLength = 0;
		incoming = [];
		outgoing = [];
		constructor(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
			if (bufferSize <= 0) throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
			if (maxBuffers <= 0) throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
			if (concurrency <= 0) throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
			this.bufferSize = bufferSize;
			this.maxBuffers = maxBuffers;
			this.readable = readable;
			this.outgoingHandler = outgoingHandler;
			this.concurrency = concurrency;
			this.encoding = encoding;
		}
		async do() {
			return new Promise((resolve$1, reject$3) => {
				this.readable.on("data", (data) => {
					data = typeof data === "string" ? Buffer.from(data, this.encoding) : data;
					this.appendUnresolvedData(data);
					if (!this.resolveData()) this.readable.pause();
				});
				this.readable.on("error", (err) => {
					this.emitter.emit("error", err);
				});
				this.readable.on("end", () => {
					this.isStreamEnd = true;
					this.emitter.emit("checkEnd");
				});
				this.emitter.on("error", (err) => {
					this.isError = true;
					this.readable.pause();
					reject$3(err);
				});
				this.emitter.on("checkEnd", () => {
					if (this.outgoing.length > 0) {
						this.triggerOutgoingHandlers();
						return;
					}
					if (this.isStreamEnd && this.executingOutgoingHandlers === 0) if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
						const buffer$2 = this.shiftBufferFromUnresolvedDataArray();
						this.outgoingHandler(() => buffer$2.getReadableStream(), buffer$2.size, this.offset).then(resolve$1).catch(reject$3);
					} else if (this.unresolvedLength >= this.bufferSize) return;
					else resolve$1();
				});
			});
		}
		appendUnresolvedData(data) {
			this.unresolvedDataArray.push(data);
			this.unresolvedLength += data.length;
		}
		shiftBufferFromUnresolvedDataArray(buffer$2) {
			if (!buffer$2) buffer$2 = new PooledBuffer_js_1.PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
			else buffer$2.fill(this.unresolvedDataArray, this.unresolvedLength);
			this.unresolvedLength -= buffer$2.size;
			return buffer$2;
		}
		resolveData() {
			while (this.unresolvedLength >= this.bufferSize) {
				let buffer$2;
				if (this.incoming.length > 0) {
					buffer$2 = this.incoming.shift();
					this.shiftBufferFromUnresolvedDataArray(buffer$2);
				} else if (this.numBuffers < this.maxBuffers) {
					buffer$2 = this.shiftBufferFromUnresolvedDataArray();
					this.numBuffers++;
				} else return false;
				this.outgoing.push(buffer$2);
				this.triggerOutgoingHandlers();
			}
			return true;
		}
		async triggerOutgoingHandlers() {
			let buffer$2;
			do {
				if (this.executingOutgoingHandlers >= this.concurrency) return;
				buffer$2 = this.outgoing.shift();
				if (buffer$2) this.triggerOutgoingHandler(buffer$2);
			} while (buffer$2);
		}
		async triggerOutgoingHandler(buffer$2) {
			const bufferLength = buffer$2.size;
			this.executingOutgoingHandlers++;
			this.offset += bufferLength;
			try {
				await this.outgoingHandler(() => buffer$2.getReadableStream(), bufferLength, this.offset - bufferLength);
			} catch (err) {
				this.emitter.emit("error", err);
				return;
			}
			this.executingOutgoingHandlers--;
			this.reuseBuffer(buffer$2);
			this.emitter.emit("checkEnd");
		}
		reuseBuffer(buffer$2) {
			this.incoming.push(buffer$2);
			if (!this.isError && this.resolveData() && !this.isStreamEnd) this.readable.resume();
		}
	};
	exports.BufferScheduler = BufferScheduler;
}));
var require_cache = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
	var core_rest_pipeline_1 = require_commonjs$12();
	var _defaultHttpClient;
	function getCachedDefaultHttpClient() {
		if (!_defaultHttpClient) _defaultHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
		return _defaultHttpClient;
	}
}));
var require_RequestPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BaseRequestPolicy = void 0;
	var BaseRequestPolicy = class {
		_nextPolicy;
		_options;
		constructor(_nextPolicy, _options) {
			this._nextPolicy = _nextPolicy;
			this._options = _options;
		}
		shouldLog(logLevel) {
			return this._options.shouldLog(logLevel);
		}
		log(logLevel, message) {
			this._options.log(logLevel, message);
		}
	};
	exports.BaseRequestPolicy = BaseRequestPolicy;
}));
var require_constants$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PathStylePorts = exports.DevelopmentConnectionString = exports.HeaderConstants = exports.URLConstants = exports.SDK_VERSION = void 0;
	exports.SDK_VERSION = "1.0.0";
	exports.URLConstants = { Parameters: {
		FORCE_BROWSER_NO_CACHE: "_",
		SIGNATURE: "sig",
		SNAPSHOT: "snapshot",
		VERSIONID: "versionid",
		TIMEOUT: "timeout"
	} };
	exports.HeaderConstants = {
		AUTHORIZATION: "Authorization",
		AUTHORIZATION_SCHEME: "Bearer",
		CONTENT_ENCODING: "Content-Encoding",
		CONTENT_ID: "Content-ID",
		CONTENT_LANGUAGE: "Content-Language",
		CONTENT_LENGTH: "Content-Length",
		CONTENT_MD5: "Content-Md5",
		CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
		CONTENT_TYPE: "Content-Type",
		COOKIE: "Cookie",
		DATE: "date",
		IF_MATCH: "if-match",
		IF_MODIFIED_SINCE: "if-modified-since",
		IF_NONE_MATCH: "if-none-match",
		IF_UNMODIFIED_SINCE: "if-unmodified-since",
		PREFIX_FOR_STORAGE: "x-ms-",
		RANGE: "Range",
		USER_AGENT: "User-Agent",
		X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
		X_MS_COPY_SOURCE: "x-ms-copy-source",
		X_MS_DATE: "x-ms-date",
		X_MS_ERROR_CODE: "x-ms-error-code",
		X_MS_VERSION: "x-ms-version",
		X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
	};
	exports.DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
	exports.PathStylePorts = [
		"10000",
		"10001",
		"10002",
		"10003",
		"10004",
		"10100",
		"10101",
		"10102",
		"10103",
		"10104",
		"11000",
		"11001",
		"11002",
		"11003",
		"11004",
		"11100",
		"11101",
		"11102",
		"11103",
		"11104"
	];
}));
var require_utils_common$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.escapeURLPath = escapeURLPath;
	exports.getValueInConnString = getValueInConnString;
	exports.extractConnectionStringParts = extractConnectionStringParts;
	exports.appendToURLPath = appendToURLPath;
	exports.setURLParameter = setURLParameter;
	exports.getURLParameter = getURLParameter;
	exports.setURLHost = setURLHost;
	exports.getURLPath = getURLPath;
	exports.getURLScheme = getURLScheme;
	exports.getURLPathAndQuery = getURLPathAndQuery;
	exports.getURLQueries = getURLQueries;
	exports.appendToURLQuery = appendToURLQuery;
	exports.truncatedISO8061Date = truncatedISO8061Date;
	exports.base64encode = base64encode;
	exports.base64decode = base64decode;
	exports.generateBlockID = generateBlockID;
	exports.delay = delay;
	exports.padStart = padStart;
	exports.sanitizeURL = sanitizeURL;
	exports.sanitizeHeaders = sanitizeHeaders;
	exports.iEqual = iEqual;
	exports.getAccountNameFromUrl = getAccountNameFromUrl;
	exports.isIpEndpointStyle = isIpEndpointStyle;
	exports.attachCredential = attachCredential;
	exports.httpAuthorizationToString = httpAuthorizationToString;
	exports.EscapePath = EscapePath;
	exports.assertResponse = assertResponse;
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_util_1 = require_commonjs$14();
	var constants_js_1 = require_constants$3();
	function escapeURLPath(url) {
		const urlParsed = new URL(url);
		let path$5 = urlParsed.pathname;
		path$5 = path$5 || "/";
		path$5 = escape(path$5);
		urlParsed.pathname = path$5;
		return urlParsed.toString();
	}
	function getProxyUriFromDevConnString(connectionString) {
		let proxyUri = "";
		if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
			const matchCredentials = connectionString.split(";");
			for (const element of matchCredentials) if (element.trim().startsWith("DevelopmentStorageProxyUri=")) proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
		}
		return proxyUri;
	}
	function getValueInConnString(connectionString, argument) {
		const elements = connectionString.split(";");
		for (const element of elements) if (element.trim().startsWith(argument)) return element.trim().match(argument + "=(.*)")[1];
		return "";
	}
	function extractConnectionStringParts(connectionString) {
		let proxyUri = "";
		if (connectionString.startsWith("UseDevelopmentStorage=true")) {
			proxyUri = getProxyUriFromDevConnString(connectionString);
			connectionString = constants_js_1.DevelopmentConnectionString;
		}
		let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
		blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
		if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
			let defaultEndpointsProtocol = "";
			let accountName = "";
			let accountKey = Buffer.from("accountKey", "base64");
			let endpointSuffix = "";
			accountName = getValueInConnString(connectionString, "AccountName");
			accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
			if (!blobEndpoint) {
				defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
				const protocol = defaultEndpointsProtocol.toLowerCase();
				if (protocol !== "https" && protocol !== "http") throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
				endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
				if (!endpointSuffix) throw new Error("Invalid EndpointSuffix in the provided Connection String");
				blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
			}
			if (!accountName) throw new Error("Invalid AccountName in the provided Connection String");
			else if (accountKey.length === 0) throw new Error("Invalid AccountKey in the provided Connection String");
			return {
				kind: "AccountConnString",
				url: blobEndpoint,
				accountName,
				accountKey,
				proxyUri
			};
		} else {
			let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
			let accountName = getValueInConnString(connectionString, "AccountName");
			if (!accountName) accountName = getAccountNameFromUrl(blobEndpoint);
			if (!blobEndpoint) throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
			else if (!accountSas) throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
			if (accountSas.startsWith("?")) accountSas = accountSas.substring(1);
			return {
				kind: "SASConnString",
				url: blobEndpoint,
				accountName,
				accountSas
			};
		}
	}
	function escape(text) {
		return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
	}
	function appendToURLPath(url, name$1) {
		const urlParsed = new URL(url);
		let path$5 = urlParsed.pathname;
		path$5 = path$5 ? path$5.endsWith("/") ? `${path$5}${name$1}` : `${path$5}/${name$1}` : name$1;
		urlParsed.pathname = path$5;
		return urlParsed.toString();
	}
	function setURLParameter(url, name$1, value$1) {
		const urlParsed = new URL(url);
		const encodedName = encodeURIComponent(name$1);
		const encodedValue = value$1 ? encodeURIComponent(value$1) : void 0;
		const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
		const searchPieces = [];
		for (const pair of searchString.slice(1).split("&")) if (pair) {
			const [key] = pair.split("=", 2);
			if (key !== encodedName) searchPieces.push(pair);
		}
		if (encodedValue) searchPieces.push(`${encodedName}=${encodedValue}`);
		urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
		return urlParsed.toString();
	}
	function getURLParameter(url, name$1) {
		return new URL(url).searchParams.get(name$1) ?? void 0;
	}
	function setURLHost(url, host) {
		const urlParsed = new URL(url);
		urlParsed.hostname = host;
		return urlParsed.toString();
	}
	function getURLPath(url) {
		try {
			return new URL(url).pathname;
		} catch (e$1) {
			return;
		}
	}
	function getURLScheme(url) {
		try {
			const urlParsed = new URL(url);
			return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
		} catch (e$1) {
			return;
		}
	}
	function getURLPathAndQuery(url) {
		const urlParsed = new URL(url);
		const pathString = urlParsed.pathname;
		if (!pathString) throw new RangeError("Invalid url without valid path.");
		let queryString = urlParsed.search || "";
		queryString = queryString.trim();
		if (queryString !== "") queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
		return `${pathString}${queryString}`;
	}
	function getURLQueries(url) {
		let queryString = new URL(url).search;
		if (!queryString) return {};
		queryString = queryString.trim();
		queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
		let querySubStrings = queryString.split("&");
		querySubStrings = querySubStrings.filter((value$1) => {
			const indexOfEqual = value$1.indexOf("=");
			const lastIndexOfEqual = value$1.lastIndexOf("=");
			return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value$1.length - 1;
		});
		const queries = {};
		for (const querySubString of querySubStrings) {
			const splitResults = querySubString.split("=");
			const key = splitResults[0];
			queries[key] = splitResults[1];
		}
		return queries;
	}
	function appendToURLQuery(url, queryParts) {
		const urlParsed = new URL(url);
		let query = urlParsed.search;
		if (query) query += "&" + queryParts;
		else query = queryParts;
		urlParsed.search = query;
		return urlParsed.toString();
	}
	function truncatedISO8061Date(date, withMilliseconds = true) {
		const dateString = date.toISOString();
		return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
	}
	function base64encode(content) {
		return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
	}
	function base64decode(encodedString) {
		return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
	}
	function generateBlockID(blockIDPrefix, blockIndex) {
		const maxSourceStringLength = 48;
		const maxAllowedBlockIDPrefixLength = maxSourceStringLength - 6;
		if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
		return base64encode(blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0"));
	}
	async function delay(timeInMs, aborter, abortError) {
		return new Promise((resolve$1, reject$3) => {
			let timeout$1;
			const abortHandler = () => {
				if (timeout$1 !== void 0) clearTimeout(timeout$1);
				reject$3(abortError);
			};
			const resolveHandler = () => {
				if (aborter !== void 0) aborter.removeEventListener("abort", abortHandler);
				resolve$1();
			};
			timeout$1 = setTimeout(resolveHandler, timeInMs);
			if (aborter !== void 0) aborter.addEventListener("abort", abortHandler);
		});
	}
	function padStart(currentString, targetLength, padString = " ") {
		if (String.prototype.padStart) return currentString.padStart(targetLength, padString);
		padString = padString || " ";
		if (currentString.length > targetLength) return currentString;
		else {
			targetLength = targetLength - currentString.length;
			if (targetLength > padString.length) padString += padString.repeat(targetLength / padString.length);
			return padString.slice(0, targetLength) + currentString;
		}
	}
	function sanitizeURL(url) {
		let safeURL = url;
		if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE)) safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
		return safeURL;
	}
	function sanitizeHeaders(originalHeader) {
		const headers = (0, core_rest_pipeline_1.createHttpHeaders)();
		for (const [name$1, value$1] of originalHeader) if (name$1.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase()) headers.set(name$1, "*****");
		else if (name$1.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE) headers.set(name$1, sanitizeURL(value$1));
		else headers.set(name$1, value$1);
		return headers;
	}
	function iEqual(str1, str2) {
		return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
	}
	function getAccountNameFromUrl(url) {
		const parsedUrl = new URL(url);
		let accountName;
		try {
			if (parsedUrl.hostname.split(".")[1] === "blob") accountName = parsedUrl.hostname.split(".")[0];
			else if (isIpEndpointStyle(parsedUrl)) accountName = parsedUrl.pathname.split("/")[1];
			else accountName = "";
			return accountName;
		} catch (error) {
			throw new Error("Unable to extract accountName with provided information.");
		}
	}
	function isIpEndpointStyle(parsedUrl) {
		const host = parsedUrl.host;
		return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
	}
	function attachCredential(thing, credential) {
		thing.credential = credential;
		return thing;
	}
	function httpAuthorizationToString(httpAuthorization) {
		return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
	}
	function EscapePath(blobName) {
		const split = blobName.split("/");
		for (let i = 0; i < split.length; i++) split[i] = encodeURIComponent(split[i]);
		return split.join("/");
	}
	function assertResponse(response) {
		if (`_response` in response) return response;
		throw new TypeError(`Unexpected response object ${response}`);
	}
}));
var require_StorageBrowserPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageBrowserPolicy = void 0;
	var RequestPolicy_js_1 = require_RequestPolicy();
	var core_util_1 = require_commonjs$14();
	var constants_js_1 = require_constants$3();
	var utils_common_js_1 = require_utils_common$1();
	var StorageBrowserPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
		constructor(nextPolicy, options) {
			super(nextPolicy, options);
		}
		async sendRequest(request$1) {
			if (core_util_1.isNodeLike) return this._nextPolicy.sendRequest(request$1);
			if (request$1.method.toUpperCase() === "GET" || request$1.method.toUpperCase() === "HEAD") request$1.url = (0, utils_common_js_1.setURLParameter)(request$1.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
			request$1.headers.remove(constants_js_1.HeaderConstants.COOKIE);
			request$1.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH);
			return this._nextPolicy.sendRequest(request$1);
		}
	};
	exports.StorageBrowserPolicy = StorageBrowserPolicy;
}));
var require_StorageBrowserPolicyFactory$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = void 0;
	var StorageBrowserPolicy_js_1 = require_StorageBrowserPolicy$1();
	Object.defineProperty(exports, "StorageBrowserPolicy", {
		enumerable: true,
		get: function() {
			return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
		}
	});
	var StorageBrowserPolicyFactory = class {
		create(nextPolicy, options) {
			return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options);
		}
	};
	exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
}));
var require_CredentialPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CredentialPolicy = void 0;
	var RequestPolicy_js_1 = require_RequestPolicy();
	var CredentialPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
		sendRequest(request$1) {
			return this._nextPolicy.sendRequest(this.signRequest(request$1));
		}
		signRequest(request$1) {
			return request$1;
		}
	};
	exports.CredentialPolicy = CredentialPolicy;
}));
var require_AnonymousCredentialPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AnonymousCredentialPolicy = void 0;
	var CredentialPolicy_js_1 = require_CredentialPolicy();
	var AnonymousCredentialPolicy = class extends CredentialPolicy_js_1.CredentialPolicy {
		constructor(nextPolicy, options) {
			super(nextPolicy, options);
		}
	};
	exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
}));
var require_Credential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Credential = void 0;
	var Credential = class {
		create(_nextPolicy, _options) {
			throw new Error("Method should be implemented in children classes.");
		}
	};
	exports.Credential = Credential;
}));
var require_AnonymousCredential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AnonymousCredential = void 0;
	var AnonymousCredentialPolicy_js_1 = require_AnonymousCredentialPolicy();
	var Credential_js_1 = require_Credential();
	var AnonymousCredential = class extends Credential_js_1.Credential {
		create(nextPolicy, options) {
			return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options);
		}
	};
	exports.AnonymousCredential = AnonymousCredential;
}));
var require_SharedKeyComparator = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.compareHeader = compareHeader;
	var table_lv0 = new Uint32Array([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1820,
		0,
		1823,
		1825,
		1827,
		1829,
		0,
		0,
		0,
		1837,
		2051,
		0,
		0,
		1843,
		0,
		3331,
		3354,
		3356,
		3358,
		3360,
		3362,
		3364,
		3366,
		3368,
		3370,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		3586,
		3593,
		3594,
		3610,
		3617,
		3619,
		3621,
		3628,
		3634,
		3637,
		3638,
		3656,
		3665,
		3696,
		3708,
		3710,
		3721,
		3722,
		3729,
		3737,
		3743,
		3746,
		3748,
		3750,
		3751,
		3753,
		0,
		0,
		0,
		1859,
		1860,
		1864,
		3586,
		3593,
		3594,
		3610,
		3617,
		3619,
		3621,
		3628,
		3634,
		3637,
		3638,
		3656,
		3665,
		3696,
		3708,
		3710,
		3721,
		3722,
		3729,
		3737,
		3743,
		3746,
		3748,
		3750,
		3751,
		3753,
		0,
		1868,
		0,
		1872,
		0
	]);
	var table_lv2 = new Uint32Array([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		18,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	]);
	var table_lv4 = new Uint32Array([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		32786,
		0,
		0,
		0,
		0,
		0,
		33298,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	]);
	function compareHeader(lhs, rhs) {
		if (isLessThan(lhs, rhs)) return -1;
		return 1;
	}
	function isLessThan(lhs, rhs) {
		const tables = [
			table_lv0,
			table_lv2,
			table_lv4
		];
		let curr_level = 0;
		let i = 0;
		let j = 0;
		while (curr_level < tables.length) {
			if (curr_level === tables.length - 1 && i !== j) return i > j;
			const weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 1;
			const weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
			if (weight1 === 1 && weight2 === 1) {
				i = 0;
				j = 0;
				++curr_level;
			} else if (weight1 === weight2) {
				++i;
				++j;
			} else if (weight1 === 0) ++i;
			else if (weight2 === 0) ++j;
			else return weight1 < weight2;
		}
		return false;
	}
}));
var require_StorageSharedKeyCredentialPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageSharedKeyCredentialPolicy = void 0;
	var constants_js_1 = require_constants$3();
	var utils_common_js_1 = require_utils_common$1();
	var CredentialPolicy_js_1 = require_CredentialPolicy();
	var SharedKeyComparator_js_1 = require_SharedKeyComparator();
	var StorageSharedKeyCredentialPolicy = class extends CredentialPolicy_js_1.CredentialPolicy {
		factory;
		constructor(nextPolicy, options, factory) {
			super(nextPolicy, options);
			this.factory = factory;
		}
		signRequest(request$1) {
			request$1.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
			if (request$1.body && (typeof request$1.body === "string" || request$1.body !== void 0) && request$1.body.length > 0) request$1.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request$1.body));
			const stringToSign = [
				request$1.method.toUpperCase(),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_ENCODING),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_LENGTH),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_MD5),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_TYPE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.DATE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_MATCH),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_NONE_MATCH),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
				this.getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.RANGE)
			].join("\n") + "\n" + this.getCanonicalizedHeadersString(request$1) + this.getCanonicalizedResourceString(request$1);
			const signature = this.factory.computeHMACSHA256(stringToSign);
			request$1.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
			return request$1;
		}
		getHeaderValueToSign(request$1, headerName) {
			const value$1 = request$1.headers.get(headerName);
			if (!value$1) return "";
			if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value$1 === "0") return "";
			return value$1;
		}
		getCanonicalizedHeadersString(request$1) {
			let headersArray = request$1.headers.headersArray().filter((value$1) => {
				return value$1.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
			});
			headersArray.sort((a, b) => {
				return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
			});
			headersArray = headersArray.filter((value$1, index$1, array) => {
				if (index$1 > 0 && value$1.name.toLowerCase() === array[index$1 - 1].name.toLowerCase()) return false;
				return true;
			});
			let canonicalizedHeadersStringToSign = "";
			headersArray.forEach((header) => {
				canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
			});
			return canonicalizedHeadersStringToSign;
		}
		getCanonicalizedResourceString(request$1) {
			const path$5 = (0, utils_common_js_1.getURLPath)(request$1.url) || "/";
			let canonicalizedResourceString = "";
			canonicalizedResourceString += `/${this.factory.accountName}${path$5}`;
			const queries = (0, utils_common_js_1.getURLQueries)(request$1.url);
			const lowercaseQueries = {};
			if (queries) {
				const queryKeys = [];
				for (const key in queries) if (Object.prototype.hasOwnProperty.call(queries, key)) {
					const lowercaseKey = key.toLowerCase();
					lowercaseQueries[lowercaseKey] = queries[key];
					queryKeys.push(lowercaseKey);
				}
				queryKeys.sort();
				for (const key of queryKeys) canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
			}
			return canonicalizedResourceString;
		}
	};
	exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
}));
var require_StorageSharedKeyCredential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageSharedKeyCredential = void 0;
	var node_crypto_1$3 = __require("node:crypto");
	var StorageSharedKeyCredentialPolicy_js_1 = require_StorageSharedKeyCredentialPolicy();
	var Credential_js_1 = require_Credential();
	var StorageSharedKeyCredential = class extends Credential_js_1.Credential {
		accountName;
		accountKey;
		constructor(accountName, accountKey) {
			super();
			this.accountName = accountName;
			this.accountKey = Buffer.from(accountKey, "base64");
		}
		create(nextPolicy, options) {
			return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
		}
		computeHMACSHA256(stringToSign) {
			return (0, node_crypto_1$3.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
		}
	};
	exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
}));
var require_log$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logger = void 0;
	exports.logger = (0, require_commonjs$16().createClientLogger)("storage-common");
}));
var require_StorageRetryPolicyType = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageRetryPolicyType = void 0;
	var StorageRetryPolicyType;
	(function(StorageRetryPolicyType) {
		StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
		StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
	})(StorageRetryPolicyType || (exports.StorageRetryPolicyType = StorageRetryPolicyType = {}));
}));
var require_StorageRetryPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageRetryPolicy = void 0;
	exports.NewRetryPolicyFactory = NewRetryPolicyFactory;
	var abort_controller_1 = require_commonjs$15();
	var RequestPolicy_js_1 = require_RequestPolicy();
	var constants_js_1 = require_constants$3();
	var utils_common_js_1 = require_utils_common$1();
	var log_js_1 = require_log$1();
	var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType();
	function NewRetryPolicyFactory(retryOptions) {
		return { create: (nextPolicy, options) => {
			return new StorageRetryPolicy(nextPolicy, options, retryOptions);
		} };
	}
	var DEFAULT_RETRY_OPTIONS = {
		maxRetryDelayInMs: 120 * 1e3,
		maxTries: 4,
		retryDelayInMs: 4 * 1e3,
		retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
		secondaryHost: "",
		tryTimeoutInMs: void 0
	};
	var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
	var StorageRetryPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
		retryOptions;
		constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS) {
			super(nextPolicy, options);
			this.retryOptions = {
				retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
				maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
				tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
				retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
				maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
				secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
			};
		}
		async sendRequest(request$1) {
			return this.attemptSendRequest(request$1, false, 1);
		}
		async attemptSendRequest(request$1, secondaryHas404, attempt) {
			const newRequest = request$1.clone();
			const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request$1.method === "GET" || request$1.method === "HEAD" || request$1.method === "OPTIONS") || attempt % 2 === 1;
			if (!isPrimaryRetry) newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
			if (this.retryOptions.tryTimeoutInMs) newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString());
			let response;
			try {
				log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
				response = await this._nextPolicy.sendRequest(newRequest);
				if (!this.shouldRetry(isPrimaryRetry, attempt, response)) return response;
				secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
			} catch (err) {
				log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
				if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) throw err;
			}
			await this.delay(isPrimaryRetry, attempt, request$1.abortSignal);
			return this.attemptSendRequest(request$1, secondaryHas404, ++attempt);
		}
		shouldRetry(isPrimaryRetry, attempt, response, err) {
			if (attempt >= this.retryOptions.maxTries) {
				log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
				return false;
			}
			const retriableErrors = [
				"ETIMEDOUT",
				"ESOCKETTIMEDOUT",
				"ECONNREFUSED",
				"ECONNRESET",
				"ENOENT",
				"ENOTFOUND",
				"TIMEOUT",
				"EPIPE",
				"REQUEST_SEND_ERROR"
			];
			if (err) {
				for (const retriableError of retriableErrors) if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
					log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
					return true;
				}
			}
			if (response || err) {
				const statusCode = response ? response.status : err ? err.statusCode : 0;
				if (!isPrimaryRetry && statusCode === 404) {
					log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
					return true;
				}
				if (statusCode === 503 || statusCode === 500) {
					log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
					return true;
				}
			}
			if (response) {
				if (response?.status >= 400) {
					const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
					if (copySourceError !== void 0) switch (copySourceError) {
						case "InternalError":
						case "OperationTimedOut":
						case "ServerBusy": return true;
					}
				}
			}
			if (err?.code === "PARSE_ERROR" && err?.message.startsWith(`Error "Error: Unclosed root tag`)) {
				log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
				return true;
			}
			return false;
		}
		async delay(isPrimaryRetry, attempt, abortSignal$1) {
			let delayTimeInMs = 0;
			if (isPrimaryRetry) switch (this.retryOptions.retryPolicyType) {
				case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
					delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
					break;
				case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
					delayTimeInMs = this.retryOptions.retryDelayInMs;
					break;
			}
			else delayTimeInMs = Math.random() * 1e3;
			log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
			return (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal$1, RETRY_ABORT_ERROR);
		}
	};
	exports.StorageRetryPolicy = StorageRetryPolicy;
}));
var require_StorageRetryPolicyFactory = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = void 0;
	var StorageRetryPolicy_js_1 = require_StorageRetryPolicy();
	Object.defineProperty(exports, "StorageRetryPolicy", {
		enumerable: true,
		get: function() {
			return StorageRetryPolicy_js_1.StorageRetryPolicy;
		}
	});
	var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType();
	Object.defineProperty(exports, "StorageRetryPolicyType", {
		enumerable: true,
		get: function() {
			return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
		}
	});
	var StorageRetryPolicyFactory = class {
		retryOptions;
		constructor(retryOptions) {
			this.retryOptions = retryOptions;
		}
		create(nextPolicy, options) {
			return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options, this.retryOptions);
		}
	};
	exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
}));
var require_StorageBrowserPolicyV2$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageBrowserPolicyName = void 0;
	exports.storageBrowserPolicy = storageBrowserPolicy;
	var core_util_1 = require_commonjs$14();
	var constants_js_1 = require_constants$3();
	var utils_common_js_1 = require_utils_common$1();
	exports.storageBrowserPolicyName = "storageBrowserPolicy";
	function storageBrowserPolicy() {
		return {
			name: exports.storageBrowserPolicyName,
			async sendRequest(request$1, next) {
				if (core_util_1.isNodeLike) return next(request$1);
				if (request$1.method === "GET" || request$1.method === "HEAD") request$1.url = (0, utils_common_js_1.setURLParameter)(request$1.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
				request$1.headers.delete(constants_js_1.HeaderConstants.COOKIE);
				request$1.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH);
				return next(request$1);
			}
		};
	}
}));
var require_StorageCorrectContentLengthPolicy$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageCorrectContentLengthPolicyName = void 0;
	exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
	var constants_js_1 = require_constants$3();
	exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
	function storageCorrectContentLengthPolicy() {
		function correctContentLength(request$1) {
			if (request$1.body && (typeof request$1.body === "string" || Buffer.isBuffer(request$1.body)) && request$1.body.length > 0) request$1.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request$1.body));
		}
		return {
			name: exports.storageCorrectContentLengthPolicyName,
			async sendRequest(request$1, next) {
				correctContentLength(request$1);
				return next(request$1);
			}
		};
	}
}));
var require_StorageRetryPolicyV2$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageRetryPolicyName = void 0;
	exports.storageRetryPolicy = storageRetryPolicy;
	var abort_controller_1 = require_commonjs$15();
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_util_1 = require_commonjs$14();
	var StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory();
	var constants_js_1 = require_constants$3();
	var utils_common_js_1 = require_utils_common$1();
	var log_js_1 = require_log$1();
	exports.storageRetryPolicyName = "storageRetryPolicy";
	var DEFAULT_RETRY_OPTIONS = {
		maxRetryDelayInMs: 120 * 1e3,
		maxTries: 4,
		retryDelayInMs: 4 * 1e3,
		retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
		secondaryHost: "",
		tryTimeoutInMs: void 0
	};
	var retriableErrors = [
		"ETIMEDOUT",
		"ESOCKETTIMEDOUT",
		"ECONNREFUSED",
		"ECONNRESET",
		"ENOENT",
		"ENOTFOUND",
		"TIMEOUT",
		"EPIPE",
		"REQUEST_SEND_ERROR"
	];
	var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
	function storageRetryPolicy(options = {}) {
		const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;
		const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;
		const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;
		const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
		const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;
		const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
		function shouldRetry({ isPrimaryRetry, attempt, response, error }) {
			if (attempt >= maxTries) {
				log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
				return false;
			}
			if (error) {
				for (const retriableError of retriableErrors) if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError) {
					log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
					return true;
				}
				if (error?.code === "PARSE_ERROR" && error?.message.startsWith(`Error "Error: Unclosed root tag`)) {
					log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
					return true;
				}
			}
			if (response || error) {
				const statusCode = response?.status ?? error?.statusCode ?? 0;
				if (!isPrimaryRetry && statusCode === 404) {
					log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
					return true;
				}
				if (statusCode === 503 || statusCode === 500) {
					log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
					return true;
				}
			}
			if (response) {
				if (response?.status >= 400) {
					const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
					if (copySourceError !== void 0) switch (copySourceError) {
						case "InternalError":
						case "OperationTimedOut":
						case "ServerBusy": return true;
					}
				}
			}
			return false;
		}
		function calculateDelay(isPrimaryRetry, attempt) {
			let delayTimeInMs = 0;
			if (isPrimaryRetry) switch (retryPolicyType) {
				case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
					delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
					break;
				case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
					delayTimeInMs = retryDelayInMs;
					break;
			}
			else delayTimeInMs = Math.random() * 1e3;
			log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
			return delayTimeInMs;
		}
		return {
			name: exports.storageRetryPolicyName,
			async sendRequest(request$1, next) {
				if (tryTimeoutInMs) request$1.url = (0, utils_common_js_1.setURLParameter)(request$1.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1e3)));
				const primaryUrl = request$1.url;
				const secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request$1.url, secondaryHost) : void 0;
				let secondaryHas404 = false;
				let attempt = 1;
				let retryAgain = true;
				let response;
				let error;
				while (retryAgain) {
					const isPrimaryRetry = secondaryHas404 || !secondaryUrl || ![
						"GET",
						"HEAD",
						"OPTIONS"
					].includes(request$1.method) || attempt % 2 === 1;
					request$1.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
					response = void 0;
					error = void 0;
					try {
						log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
						response = await next(request$1);
						secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
					} catch (e$1) {
						if ((0, core_rest_pipeline_1.isRestError)(e$1)) {
							log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e$1.message}, code: ${e$1.code}`);
							error = e$1;
						} else {
							log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e$1)}`);
							throw e$1;
						}
					}
					retryAgain = shouldRetry({
						isPrimaryRetry,
						attempt,
						response,
						error
					});
					if (retryAgain) await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request$1.abortSignal, RETRY_ABORT_ERROR);
					attempt++;
				}
				if (response) return response;
				throw error ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
			}
		};
	}
}));
var require_StorageSharedKeyCredentialPolicyV2$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageSharedKeyCredentialPolicyName = void 0;
	exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
	var node_crypto_1$2 = __require("node:crypto");
	var constants_js_1 = require_constants$3();
	var utils_common_js_1 = require_utils_common$1();
	var SharedKeyComparator_js_1 = require_SharedKeyComparator();
	exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
	function storageSharedKeyCredentialPolicy(options) {
		function signRequest(request$1) {
			request$1.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
			if (request$1.body && (typeof request$1.body === "string" || Buffer.isBuffer(request$1.body)) && request$1.body.length > 0) request$1.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request$1.body));
			const stringToSign = [
				request$1.method.toUpperCase(),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_ENCODING),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_LENGTH),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_MD5),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_TYPE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.DATE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_MATCH),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_NONE_MATCH),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.RANGE)
			].join("\n") + "\n" + getCanonicalizedHeadersString(request$1) + getCanonicalizedResourceString(request$1);
			const signature = (0, node_crypto_1$2.createHmac)("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
			request$1.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
		}
		function getHeaderValueToSign(request$1, headerName) {
			const value$1 = request$1.headers.get(headerName);
			if (!value$1) return "";
			if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value$1 === "0") return "";
			return value$1;
		}
		function getCanonicalizedHeadersString(request$1) {
			let headersArray = [];
			for (const [name$1, value$1] of request$1.headers) if (name$1.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE)) headersArray.push({
				name: name$1,
				value: value$1
			});
			headersArray.sort((a, b) => {
				return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
			});
			headersArray = headersArray.filter((value$1, index$1, array) => {
				if (index$1 > 0 && value$1.name.toLowerCase() === array[index$1 - 1].name.toLowerCase()) return false;
				return true;
			});
			let canonicalizedHeadersStringToSign = "";
			headersArray.forEach((header) => {
				canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
			});
			return canonicalizedHeadersStringToSign;
		}
		function getCanonicalizedResourceString(request$1) {
			const path$5 = (0, utils_common_js_1.getURLPath)(request$1.url) || "/";
			let canonicalizedResourceString = "";
			canonicalizedResourceString += `/${options.accountName}${path$5}`;
			const queries = (0, utils_common_js_1.getURLQueries)(request$1.url);
			const lowercaseQueries = {};
			if (queries) {
				const queryKeys = [];
				for (const key in queries) if (Object.prototype.hasOwnProperty.call(queries, key)) {
					const lowercaseKey = key.toLowerCase();
					lowercaseQueries[lowercaseKey] = queries[key];
					queryKeys.push(lowercaseKey);
				}
				queryKeys.sort();
				for (const key of queryKeys) canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
			}
			return canonicalizedResourceString;
		}
		return {
			name: exports.storageSharedKeyCredentialPolicyName,
			async sendRequest(request$1, next) {
				signRequest(request$1);
				return next(request$1);
			}
		};
	}
}));
var require_StorageRequestFailureDetailsParserPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageRequestFailureDetailsParserPolicyName = void 0;
	exports.storageRequestFailureDetailsParserPolicy = storageRequestFailureDetailsParserPolicy;
	exports.storageRequestFailureDetailsParserPolicyName = "storageRequestFailureDetailsParserPolicy";
	function storageRequestFailureDetailsParserPolicy() {
		return {
			name: exports.storageRequestFailureDetailsParserPolicyName,
			async sendRequest(request$1, next) {
				try {
					return await next(request$1);
				} catch (err) {
					if (typeof err === "object" && err !== null && err.response && err.response.parsedBody) {
						if (err.response.parsedBody.code === "InvalidHeaderValue" && err.response.parsedBody.HeaderName === "x-ms-version") err.message = "The provided service version is not enabled on this storage account. Please see https://learn.microsoft.com/rest/api/storageservices/versioning-for-the-azure-storage-services for additional information.\n";
					}
					throw err;
				}
			}
		};
	}
}));
var require_commonjs$7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BaseRequestPolicy = exports.getCachedDefaultHttpClient = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	tslib_1.__exportStar(require_BufferScheduler(), exports);
	var cache_js_1 = require_cache();
	Object.defineProperty(exports, "getCachedDefaultHttpClient", {
		enumerable: true,
		get: function() {
			return cache_js_1.getCachedDefaultHttpClient;
		}
	});
	tslib_1.__exportStar(require_StorageBrowserPolicyFactory$1(), exports);
	tslib_1.__exportStar(require_AnonymousCredential(), exports);
	tslib_1.__exportStar(require_Credential(), exports);
	tslib_1.__exportStar(require_StorageSharedKeyCredential(), exports);
	tslib_1.__exportStar(require_StorageRetryPolicyFactory(), exports);
	var RequestPolicy_js_1 = require_RequestPolicy();
	Object.defineProperty(exports, "BaseRequestPolicy", {
		enumerable: true,
		get: function() {
			return RequestPolicy_js_1.BaseRequestPolicy;
		}
	});
	tslib_1.__exportStar(require_AnonymousCredentialPolicy(), exports);
	tslib_1.__exportStar(require_CredentialPolicy(), exports);
	tslib_1.__exportStar(require_StorageBrowserPolicy$1(), exports);
	tslib_1.__exportStar(require_StorageBrowserPolicyV2$1(), exports);
	tslib_1.__exportStar(require_StorageCorrectContentLengthPolicy$1(), exports);
	tslib_1.__exportStar(require_StorageRetryPolicyType(), exports);
	tslib_1.__exportStar(require_StorageRetryPolicy(), exports);
	tslib_1.__exportStar(require_StorageRetryPolicyV2$1(), exports);
	tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicy(), exports);
	tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicyV2$1(), exports);
	tslib_1.__exportStar(require_StorageRetryPolicyFactory(), exports);
	tslib_1.__exportStar(require_StorageRequestFailureDetailsParserPolicy(), exports);
}));
var require_StorageBrowserPolicyV2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageBrowserPolicyName = void 0;
	exports.storageBrowserPolicy = storageBrowserPolicy;
	var core_util_1 = require_commonjs$14();
	var constants_js_1 = require_constants$4();
	var utils_common_js_1 = require_utils_common$2();
	exports.storageBrowserPolicyName = "storageBrowserPolicy";
	function storageBrowserPolicy() {
		return {
			name: exports.storageBrowserPolicyName,
			async sendRequest(request$1, next) {
				if (core_util_1.isNodeLike) return next(request$1);
				if (request$1.method === "GET" || request$1.method === "HEAD") request$1.url = (0, utils_common_js_1.setURLParameter)(request$1.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
				request$1.headers.delete(constants_js_1.HeaderConstants.COOKIE);
				request$1.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH);
				return next(request$1);
			}
		};
	}
}));
var require_StorageRetryPolicyV2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageRetryPolicyName = void 0;
	exports.storageRetryPolicy = storageRetryPolicy;
	var abort_controller_1 = require_commonjs$15();
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_util_1 = require_commonjs$14();
	var StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory$1();
	var constants_js_1 = require_constants$4();
	var utils_common_js_1 = require_utils_common$2();
	var log_js_1 = require_log$2();
	exports.storageRetryPolicyName = "storageRetryPolicy";
	var DEFAULT_RETRY_OPTIONS = {
		maxRetryDelayInMs: 120 * 1e3,
		maxTries: 4,
		retryDelayInMs: 4 * 1e3,
		retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
		secondaryHost: "",
		tryTimeoutInMs: void 0
	};
	var retriableErrors = [
		"ETIMEDOUT",
		"ESOCKETTIMEDOUT",
		"ECONNREFUSED",
		"ECONNRESET",
		"ENOENT",
		"ENOTFOUND",
		"TIMEOUT",
		"EPIPE",
		"REQUEST_SEND_ERROR"
	];
	var RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
	function storageRetryPolicy(options = {}) {
		const retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType;
		const maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries;
		const retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs;
		const maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
		const secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost;
		const tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
		function shouldRetry({ isPrimaryRetry, attempt, response, error }) {
			if (attempt >= maxTries) {
				log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
				return false;
			}
			if (error) {
				for (const retriableError of retriableErrors) if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError) {
					log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
					return true;
				}
				if (error?.code === "PARSE_ERROR" && error?.message.startsWith(`Error "Error: Unclosed root tag`)) {
					log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
					return true;
				}
			}
			if (response || error) {
				const statusCode = response?.status ?? error?.statusCode ?? 0;
				if (!isPrimaryRetry && statusCode === 404) {
					log_js_1.logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
					return true;
				}
				if (statusCode === 503 || statusCode === 500) {
					log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
					return true;
				}
			}
			if (response) {
				if (response?.status >= 400) {
					const copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
					if (copySourceError !== void 0) switch (copySourceError) {
						case "InternalError":
						case "OperationTimedOut":
						case "ServerBusy": return true;
					}
				}
			}
			return false;
		}
		function calculateDelay(isPrimaryRetry, attempt) {
			let delayTimeInMs = 0;
			if (isPrimaryRetry) switch (retryPolicyType) {
				case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
					delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
					break;
				case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
					delayTimeInMs = retryDelayInMs;
					break;
			}
			else delayTimeInMs = Math.random() * 1e3;
			log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
			return delayTimeInMs;
		}
		return {
			name: exports.storageRetryPolicyName,
			async sendRequest(request$1, next) {
				if (tryTimeoutInMs) request$1.url = (0, utils_common_js_1.setURLParameter)(request$1.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1e3)));
				const primaryUrl = request$1.url;
				const secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request$1.url, secondaryHost) : void 0;
				let secondaryHas404 = false;
				let attempt = 1;
				let retryAgain = true;
				let response;
				let error;
				while (retryAgain) {
					const isPrimaryRetry = secondaryHas404 || !secondaryUrl || ![
						"GET",
						"HEAD",
						"OPTIONS"
					].includes(request$1.method) || attempt % 2 === 1;
					request$1.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
					response = void 0;
					error = void 0;
					try {
						log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
						response = await next(request$1);
						secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
					} catch (e$1) {
						if ((0, core_rest_pipeline_1.isRestError)(e$1)) {
							log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e$1.message}, code: ${e$1.code}`);
							error = e$1;
						} else {
							log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e$1)}`);
							throw e$1;
						}
					}
					retryAgain = shouldRetry({
						isPrimaryRetry,
						attempt,
						response,
						error
					});
					if (retryAgain) await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request$1.abortSignal, RETRY_ABORT_ERROR);
					attempt++;
				}
				if (response) return response;
				throw error ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
			}
		};
	}
}));
var require_StorageSharedKeyCredentialPolicyV2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageSharedKeyCredentialPolicyName = void 0;
	exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
	var node_crypto_1$1 = __require("node:crypto");
	var constants_js_1 = require_constants$4();
	var utils_common_js_1 = require_utils_common$2();
	var SharedKeyComparator_js_1 = require_SharedKeyComparator$1();
	exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
	function storageSharedKeyCredentialPolicy(options) {
		function signRequest(request$1) {
			request$1.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString());
			if (request$1.body && (typeof request$1.body === "string" || Buffer.isBuffer(request$1.body)) && request$1.body.length > 0) request$1.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request$1.body));
			const stringToSign = [
				request$1.method.toUpperCase(),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_ENCODING),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_LENGTH),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_MD5),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.CONTENT_TYPE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.DATE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_MATCH),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_NONE_MATCH),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
				getHeaderValueToSign(request$1, constants_js_1.HeaderConstants.RANGE)
			].join("\n") + "\n" + getCanonicalizedHeadersString(request$1) + getCanonicalizedResourceString(request$1);
			const signature = (0, node_crypto_1$1.createHmac)("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
			request$1.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
		}
		function getHeaderValueToSign(request$1, headerName) {
			const value$1 = request$1.headers.get(headerName);
			if (!value$1) return "";
			if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value$1 === "0") return "";
			return value$1;
		}
		function getCanonicalizedHeadersString(request$1) {
			let headersArray = [];
			for (const [name$1, value$1] of request$1.headers) if (name$1.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE)) headersArray.push({
				name: name$1,
				value: value$1
			});
			headersArray.sort((a, b) => {
				return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
			});
			headersArray = headersArray.filter((value$1, index$1, array) => {
				if (index$1 > 0 && value$1.name.toLowerCase() === array[index$1 - 1].name.toLowerCase()) return false;
				return true;
			});
			let canonicalizedHeadersStringToSign = "";
			headersArray.forEach((header) => {
				canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}\n`;
			});
			return canonicalizedHeadersStringToSign;
		}
		function getCanonicalizedResourceString(request$1) {
			const path$5 = (0, utils_common_js_1.getURLPath)(request$1.url) || "/";
			let canonicalizedResourceString = "";
			canonicalizedResourceString += `/${options.accountName}${path$5}`;
			const queries = (0, utils_common_js_1.getURLQueries)(request$1.url);
			const lowercaseQueries = {};
			if (queries) {
				const queryKeys = [];
				for (const key in queries) if (Object.prototype.hasOwnProperty.call(queries, key)) {
					const lowercaseKey = key.toLowerCase();
					lowercaseQueries[lowercaseKey] = queries[key];
					queryKeys.push(lowercaseKey);
				}
				queryKeys.sort();
				for (const key of queryKeys) canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
			}
			return canonicalizedResourceString;
		}
		return {
			name: exports.storageSharedKeyCredentialPolicyName,
			async sendRequest(request$1, next) {
				signRequest(request$1);
				return next(request$1);
			}
		};
	}
}));
var require_StorageBrowserPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageBrowserPolicy = void 0;
	var RequestPolicy_js_1 = require_RequestPolicy$1();
	var core_util_1 = require_commonjs$14();
	var constants_js_1 = require_constants$4();
	var utils_common_js_1 = require_utils_common$2();
	var StorageBrowserPolicy = class extends RequestPolicy_js_1.BaseRequestPolicy {
		constructor(nextPolicy, options) {
			super(nextPolicy, options);
		}
		async sendRequest(request$1) {
			if (core_util_1.isNodeLike) return this._nextPolicy.sendRequest(request$1);
			if (request$1.method.toUpperCase() === "GET" || request$1.method.toUpperCase() === "HEAD") request$1.url = (0, utils_common_js_1.setURLParameter)(request$1.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
			request$1.headers.remove(constants_js_1.HeaderConstants.COOKIE);
			request$1.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH);
			return this._nextPolicy.sendRequest(request$1);
		}
	};
	exports.StorageBrowserPolicy = StorageBrowserPolicy;
}));
var require_StorageBrowserPolicyFactory = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = void 0;
	var StorageBrowserPolicy_js_1 = require_StorageBrowserPolicy();
	Object.defineProperty(exports, "StorageBrowserPolicy", {
		enumerable: true,
		get: function() {
			return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
		}
	});
	var StorageBrowserPolicyFactory = class {
		create(nextPolicy, options) {
			return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options);
		}
	};
	exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
}));
var require_StorageCorrectContentLengthPolicy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.storageCorrectContentLengthPolicyName = void 0;
	exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
	var constants_js_1 = require_constants$4();
	exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
	function storageCorrectContentLengthPolicy() {
		function correctContentLength(request$1) {
			if (request$1.body && (typeof request$1.body === "string" || Buffer.isBuffer(request$1.body)) && request$1.body.length > 0) request$1.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request$1.body));
		}
		return {
			name: exports.storageCorrectContentLengthPolicyName,
			async sendRequest(request$1, next) {
				correctContentLength(request$1);
				return next(request$1);
			}
		};
	}
}));
var require_Pipeline = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Pipeline = exports.StorageOAuthScopes = void 0;
	exports.isPipelineLike = isPipelineLike;
	exports.newPipeline = newPipeline;
	exports.getCoreClientOptions = getCoreClientOptions;
	exports.getCredentialFromPipeline = getCredentialFromPipeline;
	var core_http_compat_1 = require_commonjs$9();
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_client_1 = require_commonjs$10();
	var core_xml_1 = require_commonjs$8();
	var core_auth_1 = require_commonjs$11();
	var log_js_1 = require_log$2();
	var StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory$1();
	var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential$1();
	var AnonymousCredential_js_1 = require_AnonymousCredential$1();
	var constants_js_1 = require_constants$4();
	Object.defineProperty(exports, "StorageOAuthScopes", {
		enumerable: true,
		get: function() {
			return constants_js_1.StorageOAuthScopes;
		}
	});
	var storage_common_1 = require_commonjs$7();
	var StorageBrowserPolicyV2_js_1 = require_StorageBrowserPolicyV2();
	var StorageRetryPolicyV2_js_1 = require_StorageRetryPolicyV2();
	var StorageSharedKeyCredentialPolicyV2_js_1 = require_StorageSharedKeyCredentialPolicyV2();
	var StorageBrowserPolicyFactory_js_1 = require_StorageBrowserPolicyFactory();
	var StorageCorrectContentLengthPolicy_js_1 = require_StorageCorrectContentLengthPolicy();
	function isPipelineLike(pipeline) {
		if (!pipeline || typeof pipeline !== "object") return false;
		const castPipeline = pipeline;
		return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
	}
	var Pipeline = class {
		factories;
		options;
		constructor(factories, options = {}) {
			this.factories = factories;
			this.options = options;
		}
		toServiceClientOptions() {
			return {
				httpClient: this.options.httpClient,
				requestPolicyFactories: this.factories
			};
		}
	};
	exports.Pipeline = Pipeline;
	function newPipeline(credential, pipelineOptions = {}) {
		if (!credential) credential = new AnonymousCredential_js_1.AnonymousCredential();
		const pipeline = new Pipeline([], pipelineOptions);
		pipeline._credential = credential;
		return pipeline;
	}
	function processDownlevelPipeline(pipeline) {
		const knownFactoryFunctions = [
			isAnonymousCredential,
			isStorageSharedKeyCredential,
			isCoreHttpBearerTokenFactory,
			isStorageBrowserPolicyFactory,
			isStorageRetryPolicyFactory,
			isStorageTelemetryPolicyFactory,
			isCoreHttpPolicyFactory
		];
		if (pipeline.factories.length) {
			const novelFactories = pipeline.factories.filter((factory) => {
				return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));
			});
			if (novelFactories.length) {
				const hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));
				return {
					wrappedPolicies: (0, core_http_compat_1.createRequestPolicyFactoryPolicy)(novelFactories),
					afterRetry: hasInjector
				};
			}
		}
	}
	function getCoreClientOptions(pipeline) {
		const { httpClient: v1Client, ...restOptions } = pipeline.options;
		let httpClient = pipeline._coreHttpClient;
		if (!httpClient) {
			httpClient = v1Client ? (0, core_http_compat_1.convertHttpClient)(v1Client) : (0, storage_common_1.getCachedDefaultHttpClient)();
			pipeline._coreHttpClient = httpClient;
		}
		let corePipeline = pipeline._corePipeline;
		if (!corePipeline) {
			const packageDetails = `azsdk-js-azure-storage-blob/${constants_js_1.SDK_VERSION}`;
			const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
			corePipeline = (0, core_client_1.createClientPipeline)({
				...restOptions,
				loggingOptions: {
					additionalAllowedHeaderNames: constants_js_1.StorageBlobLoggingAllowedHeaderNames,
					additionalAllowedQueryParameters: constants_js_1.StorageBlobLoggingAllowedQueryParameters,
					logger: log_js_1.logger.info
				},
				userAgentOptions: { userAgentPrefix },
				serializationOptions: {
					stringifyXML: core_xml_1.stringifyXML,
					serializerOptions: { xml: { xmlCharKey: "#" } }
				},
				deserializationOptions: {
					parseXML: core_xml_1.parseXML,
					serializerOptions: { xml: { xmlCharKey: "#" } }
				}
			});
			corePipeline.removePolicy({ phase: "Retry" });
			corePipeline.removePolicy({ name: core_rest_pipeline_1.decompressResponsePolicyName });
			corePipeline.addPolicy((0, StorageCorrectContentLengthPolicy_js_1.storageCorrectContentLengthPolicy)());
			corePipeline.addPolicy((0, StorageRetryPolicyV2_js_1.storageRetryPolicy)(restOptions.retryOptions), { phase: "Retry" });
			corePipeline.addPolicy((0, storage_common_1.storageRequestFailureDetailsParserPolicy)());
			corePipeline.addPolicy((0, StorageBrowserPolicyV2_js_1.storageBrowserPolicy)());
			const downlevelResults = processDownlevelPipeline(pipeline);
			if (downlevelResults) corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? { afterPhase: "Retry" } : void 0);
			const credential = getCredentialFromPipeline(pipeline);
			if ((0, core_auth_1.isTokenCredential)(credential)) corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
				credential,
				scopes: restOptions.audience ?? constants_js_1.StorageOAuthScopes,
				challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
			}), { phase: "Sign" });
			else if (credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) corePipeline.addPolicy((0, StorageSharedKeyCredentialPolicyV2_js_1.storageSharedKeyCredentialPolicy)({
				accountName: credential.accountName,
				accountKey: credential.accountKey
			}), { phase: "Sign" });
			pipeline._corePipeline = corePipeline;
		}
		return {
			...restOptions,
			allowInsecureConnection: true,
			httpClient,
			pipeline: corePipeline
		};
	}
	function getCredentialFromPipeline(pipeline) {
		if (pipeline._credential) return pipeline._credential;
		let credential = new AnonymousCredential_js_1.AnonymousCredential();
		for (const factory of pipeline.factories) if ((0, core_auth_1.isTokenCredential)(factory.credential)) credential = factory.credential;
		else if (isStorageSharedKeyCredential(factory)) return factory;
		return credential;
	}
	function isStorageSharedKeyCredential(factory) {
		if (factory instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) return true;
		return factory.constructor.name === "StorageSharedKeyCredential";
	}
	function isAnonymousCredential(factory) {
		if (factory instanceof AnonymousCredential_js_1.AnonymousCredential) return true;
		return factory.constructor.name === "AnonymousCredential";
	}
	function isCoreHttpBearerTokenFactory(factory) {
		return (0, core_auth_1.isTokenCredential)(factory.credential);
	}
	function isStorageBrowserPolicyFactory(factory) {
		if (factory instanceof StorageBrowserPolicyFactory_js_1.StorageBrowserPolicyFactory) return true;
		return factory.constructor.name === "StorageBrowserPolicyFactory";
	}
	function isStorageRetryPolicyFactory(factory) {
		if (factory instanceof StorageRetryPolicyFactory_js_1.StorageRetryPolicyFactory) return true;
		return factory.constructor.name === "StorageRetryPolicyFactory";
	}
	function isStorageTelemetryPolicyFactory(factory) {
		return factory.constructor.name === "TelemetryPolicyFactory";
	}
	function isInjectorPolicyFactory(factory) {
		return factory.constructor.name === "InjectorPolicyFactory";
	}
	function isCoreHttpPolicyFactory(factory) {
		const knownPolicies = [
			"GenerateClientRequestIdPolicy",
			"TracingPolicy",
			"LogPolicy",
			"ProxyPolicy",
			"DisableResponseDecompressionPolicy",
			"KeepAlivePolicy",
			"DeserializationPolicy"
		];
		const policyName = factory.create({ sendRequest: async (request$1) => {
			return {
				request: request$1,
				headers: request$1.headers.clone(),
				status: 500
			};
		} }, {
			log(_logLevel, _message) {},
			shouldLog(_logLevel) {
				return false;
			}
		}).constructor.name;
		return knownPolicies.some((knownPolicyName) => {
			return policyName.startsWith(knownPolicyName);
		});
	}
}));
var require_models$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.KnownStorageErrorCode = exports.KnownBlobExpiryOptions = exports.KnownFileShareTokenIntent = exports.KnownEncryptionAlgorithmType = void 0;
	var KnownEncryptionAlgorithmType;
	(function(KnownEncryptionAlgorithmType) {
		KnownEncryptionAlgorithmType["AES256"] = "AES256";
	})(KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
	var KnownFileShareTokenIntent;
	(function(KnownFileShareTokenIntent) {
		KnownFileShareTokenIntent["Backup"] = "backup";
	})(KnownFileShareTokenIntent || (exports.KnownFileShareTokenIntent = KnownFileShareTokenIntent = {}));
	var KnownBlobExpiryOptions;
	(function(KnownBlobExpiryOptions) {
		KnownBlobExpiryOptions["NeverExpire"] = "NeverExpire";
		KnownBlobExpiryOptions["RelativeToCreation"] = "RelativeToCreation";
		KnownBlobExpiryOptions["RelativeToNow"] = "RelativeToNow";
		KnownBlobExpiryOptions["Absolute"] = "Absolute";
	})(KnownBlobExpiryOptions || (exports.KnownBlobExpiryOptions = KnownBlobExpiryOptions = {}));
	var KnownStorageErrorCode;
	(function(KnownStorageErrorCode) {
		KnownStorageErrorCode["AccountAlreadyExists"] = "AccountAlreadyExists";
		KnownStorageErrorCode["AccountBeingCreated"] = "AccountBeingCreated";
		KnownStorageErrorCode["AccountIsDisabled"] = "AccountIsDisabled";
		KnownStorageErrorCode["AuthenticationFailed"] = "AuthenticationFailed";
		KnownStorageErrorCode["AuthorizationFailure"] = "AuthorizationFailure";
		KnownStorageErrorCode["ConditionHeadersNotSupported"] = "ConditionHeadersNotSupported";
		KnownStorageErrorCode["ConditionNotMet"] = "ConditionNotMet";
		KnownStorageErrorCode["EmptyMetadataKey"] = "EmptyMetadataKey";
		KnownStorageErrorCode["InsufficientAccountPermissions"] = "InsufficientAccountPermissions";
		KnownStorageErrorCode["InternalError"] = "InternalError";
		KnownStorageErrorCode["InvalidAuthenticationInfo"] = "InvalidAuthenticationInfo";
		KnownStorageErrorCode["InvalidHeaderValue"] = "InvalidHeaderValue";
		KnownStorageErrorCode["InvalidHttpVerb"] = "InvalidHttpVerb";
		KnownStorageErrorCode["InvalidInput"] = "InvalidInput";
		KnownStorageErrorCode["InvalidMd5"] = "InvalidMd5";
		KnownStorageErrorCode["InvalidMetadata"] = "InvalidMetadata";
		KnownStorageErrorCode["InvalidQueryParameterValue"] = "InvalidQueryParameterValue";
		KnownStorageErrorCode["InvalidRange"] = "InvalidRange";
		KnownStorageErrorCode["InvalidResourceName"] = "InvalidResourceName";
		KnownStorageErrorCode["InvalidUri"] = "InvalidUri";
		KnownStorageErrorCode["InvalidXmlDocument"] = "InvalidXmlDocument";
		KnownStorageErrorCode["InvalidXmlNodeValue"] = "InvalidXmlNodeValue";
		KnownStorageErrorCode["Md5Mismatch"] = "Md5Mismatch";
		KnownStorageErrorCode["MetadataTooLarge"] = "MetadataTooLarge";
		KnownStorageErrorCode["MissingContentLengthHeader"] = "MissingContentLengthHeader";
		KnownStorageErrorCode["MissingRequiredQueryParameter"] = "MissingRequiredQueryParameter";
		KnownStorageErrorCode["MissingRequiredHeader"] = "MissingRequiredHeader";
		KnownStorageErrorCode["MissingRequiredXmlNode"] = "MissingRequiredXmlNode";
		KnownStorageErrorCode["MultipleConditionHeadersNotSupported"] = "MultipleConditionHeadersNotSupported";
		KnownStorageErrorCode["OperationTimedOut"] = "OperationTimedOut";
		KnownStorageErrorCode["OutOfRangeInput"] = "OutOfRangeInput";
		KnownStorageErrorCode["OutOfRangeQueryParameterValue"] = "OutOfRangeQueryParameterValue";
		KnownStorageErrorCode["RequestBodyTooLarge"] = "RequestBodyTooLarge";
		KnownStorageErrorCode["ResourceTypeMismatch"] = "ResourceTypeMismatch";
		KnownStorageErrorCode["RequestUrlFailedToParse"] = "RequestUrlFailedToParse";
		KnownStorageErrorCode["ResourceAlreadyExists"] = "ResourceAlreadyExists";
		KnownStorageErrorCode["ResourceNotFound"] = "ResourceNotFound";
		KnownStorageErrorCode["ServerBusy"] = "ServerBusy";
		KnownStorageErrorCode["UnsupportedHeader"] = "UnsupportedHeader";
		KnownStorageErrorCode["UnsupportedXmlNode"] = "UnsupportedXmlNode";
		KnownStorageErrorCode["UnsupportedQueryParameter"] = "UnsupportedQueryParameter";
		KnownStorageErrorCode["UnsupportedHttpVerb"] = "UnsupportedHttpVerb";
		KnownStorageErrorCode["AppendPositionConditionNotMet"] = "AppendPositionConditionNotMet";
		KnownStorageErrorCode["BlobAlreadyExists"] = "BlobAlreadyExists";
		KnownStorageErrorCode["BlobImmutableDueToPolicy"] = "BlobImmutableDueToPolicy";
		KnownStorageErrorCode["BlobNotFound"] = "BlobNotFound";
		KnownStorageErrorCode["BlobOverwritten"] = "BlobOverwritten";
		KnownStorageErrorCode["BlobTierInadequateForContentLength"] = "BlobTierInadequateForContentLength";
		KnownStorageErrorCode["BlobUsesCustomerSpecifiedEncryption"] = "BlobUsesCustomerSpecifiedEncryption";
		KnownStorageErrorCode["BlockCountExceedsLimit"] = "BlockCountExceedsLimit";
		KnownStorageErrorCode["BlockListTooLong"] = "BlockListTooLong";
		KnownStorageErrorCode["CannotChangeToLowerTier"] = "CannotChangeToLowerTier";
		KnownStorageErrorCode["CannotVerifyCopySource"] = "CannotVerifyCopySource";
		KnownStorageErrorCode["ContainerAlreadyExists"] = "ContainerAlreadyExists";
		KnownStorageErrorCode["ContainerBeingDeleted"] = "ContainerBeingDeleted";
		KnownStorageErrorCode["ContainerDisabled"] = "ContainerDisabled";
		KnownStorageErrorCode["ContainerNotFound"] = "ContainerNotFound";
		KnownStorageErrorCode["ContentLengthLargerThanTierLimit"] = "ContentLengthLargerThanTierLimit";
		KnownStorageErrorCode["CopyAcrossAccountsNotSupported"] = "CopyAcrossAccountsNotSupported";
		KnownStorageErrorCode["CopyIdMismatch"] = "CopyIdMismatch";
		KnownStorageErrorCode["FeatureVersionMismatch"] = "FeatureVersionMismatch";
		KnownStorageErrorCode["IncrementalCopyBlobMismatch"] = "IncrementalCopyBlobMismatch";
		KnownStorageErrorCode["IncrementalCopyOfEarlierVersionSnapshotNotAllowed"] = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed";
		KnownStorageErrorCode["IncrementalCopySourceMustBeSnapshot"] = "IncrementalCopySourceMustBeSnapshot";
		KnownStorageErrorCode["InfiniteLeaseDurationRequired"] = "InfiniteLeaseDurationRequired";
		KnownStorageErrorCode["InvalidBlobOrBlock"] = "InvalidBlobOrBlock";
		KnownStorageErrorCode["InvalidBlobTier"] = "InvalidBlobTier";
		KnownStorageErrorCode["InvalidBlobType"] = "InvalidBlobType";
		KnownStorageErrorCode["InvalidBlockId"] = "InvalidBlockId";
		KnownStorageErrorCode["InvalidBlockList"] = "InvalidBlockList";
		KnownStorageErrorCode["InvalidOperation"] = "InvalidOperation";
		KnownStorageErrorCode["InvalidPageRange"] = "InvalidPageRange";
		KnownStorageErrorCode["InvalidSourceBlobType"] = "InvalidSourceBlobType";
		KnownStorageErrorCode["InvalidSourceBlobUrl"] = "InvalidSourceBlobUrl";
		KnownStorageErrorCode["InvalidVersionForPageBlobOperation"] = "InvalidVersionForPageBlobOperation";
		KnownStorageErrorCode["LeaseAlreadyPresent"] = "LeaseAlreadyPresent";
		KnownStorageErrorCode["LeaseAlreadyBroken"] = "LeaseAlreadyBroken";
		KnownStorageErrorCode["LeaseIdMismatchWithBlobOperation"] = "LeaseIdMismatchWithBlobOperation";
		KnownStorageErrorCode["LeaseIdMismatchWithContainerOperation"] = "LeaseIdMismatchWithContainerOperation";
		KnownStorageErrorCode["LeaseIdMismatchWithLeaseOperation"] = "LeaseIdMismatchWithLeaseOperation";
		KnownStorageErrorCode["LeaseIdMissing"] = "LeaseIdMissing";
		KnownStorageErrorCode["LeaseIsBreakingAndCannotBeAcquired"] = "LeaseIsBreakingAndCannotBeAcquired";
		KnownStorageErrorCode["LeaseIsBreakingAndCannotBeChanged"] = "LeaseIsBreakingAndCannotBeChanged";
		KnownStorageErrorCode["LeaseIsBrokenAndCannotBeRenewed"] = "LeaseIsBrokenAndCannotBeRenewed";
		KnownStorageErrorCode["LeaseLost"] = "LeaseLost";
		KnownStorageErrorCode["LeaseNotPresentWithBlobOperation"] = "LeaseNotPresentWithBlobOperation";
		KnownStorageErrorCode["LeaseNotPresentWithContainerOperation"] = "LeaseNotPresentWithContainerOperation";
		KnownStorageErrorCode["LeaseNotPresentWithLeaseOperation"] = "LeaseNotPresentWithLeaseOperation";
		KnownStorageErrorCode["MaxBlobSizeConditionNotMet"] = "MaxBlobSizeConditionNotMet";
		KnownStorageErrorCode["NoAuthenticationInformation"] = "NoAuthenticationInformation";
		KnownStorageErrorCode["NoPendingCopyOperation"] = "NoPendingCopyOperation";
		KnownStorageErrorCode["OperationNotAllowedOnIncrementalCopyBlob"] = "OperationNotAllowedOnIncrementalCopyBlob";
		KnownStorageErrorCode["PendingCopyOperation"] = "PendingCopyOperation";
		KnownStorageErrorCode["PreviousSnapshotCannotBeNewer"] = "PreviousSnapshotCannotBeNewer";
		KnownStorageErrorCode["PreviousSnapshotNotFound"] = "PreviousSnapshotNotFound";
		KnownStorageErrorCode["PreviousSnapshotOperationNotSupported"] = "PreviousSnapshotOperationNotSupported";
		KnownStorageErrorCode["SequenceNumberConditionNotMet"] = "SequenceNumberConditionNotMet";
		KnownStorageErrorCode["SequenceNumberIncrementTooLarge"] = "SequenceNumberIncrementTooLarge";
		KnownStorageErrorCode["SnapshotCountExceeded"] = "SnapshotCountExceeded";
		KnownStorageErrorCode["SnapshotOperationRateExceeded"] = "SnapshotOperationRateExceeded";
		KnownStorageErrorCode["SnapshotsPresent"] = "SnapshotsPresent";
		KnownStorageErrorCode["SourceConditionNotMet"] = "SourceConditionNotMet";
		KnownStorageErrorCode["SystemInUse"] = "SystemInUse";
		KnownStorageErrorCode["TargetConditionNotMet"] = "TargetConditionNotMet";
		KnownStorageErrorCode["UnauthorizedBlobOverwrite"] = "UnauthorizedBlobOverwrite";
		KnownStorageErrorCode["BlobBeingRehydrated"] = "BlobBeingRehydrated";
		KnownStorageErrorCode["BlobArchived"] = "BlobArchived";
		KnownStorageErrorCode["BlobNotArchived"] = "BlobNotArchived";
		KnownStorageErrorCode["AuthorizationSourceIPMismatch"] = "AuthorizationSourceIPMismatch";
		KnownStorageErrorCode["AuthorizationProtocolMismatch"] = "AuthorizationProtocolMismatch";
		KnownStorageErrorCode["AuthorizationPermissionMismatch"] = "AuthorizationPermissionMismatch";
		KnownStorageErrorCode["AuthorizationServiceMismatch"] = "AuthorizationServiceMismatch";
		KnownStorageErrorCode["AuthorizationResourceTypeMismatch"] = "AuthorizationResourceTypeMismatch";
		KnownStorageErrorCode["BlobAccessTierNotSupportedForAccountType"] = "BlobAccessTierNotSupportedForAccountType";
	})(KnownStorageErrorCode || (exports.KnownStorageErrorCode = KnownStorageErrorCode = {}));
}));
var require_mappers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ServiceGetUserDelegationKeyHeaders = exports.ServiceListContainersSegmentExceptionHeaders = exports.ServiceListContainersSegmentHeaders = exports.ServiceGetStatisticsExceptionHeaders = exports.ServiceGetStatisticsHeaders = exports.ServiceGetPropertiesExceptionHeaders = exports.ServiceGetPropertiesHeaders = exports.ServiceSetPropertiesExceptionHeaders = exports.ServiceSetPropertiesHeaders = exports.ArrowField = exports.ArrowConfiguration = exports.JsonTextConfiguration = exports.DelimitedTextConfiguration = exports.QueryFormat = exports.QuerySerialization = exports.QueryRequest = exports.ClearRange = exports.PageRange = exports.PageList = exports.Block = exports.BlockList = exports.BlockLookupList = exports.BlobPrefix = exports.BlobHierarchyListSegment = exports.ListBlobsHierarchySegmentResponse = exports.BlobPropertiesInternal = exports.BlobName = exports.BlobItemInternal = exports.BlobFlatListSegment = exports.ListBlobsFlatSegmentResponse = exports.AccessPolicy = exports.SignedIdentifier = exports.BlobTag = exports.BlobTags = exports.FilterBlobItem = exports.FilterBlobSegment = exports.UserDelegationKey = exports.KeyInfo = exports.ContainerProperties = exports.ContainerItem = exports.ListContainersSegmentResponse = exports.GeoReplication = exports.BlobServiceStatistics = exports.StorageError = exports.StaticWebsite = exports.CorsRule = exports.Metrics = exports.RetentionPolicy = exports.Logging = exports.BlobServiceProperties = void 0;
	exports.BlobUndeleteHeaders = exports.BlobDeleteExceptionHeaders = exports.BlobDeleteHeaders = exports.BlobGetPropertiesExceptionHeaders = exports.BlobGetPropertiesHeaders = exports.BlobDownloadExceptionHeaders = exports.BlobDownloadHeaders = exports.ContainerGetAccountInfoExceptionHeaders = exports.ContainerGetAccountInfoHeaders = exports.ContainerListBlobHierarchySegmentExceptionHeaders = exports.ContainerListBlobHierarchySegmentHeaders = exports.ContainerListBlobFlatSegmentExceptionHeaders = exports.ContainerListBlobFlatSegmentHeaders = exports.ContainerChangeLeaseExceptionHeaders = exports.ContainerChangeLeaseHeaders = exports.ContainerBreakLeaseExceptionHeaders = exports.ContainerBreakLeaseHeaders = exports.ContainerRenewLeaseExceptionHeaders = exports.ContainerRenewLeaseHeaders = exports.ContainerReleaseLeaseExceptionHeaders = exports.ContainerReleaseLeaseHeaders = exports.ContainerAcquireLeaseExceptionHeaders = exports.ContainerAcquireLeaseHeaders = exports.ContainerFilterBlobsExceptionHeaders = exports.ContainerFilterBlobsHeaders = exports.ContainerSubmitBatchExceptionHeaders = exports.ContainerSubmitBatchHeaders = exports.ContainerRenameExceptionHeaders = exports.ContainerRenameHeaders = exports.ContainerRestoreExceptionHeaders = exports.ContainerRestoreHeaders = exports.ContainerSetAccessPolicyExceptionHeaders = exports.ContainerSetAccessPolicyHeaders = exports.ContainerGetAccessPolicyExceptionHeaders = exports.ContainerGetAccessPolicyHeaders = exports.ContainerSetMetadataExceptionHeaders = exports.ContainerSetMetadataHeaders = exports.ContainerDeleteExceptionHeaders = exports.ContainerDeleteHeaders = exports.ContainerGetPropertiesExceptionHeaders = exports.ContainerGetPropertiesHeaders = exports.ContainerCreateExceptionHeaders = exports.ContainerCreateHeaders = exports.ServiceFilterBlobsExceptionHeaders = exports.ServiceFilterBlobsHeaders = exports.ServiceSubmitBatchExceptionHeaders = exports.ServiceSubmitBatchHeaders = exports.ServiceGetAccountInfoExceptionHeaders = exports.ServiceGetAccountInfoHeaders = exports.ServiceGetUserDelegationKeyExceptionHeaders = void 0;
	exports.PageBlobGetPageRangesHeaders = exports.PageBlobUploadPagesFromURLExceptionHeaders = exports.PageBlobUploadPagesFromURLHeaders = exports.PageBlobClearPagesExceptionHeaders = exports.PageBlobClearPagesHeaders = exports.PageBlobUploadPagesExceptionHeaders = exports.PageBlobUploadPagesHeaders = exports.PageBlobCreateExceptionHeaders = exports.PageBlobCreateHeaders = exports.BlobSetTagsExceptionHeaders = exports.BlobSetTagsHeaders = exports.BlobGetTagsExceptionHeaders = exports.BlobGetTagsHeaders = exports.BlobQueryExceptionHeaders = exports.BlobQueryHeaders = exports.BlobGetAccountInfoExceptionHeaders = exports.BlobGetAccountInfoHeaders = exports.BlobSetTierExceptionHeaders = exports.BlobSetTierHeaders = exports.BlobAbortCopyFromURLExceptionHeaders = exports.BlobAbortCopyFromURLHeaders = exports.BlobCopyFromURLExceptionHeaders = exports.BlobCopyFromURLHeaders = exports.BlobStartCopyFromURLExceptionHeaders = exports.BlobStartCopyFromURLHeaders = exports.BlobCreateSnapshotExceptionHeaders = exports.BlobCreateSnapshotHeaders = exports.BlobBreakLeaseExceptionHeaders = exports.BlobBreakLeaseHeaders = exports.BlobChangeLeaseExceptionHeaders = exports.BlobChangeLeaseHeaders = exports.BlobRenewLeaseExceptionHeaders = exports.BlobRenewLeaseHeaders = exports.BlobReleaseLeaseExceptionHeaders = exports.BlobReleaseLeaseHeaders = exports.BlobAcquireLeaseExceptionHeaders = exports.BlobAcquireLeaseHeaders = exports.BlobSetMetadataExceptionHeaders = exports.BlobSetMetadataHeaders = exports.BlobSetLegalHoldExceptionHeaders = exports.BlobSetLegalHoldHeaders = exports.BlobDeleteImmutabilityPolicyExceptionHeaders = exports.BlobDeleteImmutabilityPolicyHeaders = exports.BlobSetImmutabilityPolicyExceptionHeaders = exports.BlobSetImmutabilityPolicyHeaders = exports.BlobSetHttpHeadersExceptionHeaders = exports.BlobSetHttpHeadersHeaders = exports.BlobSetExpiryExceptionHeaders = exports.BlobSetExpiryHeaders = exports.BlobUndeleteExceptionHeaders = void 0;
	exports.BlockBlobGetBlockListExceptionHeaders = exports.BlockBlobGetBlockListHeaders = exports.BlockBlobCommitBlockListExceptionHeaders = exports.BlockBlobCommitBlockListHeaders = exports.BlockBlobStageBlockFromURLExceptionHeaders = exports.BlockBlobStageBlockFromURLHeaders = exports.BlockBlobStageBlockExceptionHeaders = exports.BlockBlobStageBlockHeaders = exports.BlockBlobPutBlobFromUrlExceptionHeaders = exports.BlockBlobPutBlobFromUrlHeaders = exports.BlockBlobUploadExceptionHeaders = exports.BlockBlobUploadHeaders = exports.AppendBlobSealExceptionHeaders = exports.AppendBlobSealHeaders = exports.AppendBlobAppendBlockFromUrlExceptionHeaders = exports.AppendBlobAppendBlockFromUrlHeaders = exports.AppendBlobAppendBlockExceptionHeaders = exports.AppendBlobAppendBlockHeaders = exports.AppendBlobCreateExceptionHeaders = exports.AppendBlobCreateHeaders = exports.PageBlobCopyIncrementalExceptionHeaders = exports.PageBlobCopyIncrementalHeaders = exports.PageBlobUpdateSequenceNumberExceptionHeaders = exports.PageBlobUpdateSequenceNumberHeaders = exports.PageBlobResizeExceptionHeaders = exports.PageBlobResizeHeaders = exports.PageBlobGetPageRangesDiffExceptionHeaders = exports.PageBlobGetPageRangesDiffHeaders = exports.PageBlobGetPageRangesExceptionHeaders = void 0;
	exports.BlobServiceProperties = {
		serializedName: "BlobServiceProperties",
		xmlName: "StorageServiceProperties",
		type: {
			name: "Composite",
			className: "BlobServiceProperties",
			modelProperties: {
				blobAnalyticsLogging: {
					serializedName: "Logging",
					xmlName: "Logging",
					type: {
						name: "Composite",
						className: "Logging"
					}
				},
				hourMetrics: {
					serializedName: "HourMetrics",
					xmlName: "HourMetrics",
					type: {
						name: "Composite",
						className: "Metrics"
					}
				},
				minuteMetrics: {
					serializedName: "MinuteMetrics",
					xmlName: "MinuteMetrics",
					type: {
						name: "Composite",
						className: "Metrics"
					}
				},
				cors: {
					serializedName: "Cors",
					xmlName: "Cors",
					xmlIsWrapped: true,
					xmlElementName: "CorsRule",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "CorsRule"
						} }
					}
				},
				defaultServiceVersion: {
					serializedName: "DefaultServiceVersion",
					xmlName: "DefaultServiceVersion",
					type: { name: "String" }
				},
				deleteRetentionPolicy: {
					serializedName: "DeleteRetentionPolicy",
					xmlName: "DeleteRetentionPolicy",
					type: {
						name: "Composite",
						className: "RetentionPolicy"
					}
				},
				staticWebsite: {
					serializedName: "StaticWebsite",
					xmlName: "StaticWebsite",
					type: {
						name: "Composite",
						className: "StaticWebsite"
					}
				}
			}
		}
	};
	exports.Logging = {
		serializedName: "Logging",
		type: {
			name: "Composite",
			className: "Logging",
			modelProperties: {
				version: {
					serializedName: "Version",
					required: true,
					xmlName: "Version",
					type: { name: "String" }
				},
				deleteProperty: {
					serializedName: "Delete",
					required: true,
					xmlName: "Delete",
					type: { name: "Boolean" }
				},
				read: {
					serializedName: "Read",
					required: true,
					xmlName: "Read",
					type: { name: "Boolean" }
				},
				write: {
					serializedName: "Write",
					required: true,
					xmlName: "Write",
					type: { name: "Boolean" }
				},
				retentionPolicy: {
					serializedName: "RetentionPolicy",
					xmlName: "RetentionPolicy",
					type: {
						name: "Composite",
						className: "RetentionPolicy"
					}
				}
			}
		}
	};
	exports.RetentionPolicy = {
		serializedName: "RetentionPolicy",
		type: {
			name: "Composite",
			className: "RetentionPolicy",
			modelProperties: {
				enabled: {
					serializedName: "Enabled",
					required: true,
					xmlName: "Enabled",
					type: { name: "Boolean" }
				},
				days: {
					constraints: { InclusiveMinimum: 1 },
					serializedName: "Days",
					xmlName: "Days",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.Metrics = {
		serializedName: "Metrics",
		type: {
			name: "Composite",
			className: "Metrics",
			modelProperties: {
				version: {
					serializedName: "Version",
					xmlName: "Version",
					type: { name: "String" }
				},
				enabled: {
					serializedName: "Enabled",
					required: true,
					xmlName: "Enabled",
					type: { name: "Boolean" }
				},
				includeAPIs: {
					serializedName: "IncludeAPIs",
					xmlName: "IncludeAPIs",
					type: { name: "Boolean" }
				},
				retentionPolicy: {
					serializedName: "RetentionPolicy",
					xmlName: "RetentionPolicy",
					type: {
						name: "Composite",
						className: "RetentionPolicy"
					}
				}
			}
		}
	};
	exports.CorsRule = {
		serializedName: "CorsRule",
		type: {
			name: "Composite",
			className: "CorsRule",
			modelProperties: {
				allowedOrigins: {
					serializedName: "AllowedOrigins",
					required: true,
					xmlName: "AllowedOrigins",
					type: { name: "String" }
				},
				allowedMethods: {
					serializedName: "AllowedMethods",
					required: true,
					xmlName: "AllowedMethods",
					type: { name: "String" }
				},
				allowedHeaders: {
					serializedName: "AllowedHeaders",
					required: true,
					xmlName: "AllowedHeaders",
					type: { name: "String" }
				},
				exposedHeaders: {
					serializedName: "ExposedHeaders",
					required: true,
					xmlName: "ExposedHeaders",
					type: { name: "String" }
				},
				maxAgeInSeconds: {
					constraints: { InclusiveMinimum: 0 },
					serializedName: "MaxAgeInSeconds",
					required: true,
					xmlName: "MaxAgeInSeconds",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.StaticWebsite = {
		serializedName: "StaticWebsite",
		type: {
			name: "Composite",
			className: "StaticWebsite",
			modelProperties: {
				enabled: {
					serializedName: "Enabled",
					required: true,
					xmlName: "Enabled",
					type: { name: "Boolean" }
				},
				indexDocument: {
					serializedName: "IndexDocument",
					xmlName: "IndexDocument",
					type: { name: "String" }
				},
				errorDocument404Path: {
					serializedName: "ErrorDocument404Path",
					xmlName: "ErrorDocument404Path",
					type: { name: "String" }
				},
				defaultIndexDocumentPath: {
					serializedName: "DefaultIndexDocumentPath",
					xmlName: "DefaultIndexDocumentPath",
					type: { name: "String" }
				}
			}
		}
	};
	exports.StorageError = {
		serializedName: "StorageError",
		type: {
			name: "Composite",
			className: "StorageError",
			modelProperties: {
				message: {
					serializedName: "Message",
					xmlName: "Message",
					type: { name: "String" }
				},
				copySourceStatusCode: {
					serializedName: "CopySourceStatusCode",
					xmlName: "CopySourceStatusCode",
					type: { name: "Number" }
				},
				copySourceErrorCode: {
					serializedName: "CopySourceErrorCode",
					xmlName: "CopySourceErrorCode",
					type: { name: "String" }
				},
				copySourceErrorMessage: {
					serializedName: "CopySourceErrorMessage",
					xmlName: "CopySourceErrorMessage",
					type: { name: "String" }
				},
				code: {
					serializedName: "Code",
					xmlName: "Code",
					type: { name: "String" }
				},
				authenticationErrorDetail: {
					serializedName: "AuthenticationErrorDetail",
					xmlName: "AuthenticationErrorDetail",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobServiceStatistics = {
		serializedName: "BlobServiceStatistics",
		xmlName: "StorageServiceStats",
		type: {
			name: "Composite",
			className: "BlobServiceStatistics",
			modelProperties: { geoReplication: {
				serializedName: "GeoReplication",
				xmlName: "GeoReplication",
				type: {
					name: "Composite",
					className: "GeoReplication"
				}
			} }
		}
	};
	exports.GeoReplication = {
		serializedName: "GeoReplication",
		type: {
			name: "Composite",
			className: "GeoReplication",
			modelProperties: {
				status: {
					serializedName: "Status",
					required: true,
					xmlName: "Status",
					type: {
						name: "Enum",
						allowedValues: [
							"live",
							"bootstrap",
							"unavailable"
						]
					}
				},
				lastSyncOn: {
					serializedName: "LastSyncTime",
					required: true,
					xmlName: "LastSyncTime",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.ListContainersSegmentResponse = {
		serializedName: "ListContainersSegmentResponse",
		xmlName: "EnumerationResults",
		type: {
			name: "Composite",
			className: "ListContainersSegmentResponse",
			modelProperties: {
				serviceEndpoint: {
					serializedName: "ServiceEndpoint",
					required: true,
					xmlName: "ServiceEndpoint",
					xmlIsAttribute: true,
					type: { name: "String" }
				},
				prefix: {
					serializedName: "Prefix",
					xmlName: "Prefix",
					type: { name: "String" }
				},
				marker: {
					serializedName: "Marker",
					xmlName: "Marker",
					type: { name: "String" }
				},
				maxPageSize: {
					serializedName: "MaxResults",
					xmlName: "MaxResults",
					type: { name: "Number" }
				},
				containerItems: {
					serializedName: "ContainerItems",
					required: true,
					xmlName: "Containers",
					xmlIsWrapped: true,
					xmlElementName: "Container",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "ContainerItem"
						} }
					}
				},
				continuationToken: {
					serializedName: "NextMarker",
					xmlName: "NextMarker",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerItem = {
		serializedName: "ContainerItem",
		xmlName: "Container",
		type: {
			name: "Composite",
			className: "ContainerItem",
			modelProperties: {
				name: {
					serializedName: "Name",
					required: true,
					xmlName: "Name",
					type: { name: "String" }
				},
				deleted: {
					serializedName: "Deleted",
					xmlName: "Deleted",
					type: { name: "Boolean" }
				},
				version: {
					serializedName: "Version",
					xmlName: "Version",
					type: { name: "String" }
				},
				properties: {
					serializedName: "Properties",
					xmlName: "Properties",
					type: {
						name: "Composite",
						className: "ContainerProperties"
					}
				},
				metadata: {
					serializedName: "Metadata",
					xmlName: "Metadata",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				}
			}
		}
	};
	exports.ContainerProperties = {
		serializedName: "ContainerProperties",
		type: {
			name: "Composite",
			className: "ContainerProperties",
			modelProperties: {
				lastModified: {
					serializedName: "Last-Modified",
					required: true,
					xmlName: "Last-Modified",
					type: { name: "DateTimeRfc1123" }
				},
				etag: {
					serializedName: "Etag",
					required: true,
					xmlName: "Etag",
					type: { name: "String" }
				},
				leaseStatus: {
					serializedName: "LeaseStatus",
					xmlName: "LeaseStatus",
					type: {
						name: "Enum",
						allowedValues: ["locked", "unlocked"]
					}
				},
				leaseState: {
					serializedName: "LeaseState",
					xmlName: "LeaseState",
					type: {
						name: "Enum",
						allowedValues: [
							"available",
							"leased",
							"expired",
							"breaking",
							"broken"
						]
					}
				},
				leaseDuration: {
					serializedName: "LeaseDuration",
					xmlName: "LeaseDuration",
					type: {
						name: "Enum",
						allowedValues: ["infinite", "fixed"]
					}
				},
				publicAccess: {
					serializedName: "PublicAccess",
					xmlName: "PublicAccess",
					type: {
						name: "Enum",
						allowedValues: ["container", "blob"]
					}
				},
				hasImmutabilityPolicy: {
					serializedName: "HasImmutabilityPolicy",
					xmlName: "HasImmutabilityPolicy",
					type: { name: "Boolean" }
				},
				hasLegalHold: {
					serializedName: "HasLegalHold",
					xmlName: "HasLegalHold",
					type: { name: "Boolean" }
				},
				defaultEncryptionScope: {
					serializedName: "DefaultEncryptionScope",
					xmlName: "DefaultEncryptionScope",
					type: { name: "String" }
				},
				preventEncryptionScopeOverride: {
					serializedName: "DenyEncryptionScopeOverride",
					xmlName: "DenyEncryptionScopeOverride",
					type: { name: "Boolean" }
				},
				deletedOn: {
					serializedName: "DeletedTime",
					xmlName: "DeletedTime",
					type: { name: "DateTimeRfc1123" }
				},
				remainingRetentionDays: {
					serializedName: "RemainingRetentionDays",
					xmlName: "RemainingRetentionDays",
					type: { name: "Number" }
				},
				isImmutableStorageWithVersioningEnabled: {
					serializedName: "ImmutableStorageWithVersioningEnabled",
					xmlName: "ImmutableStorageWithVersioningEnabled",
					type: { name: "Boolean" }
				}
			}
		}
	};
	exports.KeyInfo = {
		serializedName: "KeyInfo",
		type: {
			name: "Composite",
			className: "KeyInfo",
			modelProperties: {
				startsOn: {
					serializedName: "Start",
					required: true,
					xmlName: "Start",
					type: { name: "String" }
				},
				expiresOn: {
					serializedName: "Expiry",
					required: true,
					xmlName: "Expiry",
					type: { name: "String" }
				}
			}
		}
	};
	exports.UserDelegationKey = {
		serializedName: "UserDelegationKey",
		type: {
			name: "Composite",
			className: "UserDelegationKey",
			modelProperties: {
				signedObjectId: {
					serializedName: "SignedOid",
					required: true,
					xmlName: "SignedOid",
					type: { name: "String" }
				},
				signedTenantId: {
					serializedName: "SignedTid",
					required: true,
					xmlName: "SignedTid",
					type: { name: "String" }
				},
				signedStartsOn: {
					serializedName: "SignedStart",
					required: true,
					xmlName: "SignedStart",
					type: { name: "String" }
				},
				signedExpiresOn: {
					serializedName: "SignedExpiry",
					required: true,
					xmlName: "SignedExpiry",
					type: { name: "String" }
				},
				signedService: {
					serializedName: "SignedService",
					required: true,
					xmlName: "SignedService",
					type: { name: "String" }
				},
				signedVersion: {
					serializedName: "SignedVersion",
					required: true,
					xmlName: "SignedVersion",
					type: { name: "String" }
				},
				value: {
					serializedName: "Value",
					required: true,
					xmlName: "Value",
					type: { name: "String" }
				}
			}
		}
	};
	exports.FilterBlobSegment = {
		serializedName: "FilterBlobSegment",
		xmlName: "EnumerationResults",
		type: {
			name: "Composite",
			className: "FilterBlobSegment",
			modelProperties: {
				serviceEndpoint: {
					serializedName: "ServiceEndpoint",
					required: true,
					xmlName: "ServiceEndpoint",
					xmlIsAttribute: true,
					type: { name: "String" }
				},
				where: {
					serializedName: "Where",
					required: true,
					xmlName: "Where",
					type: { name: "String" }
				},
				blobs: {
					serializedName: "Blobs",
					required: true,
					xmlName: "Blobs",
					xmlIsWrapped: true,
					xmlElementName: "Blob",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "FilterBlobItem"
						} }
					}
				},
				continuationToken: {
					serializedName: "NextMarker",
					xmlName: "NextMarker",
					type: { name: "String" }
				}
			}
		}
	};
	exports.FilterBlobItem = {
		serializedName: "FilterBlobItem",
		xmlName: "Blob",
		type: {
			name: "Composite",
			className: "FilterBlobItem",
			modelProperties: {
				name: {
					serializedName: "Name",
					required: true,
					xmlName: "Name",
					type: { name: "String" }
				},
				containerName: {
					serializedName: "ContainerName",
					required: true,
					xmlName: "ContainerName",
					type: { name: "String" }
				},
				tags: {
					serializedName: "Tags",
					xmlName: "Tags",
					type: {
						name: "Composite",
						className: "BlobTags"
					}
				}
			}
		}
	};
	exports.BlobTags = {
		serializedName: "BlobTags",
		xmlName: "Tags",
		type: {
			name: "Composite",
			className: "BlobTags",
			modelProperties: { blobTagSet: {
				serializedName: "BlobTagSet",
				required: true,
				xmlName: "TagSet",
				xmlIsWrapped: true,
				xmlElementName: "Tag",
				type: {
					name: "Sequence",
					element: { type: {
						name: "Composite",
						className: "BlobTag"
					} }
				}
			} }
		}
	};
	exports.BlobTag = {
		serializedName: "BlobTag",
		xmlName: "Tag",
		type: {
			name: "Composite",
			className: "BlobTag",
			modelProperties: {
				key: {
					serializedName: "Key",
					required: true,
					xmlName: "Key",
					type: { name: "String" }
				},
				value: {
					serializedName: "Value",
					required: true,
					xmlName: "Value",
					type: { name: "String" }
				}
			}
		}
	};
	exports.SignedIdentifier = {
		serializedName: "SignedIdentifier",
		xmlName: "SignedIdentifier",
		type: {
			name: "Composite",
			className: "SignedIdentifier",
			modelProperties: {
				id: {
					serializedName: "Id",
					required: true,
					xmlName: "Id",
					type: { name: "String" }
				},
				accessPolicy: {
					serializedName: "AccessPolicy",
					xmlName: "AccessPolicy",
					type: {
						name: "Composite",
						className: "AccessPolicy"
					}
				}
			}
		}
	};
	exports.AccessPolicy = {
		serializedName: "AccessPolicy",
		type: {
			name: "Composite",
			className: "AccessPolicy",
			modelProperties: {
				startsOn: {
					serializedName: "Start",
					xmlName: "Start",
					type: { name: "String" }
				},
				expiresOn: {
					serializedName: "Expiry",
					xmlName: "Expiry",
					type: { name: "String" }
				},
				permissions: {
					serializedName: "Permission",
					xmlName: "Permission",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ListBlobsFlatSegmentResponse = {
		serializedName: "ListBlobsFlatSegmentResponse",
		xmlName: "EnumerationResults",
		type: {
			name: "Composite",
			className: "ListBlobsFlatSegmentResponse",
			modelProperties: {
				serviceEndpoint: {
					serializedName: "ServiceEndpoint",
					required: true,
					xmlName: "ServiceEndpoint",
					xmlIsAttribute: true,
					type: { name: "String" }
				},
				containerName: {
					serializedName: "ContainerName",
					required: true,
					xmlName: "ContainerName",
					xmlIsAttribute: true,
					type: { name: "String" }
				},
				prefix: {
					serializedName: "Prefix",
					xmlName: "Prefix",
					type: { name: "String" }
				},
				marker: {
					serializedName: "Marker",
					xmlName: "Marker",
					type: { name: "String" }
				},
				maxPageSize: {
					serializedName: "MaxResults",
					xmlName: "MaxResults",
					type: { name: "Number" }
				},
				segment: {
					serializedName: "Segment",
					xmlName: "Blobs",
					type: {
						name: "Composite",
						className: "BlobFlatListSegment"
					}
				},
				continuationToken: {
					serializedName: "NextMarker",
					xmlName: "NextMarker",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobFlatListSegment = {
		serializedName: "BlobFlatListSegment",
		xmlName: "Blobs",
		type: {
			name: "Composite",
			className: "BlobFlatListSegment",
			modelProperties: { blobItems: {
				serializedName: "BlobItems",
				required: true,
				xmlName: "BlobItems",
				xmlElementName: "Blob",
				type: {
					name: "Sequence",
					element: { type: {
						name: "Composite",
						className: "BlobItemInternal"
					} }
				}
			} }
		}
	};
	exports.BlobItemInternal = {
		serializedName: "BlobItemInternal",
		xmlName: "Blob",
		type: {
			name: "Composite",
			className: "BlobItemInternal",
			modelProperties: {
				name: {
					serializedName: "Name",
					xmlName: "Name",
					type: {
						name: "Composite",
						className: "BlobName"
					}
				},
				deleted: {
					serializedName: "Deleted",
					required: true,
					xmlName: "Deleted",
					type: { name: "Boolean" }
				},
				snapshot: {
					serializedName: "Snapshot",
					required: true,
					xmlName: "Snapshot",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "VersionId",
					xmlName: "VersionId",
					type: { name: "String" }
				},
				isCurrentVersion: {
					serializedName: "IsCurrentVersion",
					xmlName: "IsCurrentVersion",
					type: { name: "Boolean" }
				},
				properties: {
					serializedName: "Properties",
					xmlName: "Properties",
					type: {
						name: "Composite",
						className: "BlobPropertiesInternal"
					}
				},
				metadata: {
					serializedName: "Metadata",
					xmlName: "Metadata",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				},
				blobTags: {
					serializedName: "BlobTags",
					xmlName: "Tags",
					type: {
						name: "Composite",
						className: "BlobTags"
					}
				},
				objectReplicationMetadata: {
					serializedName: "ObjectReplicationMetadata",
					xmlName: "OrMetadata",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				},
				hasVersionsOnly: {
					serializedName: "HasVersionsOnly",
					xmlName: "HasVersionsOnly",
					type: { name: "Boolean" }
				}
			}
		}
	};
	exports.BlobName = {
		serializedName: "BlobName",
		type: {
			name: "Composite",
			className: "BlobName",
			modelProperties: {
				encoded: {
					serializedName: "Encoded",
					xmlName: "Encoded",
					xmlIsAttribute: true,
					type: { name: "Boolean" }
				},
				content: {
					serializedName: "content",
					xmlName: "content",
					xmlIsMsText: true,
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobPropertiesInternal = {
		serializedName: "BlobPropertiesInternal",
		xmlName: "Properties",
		type: {
			name: "Composite",
			className: "BlobPropertiesInternal",
			modelProperties: {
				createdOn: {
					serializedName: "Creation-Time",
					xmlName: "Creation-Time",
					type: { name: "DateTimeRfc1123" }
				},
				lastModified: {
					serializedName: "Last-Modified",
					required: true,
					xmlName: "Last-Modified",
					type: { name: "DateTimeRfc1123" }
				},
				etag: {
					serializedName: "Etag",
					required: true,
					xmlName: "Etag",
					type: { name: "String" }
				},
				contentLength: {
					serializedName: "Content-Length",
					xmlName: "Content-Length",
					type: { name: "Number" }
				},
				contentType: {
					serializedName: "Content-Type",
					xmlName: "Content-Type",
					type: { name: "String" }
				},
				contentEncoding: {
					serializedName: "Content-Encoding",
					xmlName: "Content-Encoding",
					type: { name: "String" }
				},
				contentLanguage: {
					serializedName: "Content-Language",
					xmlName: "Content-Language",
					type: { name: "String" }
				},
				contentMD5: {
					serializedName: "Content-MD5",
					xmlName: "Content-MD5",
					type: { name: "ByteArray" }
				},
				contentDisposition: {
					serializedName: "Content-Disposition",
					xmlName: "Content-Disposition",
					type: { name: "String" }
				},
				cacheControl: {
					serializedName: "Cache-Control",
					xmlName: "Cache-Control",
					type: { name: "String" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				blobType: {
					serializedName: "BlobType",
					xmlName: "BlobType",
					type: {
						name: "Enum",
						allowedValues: [
							"BlockBlob",
							"PageBlob",
							"AppendBlob"
						]
					}
				},
				leaseStatus: {
					serializedName: "LeaseStatus",
					xmlName: "LeaseStatus",
					type: {
						name: "Enum",
						allowedValues: ["locked", "unlocked"]
					}
				},
				leaseState: {
					serializedName: "LeaseState",
					xmlName: "LeaseState",
					type: {
						name: "Enum",
						allowedValues: [
							"available",
							"leased",
							"expired",
							"breaking",
							"broken"
						]
					}
				},
				leaseDuration: {
					serializedName: "LeaseDuration",
					xmlName: "LeaseDuration",
					type: {
						name: "Enum",
						allowedValues: ["infinite", "fixed"]
					}
				},
				copyId: {
					serializedName: "CopyId",
					xmlName: "CopyId",
					type: { name: "String" }
				},
				copyStatus: {
					serializedName: "CopyStatus",
					xmlName: "CopyStatus",
					type: {
						name: "Enum",
						allowedValues: [
							"pending",
							"success",
							"aborted",
							"failed"
						]
					}
				},
				copySource: {
					serializedName: "CopySource",
					xmlName: "CopySource",
					type: { name: "String" }
				},
				copyProgress: {
					serializedName: "CopyProgress",
					xmlName: "CopyProgress",
					type: { name: "String" }
				},
				copyCompletedOn: {
					serializedName: "CopyCompletionTime",
					xmlName: "CopyCompletionTime",
					type: { name: "DateTimeRfc1123" }
				},
				copyStatusDescription: {
					serializedName: "CopyStatusDescription",
					xmlName: "CopyStatusDescription",
					type: { name: "String" }
				},
				serverEncrypted: {
					serializedName: "ServerEncrypted",
					xmlName: "ServerEncrypted",
					type: { name: "Boolean" }
				},
				incrementalCopy: {
					serializedName: "IncrementalCopy",
					xmlName: "IncrementalCopy",
					type: { name: "Boolean" }
				},
				destinationSnapshot: {
					serializedName: "DestinationSnapshot",
					xmlName: "DestinationSnapshot",
					type: { name: "String" }
				},
				deletedOn: {
					serializedName: "DeletedTime",
					xmlName: "DeletedTime",
					type: { name: "DateTimeRfc1123" }
				},
				remainingRetentionDays: {
					serializedName: "RemainingRetentionDays",
					xmlName: "RemainingRetentionDays",
					type: { name: "Number" }
				},
				accessTier: {
					serializedName: "AccessTier",
					xmlName: "AccessTier",
					type: {
						name: "Enum",
						allowedValues: [
							"P4",
							"P6",
							"P10",
							"P15",
							"P20",
							"P30",
							"P40",
							"P50",
							"P60",
							"P70",
							"P80",
							"Hot",
							"Cool",
							"Archive",
							"Cold"
						]
					}
				},
				accessTierInferred: {
					serializedName: "AccessTierInferred",
					xmlName: "AccessTierInferred",
					type: { name: "Boolean" }
				},
				archiveStatus: {
					serializedName: "ArchiveStatus",
					xmlName: "ArchiveStatus",
					type: {
						name: "Enum",
						allowedValues: [
							"rehydrate-pending-to-hot",
							"rehydrate-pending-to-cool",
							"rehydrate-pending-to-cold"
						]
					}
				},
				customerProvidedKeySha256: {
					serializedName: "CustomerProvidedKeySha256",
					xmlName: "CustomerProvidedKeySha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "EncryptionScope",
					xmlName: "EncryptionScope",
					type: { name: "String" }
				},
				accessTierChangedOn: {
					serializedName: "AccessTierChangeTime",
					xmlName: "AccessTierChangeTime",
					type: { name: "DateTimeRfc1123" }
				},
				tagCount: {
					serializedName: "TagCount",
					xmlName: "TagCount",
					type: { name: "Number" }
				},
				expiresOn: {
					serializedName: "Expiry-Time",
					xmlName: "Expiry-Time",
					type: { name: "DateTimeRfc1123" }
				},
				isSealed: {
					serializedName: "Sealed",
					xmlName: "Sealed",
					type: { name: "Boolean" }
				},
				rehydratePriority: {
					serializedName: "RehydratePriority",
					xmlName: "RehydratePriority",
					type: {
						name: "Enum",
						allowedValues: ["High", "Standard"]
					}
				},
				lastAccessedOn: {
					serializedName: "LastAccessTime",
					xmlName: "LastAccessTime",
					type: { name: "DateTimeRfc1123" }
				},
				immutabilityPolicyExpiresOn: {
					serializedName: "ImmutabilityPolicyUntilDate",
					xmlName: "ImmutabilityPolicyUntilDate",
					type: { name: "DateTimeRfc1123" }
				},
				immutabilityPolicyMode: {
					serializedName: "ImmutabilityPolicyMode",
					xmlName: "ImmutabilityPolicyMode",
					type: {
						name: "Enum",
						allowedValues: [
							"Mutable",
							"Unlocked",
							"Locked"
						]
					}
				},
				legalHold: {
					serializedName: "LegalHold",
					xmlName: "LegalHold",
					type: { name: "Boolean" }
				}
			}
		}
	};
	exports.ListBlobsHierarchySegmentResponse = {
		serializedName: "ListBlobsHierarchySegmentResponse",
		xmlName: "EnumerationResults",
		type: {
			name: "Composite",
			className: "ListBlobsHierarchySegmentResponse",
			modelProperties: {
				serviceEndpoint: {
					serializedName: "ServiceEndpoint",
					required: true,
					xmlName: "ServiceEndpoint",
					xmlIsAttribute: true,
					type: { name: "String" }
				},
				containerName: {
					serializedName: "ContainerName",
					required: true,
					xmlName: "ContainerName",
					xmlIsAttribute: true,
					type: { name: "String" }
				},
				prefix: {
					serializedName: "Prefix",
					xmlName: "Prefix",
					type: { name: "String" }
				},
				marker: {
					serializedName: "Marker",
					xmlName: "Marker",
					type: { name: "String" }
				},
				maxPageSize: {
					serializedName: "MaxResults",
					xmlName: "MaxResults",
					type: { name: "Number" }
				},
				delimiter: {
					serializedName: "Delimiter",
					xmlName: "Delimiter",
					type: { name: "String" }
				},
				segment: {
					serializedName: "Segment",
					xmlName: "Blobs",
					type: {
						name: "Composite",
						className: "BlobHierarchyListSegment"
					}
				},
				continuationToken: {
					serializedName: "NextMarker",
					xmlName: "NextMarker",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobHierarchyListSegment = {
		serializedName: "BlobHierarchyListSegment",
		xmlName: "Blobs",
		type: {
			name: "Composite",
			className: "BlobHierarchyListSegment",
			modelProperties: {
				blobPrefixes: {
					serializedName: "BlobPrefixes",
					xmlName: "BlobPrefixes",
					xmlElementName: "BlobPrefix",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "BlobPrefix"
						} }
					}
				},
				blobItems: {
					serializedName: "BlobItems",
					required: true,
					xmlName: "BlobItems",
					xmlElementName: "Blob",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "BlobItemInternal"
						} }
					}
				}
			}
		}
	};
	exports.BlobPrefix = {
		serializedName: "BlobPrefix",
		type: {
			name: "Composite",
			className: "BlobPrefix",
			modelProperties: { name: {
				serializedName: "Name",
				xmlName: "Name",
				type: {
					name: "Composite",
					className: "BlobName"
				}
			} }
		}
	};
	exports.BlockLookupList = {
		serializedName: "BlockLookupList",
		xmlName: "BlockList",
		type: {
			name: "Composite",
			className: "BlockLookupList",
			modelProperties: {
				committed: {
					serializedName: "Committed",
					xmlName: "Committed",
					xmlElementName: "Committed",
					type: {
						name: "Sequence",
						element: { type: { name: "String" } }
					}
				},
				uncommitted: {
					serializedName: "Uncommitted",
					xmlName: "Uncommitted",
					xmlElementName: "Uncommitted",
					type: {
						name: "Sequence",
						element: { type: { name: "String" } }
					}
				},
				latest: {
					serializedName: "Latest",
					xmlName: "Latest",
					xmlElementName: "Latest",
					type: {
						name: "Sequence",
						element: { type: { name: "String" } }
					}
				}
			}
		}
	};
	exports.BlockList = {
		serializedName: "BlockList",
		type: {
			name: "Composite",
			className: "BlockList",
			modelProperties: {
				committedBlocks: {
					serializedName: "CommittedBlocks",
					xmlName: "CommittedBlocks",
					xmlIsWrapped: true,
					xmlElementName: "Block",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "Block"
						} }
					}
				},
				uncommittedBlocks: {
					serializedName: "UncommittedBlocks",
					xmlName: "UncommittedBlocks",
					xmlIsWrapped: true,
					xmlElementName: "Block",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "Block"
						} }
					}
				}
			}
		}
	};
	exports.Block = {
		serializedName: "Block",
		type: {
			name: "Composite",
			className: "Block",
			modelProperties: {
				name: {
					serializedName: "Name",
					required: true,
					xmlName: "Name",
					type: { name: "String" }
				},
				size: {
					serializedName: "Size",
					required: true,
					xmlName: "Size",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.PageList = {
		serializedName: "PageList",
		type: {
			name: "Composite",
			className: "PageList",
			modelProperties: {
				pageRange: {
					serializedName: "PageRange",
					xmlName: "PageRange",
					xmlElementName: "PageRange",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "PageRange"
						} }
					}
				},
				clearRange: {
					serializedName: "ClearRange",
					xmlName: "ClearRange",
					xmlElementName: "ClearRange",
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "ClearRange"
						} }
					}
				},
				continuationToken: {
					serializedName: "NextMarker",
					xmlName: "NextMarker",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageRange = {
		serializedName: "PageRange",
		xmlName: "PageRange",
		type: {
			name: "Composite",
			className: "PageRange",
			modelProperties: {
				start: {
					serializedName: "Start",
					required: true,
					xmlName: "Start",
					type: { name: "Number" }
				},
				end: {
					serializedName: "End",
					required: true,
					xmlName: "End",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.ClearRange = {
		serializedName: "ClearRange",
		xmlName: "ClearRange",
		type: {
			name: "Composite",
			className: "ClearRange",
			modelProperties: {
				start: {
					serializedName: "Start",
					required: true,
					xmlName: "Start",
					type: { name: "Number" }
				},
				end: {
					serializedName: "End",
					required: true,
					xmlName: "End",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.QueryRequest = {
		serializedName: "QueryRequest",
		xmlName: "QueryRequest",
		type: {
			name: "Composite",
			className: "QueryRequest",
			modelProperties: {
				queryType: {
					serializedName: "QueryType",
					required: true,
					xmlName: "QueryType",
					type: { name: "String" }
				},
				expression: {
					serializedName: "Expression",
					required: true,
					xmlName: "Expression",
					type: { name: "String" }
				},
				inputSerialization: {
					serializedName: "InputSerialization",
					xmlName: "InputSerialization",
					type: {
						name: "Composite",
						className: "QuerySerialization"
					}
				},
				outputSerialization: {
					serializedName: "OutputSerialization",
					xmlName: "OutputSerialization",
					type: {
						name: "Composite",
						className: "QuerySerialization"
					}
				}
			}
		}
	};
	exports.QuerySerialization = {
		serializedName: "QuerySerialization",
		type: {
			name: "Composite",
			className: "QuerySerialization",
			modelProperties: { format: {
				serializedName: "Format",
				xmlName: "Format",
				type: {
					name: "Composite",
					className: "QueryFormat"
				}
			} }
		}
	};
	exports.QueryFormat = {
		serializedName: "QueryFormat",
		type: {
			name: "Composite",
			className: "QueryFormat",
			modelProperties: {
				type: {
					serializedName: "Type",
					required: true,
					xmlName: "Type",
					type: {
						name: "Enum",
						allowedValues: [
							"delimited",
							"json",
							"arrow",
							"parquet"
						]
					}
				},
				delimitedTextConfiguration: {
					serializedName: "DelimitedTextConfiguration",
					xmlName: "DelimitedTextConfiguration",
					type: {
						name: "Composite",
						className: "DelimitedTextConfiguration"
					}
				},
				jsonTextConfiguration: {
					serializedName: "JsonTextConfiguration",
					xmlName: "JsonTextConfiguration",
					type: {
						name: "Composite",
						className: "JsonTextConfiguration"
					}
				},
				arrowConfiguration: {
					serializedName: "ArrowConfiguration",
					xmlName: "ArrowConfiguration",
					type: {
						name: "Composite",
						className: "ArrowConfiguration"
					}
				},
				parquetTextConfiguration: {
					serializedName: "ParquetTextConfiguration",
					xmlName: "ParquetTextConfiguration",
					type: {
						name: "Dictionary",
						value: { type: { name: "any" } }
					}
				}
			}
		}
	};
	exports.DelimitedTextConfiguration = {
		serializedName: "DelimitedTextConfiguration",
		xmlName: "DelimitedTextConfiguration",
		type: {
			name: "Composite",
			className: "DelimitedTextConfiguration",
			modelProperties: {
				columnSeparator: {
					serializedName: "ColumnSeparator",
					xmlName: "ColumnSeparator",
					type: { name: "String" }
				},
				fieldQuote: {
					serializedName: "FieldQuote",
					xmlName: "FieldQuote",
					type: { name: "String" }
				},
				recordSeparator: {
					serializedName: "RecordSeparator",
					xmlName: "RecordSeparator",
					type: { name: "String" }
				},
				escapeChar: {
					serializedName: "EscapeChar",
					xmlName: "EscapeChar",
					type: { name: "String" }
				},
				headersPresent: {
					serializedName: "HeadersPresent",
					xmlName: "HasHeaders",
					type: { name: "Boolean" }
				}
			}
		}
	};
	exports.JsonTextConfiguration = {
		serializedName: "JsonTextConfiguration",
		xmlName: "JsonTextConfiguration",
		type: {
			name: "Composite",
			className: "JsonTextConfiguration",
			modelProperties: { recordSeparator: {
				serializedName: "RecordSeparator",
				xmlName: "RecordSeparator",
				type: { name: "String" }
			} }
		}
	};
	exports.ArrowConfiguration = {
		serializedName: "ArrowConfiguration",
		xmlName: "ArrowConfiguration",
		type: {
			name: "Composite",
			className: "ArrowConfiguration",
			modelProperties: { schema: {
				serializedName: "Schema",
				required: true,
				xmlName: "Schema",
				xmlIsWrapped: true,
				xmlElementName: "Field",
				type: {
					name: "Sequence",
					element: { type: {
						name: "Composite",
						className: "ArrowField"
					} }
				}
			} }
		}
	};
	exports.ArrowField = {
		serializedName: "ArrowField",
		xmlName: "Field",
		type: {
			name: "Composite",
			className: "ArrowField",
			modelProperties: {
				type: {
					serializedName: "Type",
					required: true,
					xmlName: "Type",
					type: { name: "String" }
				},
				name: {
					serializedName: "Name",
					xmlName: "Name",
					type: { name: "String" }
				},
				precision: {
					serializedName: "Precision",
					xmlName: "Precision",
					type: { name: "Number" }
				},
				scale: {
					serializedName: "Scale",
					xmlName: "Scale",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.ServiceSetPropertiesHeaders = {
		serializedName: "Service_setPropertiesHeaders",
		type: {
			name: "Composite",
			className: "ServiceSetPropertiesHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ServiceSetPropertiesExceptionHeaders = {
		serializedName: "Service_setPropertiesExceptionHeaders",
		type: {
			name: "Composite",
			className: "ServiceSetPropertiesExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ServiceGetPropertiesHeaders = {
		serializedName: "Service_getPropertiesHeaders",
		type: {
			name: "Composite",
			className: "ServiceGetPropertiesHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ServiceGetPropertiesExceptionHeaders = {
		serializedName: "Service_getPropertiesExceptionHeaders",
		type: {
			name: "Composite",
			className: "ServiceGetPropertiesExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ServiceGetStatisticsHeaders = {
		serializedName: "Service_getStatisticsHeaders",
		type: {
			name: "Composite",
			className: "ServiceGetStatisticsHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ServiceGetStatisticsExceptionHeaders = {
		serializedName: "Service_getStatisticsExceptionHeaders",
		type: {
			name: "Composite",
			className: "ServiceGetStatisticsExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ServiceListContainersSegmentHeaders = {
		serializedName: "Service_listContainersSegmentHeaders",
		type: {
			name: "Composite",
			className: "ServiceListContainersSegmentHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ServiceListContainersSegmentExceptionHeaders = {
		serializedName: "Service_listContainersSegmentExceptionHeaders",
		type: {
			name: "Composite",
			className: "ServiceListContainersSegmentExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ServiceGetUserDelegationKeyHeaders = {
		serializedName: "Service_getUserDelegationKeyHeaders",
		type: {
			name: "Composite",
			className: "ServiceGetUserDelegationKeyHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ServiceGetUserDelegationKeyExceptionHeaders = {
		serializedName: "Service_getUserDelegationKeyExceptionHeaders",
		type: {
			name: "Composite",
			className: "ServiceGetUserDelegationKeyExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ServiceGetAccountInfoHeaders = {
		serializedName: "Service_getAccountInfoHeaders",
		type: {
			name: "Composite",
			className: "ServiceGetAccountInfoHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				skuName: {
					serializedName: "x-ms-sku-name",
					xmlName: "x-ms-sku-name",
					type: {
						name: "Enum",
						allowedValues: [
							"Standard_LRS",
							"Standard_GRS",
							"Standard_RAGRS",
							"Standard_ZRS",
							"Premium_LRS"
						]
					}
				},
				accountKind: {
					serializedName: "x-ms-account-kind",
					xmlName: "x-ms-account-kind",
					type: {
						name: "Enum",
						allowedValues: [
							"Storage",
							"BlobStorage",
							"StorageV2",
							"FileStorage",
							"BlockBlobStorage"
						]
					}
				},
				isHierarchicalNamespaceEnabled: {
					serializedName: "x-ms-is-hns-enabled",
					xmlName: "x-ms-is-hns-enabled",
					type: { name: "Boolean" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ServiceGetAccountInfoExceptionHeaders = {
		serializedName: "Service_getAccountInfoExceptionHeaders",
		type: {
			name: "Composite",
			className: "ServiceGetAccountInfoExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ServiceSubmitBatchHeaders = {
		serializedName: "Service_submitBatchHeaders",
		type: {
			name: "Composite",
			className: "ServiceSubmitBatchHeaders",
			modelProperties: {
				contentType: {
					serializedName: "content-type",
					xmlName: "content-type",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ServiceSubmitBatchExceptionHeaders = {
		serializedName: "Service_submitBatchExceptionHeaders",
		type: {
			name: "Composite",
			className: "ServiceSubmitBatchExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ServiceFilterBlobsHeaders = {
		serializedName: "Service_filterBlobsHeaders",
		type: {
			name: "Composite",
			className: "ServiceFilterBlobsHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ServiceFilterBlobsExceptionHeaders = {
		serializedName: "Service_filterBlobsExceptionHeaders",
		type: {
			name: "Composite",
			className: "ServiceFilterBlobsExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerCreateHeaders = {
		serializedName: "Container_createHeaders",
		type: {
			name: "Composite",
			className: "ContainerCreateHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerCreateExceptionHeaders = {
		serializedName: "Container_createExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerCreateExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerGetPropertiesHeaders = {
		serializedName: "Container_getPropertiesHeaders",
		type: {
			name: "Composite",
			className: "ContainerGetPropertiesHeaders",
			modelProperties: {
				metadata: {
					serializedName: "x-ms-meta",
					headerCollectionPrefix: "x-ms-meta-",
					xmlName: "x-ms-meta",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				leaseDuration: {
					serializedName: "x-ms-lease-duration",
					xmlName: "x-ms-lease-duration",
					type: {
						name: "Enum",
						allowedValues: ["infinite", "fixed"]
					}
				},
				leaseState: {
					serializedName: "x-ms-lease-state",
					xmlName: "x-ms-lease-state",
					type: {
						name: "Enum",
						allowedValues: [
							"available",
							"leased",
							"expired",
							"breaking",
							"broken"
						]
					}
				},
				leaseStatus: {
					serializedName: "x-ms-lease-status",
					xmlName: "x-ms-lease-status",
					type: {
						name: "Enum",
						allowedValues: ["locked", "unlocked"]
					}
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				blobPublicAccess: {
					serializedName: "x-ms-blob-public-access",
					xmlName: "x-ms-blob-public-access",
					type: {
						name: "Enum",
						allowedValues: ["container", "blob"]
					}
				},
				hasImmutabilityPolicy: {
					serializedName: "x-ms-has-immutability-policy",
					xmlName: "x-ms-has-immutability-policy",
					type: { name: "Boolean" }
				},
				hasLegalHold: {
					serializedName: "x-ms-has-legal-hold",
					xmlName: "x-ms-has-legal-hold",
					type: { name: "Boolean" }
				},
				defaultEncryptionScope: {
					serializedName: "x-ms-default-encryption-scope",
					xmlName: "x-ms-default-encryption-scope",
					type: { name: "String" }
				},
				denyEncryptionScopeOverride: {
					serializedName: "x-ms-deny-encryption-scope-override",
					xmlName: "x-ms-deny-encryption-scope-override",
					type: { name: "Boolean" }
				},
				isImmutableStorageWithVersioningEnabled: {
					serializedName: "x-ms-immutable-storage-with-versioning-enabled",
					xmlName: "x-ms-immutable-storage-with-versioning-enabled",
					type: { name: "Boolean" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerGetPropertiesExceptionHeaders = {
		serializedName: "Container_getPropertiesExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerGetPropertiesExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerDeleteHeaders = {
		serializedName: "Container_deleteHeaders",
		type: {
			name: "Composite",
			className: "ContainerDeleteHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerDeleteExceptionHeaders = {
		serializedName: "Container_deleteExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerDeleteExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerSetMetadataHeaders = {
		serializedName: "Container_setMetadataHeaders",
		type: {
			name: "Composite",
			className: "ContainerSetMetadataHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerSetMetadataExceptionHeaders = {
		serializedName: "Container_setMetadataExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerSetMetadataExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerGetAccessPolicyHeaders = {
		serializedName: "Container_getAccessPolicyHeaders",
		type: {
			name: "Composite",
			className: "ContainerGetAccessPolicyHeaders",
			modelProperties: {
				blobPublicAccess: {
					serializedName: "x-ms-blob-public-access",
					xmlName: "x-ms-blob-public-access",
					type: {
						name: "Enum",
						allowedValues: ["container", "blob"]
					}
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerGetAccessPolicyExceptionHeaders = {
		serializedName: "Container_getAccessPolicyExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerGetAccessPolicyExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerSetAccessPolicyHeaders = {
		serializedName: "Container_setAccessPolicyHeaders",
		type: {
			name: "Composite",
			className: "ContainerSetAccessPolicyHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerSetAccessPolicyExceptionHeaders = {
		serializedName: "Container_setAccessPolicyExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerSetAccessPolicyExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerRestoreHeaders = {
		serializedName: "Container_restoreHeaders",
		type: {
			name: "Composite",
			className: "ContainerRestoreHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerRestoreExceptionHeaders = {
		serializedName: "Container_restoreExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerRestoreExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerRenameHeaders = {
		serializedName: "Container_renameHeaders",
		type: {
			name: "Composite",
			className: "ContainerRenameHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerRenameExceptionHeaders = {
		serializedName: "Container_renameExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerRenameExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerSubmitBatchHeaders = {
		serializedName: "Container_submitBatchHeaders",
		type: {
			name: "Composite",
			className: "ContainerSubmitBatchHeaders",
			modelProperties: {
				contentType: {
					serializedName: "content-type",
					xmlName: "content-type",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerSubmitBatchExceptionHeaders = {
		serializedName: "Container_submitBatchExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerSubmitBatchExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerFilterBlobsHeaders = {
		serializedName: "Container_filterBlobsHeaders",
		type: {
			name: "Composite",
			className: "ContainerFilterBlobsHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.ContainerFilterBlobsExceptionHeaders = {
		serializedName: "Container_filterBlobsExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerFilterBlobsExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerAcquireLeaseHeaders = {
		serializedName: "Container_acquireLeaseHeaders",
		type: {
			name: "Composite",
			className: "ContainerAcquireLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				leaseId: {
					serializedName: "x-ms-lease-id",
					xmlName: "x-ms-lease-id",
					type: { name: "String" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.ContainerAcquireLeaseExceptionHeaders = {
		serializedName: "Container_acquireLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerAcquireLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerReleaseLeaseHeaders = {
		serializedName: "Container_releaseLeaseHeaders",
		type: {
			name: "Composite",
			className: "ContainerReleaseLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.ContainerReleaseLeaseExceptionHeaders = {
		serializedName: "Container_releaseLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerReleaseLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerRenewLeaseHeaders = {
		serializedName: "Container_renewLeaseHeaders",
		type: {
			name: "Composite",
			className: "ContainerRenewLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				leaseId: {
					serializedName: "x-ms-lease-id",
					xmlName: "x-ms-lease-id",
					type: { name: "String" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.ContainerRenewLeaseExceptionHeaders = {
		serializedName: "Container_renewLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerRenewLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerBreakLeaseHeaders = {
		serializedName: "Container_breakLeaseHeaders",
		type: {
			name: "Composite",
			className: "ContainerBreakLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				leaseTime: {
					serializedName: "x-ms-lease-time",
					xmlName: "x-ms-lease-time",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.ContainerBreakLeaseExceptionHeaders = {
		serializedName: "Container_breakLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerBreakLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerChangeLeaseHeaders = {
		serializedName: "Container_changeLeaseHeaders",
		type: {
			name: "Composite",
			className: "ContainerChangeLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				leaseId: {
					serializedName: "x-ms-lease-id",
					xmlName: "x-ms-lease-id",
					type: { name: "String" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.ContainerChangeLeaseExceptionHeaders = {
		serializedName: "Container_changeLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerChangeLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerListBlobFlatSegmentHeaders = {
		serializedName: "Container_listBlobFlatSegmentHeaders",
		type: {
			name: "Composite",
			className: "ContainerListBlobFlatSegmentHeaders",
			modelProperties: {
				contentType: {
					serializedName: "content-type",
					xmlName: "content-type",
					type: { name: "String" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerListBlobFlatSegmentExceptionHeaders = {
		serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerListBlobFlatSegmentExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerListBlobHierarchySegmentHeaders = {
		serializedName: "Container_listBlobHierarchySegmentHeaders",
		type: {
			name: "Composite",
			className: "ContainerListBlobHierarchySegmentHeaders",
			modelProperties: {
				contentType: {
					serializedName: "content-type",
					xmlName: "content-type",
					type: { name: "String" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.ContainerListBlobHierarchySegmentExceptionHeaders = {
		serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerListBlobHierarchySegmentExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.ContainerGetAccountInfoHeaders = {
		serializedName: "Container_getAccountInfoHeaders",
		type: {
			name: "Composite",
			className: "ContainerGetAccountInfoHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				skuName: {
					serializedName: "x-ms-sku-name",
					xmlName: "x-ms-sku-name",
					type: {
						name: "Enum",
						allowedValues: [
							"Standard_LRS",
							"Standard_GRS",
							"Standard_RAGRS",
							"Standard_ZRS",
							"Premium_LRS"
						]
					}
				},
				accountKind: {
					serializedName: "x-ms-account-kind",
					xmlName: "x-ms-account-kind",
					type: {
						name: "Enum",
						allowedValues: [
							"Storage",
							"BlobStorage",
							"StorageV2",
							"FileStorage",
							"BlockBlobStorage"
						]
					}
				},
				isHierarchicalNamespaceEnabled: {
					serializedName: "x-ms-is-hns-enabled",
					xmlName: "x-ms-is-hns-enabled",
					type: { name: "Boolean" }
				}
			}
		}
	};
	exports.ContainerGetAccountInfoExceptionHeaders = {
		serializedName: "Container_getAccountInfoExceptionHeaders",
		type: {
			name: "Composite",
			className: "ContainerGetAccountInfoExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobDownloadHeaders = {
		serializedName: "Blob_downloadHeaders",
		type: {
			name: "Composite",
			className: "BlobDownloadHeaders",
			modelProperties: {
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				createdOn: {
					serializedName: "x-ms-creation-time",
					xmlName: "x-ms-creation-time",
					type: { name: "DateTimeRfc1123" }
				},
				metadata: {
					serializedName: "x-ms-meta",
					headerCollectionPrefix: "x-ms-meta-",
					xmlName: "x-ms-meta",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				},
				objectReplicationPolicyId: {
					serializedName: "x-ms-or-policy-id",
					xmlName: "x-ms-or-policy-id",
					type: { name: "String" }
				},
				objectReplicationRules: {
					serializedName: "x-ms-or",
					headerCollectionPrefix: "x-ms-or-",
					xmlName: "x-ms-or",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				},
				contentLength: {
					serializedName: "content-length",
					xmlName: "content-length",
					type: { name: "Number" }
				},
				contentType: {
					serializedName: "content-type",
					xmlName: "content-type",
					type: { name: "String" }
				},
				contentRange: {
					serializedName: "content-range",
					xmlName: "content-range",
					type: { name: "String" }
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				contentEncoding: {
					serializedName: "content-encoding",
					xmlName: "content-encoding",
					type: { name: "String" }
				},
				cacheControl: {
					serializedName: "cache-control",
					xmlName: "cache-control",
					type: { name: "String" }
				},
				contentDisposition: {
					serializedName: "content-disposition",
					xmlName: "content-disposition",
					type: { name: "String" }
				},
				contentLanguage: {
					serializedName: "content-language",
					xmlName: "content-language",
					type: { name: "String" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				blobType: {
					serializedName: "x-ms-blob-type",
					xmlName: "x-ms-blob-type",
					type: {
						name: "Enum",
						allowedValues: [
							"BlockBlob",
							"PageBlob",
							"AppendBlob"
						]
					}
				},
				copyCompletedOn: {
					serializedName: "x-ms-copy-completion-time",
					xmlName: "x-ms-copy-completion-time",
					type: { name: "DateTimeRfc1123" }
				},
				copyStatusDescription: {
					serializedName: "x-ms-copy-status-description",
					xmlName: "x-ms-copy-status-description",
					type: { name: "String" }
				},
				copyId: {
					serializedName: "x-ms-copy-id",
					xmlName: "x-ms-copy-id",
					type: { name: "String" }
				},
				copyProgress: {
					serializedName: "x-ms-copy-progress",
					xmlName: "x-ms-copy-progress",
					type: { name: "String" }
				},
				copySource: {
					serializedName: "x-ms-copy-source",
					xmlName: "x-ms-copy-source",
					type: { name: "String" }
				},
				copyStatus: {
					serializedName: "x-ms-copy-status",
					xmlName: "x-ms-copy-status",
					type: {
						name: "Enum",
						allowedValues: [
							"pending",
							"success",
							"aborted",
							"failed"
						]
					}
				},
				leaseDuration: {
					serializedName: "x-ms-lease-duration",
					xmlName: "x-ms-lease-duration",
					type: {
						name: "Enum",
						allowedValues: ["infinite", "fixed"]
					}
				},
				leaseState: {
					serializedName: "x-ms-lease-state",
					xmlName: "x-ms-lease-state",
					type: {
						name: "Enum",
						allowedValues: [
							"available",
							"leased",
							"expired",
							"breaking",
							"broken"
						]
					}
				},
				leaseStatus: {
					serializedName: "x-ms-lease-status",
					xmlName: "x-ms-lease-status",
					type: {
						name: "Enum",
						allowedValues: ["locked", "unlocked"]
					}
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				isCurrentVersion: {
					serializedName: "x-ms-is-current-version",
					xmlName: "x-ms-is-current-version",
					type: { name: "Boolean" }
				},
				acceptRanges: {
					serializedName: "accept-ranges",
					xmlName: "accept-ranges",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				blobCommittedBlockCount: {
					serializedName: "x-ms-blob-committed-block-count",
					xmlName: "x-ms-blob-committed-block-count",
					type: { name: "Number" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-server-encrypted",
					xmlName: "x-ms-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				blobContentMD5: {
					serializedName: "x-ms-blob-content-md5",
					xmlName: "x-ms-blob-content-md5",
					type: { name: "ByteArray" }
				},
				tagCount: {
					serializedName: "x-ms-tag-count",
					xmlName: "x-ms-tag-count",
					type: { name: "Number" }
				},
				isSealed: {
					serializedName: "x-ms-blob-sealed",
					xmlName: "x-ms-blob-sealed",
					type: { name: "Boolean" }
				},
				lastAccessed: {
					serializedName: "x-ms-last-access-time",
					xmlName: "x-ms-last-access-time",
					type: { name: "DateTimeRfc1123" }
				},
				immutabilityPolicyExpiresOn: {
					serializedName: "x-ms-immutability-policy-until-date",
					xmlName: "x-ms-immutability-policy-until-date",
					type: { name: "DateTimeRfc1123" }
				},
				immutabilityPolicyMode: {
					serializedName: "x-ms-immutability-policy-mode",
					xmlName: "x-ms-immutability-policy-mode",
					type: {
						name: "Enum",
						allowedValues: [
							"Mutable",
							"Unlocked",
							"Locked"
						]
					}
				},
				legalHold: {
					serializedName: "x-ms-legal-hold",
					xmlName: "x-ms-legal-hold",
					type: { name: "Boolean" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				},
				contentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				}
			}
		}
	};
	exports.BlobDownloadExceptionHeaders = {
		serializedName: "Blob_downloadExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobDownloadExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobGetPropertiesHeaders = {
		serializedName: "Blob_getPropertiesHeaders",
		type: {
			name: "Composite",
			className: "BlobGetPropertiesHeaders",
			modelProperties: {
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				createdOn: {
					serializedName: "x-ms-creation-time",
					xmlName: "x-ms-creation-time",
					type: { name: "DateTimeRfc1123" }
				},
				metadata: {
					serializedName: "x-ms-meta",
					headerCollectionPrefix: "x-ms-meta-",
					xmlName: "x-ms-meta",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				},
				objectReplicationPolicyId: {
					serializedName: "x-ms-or-policy-id",
					xmlName: "x-ms-or-policy-id",
					type: { name: "String" }
				},
				objectReplicationRules: {
					serializedName: "x-ms-or",
					headerCollectionPrefix: "x-ms-or-",
					xmlName: "x-ms-or",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				},
				blobType: {
					serializedName: "x-ms-blob-type",
					xmlName: "x-ms-blob-type",
					type: {
						name: "Enum",
						allowedValues: [
							"BlockBlob",
							"PageBlob",
							"AppendBlob"
						]
					}
				},
				copyCompletedOn: {
					serializedName: "x-ms-copy-completion-time",
					xmlName: "x-ms-copy-completion-time",
					type: { name: "DateTimeRfc1123" }
				},
				copyStatusDescription: {
					serializedName: "x-ms-copy-status-description",
					xmlName: "x-ms-copy-status-description",
					type: { name: "String" }
				},
				copyId: {
					serializedName: "x-ms-copy-id",
					xmlName: "x-ms-copy-id",
					type: { name: "String" }
				},
				copyProgress: {
					serializedName: "x-ms-copy-progress",
					xmlName: "x-ms-copy-progress",
					type: { name: "String" }
				},
				copySource: {
					serializedName: "x-ms-copy-source",
					xmlName: "x-ms-copy-source",
					type: { name: "String" }
				},
				copyStatus: {
					serializedName: "x-ms-copy-status",
					xmlName: "x-ms-copy-status",
					type: {
						name: "Enum",
						allowedValues: [
							"pending",
							"success",
							"aborted",
							"failed"
						]
					}
				},
				isIncrementalCopy: {
					serializedName: "x-ms-incremental-copy",
					xmlName: "x-ms-incremental-copy",
					type: { name: "Boolean" }
				},
				destinationSnapshot: {
					serializedName: "x-ms-copy-destination-snapshot",
					xmlName: "x-ms-copy-destination-snapshot",
					type: { name: "String" }
				},
				leaseDuration: {
					serializedName: "x-ms-lease-duration",
					xmlName: "x-ms-lease-duration",
					type: {
						name: "Enum",
						allowedValues: ["infinite", "fixed"]
					}
				},
				leaseState: {
					serializedName: "x-ms-lease-state",
					xmlName: "x-ms-lease-state",
					type: {
						name: "Enum",
						allowedValues: [
							"available",
							"leased",
							"expired",
							"breaking",
							"broken"
						]
					}
				},
				leaseStatus: {
					serializedName: "x-ms-lease-status",
					xmlName: "x-ms-lease-status",
					type: {
						name: "Enum",
						allowedValues: ["locked", "unlocked"]
					}
				},
				contentLength: {
					serializedName: "content-length",
					xmlName: "content-length",
					type: { name: "Number" }
				},
				contentType: {
					serializedName: "content-type",
					xmlName: "content-type",
					type: { name: "String" }
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				contentEncoding: {
					serializedName: "content-encoding",
					xmlName: "content-encoding",
					type: { name: "String" }
				},
				contentDisposition: {
					serializedName: "content-disposition",
					xmlName: "content-disposition",
					type: { name: "String" }
				},
				contentLanguage: {
					serializedName: "content-language",
					xmlName: "content-language",
					type: { name: "String" }
				},
				cacheControl: {
					serializedName: "cache-control",
					xmlName: "cache-control",
					type: { name: "String" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				acceptRanges: {
					serializedName: "accept-ranges",
					xmlName: "accept-ranges",
					type: { name: "String" }
				},
				blobCommittedBlockCount: {
					serializedName: "x-ms-blob-committed-block-count",
					xmlName: "x-ms-blob-committed-block-count",
					type: { name: "Number" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-server-encrypted",
					xmlName: "x-ms-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				accessTier: {
					serializedName: "x-ms-access-tier",
					xmlName: "x-ms-access-tier",
					type: { name: "String" }
				},
				accessTierInferred: {
					serializedName: "x-ms-access-tier-inferred",
					xmlName: "x-ms-access-tier-inferred",
					type: { name: "Boolean" }
				},
				archiveStatus: {
					serializedName: "x-ms-archive-status",
					xmlName: "x-ms-archive-status",
					type: { name: "String" }
				},
				accessTierChangedOn: {
					serializedName: "x-ms-access-tier-change-time",
					xmlName: "x-ms-access-tier-change-time",
					type: { name: "DateTimeRfc1123" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				isCurrentVersion: {
					serializedName: "x-ms-is-current-version",
					xmlName: "x-ms-is-current-version",
					type: { name: "Boolean" }
				},
				tagCount: {
					serializedName: "x-ms-tag-count",
					xmlName: "x-ms-tag-count",
					type: { name: "Number" }
				},
				expiresOn: {
					serializedName: "x-ms-expiry-time",
					xmlName: "x-ms-expiry-time",
					type: { name: "DateTimeRfc1123" }
				},
				isSealed: {
					serializedName: "x-ms-blob-sealed",
					xmlName: "x-ms-blob-sealed",
					type: { name: "Boolean" }
				},
				rehydratePriority: {
					serializedName: "x-ms-rehydrate-priority",
					xmlName: "x-ms-rehydrate-priority",
					type: {
						name: "Enum",
						allowedValues: ["High", "Standard"]
					}
				},
				lastAccessed: {
					serializedName: "x-ms-last-access-time",
					xmlName: "x-ms-last-access-time",
					type: { name: "DateTimeRfc1123" }
				},
				immutabilityPolicyExpiresOn: {
					serializedName: "x-ms-immutability-policy-until-date",
					xmlName: "x-ms-immutability-policy-until-date",
					type: { name: "DateTimeRfc1123" }
				},
				immutabilityPolicyMode: {
					serializedName: "x-ms-immutability-policy-mode",
					xmlName: "x-ms-immutability-policy-mode",
					type: {
						name: "Enum",
						allowedValues: [
							"Mutable",
							"Unlocked",
							"Locked"
						]
					}
				},
				legalHold: {
					serializedName: "x-ms-legal-hold",
					xmlName: "x-ms-legal-hold",
					type: { name: "Boolean" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobGetPropertiesExceptionHeaders = {
		serializedName: "Blob_getPropertiesExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobGetPropertiesExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobDeleteHeaders = {
		serializedName: "Blob_deleteHeaders",
		type: {
			name: "Composite",
			className: "BlobDeleteHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobDeleteExceptionHeaders = {
		serializedName: "Blob_deleteExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobDeleteExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobUndeleteHeaders = {
		serializedName: "Blob_undeleteHeaders",
		type: {
			name: "Composite",
			className: "BlobUndeleteHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobUndeleteExceptionHeaders = {
		serializedName: "Blob_undeleteExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobUndeleteExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobSetExpiryHeaders = {
		serializedName: "Blob_setExpiryHeaders",
		type: {
			name: "Composite",
			className: "BlobSetExpiryHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.BlobSetExpiryExceptionHeaders = {
		serializedName: "Blob_setExpiryExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobSetExpiryExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobSetHttpHeadersHeaders = {
		serializedName: "Blob_setHttpHeadersHeaders",
		type: {
			name: "Composite",
			className: "BlobSetHttpHeadersHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobSetHttpHeadersExceptionHeaders = {
		serializedName: "Blob_setHttpHeadersExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobSetHttpHeadersExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobSetImmutabilityPolicyHeaders = {
		serializedName: "Blob_setImmutabilityPolicyHeaders",
		type: {
			name: "Composite",
			className: "BlobSetImmutabilityPolicyHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				immutabilityPolicyExpiry: {
					serializedName: "x-ms-immutability-policy-until-date",
					xmlName: "x-ms-immutability-policy-until-date",
					type: { name: "DateTimeRfc1123" }
				},
				immutabilityPolicyMode: {
					serializedName: "x-ms-immutability-policy-mode",
					xmlName: "x-ms-immutability-policy-mode",
					type: {
						name: "Enum",
						allowedValues: [
							"Mutable",
							"Unlocked",
							"Locked"
						]
					}
				}
			}
		}
	};
	exports.BlobSetImmutabilityPolicyExceptionHeaders = {
		serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobSetImmutabilityPolicyExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobDeleteImmutabilityPolicyHeaders = {
		serializedName: "Blob_deleteImmutabilityPolicyHeaders",
		type: {
			name: "Composite",
			className: "BlobDeleteImmutabilityPolicyHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.BlobDeleteImmutabilityPolicyExceptionHeaders = {
		serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobSetLegalHoldHeaders = {
		serializedName: "Blob_setLegalHoldHeaders",
		type: {
			name: "Composite",
			className: "BlobSetLegalHoldHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				legalHold: {
					serializedName: "x-ms-legal-hold",
					xmlName: "x-ms-legal-hold",
					type: { name: "Boolean" }
				}
			}
		}
	};
	exports.BlobSetLegalHoldExceptionHeaders = {
		serializedName: "Blob_setLegalHoldExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobSetLegalHoldExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobSetMetadataHeaders = {
		serializedName: "Blob_setMetadataHeaders",
		type: {
			name: "Composite",
			className: "BlobSetMetadataHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobSetMetadataExceptionHeaders = {
		serializedName: "Blob_setMetadataExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobSetMetadataExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobAcquireLeaseHeaders = {
		serializedName: "Blob_acquireLeaseHeaders",
		type: {
			name: "Composite",
			className: "BlobAcquireLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				leaseId: {
					serializedName: "x-ms-lease-id",
					xmlName: "x-ms-lease-id",
					type: { name: "String" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.BlobAcquireLeaseExceptionHeaders = {
		serializedName: "Blob_acquireLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobAcquireLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobReleaseLeaseHeaders = {
		serializedName: "Blob_releaseLeaseHeaders",
		type: {
			name: "Composite",
			className: "BlobReleaseLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.BlobReleaseLeaseExceptionHeaders = {
		serializedName: "Blob_releaseLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobReleaseLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobRenewLeaseHeaders = {
		serializedName: "Blob_renewLeaseHeaders",
		type: {
			name: "Composite",
			className: "BlobRenewLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				leaseId: {
					serializedName: "x-ms-lease-id",
					xmlName: "x-ms-lease-id",
					type: { name: "String" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.BlobRenewLeaseExceptionHeaders = {
		serializedName: "Blob_renewLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobRenewLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobChangeLeaseHeaders = {
		serializedName: "Blob_changeLeaseHeaders",
		type: {
			name: "Composite",
			className: "BlobChangeLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				leaseId: {
					serializedName: "x-ms-lease-id",
					xmlName: "x-ms-lease-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.BlobChangeLeaseExceptionHeaders = {
		serializedName: "Blob_changeLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobChangeLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobBreakLeaseHeaders = {
		serializedName: "Blob_breakLeaseHeaders",
		type: {
			name: "Composite",
			className: "BlobBreakLeaseHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				leaseTime: {
					serializedName: "x-ms-lease-time",
					xmlName: "x-ms-lease-time",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				}
			}
		}
	};
	exports.BlobBreakLeaseExceptionHeaders = {
		serializedName: "Blob_breakLeaseExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobBreakLeaseExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobCreateSnapshotHeaders = {
		serializedName: "Blob_createSnapshotHeaders",
		type: {
			name: "Composite",
			className: "BlobCreateSnapshotHeaders",
			modelProperties: {
				snapshot: {
					serializedName: "x-ms-snapshot",
					xmlName: "x-ms-snapshot",
					type: { name: "String" }
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobCreateSnapshotExceptionHeaders = {
		serializedName: "Blob_createSnapshotExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobCreateSnapshotExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobStartCopyFromURLHeaders = {
		serializedName: "Blob_startCopyFromURLHeaders",
		type: {
			name: "Composite",
			className: "BlobStartCopyFromURLHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				copyId: {
					serializedName: "x-ms-copy-id",
					xmlName: "x-ms-copy-id",
					type: { name: "String" }
				},
				copyStatus: {
					serializedName: "x-ms-copy-status",
					xmlName: "x-ms-copy-status",
					type: {
						name: "Enum",
						allowedValues: [
							"pending",
							"success",
							"aborted",
							"failed"
						]
					}
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobStartCopyFromURLExceptionHeaders = {
		serializedName: "Blob_startCopyFromURLExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobStartCopyFromURLExceptionHeaders",
			modelProperties: {
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				},
				copySourceErrorCode: {
					serializedName: "x-ms-copy-source-error-code",
					xmlName: "x-ms-copy-source-error-code",
					type: { name: "String" }
				},
				copySourceStatusCode: {
					serializedName: "x-ms-copy-source-status-code",
					xmlName: "x-ms-copy-source-status-code",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.BlobCopyFromURLHeaders = {
		serializedName: "Blob_copyFromURLHeaders",
		type: {
			name: "Composite",
			className: "BlobCopyFromURLHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				copyId: {
					serializedName: "x-ms-copy-id",
					xmlName: "x-ms-copy-id",
					type: { name: "String" }
				},
				copyStatus: {
					defaultValue: "success",
					isConstant: true,
					serializedName: "x-ms-copy-status",
					type: { name: "String" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobCopyFromURLExceptionHeaders = {
		serializedName: "Blob_copyFromURLExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobCopyFromURLExceptionHeaders",
			modelProperties: {
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				},
				copySourceErrorCode: {
					serializedName: "x-ms-copy-source-error-code",
					xmlName: "x-ms-copy-source-error-code",
					type: { name: "String" }
				},
				copySourceStatusCode: {
					serializedName: "x-ms-copy-source-status-code",
					xmlName: "x-ms-copy-source-status-code",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.BlobAbortCopyFromURLHeaders = {
		serializedName: "Blob_abortCopyFromURLHeaders",
		type: {
			name: "Composite",
			className: "BlobAbortCopyFromURLHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobAbortCopyFromURLExceptionHeaders = {
		serializedName: "Blob_abortCopyFromURLExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobAbortCopyFromURLExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobSetTierHeaders = {
		serializedName: "Blob_setTierHeaders",
		type: {
			name: "Composite",
			className: "BlobSetTierHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobSetTierExceptionHeaders = {
		serializedName: "Blob_setTierExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobSetTierExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobGetAccountInfoHeaders = {
		serializedName: "Blob_getAccountInfoHeaders",
		type: {
			name: "Composite",
			className: "BlobGetAccountInfoHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				skuName: {
					serializedName: "x-ms-sku-name",
					xmlName: "x-ms-sku-name",
					type: {
						name: "Enum",
						allowedValues: [
							"Standard_LRS",
							"Standard_GRS",
							"Standard_RAGRS",
							"Standard_ZRS",
							"Premium_LRS"
						]
					}
				},
				accountKind: {
					serializedName: "x-ms-account-kind",
					xmlName: "x-ms-account-kind",
					type: {
						name: "Enum",
						allowedValues: [
							"Storage",
							"BlobStorage",
							"StorageV2",
							"FileStorage",
							"BlockBlobStorage"
						]
					}
				},
				isHierarchicalNamespaceEnabled: {
					serializedName: "x-ms-is-hns-enabled",
					xmlName: "x-ms-is-hns-enabled",
					type: { name: "Boolean" }
				}
			}
		}
	};
	exports.BlobGetAccountInfoExceptionHeaders = {
		serializedName: "Blob_getAccountInfoExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobGetAccountInfoExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobQueryHeaders = {
		serializedName: "Blob_queryHeaders",
		type: {
			name: "Composite",
			className: "BlobQueryHeaders",
			modelProperties: {
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				metadata: {
					serializedName: "x-ms-meta",
					headerCollectionPrefix: "x-ms-meta-",
					xmlName: "x-ms-meta",
					type: {
						name: "Dictionary",
						value: { type: { name: "String" } }
					}
				},
				contentLength: {
					serializedName: "content-length",
					xmlName: "content-length",
					type: { name: "Number" }
				},
				contentType: {
					serializedName: "content-type",
					xmlName: "content-type",
					type: { name: "String" }
				},
				contentRange: {
					serializedName: "content-range",
					xmlName: "content-range",
					type: { name: "String" }
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				contentEncoding: {
					serializedName: "content-encoding",
					xmlName: "content-encoding",
					type: { name: "String" }
				},
				cacheControl: {
					serializedName: "cache-control",
					xmlName: "cache-control",
					type: { name: "String" }
				},
				contentDisposition: {
					serializedName: "content-disposition",
					xmlName: "content-disposition",
					type: { name: "String" }
				},
				contentLanguage: {
					serializedName: "content-language",
					xmlName: "content-language",
					type: { name: "String" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				blobType: {
					serializedName: "x-ms-blob-type",
					xmlName: "x-ms-blob-type",
					type: {
						name: "Enum",
						allowedValues: [
							"BlockBlob",
							"PageBlob",
							"AppendBlob"
						]
					}
				},
				copyCompletionTime: {
					serializedName: "x-ms-copy-completion-time",
					xmlName: "x-ms-copy-completion-time",
					type: { name: "DateTimeRfc1123" }
				},
				copyStatusDescription: {
					serializedName: "x-ms-copy-status-description",
					xmlName: "x-ms-copy-status-description",
					type: { name: "String" }
				},
				copyId: {
					serializedName: "x-ms-copy-id",
					xmlName: "x-ms-copy-id",
					type: { name: "String" }
				},
				copyProgress: {
					serializedName: "x-ms-copy-progress",
					xmlName: "x-ms-copy-progress",
					type: { name: "String" }
				},
				copySource: {
					serializedName: "x-ms-copy-source",
					xmlName: "x-ms-copy-source",
					type: { name: "String" }
				},
				copyStatus: {
					serializedName: "x-ms-copy-status",
					xmlName: "x-ms-copy-status",
					type: {
						name: "Enum",
						allowedValues: [
							"pending",
							"success",
							"aborted",
							"failed"
						]
					}
				},
				leaseDuration: {
					serializedName: "x-ms-lease-duration",
					xmlName: "x-ms-lease-duration",
					type: {
						name: "Enum",
						allowedValues: ["infinite", "fixed"]
					}
				},
				leaseState: {
					serializedName: "x-ms-lease-state",
					xmlName: "x-ms-lease-state",
					type: {
						name: "Enum",
						allowedValues: [
							"available",
							"leased",
							"expired",
							"breaking",
							"broken"
						]
					}
				},
				leaseStatus: {
					serializedName: "x-ms-lease-status",
					xmlName: "x-ms-lease-status",
					type: {
						name: "Enum",
						allowedValues: ["locked", "unlocked"]
					}
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				acceptRanges: {
					serializedName: "accept-ranges",
					xmlName: "accept-ranges",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				blobCommittedBlockCount: {
					serializedName: "x-ms-blob-committed-block-count",
					xmlName: "x-ms-blob-committed-block-count",
					type: { name: "Number" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-server-encrypted",
					xmlName: "x-ms-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				blobContentMD5: {
					serializedName: "x-ms-blob-content-md5",
					xmlName: "x-ms-blob-content-md5",
					type: { name: "ByteArray" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				},
				contentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				}
			}
		}
	};
	exports.BlobQueryExceptionHeaders = {
		serializedName: "Blob_queryExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobQueryExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobGetTagsHeaders = {
		serializedName: "Blob_getTagsHeaders",
		type: {
			name: "Composite",
			className: "BlobGetTagsHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobGetTagsExceptionHeaders = {
		serializedName: "Blob_getTagsExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobGetTagsExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlobSetTagsHeaders = {
		serializedName: "Blob_setTagsHeaders",
		type: {
			name: "Composite",
			className: "BlobSetTagsHeaders",
			modelProperties: {
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlobSetTagsExceptionHeaders = {
		serializedName: "Blob_setTagsExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlobSetTagsExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.PageBlobCreateHeaders = {
		serializedName: "PageBlob_createHeaders",
		type: {
			name: "Composite",
			className: "PageBlobCreateHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobCreateExceptionHeaders = {
		serializedName: "PageBlob_createExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobCreateExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.PageBlobUploadPagesHeaders = {
		serializedName: "PageBlob_uploadPagesHeaders",
		type: {
			name: "Composite",
			className: "PageBlobUploadPagesHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobUploadPagesExceptionHeaders = {
		serializedName: "PageBlob_uploadPagesExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobUploadPagesExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.PageBlobClearPagesHeaders = {
		serializedName: "PageBlob_clearPagesHeaders",
		type: {
			name: "Composite",
			className: "PageBlobClearPagesHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobClearPagesExceptionHeaders = {
		serializedName: "PageBlob_clearPagesExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobClearPagesExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.PageBlobUploadPagesFromURLHeaders = {
		serializedName: "PageBlob_uploadPagesFromURLHeaders",
		type: {
			name: "Composite",
			className: "PageBlobUploadPagesFromURLHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobUploadPagesFromURLExceptionHeaders = {
		serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobUploadPagesFromURLExceptionHeaders",
			modelProperties: {
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				},
				copySourceErrorCode: {
					serializedName: "x-ms-copy-source-error-code",
					xmlName: "x-ms-copy-source-error-code",
					type: { name: "String" }
				},
				copySourceStatusCode: {
					serializedName: "x-ms-copy-source-status-code",
					xmlName: "x-ms-copy-source-status-code",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.PageBlobGetPageRangesHeaders = {
		serializedName: "PageBlob_getPageRangesHeaders",
		type: {
			name: "Composite",
			className: "PageBlobGetPageRangesHeaders",
			modelProperties: {
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				blobContentLength: {
					serializedName: "x-ms-blob-content-length",
					xmlName: "x-ms-blob-content-length",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobGetPageRangesExceptionHeaders = {
		serializedName: "PageBlob_getPageRangesExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobGetPageRangesExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.PageBlobGetPageRangesDiffHeaders = {
		serializedName: "PageBlob_getPageRangesDiffHeaders",
		type: {
			name: "Composite",
			className: "PageBlobGetPageRangesDiffHeaders",
			modelProperties: {
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				blobContentLength: {
					serializedName: "x-ms-blob-content-length",
					xmlName: "x-ms-blob-content-length",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobGetPageRangesDiffExceptionHeaders = {
		serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobGetPageRangesDiffExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.PageBlobResizeHeaders = {
		serializedName: "PageBlob_resizeHeaders",
		type: {
			name: "Composite",
			className: "PageBlobResizeHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobResizeExceptionHeaders = {
		serializedName: "PageBlob_resizeExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobResizeExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.PageBlobUpdateSequenceNumberHeaders = {
		serializedName: "PageBlob_updateSequenceNumberHeaders",
		type: {
			name: "Composite",
			className: "PageBlobUpdateSequenceNumberHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				blobSequenceNumber: {
					serializedName: "x-ms-blob-sequence-number",
					xmlName: "x-ms-blob-sequence-number",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobUpdateSequenceNumberExceptionHeaders = {
		serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobUpdateSequenceNumberExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.PageBlobCopyIncrementalHeaders = {
		serializedName: "PageBlob_copyIncrementalHeaders",
		type: {
			name: "Composite",
			className: "PageBlobCopyIncrementalHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				copyId: {
					serializedName: "x-ms-copy-id",
					xmlName: "x-ms-copy-id",
					type: { name: "String" }
				},
				copyStatus: {
					serializedName: "x-ms-copy-status",
					xmlName: "x-ms-copy-status",
					type: {
						name: "Enum",
						allowedValues: [
							"pending",
							"success",
							"aborted",
							"failed"
						]
					}
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.PageBlobCopyIncrementalExceptionHeaders = {
		serializedName: "PageBlob_copyIncrementalExceptionHeaders",
		type: {
			name: "Composite",
			className: "PageBlobCopyIncrementalExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.AppendBlobCreateHeaders = {
		serializedName: "AppendBlob_createHeaders",
		type: {
			name: "Composite",
			className: "AppendBlobCreateHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.AppendBlobCreateExceptionHeaders = {
		serializedName: "AppendBlob_createExceptionHeaders",
		type: {
			name: "Composite",
			className: "AppendBlobCreateExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.AppendBlobAppendBlockHeaders = {
		serializedName: "AppendBlob_appendBlockHeaders",
		type: {
			name: "Composite",
			className: "AppendBlobAppendBlockHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				blobAppendOffset: {
					serializedName: "x-ms-blob-append-offset",
					xmlName: "x-ms-blob-append-offset",
					type: { name: "String" }
				},
				blobCommittedBlockCount: {
					serializedName: "x-ms-blob-committed-block-count",
					xmlName: "x-ms-blob-committed-block-count",
					type: { name: "Number" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.AppendBlobAppendBlockExceptionHeaders = {
		serializedName: "AppendBlob_appendBlockExceptionHeaders",
		type: {
			name: "Composite",
			className: "AppendBlobAppendBlockExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.AppendBlobAppendBlockFromUrlHeaders = {
		serializedName: "AppendBlob_appendBlockFromUrlHeaders",
		type: {
			name: "Composite",
			className: "AppendBlobAppendBlockFromUrlHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				blobAppendOffset: {
					serializedName: "x-ms-blob-append-offset",
					xmlName: "x-ms-blob-append-offset",
					type: { name: "String" }
				},
				blobCommittedBlockCount: {
					serializedName: "x-ms-blob-committed-block-count",
					xmlName: "x-ms-blob-committed-block-count",
					type: { name: "Number" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.AppendBlobAppendBlockFromUrlExceptionHeaders = {
		serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
		type: {
			name: "Composite",
			className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
			modelProperties: {
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				},
				copySourceErrorCode: {
					serializedName: "x-ms-copy-source-error-code",
					xmlName: "x-ms-copy-source-error-code",
					type: { name: "String" }
				},
				copySourceStatusCode: {
					serializedName: "x-ms-copy-source-status-code",
					xmlName: "x-ms-copy-source-status-code",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.AppendBlobSealHeaders = {
		serializedName: "AppendBlob_sealHeaders",
		type: {
			name: "Composite",
			className: "AppendBlobSealHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isSealed: {
					serializedName: "x-ms-blob-sealed",
					xmlName: "x-ms-blob-sealed",
					type: { name: "Boolean" }
				}
			}
		}
	};
	exports.AppendBlobSealExceptionHeaders = {
		serializedName: "AppendBlob_sealExceptionHeaders",
		type: {
			name: "Composite",
			className: "AppendBlobSealExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlockBlobUploadHeaders = {
		serializedName: "BlockBlob_uploadHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobUploadHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlockBlobUploadExceptionHeaders = {
		serializedName: "BlockBlob_uploadExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobUploadExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlockBlobPutBlobFromUrlHeaders = {
		serializedName: "BlockBlob_putBlobFromUrlHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobPutBlobFromUrlHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlockBlobPutBlobFromUrlExceptionHeaders = {
		serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobPutBlobFromUrlExceptionHeaders",
			modelProperties: {
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				},
				copySourceErrorCode: {
					serializedName: "x-ms-copy-source-error-code",
					xmlName: "x-ms-copy-source-error-code",
					type: { name: "String" }
				},
				copySourceStatusCode: {
					serializedName: "x-ms-copy-source-status-code",
					xmlName: "x-ms-copy-source-status-code",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.BlockBlobStageBlockHeaders = {
		serializedName: "BlockBlob_stageBlockHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobStageBlockHeaders",
			modelProperties: {
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlockBlobStageBlockExceptionHeaders = {
		serializedName: "BlockBlob_stageBlockExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobStageBlockExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlockBlobStageBlockFromURLHeaders = {
		serializedName: "BlockBlob_stageBlockFromURLHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobStageBlockFromURLHeaders",
			modelProperties: {
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlockBlobStageBlockFromURLExceptionHeaders = {
		serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobStageBlockFromURLExceptionHeaders",
			modelProperties: {
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				},
				copySourceErrorCode: {
					serializedName: "x-ms-copy-source-error-code",
					xmlName: "x-ms-copy-source-error-code",
					type: { name: "String" }
				},
				copySourceStatusCode: {
					serializedName: "x-ms-copy-source-status-code",
					xmlName: "x-ms-copy-source-status-code",
					type: { name: "Number" }
				}
			}
		}
	};
	exports.BlockBlobCommitBlockListHeaders = {
		serializedName: "BlockBlob_commitBlockListHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobCommitBlockListHeaders",
			modelProperties: {
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				contentMD5: {
					serializedName: "content-md5",
					xmlName: "content-md5",
					type: { name: "ByteArray" }
				},
				xMsContentCrc64: {
					serializedName: "x-ms-content-crc64",
					xmlName: "x-ms-content-crc64",
					type: { name: "ByteArray" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				versionId: {
					serializedName: "x-ms-version-id",
					xmlName: "x-ms-version-id",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				isServerEncrypted: {
					serializedName: "x-ms-request-server-encrypted",
					xmlName: "x-ms-request-server-encrypted",
					type: { name: "Boolean" }
				},
				encryptionKeySha256: {
					serializedName: "x-ms-encryption-key-sha256",
					xmlName: "x-ms-encryption-key-sha256",
					type: { name: "String" }
				},
				encryptionScope: {
					serializedName: "x-ms-encryption-scope",
					xmlName: "x-ms-encryption-scope",
					type: { name: "String" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlockBlobCommitBlockListExceptionHeaders = {
		serializedName: "BlockBlob_commitBlockListExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobCommitBlockListExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
	exports.BlockBlobGetBlockListHeaders = {
		serializedName: "BlockBlob_getBlockListHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobGetBlockListHeaders",
			modelProperties: {
				lastModified: {
					serializedName: "last-modified",
					xmlName: "last-modified",
					type: { name: "DateTimeRfc1123" }
				},
				etag: {
					serializedName: "etag",
					xmlName: "etag",
					type: { name: "String" }
				},
				contentType: {
					serializedName: "content-type",
					xmlName: "content-type",
					type: { name: "String" }
				},
				blobContentLength: {
					serializedName: "x-ms-blob-content-length",
					xmlName: "x-ms-blob-content-length",
					type: { name: "Number" }
				},
				clientRequestId: {
					serializedName: "x-ms-client-request-id",
					xmlName: "x-ms-client-request-id",
					type: { name: "String" }
				},
				requestId: {
					serializedName: "x-ms-request-id",
					xmlName: "x-ms-request-id",
					type: { name: "String" }
				},
				version: {
					serializedName: "x-ms-version",
					xmlName: "x-ms-version",
					type: { name: "String" }
				},
				date: {
					serializedName: "date",
					xmlName: "date",
					type: { name: "DateTimeRfc1123" }
				},
				errorCode: {
					serializedName: "x-ms-error-code",
					xmlName: "x-ms-error-code",
					type: { name: "String" }
				}
			}
		}
	};
	exports.BlockBlobGetBlockListExceptionHeaders = {
		serializedName: "BlockBlob_getBlockListExceptionHeaders",
		type: {
			name: "Composite",
			className: "BlockBlobGetBlockListExceptionHeaders",
			modelProperties: { errorCode: {
				serializedName: "x-ms-error-code",
				xmlName: "x-ms-error-code",
				type: { name: "String" }
			} }
		}
	};
}));
var require_parameters = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.action3 = exports.action2 = exports.leaseId1 = exports.action1 = exports.proposedLeaseId = exports.duration = exports.action = exports.comp10 = exports.sourceLeaseId = exports.sourceContainerName = exports.comp9 = exports.deletedContainerVersion = exports.deletedContainerName = exports.comp8 = exports.containerAcl = exports.comp7 = exports.comp6 = exports.ifUnmodifiedSince = exports.ifModifiedSince = exports.leaseId = exports.preventEncryptionScopeOverride = exports.defaultEncryptionScope = exports.access = exports.metadata = exports.restype2 = exports.where = exports.comp5 = exports.multipartContentType = exports.contentLength = exports.comp4 = exports.body = exports.restype1 = exports.comp3 = exports.keyInfo = exports.include = exports.maxPageSize = exports.marker = exports.prefix = exports.comp2 = exports.comp1 = exports.accept1 = exports.requestId = exports.version = exports.timeoutInSeconds = exports.comp = exports.restype = exports.url = exports.accept = exports.blobServiceProperties = exports.contentType = void 0;
	exports.fileRequestIntent = exports.copySourceTags = exports.copySourceAuthorization = exports.sourceContentMD5 = exports.xMsRequiresSync = exports.legalHold1 = exports.sealBlob = exports.blobTagsString = exports.copySource = exports.sourceIfTags = exports.sourceIfNoneMatch = exports.sourceIfMatch = exports.sourceIfUnmodifiedSince = exports.sourceIfModifiedSince = exports.rehydratePriority = exports.tier = exports.comp14 = exports.encryptionScope = exports.legalHold = exports.comp13 = exports.immutabilityPolicyMode = exports.immutabilityPolicyExpiry = exports.comp12 = exports.blobContentDisposition = exports.blobContentLanguage = exports.blobContentEncoding = exports.blobContentMD5 = exports.blobContentType = exports.blobCacheControl = exports.expiresOn = exports.expiryOptions = exports.comp11 = exports.blobDeleteType = exports.deleteSnapshots = exports.ifTags = exports.ifNoneMatch = exports.ifMatch = exports.encryptionAlgorithm = exports.encryptionKeySha256 = exports.encryptionKey = exports.rangeGetContentCRC64 = exports.rangeGetContentMD5 = exports.range = exports.versionId = exports.snapshot = exports.delimiter = exports.include1 = exports.proposedLeaseId1 = exports.action4 = exports.breakPeriod = void 0;
	exports.listType = exports.comp25 = exports.blocks = exports.blockId = exports.comp24 = exports.copySourceBlobProperties = exports.blobType2 = exports.comp23 = exports.sourceRange1 = exports.appendPosition = exports.maxSize = exports.comp22 = exports.blobType1 = exports.comp21 = exports.sequenceNumberAction = exports.prevSnapshotUrl = exports.prevsnapshot = exports.comp20 = exports.range1 = exports.sourceContentCrc64 = exports.sourceRange = exports.sourceUrl = exports.pageWrite1 = exports.ifSequenceNumberEqualTo = exports.ifSequenceNumberLessThan = exports.ifSequenceNumberLessThanOrEqualTo = exports.pageWrite = exports.comp19 = exports.accept2 = exports.body1 = exports.contentType1 = exports.blobSequenceNumber = exports.blobContentLength = exports.blobType = exports.transactionalContentCrc64 = exports.transactionalContentMD5 = exports.tags = exports.comp18 = exports.comp17 = exports.queryRequest = exports.tier1 = exports.comp16 = exports.copyId = exports.copyActionAbortConstant = exports.comp15 = void 0;
	var mappers_js_1 = require_mappers();
	exports.contentType = {
		parameterPath: ["options", "contentType"],
		mapper: {
			defaultValue: "application/xml",
			isConstant: true,
			serializedName: "Content-Type",
			type: { name: "String" }
		}
	};
	exports.blobServiceProperties = {
		parameterPath: "blobServiceProperties",
		mapper: mappers_js_1.BlobServiceProperties
	};
	exports.accept = {
		parameterPath: "accept",
		mapper: {
			defaultValue: "application/xml",
			isConstant: true,
			serializedName: "Accept",
			type: { name: "String" }
		}
	};
	exports.url = {
		parameterPath: "url",
		mapper: {
			serializedName: "url",
			required: true,
			xmlName: "url",
			type: { name: "String" }
		},
		skipEncoding: true
	};
	exports.restype = {
		parameterPath: "restype",
		mapper: {
			defaultValue: "service",
			isConstant: true,
			serializedName: "restype",
			type: { name: "String" }
		}
	};
	exports.comp = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "properties",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.timeoutInSeconds = {
		parameterPath: ["options", "timeoutInSeconds"],
		mapper: {
			constraints: { InclusiveMinimum: 0 },
			serializedName: "timeout",
			xmlName: "timeout",
			type: { name: "Number" }
		}
	};
	exports.version = {
		parameterPath: "version",
		mapper: {
			defaultValue: "2025-11-05",
			isConstant: true,
			serializedName: "x-ms-version",
			type: { name: "String" }
		}
	};
	exports.requestId = {
		parameterPath: ["options", "requestId"],
		mapper: {
			serializedName: "x-ms-client-request-id",
			xmlName: "x-ms-client-request-id",
			type: { name: "String" }
		}
	};
	exports.accept1 = {
		parameterPath: "accept",
		mapper: {
			defaultValue: "application/xml",
			isConstant: true,
			serializedName: "Accept",
			type: { name: "String" }
		}
	};
	exports.comp1 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "stats",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.comp2 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "list",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.prefix = {
		parameterPath: ["options", "prefix"],
		mapper: {
			serializedName: "prefix",
			xmlName: "prefix",
			type: { name: "String" }
		}
	};
	exports.marker = {
		parameterPath: ["options", "marker"],
		mapper: {
			serializedName: "marker",
			xmlName: "marker",
			type: { name: "String" }
		}
	};
	exports.maxPageSize = {
		parameterPath: ["options", "maxPageSize"],
		mapper: {
			constraints: { InclusiveMinimum: 1 },
			serializedName: "maxresults",
			xmlName: "maxresults",
			type: { name: "Number" }
		}
	};
	exports.include = {
		parameterPath: ["options", "include"],
		mapper: {
			serializedName: "include",
			xmlName: "include",
			xmlElementName: "ListContainersIncludeType",
			type: {
				name: "Sequence",
				element: { type: {
					name: "Enum",
					allowedValues: [
						"metadata",
						"deleted",
						"system"
					]
				} }
			}
		},
		collectionFormat: "CSV"
	};
	exports.keyInfo = {
		parameterPath: "keyInfo",
		mapper: mappers_js_1.KeyInfo
	};
	exports.comp3 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "userdelegationkey",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.restype1 = {
		parameterPath: "restype",
		mapper: {
			defaultValue: "account",
			isConstant: true,
			serializedName: "restype",
			type: { name: "String" }
		}
	};
	exports.body = {
		parameterPath: "body",
		mapper: {
			serializedName: "body",
			required: true,
			xmlName: "body",
			type: { name: "Stream" }
		}
	};
	exports.comp4 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "batch",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.contentLength = {
		parameterPath: "contentLength",
		mapper: {
			serializedName: "Content-Length",
			required: true,
			xmlName: "Content-Length",
			type: { name: "Number" }
		}
	};
	exports.multipartContentType = {
		parameterPath: "multipartContentType",
		mapper: {
			serializedName: "Content-Type",
			required: true,
			xmlName: "Content-Type",
			type: { name: "String" }
		}
	};
	exports.comp5 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "blobs",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.where = {
		parameterPath: ["options", "where"],
		mapper: {
			serializedName: "where",
			xmlName: "where",
			type: { name: "String" }
		}
	};
	exports.restype2 = {
		parameterPath: "restype",
		mapper: {
			defaultValue: "container",
			isConstant: true,
			serializedName: "restype",
			type: { name: "String" }
		}
	};
	exports.metadata = {
		parameterPath: ["options", "metadata"],
		mapper: {
			serializedName: "x-ms-meta",
			xmlName: "x-ms-meta",
			headerCollectionPrefix: "x-ms-meta-",
			type: {
				name: "Dictionary",
				value: { type: { name: "String" } }
			}
		}
	};
	exports.access = {
		parameterPath: ["options", "access"],
		mapper: {
			serializedName: "x-ms-blob-public-access",
			xmlName: "x-ms-blob-public-access",
			type: {
				name: "Enum",
				allowedValues: ["container", "blob"]
			}
		}
	};
	exports.defaultEncryptionScope = {
		parameterPath: [
			"options",
			"containerEncryptionScope",
			"defaultEncryptionScope"
		],
		mapper: {
			serializedName: "x-ms-default-encryption-scope",
			xmlName: "x-ms-default-encryption-scope",
			type: { name: "String" }
		}
	};
	exports.preventEncryptionScopeOverride = {
		parameterPath: [
			"options",
			"containerEncryptionScope",
			"preventEncryptionScopeOverride"
		],
		mapper: {
			serializedName: "x-ms-deny-encryption-scope-override",
			xmlName: "x-ms-deny-encryption-scope-override",
			type: { name: "Boolean" }
		}
	};
	exports.leaseId = {
		parameterPath: [
			"options",
			"leaseAccessConditions",
			"leaseId"
		],
		mapper: {
			serializedName: "x-ms-lease-id",
			xmlName: "x-ms-lease-id",
			type: { name: "String" }
		}
	};
	exports.ifModifiedSince = {
		parameterPath: [
			"options",
			"modifiedAccessConditions",
			"ifModifiedSince"
		],
		mapper: {
			serializedName: "If-Modified-Since",
			xmlName: "If-Modified-Since",
			type: { name: "DateTimeRfc1123" }
		}
	};
	exports.ifUnmodifiedSince = {
		parameterPath: [
			"options",
			"modifiedAccessConditions",
			"ifUnmodifiedSince"
		],
		mapper: {
			serializedName: "If-Unmodified-Since",
			xmlName: "If-Unmodified-Since",
			type: { name: "DateTimeRfc1123" }
		}
	};
	exports.comp6 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "metadata",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.comp7 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "acl",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.containerAcl = {
		parameterPath: ["options", "containerAcl"],
		mapper: {
			serializedName: "containerAcl",
			xmlName: "SignedIdentifiers",
			xmlIsWrapped: true,
			xmlElementName: "SignedIdentifier",
			type: {
				name: "Sequence",
				element: { type: {
					name: "Composite",
					className: "SignedIdentifier"
				} }
			}
		}
	};
	exports.comp8 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "undelete",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.deletedContainerName = {
		parameterPath: ["options", "deletedContainerName"],
		mapper: {
			serializedName: "x-ms-deleted-container-name",
			xmlName: "x-ms-deleted-container-name",
			type: { name: "String" }
		}
	};
	exports.deletedContainerVersion = {
		parameterPath: ["options", "deletedContainerVersion"],
		mapper: {
			serializedName: "x-ms-deleted-container-version",
			xmlName: "x-ms-deleted-container-version",
			type: { name: "String" }
		}
	};
	exports.comp9 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "rename",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.sourceContainerName = {
		parameterPath: "sourceContainerName",
		mapper: {
			serializedName: "x-ms-source-container-name",
			required: true,
			xmlName: "x-ms-source-container-name",
			type: { name: "String" }
		}
	};
	exports.sourceLeaseId = {
		parameterPath: ["options", "sourceLeaseId"],
		mapper: {
			serializedName: "x-ms-source-lease-id",
			xmlName: "x-ms-source-lease-id",
			type: { name: "String" }
		}
	};
	exports.comp10 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "lease",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.action = {
		parameterPath: "action",
		mapper: {
			defaultValue: "acquire",
			isConstant: true,
			serializedName: "x-ms-lease-action",
			type: { name: "String" }
		}
	};
	exports.duration = {
		parameterPath: ["options", "duration"],
		mapper: {
			serializedName: "x-ms-lease-duration",
			xmlName: "x-ms-lease-duration",
			type: { name: "Number" }
		}
	};
	exports.proposedLeaseId = {
		parameterPath: ["options", "proposedLeaseId"],
		mapper: {
			serializedName: "x-ms-proposed-lease-id",
			xmlName: "x-ms-proposed-lease-id",
			type: { name: "String" }
		}
	};
	exports.action1 = {
		parameterPath: "action",
		mapper: {
			defaultValue: "release",
			isConstant: true,
			serializedName: "x-ms-lease-action",
			type: { name: "String" }
		}
	};
	exports.leaseId1 = {
		parameterPath: "leaseId",
		mapper: {
			serializedName: "x-ms-lease-id",
			required: true,
			xmlName: "x-ms-lease-id",
			type: { name: "String" }
		}
	};
	exports.action2 = {
		parameterPath: "action",
		mapper: {
			defaultValue: "renew",
			isConstant: true,
			serializedName: "x-ms-lease-action",
			type: { name: "String" }
		}
	};
	exports.action3 = {
		parameterPath: "action",
		mapper: {
			defaultValue: "break",
			isConstant: true,
			serializedName: "x-ms-lease-action",
			type: { name: "String" }
		}
	};
	exports.breakPeriod = {
		parameterPath: ["options", "breakPeriod"],
		mapper: {
			serializedName: "x-ms-lease-break-period",
			xmlName: "x-ms-lease-break-period",
			type: { name: "Number" }
		}
	};
	exports.action4 = {
		parameterPath: "action",
		mapper: {
			defaultValue: "change",
			isConstant: true,
			serializedName: "x-ms-lease-action",
			type: { name: "String" }
		}
	};
	exports.proposedLeaseId1 = {
		parameterPath: "proposedLeaseId",
		mapper: {
			serializedName: "x-ms-proposed-lease-id",
			required: true,
			xmlName: "x-ms-proposed-lease-id",
			type: { name: "String" }
		}
	};
	exports.include1 = {
		parameterPath: ["options", "include"],
		mapper: {
			serializedName: "include",
			xmlName: "include",
			xmlElementName: "ListBlobsIncludeItem",
			type: {
				name: "Sequence",
				element: { type: {
					name: "Enum",
					allowedValues: [
						"copy",
						"deleted",
						"metadata",
						"snapshots",
						"uncommittedblobs",
						"versions",
						"tags",
						"immutabilitypolicy",
						"legalhold",
						"deletedwithversions"
					]
				} }
			}
		},
		collectionFormat: "CSV"
	};
	exports.delimiter = {
		parameterPath: "delimiter",
		mapper: {
			serializedName: "delimiter",
			required: true,
			xmlName: "delimiter",
			type: { name: "String" }
		}
	};
	exports.snapshot = {
		parameterPath: ["options", "snapshot"],
		mapper: {
			serializedName: "snapshot",
			xmlName: "snapshot",
			type: { name: "String" }
		}
	};
	exports.versionId = {
		parameterPath: ["options", "versionId"],
		mapper: {
			serializedName: "versionid",
			xmlName: "versionid",
			type: { name: "String" }
		}
	};
	exports.range = {
		parameterPath: ["options", "range"],
		mapper: {
			serializedName: "x-ms-range",
			xmlName: "x-ms-range",
			type: { name: "String" }
		}
	};
	exports.rangeGetContentMD5 = {
		parameterPath: ["options", "rangeGetContentMD5"],
		mapper: {
			serializedName: "x-ms-range-get-content-md5",
			xmlName: "x-ms-range-get-content-md5",
			type: { name: "Boolean" }
		}
	};
	exports.rangeGetContentCRC64 = {
		parameterPath: ["options", "rangeGetContentCRC64"],
		mapper: {
			serializedName: "x-ms-range-get-content-crc64",
			xmlName: "x-ms-range-get-content-crc64",
			type: { name: "Boolean" }
		}
	};
	exports.encryptionKey = {
		parameterPath: [
			"options",
			"cpkInfo",
			"encryptionKey"
		],
		mapper: {
			serializedName: "x-ms-encryption-key",
			xmlName: "x-ms-encryption-key",
			type: { name: "String" }
		}
	};
	exports.encryptionKeySha256 = {
		parameterPath: [
			"options",
			"cpkInfo",
			"encryptionKeySha256"
		],
		mapper: {
			serializedName: "x-ms-encryption-key-sha256",
			xmlName: "x-ms-encryption-key-sha256",
			type: { name: "String" }
		}
	};
	exports.encryptionAlgorithm = {
		parameterPath: [
			"options",
			"cpkInfo",
			"encryptionAlgorithm"
		],
		mapper: {
			serializedName: "x-ms-encryption-algorithm",
			xmlName: "x-ms-encryption-algorithm",
			type: { name: "String" }
		}
	};
	exports.ifMatch = {
		parameterPath: [
			"options",
			"modifiedAccessConditions",
			"ifMatch"
		],
		mapper: {
			serializedName: "If-Match",
			xmlName: "If-Match",
			type: { name: "String" }
		}
	};
	exports.ifNoneMatch = {
		parameterPath: [
			"options",
			"modifiedAccessConditions",
			"ifNoneMatch"
		],
		mapper: {
			serializedName: "If-None-Match",
			xmlName: "If-None-Match",
			type: { name: "String" }
		}
	};
	exports.ifTags = {
		parameterPath: [
			"options",
			"modifiedAccessConditions",
			"ifTags"
		],
		mapper: {
			serializedName: "x-ms-if-tags",
			xmlName: "x-ms-if-tags",
			type: { name: "String" }
		}
	};
	exports.deleteSnapshots = {
		parameterPath: ["options", "deleteSnapshots"],
		mapper: {
			serializedName: "x-ms-delete-snapshots",
			xmlName: "x-ms-delete-snapshots",
			type: {
				name: "Enum",
				allowedValues: ["include", "only"]
			}
		}
	};
	exports.blobDeleteType = {
		parameterPath: ["options", "blobDeleteType"],
		mapper: {
			serializedName: "deletetype",
			xmlName: "deletetype",
			type: { name: "String" }
		}
	};
	exports.comp11 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "expiry",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.expiryOptions = {
		parameterPath: "expiryOptions",
		mapper: {
			serializedName: "x-ms-expiry-option",
			required: true,
			xmlName: "x-ms-expiry-option",
			type: { name: "String" }
		}
	};
	exports.expiresOn = {
		parameterPath: ["options", "expiresOn"],
		mapper: {
			serializedName: "x-ms-expiry-time",
			xmlName: "x-ms-expiry-time",
			type: { name: "String" }
		}
	};
	exports.blobCacheControl = {
		parameterPath: [
			"options",
			"blobHttpHeaders",
			"blobCacheControl"
		],
		mapper: {
			serializedName: "x-ms-blob-cache-control",
			xmlName: "x-ms-blob-cache-control",
			type: { name: "String" }
		}
	};
	exports.blobContentType = {
		parameterPath: [
			"options",
			"blobHttpHeaders",
			"blobContentType"
		],
		mapper: {
			serializedName: "x-ms-blob-content-type",
			xmlName: "x-ms-blob-content-type",
			type: { name: "String" }
		}
	};
	exports.blobContentMD5 = {
		parameterPath: [
			"options",
			"blobHttpHeaders",
			"blobContentMD5"
		],
		mapper: {
			serializedName: "x-ms-blob-content-md5",
			xmlName: "x-ms-blob-content-md5",
			type: { name: "ByteArray" }
		}
	};
	exports.blobContentEncoding = {
		parameterPath: [
			"options",
			"blobHttpHeaders",
			"blobContentEncoding"
		],
		mapper: {
			serializedName: "x-ms-blob-content-encoding",
			xmlName: "x-ms-blob-content-encoding",
			type: { name: "String" }
		}
	};
	exports.blobContentLanguage = {
		parameterPath: [
			"options",
			"blobHttpHeaders",
			"blobContentLanguage"
		],
		mapper: {
			serializedName: "x-ms-blob-content-language",
			xmlName: "x-ms-blob-content-language",
			type: { name: "String" }
		}
	};
	exports.blobContentDisposition = {
		parameterPath: [
			"options",
			"blobHttpHeaders",
			"blobContentDisposition"
		],
		mapper: {
			serializedName: "x-ms-blob-content-disposition",
			xmlName: "x-ms-blob-content-disposition",
			type: { name: "String" }
		}
	};
	exports.comp12 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "immutabilityPolicies",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.immutabilityPolicyExpiry = {
		parameterPath: ["options", "immutabilityPolicyExpiry"],
		mapper: {
			serializedName: "x-ms-immutability-policy-until-date",
			xmlName: "x-ms-immutability-policy-until-date",
			type: { name: "DateTimeRfc1123" }
		}
	};
	exports.immutabilityPolicyMode = {
		parameterPath: ["options", "immutabilityPolicyMode"],
		mapper: {
			serializedName: "x-ms-immutability-policy-mode",
			xmlName: "x-ms-immutability-policy-mode",
			type: {
				name: "Enum",
				allowedValues: [
					"Mutable",
					"Unlocked",
					"Locked"
				]
			}
		}
	};
	exports.comp13 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "legalhold",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.legalHold = {
		parameterPath: "legalHold",
		mapper: {
			serializedName: "x-ms-legal-hold",
			required: true,
			xmlName: "x-ms-legal-hold",
			type: { name: "Boolean" }
		}
	};
	exports.encryptionScope = {
		parameterPath: ["options", "encryptionScope"],
		mapper: {
			serializedName: "x-ms-encryption-scope",
			xmlName: "x-ms-encryption-scope",
			type: { name: "String" }
		}
	};
	exports.comp14 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "snapshot",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.tier = {
		parameterPath: ["options", "tier"],
		mapper: {
			serializedName: "x-ms-access-tier",
			xmlName: "x-ms-access-tier",
			type: {
				name: "Enum",
				allowedValues: [
					"P4",
					"P6",
					"P10",
					"P15",
					"P20",
					"P30",
					"P40",
					"P50",
					"P60",
					"P70",
					"P80",
					"Hot",
					"Cool",
					"Archive",
					"Cold"
				]
			}
		}
	};
	exports.rehydratePriority = {
		parameterPath: ["options", "rehydratePriority"],
		mapper: {
			serializedName: "x-ms-rehydrate-priority",
			xmlName: "x-ms-rehydrate-priority",
			type: {
				name: "Enum",
				allowedValues: ["High", "Standard"]
			}
		}
	};
	exports.sourceIfModifiedSince = {
		parameterPath: [
			"options",
			"sourceModifiedAccessConditions",
			"sourceIfModifiedSince"
		],
		mapper: {
			serializedName: "x-ms-source-if-modified-since",
			xmlName: "x-ms-source-if-modified-since",
			type: { name: "DateTimeRfc1123" }
		}
	};
	exports.sourceIfUnmodifiedSince = {
		parameterPath: [
			"options",
			"sourceModifiedAccessConditions",
			"sourceIfUnmodifiedSince"
		],
		mapper: {
			serializedName: "x-ms-source-if-unmodified-since",
			xmlName: "x-ms-source-if-unmodified-since",
			type: { name: "DateTimeRfc1123" }
		}
	};
	exports.sourceIfMatch = {
		parameterPath: [
			"options",
			"sourceModifiedAccessConditions",
			"sourceIfMatch"
		],
		mapper: {
			serializedName: "x-ms-source-if-match",
			xmlName: "x-ms-source-if-match",
			type: { name: "String" }
		}
	};
	exports.sourceIfNoneMatch = {
		parameterPath: [
			"options",
			"sourceModifiedAccessConditions",
			"sourceIfNoneMatch"
		],
		mapper: {
			serializedName: "x-ms-source-if-none-match",
			xmlName: "x-ms-source-if-none-match",
			type: { name: "String" }
		}
	};
	exports.sourceIfTags = {
		parameterPath: [
			"options",
			"sourceModifiedAccessConditions",
			"sourceIfTags"
		],
		mapper: {
			serializedName: "x-ms-source-if-tags",
			xmlName: "x-ms-source-if-tags",
			type: { name: "String" }
		}
	};
	exports.copySource = {
		parameterPath: "copySource",
		mapper: {
			serializedName: "x-ms-copy-source",
			required: true,
			xmlName: "x-ms-copy-source",
			type: { name: "String" }
		}
	};
	exports.blobTagsString = {
		parameterPath: ["options", "blobTagsString"],
		mapper: {
			serializedName: "x-ms-tags",
			xmlName: "x-ms-tags",
			type: { name: "String" }
		}
	};
	exports.sealBlob = {
		parameterPath: ["options", "sealBlob"],
		mapper: {
			serializedName: "x-ms-seal-blob",
			xmlName: "x-ms-seal-blob",
			type: { name: "Boolean" }
		}
	};
	exports.legalHold1 = {
		parameterPath: ["options", "legalHold"],
		mapper: {
			serializedName: "x-ms-legal-hold",
			xmlName: "x-ms-legal-hold",
			type: { name: "Boolean" }
		}
	};
	exports.xMsRequiresSync = {
		parameterPath: "xMsRequiresSync",
		mapper: {
			defaultValue: "true",
			isConstant: true,
			serializedName: "x-ms-requires-sync",
			type: { name: "String" }
		}
	};
	exports.sourceContentMD5 = {
		parameterPath: ["options", "sourceContentMD5"],
		mapper: {
			serializedName: "x-ms-source-content-md5",
			xmlName: "x-ms-source-content-md5",
			type: { name: "ByteArray" }
		}
	};
	exports.copySourceAuthorization = {
		parameterPath: ["options", "copySourceAuthorization"],
		mapper: {
			serializedName: "x-ms-copy-source-authorization",
			xmlName: "x-ms-copy-source-authorization",
			type: { name: "String" }
		}
	};
	exports.copySourceTags = {
		parameterPath: ["options", "copySourceTags"],
		mapper: {
			serializedName: "x-ms-copy-source-tag-option",
			xmlName: "x-ms-copy-source-tag-option",
			type: {
				name: "Enum",
				allowedValues: ["REPLACE", "COPY"]
			}
		}
	};
	exports.fileRequestIntent = {
		parameterPath: ["options", "fileRequestIntent"],
		mapper: {
			serializedName: "x-ms-file-request-intent",
			xmlName: "x-ms-file-request-intent",
			type: { name: "String" }
		}
	};
	exports.comp15 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "copy",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.copyActionAbortConstant = {
		parameterPath: "copyActionAbortConstant",
		mapper: {
			defaultValue: "abort",
			isConstant: true,
			serializedName: "x-ms-copy-action",
			type: { name: "String" }
		}
	};
	exports.copyId = {
		parameterPath: "copyId",
		mapper: {
			serializedName: "copyid",
			required: true,
			xmlName: "copyid",
			type: { name: "String" }
		}
	};
	exports.comp16 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "tier",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.tier1 = {
		parameterPath: "tier",
		mapper: {
			serializedName: "x-ms-access-tier",
			required: true,
			xmlName: "x-ms-access-tier",
			type: {
				name: "Enum",
				allowedValues: [
					"P4",
					"P6",
					"P10",
					"P15",
					"P20",
					"P30",
					"P40",
					"P50",
					"P60",
					"P70",
					"P80",
					"Hot",
					"Cool",
					"Archive",
					"Cold"
				]
			}
		}
	};
	exports.queryRequest = {
		parameterPath: ["options", "queryRequest"],
		mapper: mappers_js_1.QueryRequest
	};
	exports.comp17 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "query",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.comp18 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "tags",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.tags = {
		parameterPath: ["options", "tags"],
		mapper: mappers_js_1.BlobTags
	};
	exports.transactionalContentMD5 = {
		parameterPath: ["options", "transactionalContentMD5"],
		mapper: {
			serializedName: "Content-MD5",
			xmlName: "Content-MD5",
			type: { name: "ByteArray" }
		}
	};
	exports.transactionalContentCrc64 = {
		parameterPath: ["options", "transactionalContentCrc64"],
		mapper: {
			serializedName: "x-ms-content-crc64",
			xmlName: "x-ms-content-crc64",
			type: { name: "ByteArray" }
		}
	};
	exports.blobType = {
		parameterPath: "blobType",
		mapper: {
			defaultValue: "PageBlob",
			isConstant: true,
			serializedName: "x-ms-blob-type",
			type: { name: "String" }
		}
	};
	exports.blobContentLength = {
		parameterPath: "blobContentLength",
		mapper: {
			serializedName: "x-ms-blob-content-length",
			required: true,
			xmlName: "x-ms-blob-content-length",
			type: { name: "Number" }
		}
	};
	exports.blobSequenceNumber = {
		parameterPath: ["options", "blobSequenceNumber"],
		mapper: {
			defaultValue: 0,
			serializedName: "x-ms-blob-sequence-number",
			xmlName: "x-ms-blob-sequence-number",
			type: { name: "Number" }
		}
	};
	exports.contentType1 = {
		parameterPath: ["options", "contentType"],
		mapper: {
			defaultValue: "application/octet-stream",
			isConstant: true,
			serializedName: "Content-Type",
			type: { name: "String" }
		}
	};
	exports.body1 = {
		parameterPath: "body",
		mapper: {
			serializedName: "body",
			required: true,
			xmlName: "body",
			type: { name: "Stream" }
		}
	};
	exports.accept2 = {
		parameterPath: "accept",
		mapper: {
			defaultValue: "application/xml",
			isConstant: true,
			serializedName: "Accept",
			type: { name: "String" }
		}
	};
	exports.comp19 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "page",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.pageWrite = {
		parameterPath: "pageWrite",
		mapper: {
			defaultValue: "update",
			isConstant: true,
			serializedName: "x-ms-page-write",
			type: { name: "String" }
		}
	};
	exports.ifSequenceNumberLessThanOrEqualTo = {
		parameterPath: [
			"options",
			"sequenceNumberAccessConditions",
			"ifSequenceNumberLessThanOrEqualTo"
		],
		mapper: {
			serializedName: "x-ms-if-sequence-number-le",
			xmlName: "x-ms-if-sequence-number-le",
			type: { name: "Number" }
		}
	};
	exports.ifSequenceNumberLessThan = {
		parameterPath: [
			"options",
			"sequenceNumberAccessConditions",
			"ifSequenceNumberLessThan"
		],
		mapper: {
			serializedName: "x-ms-if-sequence-number-lt",
			xmlName: "x-ms-if-sequence-number-lt",
			type: { name: "Number" }
		}
	};
	exports.ifSequenceNumberEqualTo = {
		parameterPath: [
			"options",
			"sequenceNumberAccessConditions",
			"ifSequenceNumberEqualTo"
		],
		mapper: {
			serializedName: "x-ms-if-sequence-number-eq",
			xmlName: "x-ms-if-sequence-number-eq",
			type: { name: "Number" }
		}
	};
	exports.pageWrite1 = {
		parameterPath: "pageWrite",
		mapper: {
			defaultValue: "clear",
			isConstant: true,
			serializedName: "x-ms-page-write",
			type: { name: "String" }
		}
	};
	exports.sourceUrl = {
		parameterPath: "sourceUrl",
		mapper: {
			serializedName: "x-ms-copy-source",
			required: true,
			xmlName: "x-ms-copy-source",
			type: { name: "String" }
		}
	};
	exports.sourceRange = {
		parameterPath: "sourceRange",
		mapper: {
			serializedName: "x-ms-source-range",
			required: true,
			xmlName: "x-ms-source-range",
			type: { name: "String" }
		}
	};
	exports.sourceContentCrc64 = {
		parameterPath: ["options", "sourceContentCrc64"],
		mapper: {
			serializedName: "x-ms-source-content-crc64",
			xmlName: "x-ms-source-content-crc64",
			type: { name: "ByteArray" }
		}
	};
	exports.range1 = {
		parameterPath: "range",
		mapper: {
			serializedName: "x-ms-range",
			required: true,
			xmlName: "x-ms-range",
			type: { name: "String" }
		}
	};
	exports.comp20 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "pagelist",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.prevsnapshot = {
		parameterPath: ["options", "prevsnapshot"],
		mapper: {
			serializedName: "prevsnapshot",
			xmlName: "prevsnapshot",
			type: { name: "String" }
		}
	};
	exports.prevSnapshotUrl = {
		parameterPath: ["options", "prevSnapshotUrl"],
		mapper: {
			serializedName: "x-ms-previous-snapshot-url",
			xmlName: "x-ms-previous-snapshot-url",
			type: { name: "String" }
		}
	};
	exports.sequenceNumberAction = {
		parameterPath: "sequenceNumberAction",
		mapper: {
			serializedName: "x-ms-sequence-number-action",
			required: true,
			xmlName: "x-ms-sequence-number-action",
			type: {
				name: "Enum",
				allowedValues: [
					"max",
					"update",
					"increment"
				]
			}
		}
	};
	exports.comp21 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "incrementalcopy",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.blobType1 = {
		parameterPath: "blobType",
		mapper: {
			defaultValue: "AppendBlob",
			isConstant: true,
			serializedName: "x-ms-blob-type",
			type: { name: "String" }
		}
	};
	exports.comp22 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "appendblock",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.maxSize = {
		parameterPath: [
			"options",
			"appendPositionAccessConditions",
			"maxSize"
		],
		mapper: {
			serializedName: "x-ms-blob-condition-maxsize",
			xmlName: "x-ms-blob-condition-maxsize",
			type: { name: "Number" }
		}
	};
	exports.appendPosition = {
		parameterPath: [
			"options",
			"appendPositionAccessConditions",
			"appendPosition"
		],
		mapper: {
			serializedName: "x-ms-blob-condition-appendpos",
			xmlName: "x-ms-blob-condition-appendpos",
			type: { name: "Number" }
		}
	};
	exports.sourceRange1 = {
		parameterPath: ["options", "sourceRange"],
		mapper: {
			serializedName: "x-ms-source-range",
			xmlName: "x-ms-source-range",
			type: { name: "String" }
		}
	};
	exports.comp23 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "seal",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.blobType2 = {
		parameterPath: "blobType",
		mapper: {
			defaultValue: "BlockBlob",
			isConstant: true,
			serializedName: "x-ms-blob-type",
			type: { name: "String" }
		}
	};
	exports.copySourceBlobProperties = {
		parameterPath: ["options", "copySourceBlobProperties"],
		mapper: {
			serializedName: "x-ms-copy-source-blob-properties",
			xmlName: "x-ms-copy-source-blob-properties",
			type: { name: "Boolean" }
		}
	};
	exports.comp24 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "block",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.blockId = {
		parameterPath: "blockId",
		mapper: {
			serializedName: "blockid",
			required: true,
			xmlName: "blockid",
			type: { name: "String" }
		}
	};
	exports.blocks = {
		parameterPath: "blocks",
		mapper: mappers_js_1.BlockLookupList
	};
	exports.comp25 = {
		parameterPath: "comp",
		mapper: {
			defaultValue: "blocklist",
			isConstant: true,
			serializedName: "comp",
			type: { name: "String" }
		}
	};
	exports.listType = {
		parameterPath: "listType",
		mapper: {
			defaultValue: "committed",
			serializedName: "blocklisttype",
			required: true,
			xmlName: "blocklisttype",
			type: {
				name: "Enum",
				allowedValues: [
					"committed",
					"uncommitted",
					"all"
				]
			}
		}
	};
}));
var require_service$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ServiceImpl = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var coreClient = tslib_1.__importStar(require_commonjs$10());
	var Mappers = tslib_1.__importStar(require_mappers());
	var Parameters = tslib_1.__importStar(require_parameters());
	var ServiceImpl = class {
		client;
		constructor(client) {
			this.client = client;
		}
		setProperties(blobServiceProperties, options) {
			return this.client.sendOperationRequest({
				blobServiceProperties,
				options
			}, setPropertiesOperationSpec);
		}
		getProperties(options) {
			return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
		}
		getStatistics(options) {
			return this.client.sendOperationRequest({ options }, getStatisticsOperationSpec);
		}
		listContainersSegment(options) {
			return this.client.sendOperationRequest({ options }, listContainersSegmentOperationSpec);
		}
		getUserDelegationKey(keyInfo, options) {
			return this.client.sendOperationRequest({
				keyInfo,
				options
			}, getUserDelegationKeyOperationSpec);
		}
		getAccountInfo(options) {
			return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
		}
		submitBatch(contentLength, multipartContentType, body, options) {
			return this.client.sendOperationRequest({
				contentLength,
				multipartContentType,
				body,
				options
			}, submitBatchOperationSpec);
		}
		filterBlobs(options) {
			return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
		}
	};
	exports.ServiceImpl = ServiceImpl;
	var xmlSerializer = coreClient.createSerializer(Mappers, true);
	var setPropertiesOperationSpec = {
		path: "/",
		httpMethod: "PUT",
		responses: {
			202: { headersMapper: Mappers.ServiceSetPropertiesHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ServiceSetPropertiesExceptionHeaders
			}
		},
		requestBody: Parameters.blobServiceProperties,
		queryParameters: [
			Parameters.restype,
			Parameters.comp,
			Parameters.timeoutInSeconds
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.contentType,
			Parameters.accept,
			Parameters.version,
			Parameters.requestId
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "xml",
		serializer: xmlSerializer
	};
	var getPropertiesOperationSpec = {
		path: "/",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.BlobServiceProperties,
				headersMapper: Mappers.ServiceGetPropertiesHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ServiceGetPropertiesExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.restype,
			Parameters.comp,
			Parameters.timeoutInSeconds
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getStatisticsOperationSpec = {
		path: "/",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.BlobServiceStatistics,
				headersMapper: Mappers.ServiceGetStatisticsHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ServiceGetStatisticsExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.restype,
			Parameters.timeoutInSeconds,
			Parameters.comp1
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var listContainersSegmentOperationSpec = {
		path: "/",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.ListContainersSegmentResponse,
				headersMapper: Mappers.ServiceListContainersSegmentHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ServiceListContainersSegmentExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.comp2,
			Parameters.prefix,
			Parameters.marker,
			Parameters.maxPageSize,
			Parameters.include
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getUserDelegationKeyOperationSpec = {
		path: "/",
		httpMethod: "POST",
		responses: {
			200: {
				bodyMapper: Mappers.UserDelegationKey,
				headersMapper: Mappers.ServiceGetUserDelegationKeyHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ServiceGetUserDelegationKeyExceptionHeaders
			}
		},
		requestBody: Parameters.keyInfo,
		queryParameters: [
			Parameters.restype,
			Parameters.timeoutInSeconds,
			Parameters.comp3
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.contentType,
			Parameters.accept,
			Parameters.version,
			Parameters.requestId
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "xml",
		serializer: xmlSerializer
	};
	var getAccountInfoOperationSpec = {
		path: "/",
		httpMethod: "GET",
		responses: {
			200: { headersMapper: Mappers.ServiceGetAccountInfoHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ServiceGetAccountInfoExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.comp,
			Parameters.timeoutInSeconds,
			Parameters.restype1
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var submitBatchOperationSpec = {
		path: "/",
		httpMethod: "POST",
		responses: {
			202: {
				bodyMapper: {
					type: { name: "Stream" },
					serializedName: "parsedResponse"
				},
				headersMapper: Mappers.ServiceSubmitBatchHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ServiceSubmitBatchExceptionHeaders
			}
		},
		requestBody: Parameters.body,
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp4],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.accept,
			Parameters.version,
			Parameters.requestId,
			Parameters.contentLength,
			Parameters.multipartContentType
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "xml",
		serializer: xmlSerializer
	};
	var filterBlobsOperationSpec = {
		path: "/",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.FilterBlobSegment,
				headersMapper: Mappers.ServiceFilterBlobsHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ServiceFilterBlobsExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.marker,
			Parameters.maxPageSize,
			Parameters.comp5,
			Parameters.where
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
}));
var require_container$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ContainerImpl = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var coreClient = tslib_1.__importStar(require_commonjs$10());
	var Mappers = tslib_1.__importStar(require_mappers());
	var Parameters = tslib_1.__importStar(require_parameters());
	var ContainerImpl = class {
		client;
		constructor(client) {
			this.client = client;
		}
		create(options) {
			return this.client.sendOperationRequest({ options }, createOperationSpec);
		}
		getProperties(options) {
			return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
		}
		delete(options) {
			return this.client.sendOperationRequest({ options }, deleteOperationSpec);
		}
		setMetadata(options) {
			return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
		}
		getAccessPolicy(options) {
			return this.client.sendOperationRequest({ options }, getAccessPolicyOperationSpec);
		}
		setAccessPolicy(options) {
			return this.client.sendOperationRequest({ options }, setAccessPolicyOperationSpec);
		}
		restore(options) {
			return this.client.sendOperationRequest({ options }, restoreOperationSpec);
		}
		rename(sourceContainerName, options) {
			return this.client.sendOperationRequest({
				sourceContainerName,
				options
			}, renameOperationSpec);
		}
		submitBatch(contentLength, multipartContentType, body, options) {
			return this.client.sendOperationRequest({
				contentLength,
				multipartContentType,
				body,
				options
			}, submitBatchOperationSpec);
		}
		filterBlobs(options) {
			return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
		}
		acquireLease(options) {
			return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
		}
		releaseLease(leaseId, options) {
			return this.client.sendOperationRequest({
				leaseId,
				options
			}, releaseLeaseOperationSpec);
		}
		renewLease(leaseId, options) {
			return this.client.sendOperationRequest({
				leaseId,
				options
			}, renewLeaseOperationSpec);
		}
		breakLease(options) {
			return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
		}
		changeLease(leaseId, proposedLeaseId, options) {
			return this.client.sendOperationRequest({
				leaseId,
				proposedLeaseId,
				options
			}, changeLeaseOperationSpec);
		}
		listBlobFlatSegment(options) {
			return this.client.sendOperationRequest({ options }, listBlobFlatSegmentOperationSpec);
		}
		listBlobHierarchySegment(delimiter, options) {
			return this.client.sendOperationRequest({
				delimiter,
				options
			}, listBlobHierarchySegmentOperationSpec);
		}
		getAccountInfo(options) {
			return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
		}
	};
	exports.ContainerImpl = ContainerImpl;
	var xmlSerializer = coreClient.createSerializer(Mappers, true);
	var createOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.ContainerCreateHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerCreateExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.metadata,
			Parameters.access,
			Parameters.defaultEncryptionScope,
			Parameters.preventEncryptionScopeOverride
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getPropertiesOperationSpec = {
		path: "/{containerName}",
		httpMethod: "GET",
		responses: {
			200: { headersMapper: Mappers.ContainerGetPropertiesHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerGetPropertiesExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var deleteOperationSpec = {
		path: "/{containerName}",
		httpMethod: "DELETE",
		responses: {
			202: { headersMapper: Mappers.ContainerDeleteHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerDeleteExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setMetadataOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.ContainerSetMetadataHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerSetMetadataExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp6
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getAccessPolicyOperationSpec = {
		path: "/{containerName}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: {
					type: {
						name: "Sequence",
						element: { type: {
							name: "Composite",
							className: "SignedIdentifier"
						} }
					},
					serializedName: "SignedIdentifiers",
					xmlName: "SignedIdentifiers",
					xmlIsWrapped: true,
					xmlElementName: "SignedIdentifier"
				},
				headersMapper: Mappers.ContainerGetAccessPolicyHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerGetAccessPolicyExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp7
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setAccessPolicyOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.ContainerSetAccessPolicyHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerSetAccessPolicyExceptionHeaders
			}
		},
		requestBody: Parameters.containerAcl,
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp7
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.contentType,
			Parameters.accept,
			Parameters.version,
			Parameters.requestId,
			Parameters.access,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "xml",
		serializer: xmlSerializer
	};
	var restoreOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.ContainerRestoreHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerRestoreExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp8
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.deletedContainerName,
			Parameters.deletedContainerVersion
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var renameOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.ContainerRenameHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerRenameExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp9
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.sourceContainerName,
			Parameters.sourceLeaseId
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var submitBatchOperationSpec = {
		path: "/{containerName}",
		httpMethod: "POST",
		responses: {
			202: {
				bodyMapper: {
					type: { name: "Stream" },
					serializedName: "parsedResponse"
				},
				headersMapper: Mappers.ContainerSubmitBatchHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerSubmitBatchExceptionHeaders
			}
		},
		requestBody: Parameters.body,
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.comp4,
			Parameters.restype2
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.accept,
			Parameters.version,
			Parameters.requestId,
			Parameters.contentLength,
			Parameters.multipartContentType
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "xml",
		serializer: xmlSerializer
	};
	var filterBlobsOperationSpec = {
		path: "/{containerName}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.FilterBlobSegment,
				headersMapper: Mappers.ContainerFilterBlobsHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerFilterBlobsExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.marker,
			Parameters.maxPageSize,
			Parameters.comp5,
			Parameters.where,
			Parameters.restype2
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var acquireLeaseOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.ContainerAcquireLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerAcquireLeaseExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp10
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.action,
			Parameters.duration,
			Parameters.proposedLeaseId
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var releaseLeaseOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.ContainerReleaseLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerReleaseLeaseExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp10
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.action1,
			Parameters.leaseId1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var renewLeaseOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.ContainerRenewLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerRenewLeaseExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp10
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.leaseId1,
			Parameters.action2
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var breakLeaseOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			202: { headersMapper: Mappers.ContainerBreakLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerBreakLeaseExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp10
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.action3,
			Parameters.breakPeriod
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var changeLeaseOperationSpec = {
		path: "/{containerName}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.ContainerChangeLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerChangeLeaseExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.restype2,
			Parameters.comp10
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.leaseId1,
			Parameters.action4,
			Parameters.proposedLeaseId1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var listBlobFlatSegmentOperationSpec = {
		path: "/{containerName}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.ListBlobsFlatSegmentResponse,
				headersMapper: Mappers.ContainerListBlobFlatSegmentHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerListBlobFlatSegmentExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.comp2,
			Parameters.prefix,
			Parameters.marker,
			Parameters.maxPageSize,
			Parameters.restype2,
			Parameters.include1
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var listBlobHierarchySegmentOperationSpec = {
		path: "/{containerName}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.ListBlobsHierarchySegmentResponse,
				headersMapper: Mappers.ContainerListBlobHierarchySegmentHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerListBlobHierarchySegmentExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.comp2,
			Parameters.prefix,
			Parameters.marker,
			Parameters.maxPageSize,
			Parameters.restype2,
			Parameters.include1,
			Parameters.delimiter
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getAccountInfoOperationSpec = {
		path: "/{containerName}",
		httpMethod: "GET",
		responses: {
			200: { headersMapper: Mappers.ContainerGetAccountInfoHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.ContainerGetAccountInfoExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.comp,
			Parameters.timeoutInSeconds,
			Parameters.restype1
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
}));
var require_blob$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobImpl = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var coreClient = tslib_1.__importStar(require_commonjs$10());
	var Mappers = tslib_1.__importStar(require_mappers());
	var Parameters = tslib_1.__importStar(require_parameters());
	var BlobImpl = class {
		client;
		constructor(client) {
			this.client = client;
		}
		download(options) {
			return this.client.sendOperationRequest({ options }, downloadOperationSpec);
		}
		getProperties(options) {
			return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
		}
		delete(options) {
			return this.client.sendOperationRequest({ options }, deleteOperationSpec);
		}
		undelete(options) {
			return this.client.sendOperationRequest({ options }, undeleteOperationSpec);
		}
		setExpiry(expiryOptions, options) {
			return this.client.sendOperationRequest({
				expiryOptions,
				options
			}, setExpiryOperationSpec);
		}
		setHttpHeaders(options) {
			return this.client.sendOperationRequest({ options }, setHttpHeadersOperationSpec);
		}
		setImmutabilityPolicy(options) {
			return this.client.sendOperationRequest({ options }, setImmutabilityPolicyOperationSpec);
		}
		deleteImmutabilityPolicy(options) {
			return this.client.sendOperationRequest({ options }, deleteImmutabilityPolicyOperationSpec);
		}
		setLegalHold(legalHold, options) {
			return this.client.sendOperationRequest({
				legalHold,
				options
			}, setLegalHoldOperationSpec);
		}
		setMetadata(options) {
			return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
		}
		acquireLease(options) {
			return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
		}
		releaseLease(leaseId, options) {
			return this.client.sendOperationRequest({
				leaseId,
				options
			}, releaseLeaseOperationSpec);
		}
		renewLease(leaseId, options) {
			return this.client.sendOperationRequest({
				leaseId,
				options
			}, renewLeaseOperationSpec);
		}
		changeLease(leaseId, proposedLeaseId, options) {
			return this.client.sendOperationRequest({
				leaseId,
				proposedLeaseId,
				options
			}, changeLeaseOperationSpec);
		}
		breakLease(options) {
			return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
		}
		createSnapshot(options) {
			return this.client.sendOperationRequest({ options }, createSnapshotOperationSpec);
		}
		startCopyFromURL(copySource, options) {
			return this.client.sendOperationRequest({
				copySource,
				options
			}, startCopyFromURLOperationSpec);
		}
		copyFromURL(copySource, options) {
			return this.client.sendOperationRequest({
				copySource,
				options
			}, copyFromURLOperationSpec);
		}
		abortCopyFromURL(copyId, options) {
			return this.client.sendOperationRequest({
				copyId,
				options
			}, abortCopyFromURLOperationSpec);
		}
		setTier(tier, options) {
			return this.client.sendOperationRequest({
				tier,
				options
			}, setTierOperationSpec);
		}
		getAccountInfo(options) {
			return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
		}
		query(options) {
			return this.client.sendOperationRequest({ options }, queryOperationSpec);
		}
		getTags(options) {
			return this.client.sendOperationRequest({ options }, getTagsOperationSpec);
		}
		setTags(options) {
			return this.client.sendOperationRequest({ options }, setTagsOperationSpec);
		}
	};
	exports.BlobImpl = BlobImpl;
	var xmlSerializer = coreClient.createSerializer(Mappers, true);
	var downloadOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: {
					type: { name: "Stream" },
					serializedName: "parsedResponse"
				},
				headersMapper: Mappers.BlobDownloadHeaders
			},
			206: {
				bodyMapper: {
					type: { name: "Stream" },
					serializedName: "parsedResponse"
				},
				headersMapper: Mappers.BlobDownloadHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobDownloadExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.versionId
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.range,
			Parameters.rangeGetContentMD5,
			Parameters.rangeGetContentCRC64,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getPropertiesOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "HEAD",
		responses: {
			200: { headersMapper: Mappers.BlobGetPropertiesHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobGetPropertiesExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.versionId
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var deleteOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "DELETE",
		responses: {
			202: { headersMapper: Mappers.BlobDeleteHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobDeleteExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.versionId,
			Parameters.blobDeleteType
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.deleteSnapshots
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var undeleteOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobUndeleteHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobUndeleteExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp8],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setExpiryOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobSetExpiryHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobSetExpiryExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp11],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.expiryOptions,
			Parameters.expiresOn
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setHttpHeadersOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobSetHttpHeadersHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobSetHttpHeadersExceptionHeaders
			}
		},
		queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.blobCacheControl,
			Parameters.blobContentType,
			Parameters.blobContentMD5,
			Parameters.blobContentEncoding,
			Parameters.blobContentLanguage,
			Parameters.blobContentDisposition
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setImmutabilityPolicyOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobSetImmutabilityPolicyHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobSetImmutabilityPolicyExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.versionId,
			Parameters.comp12
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifUnmodifiedSince,
			Parameters.immutabilityPolicyExpiry,
			Parameters.immutabilityPolicyMode
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var deleteImmutabilityPolicyOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "DELETE",
		responses: {
			200: { headersMapper: Mappers.BlobDeleteImmutabilityPolicyHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobDeleteImmutabilityPolicyExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.versionId,
			Parameters.comp12
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setLegalHoldOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobSetLegalHoldHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobSetLegalHoldExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.versionId,
			Parameters.comp13
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.legalHold
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setMetadataOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobSetMetadataHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobSetMetadataExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp6],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.encryptionScope
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var acquireLeaseOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.BlobAcquireLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobAcquireLeaseExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.action,
			Parameters.duration,
			Parameters.proposedLeaseId,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var releaseLeaseOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobReleaseLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobReleaseLeaseExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.action1,
			Parameters.leaseId1,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var renewLeaseOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobRenewLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobRenewLeaseExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.leaseId1,
			Parameters.action2,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var changeLeaseOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobChangeLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobChangeLeaseExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.leaseId1,
			Parameters.action4,
			Parameters.proposedLeaseId1,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var breakLeaseOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			202: { headersMapper: Mappers.BlobBreakLeaseHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobBreakLeaseExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.action3,
			Parameters.breakPeriod,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var createSnapshotOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.BlobCreateSnapshotHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobCreateSnapshotExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp14],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.encryptionScope
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var startCopyFromURLOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			202: { headersMapper: Mappers.BlobStartCopyFromURLHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobStartCopyFromURLExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.immutabilityPolicyExpiry,
			Parameters.immutabilityPolicyMode,
			Parameters.tier,
			Parameters.rehydratePriority,
			Parameters.sourceIfModifiedSince,
			Parameters.sourceIfUnmodifiedSince,
			Parameters.sourceIfMatch,
			Parameters.sourceIfNoneMatch,
			Parameters.sourceIfTags,
			Parameters.copySource,
			Parameters.blobTagsString,
			Parameters.sealBlob,
			Parameters.legalHold1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var copyFromURLOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			202: { headersMapper: Mappers.BlobCopyFromURLHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobCopyFromURLExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.immutabilityPolicyExpiry,
			Parameters.immutabilityPolicyMode,
			Parameters.encryptionScope,
			Parameters.tier,
			Parameters.sourceIfModifiedSince,
			Parameters.sourceIfUnmodifiedSince,
			Parameters.sourceIfMatch,
			Parameters.sourceIfNoneMatch,
			Parameters.copySource,
			Parameters.blobTagsString,
			Parameters.legalHold1,
			Parameters.xMsRequiresSync,
			Parameters.sourceContentMD5,
			Parameters.copySourceAuthorization,
			Parameters.copySourceTags,
			Parameters.fileRequestIntent
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var abortCopyFromURLOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			204: { headersMapper: Mappers.BlobAbortCopyFromURLHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobAbortCopyFromURLExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.comp15,
			Parameters.copyId
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.copyActionAbortConstant
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setTierOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.BlobSetTierHeaders },
			202: { headersMapper: Mappers.BlobSetTierHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobSetTierExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.versionId,
			Parameters.comp16
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifTags,
			Parameters.rehydratePriority,
			Parameters.tier1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getAccountInfoOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "GET",
		responses: {
			200: { headersMapper: Mappers.BlobGetAccountInfoHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobGetAccountInfoExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.comp,
			Parameters.timeoutInSeconds,
			Parameters.restype1
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var queryOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "POST",
		responses: {
			200: {
				bodyMapper: {
					type: { name: "Stream" },
					serializedName: "parsedResponse"
				},
				headersMapper: Mappers.BlobQueryHeaders
			},
			206: {
				bodyMapper: {
					type: { name: "Stream" },
					serializedName: "parsedResponse"
				},
				headersMapper: Mappers.BlobQueryHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobQueryExceptionHeaders
			}
		},
		requestBody: Parameters.queryRequest,
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.comp17
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.contentType,
			Parameters.accept,
			Parameters.version,
			Parameters.requestId,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "xml",
		serializer: xmlSerializer
	};
	var getTagsOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.BlobTags,
				headersMapper: Mappers.BlobGetTagsHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobGetTagsExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.versionId,
			Parameters.comp18
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var setTagsOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			204: { headersMapper: Mappers.BlobSetTagsHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlobSetTagsExceptionHeaders
			}
		},
		requestBody: Parameters.tags,
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.versionId,
			Parameters.comp18
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.contentType,
			Parameters.accept,
			Parameters.version,
			Parameters.requestId,
			Parameters.leaseId,
			Parameters.ifTags,
			Parameters.transactionalContentMD5,
			Parameters.transactionalContentCrc64
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "xml",
		serializer: xmlSerializer
	};
}));
var require_pageBlob$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PageBlobImpl = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var coreClient = tslib_1.__importStar(require_commonjs$10());
	var Mappers = tslib_1.__importStar(require_mappers());
	var Parameters = tslib_1.__importStar(require_parameters());
	var PageBlobImpl = class {
		client;
		constructor(client) {
			this.client = client;
		}
		create(contentLength, blobContentLength, options) {
			return this.client.sendOperationRequest({
				contentLength,
				blobContentLength,
				options
			}, createOperationSpec);
		}
		uploadPages(contentLength, body, options) {
			return this.client.sendOperationRequest({
				contentLength,
				body,
				options
			}, uploadPagesOperationSpec);
		}
		clearPages(contentLength, options) {
			return this.client.sendOperationRequest({
				contentLength,
				options
			}, clearPagesOperationSpec);
		}
		uploadPagesFromURL(sourceUrl, sourceRange, contentLength, range$1, options) {
			return this.client.sendOperationRequest({
				sourceUrl,
				sourceRange,
				contentLength,
				range: range$1,
				options
			}, uploadPagesFromURLOperationSpec);
		}
		getPageRanges(options) {
			return this.client.sendOperationRequest({ options }, getPageRangesOperationSpec);
		}
		getPageRangesDiff(options) {
			return this.client.sendOperationRequest({ options }, getPageRangesDiffOperationSpec);
		}
		resize(blobContentLength, options) {
			return this.client.sendOperationRequest({
				blobContentLength,
				options
			}, resizeOperationSpec);
		}
		updateSequenceNumber(sequenceNumberAction, options) {
			return this.client.sendOperationRequest({
				sequenceNumberAction,
				options
			}, updateSequenceNumberOperationSpec);
		}
		copyIncremental(copySource, options) {
			return this.client.sendOperationRequest({
				copySource,
				options
			}, copyIncrementalOperationSpec);
		}
	};
	exports.PageBlobImpl = PageBlobImpl;
	var xmlSerializer = coreClient.createSerializer(Mappers, true);
	var createOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.PageBlobCreateHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobCreateExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.contentLength,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.blobCacheControl,
			Parameters.blobContentType,
			Parameters.blobContentMD5,
			Parameters.blobContentEncoding,
			Parameters.blobContentLanguage,
			Parameters.blobContentDisposition,
			Parameters.immutabilityPolicyExpiry,
			Parameters.immutabilityPolicyMode,
			Parameters.encryptionScope,
			Parameters.tier,
			Parameters.blobTagsString,
			Parameters.legalHold1,
			Parameters.blobType,
			Parameters.blobContentLength,
			Parameters.blobSequenceNumber
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var uploadPagesOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.PageBlobUploadPagesHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobUploadPagesExceptionHeaders
			}
		},
		requestBody: Parameters.body1,
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.contentLength,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.range,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.encryptionScope,
			Parameters.transactionalContentMD5,
			Parameters.transactionalContentCrc64,
			Parameters.contentType1,
			Parameters.accept2,
			Parameters.pageWrite,
			Parameters.ifSequenceNumberLessThanOrEqualTo,
			Parameters.ifSequenceNumberLessThan,
			Parameters.ifSequenceNumberEqualTo
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "binary",
		serializer: xmlSerializer
	};
	var clearPagesOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.PageBlobClearPagesHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobClearPagesExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.contentLength,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.range,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.encryptionScope,
			Parameters.ifSequenceNumberLessThanOrEqualTo,
			Parameters.ifSequenceNumberLessThan,
			Parameters.ifSequenceNumberEqualTo,
			Parameters.pageWrite1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var uploadPagesFromURLOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.PageBlobUploadPagesFromURLHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobUploadPagesFromURLExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.contentLength,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.encryptionScope,
			Parameters.sourceIfModifiedSince,
			Parameters.sourceIfUnmodifiedSince,
			Parameters.sourceIfMatch,
			Parameters.sourceIfNoneMatch,
			Parameters.sourceContentMD5,
			Parameters.copySourceAuthorization,
			Parameters.fileRequestIntent,
			Parameters.pageWrite,
			Parameters.ifSequenceNumberLessThanOrEqualTo,
			Parameters.ifSequenceNumberLessThan,
			Parameters.ifSequenceNumberEqualTo,
			Parameters.sourceUrl,
			Parameters.sourceRange,
			Parameters.sourceContentCrc64,
			Parameters.range1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getPageRangesOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.PageList,
				headersMapper: Mappers.PageBlobGetPageRangesHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobGetPageRangesExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.marker,
			Parameters.maxPageSize,
			Parameters.snapshot,
			Parameters.comp20
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.range,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var getPageRangesDiffOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.PageList,
				headersMapper: Mappers.PageBlobGetPageRangesDiffHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobGetPageRangesDiffExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.marker,
			Parameters.maxPageSize,
			Parameters.snapshot,
			Parameters.comp20,
			Parameters.prevsnapshot
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.range,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.prevSnapshotUrl
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var resizeOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.PageBlobResizeHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobResizeExceptionHeaders
			}
		},
		queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.encryptionScope,
			Parameters.blobContentLength
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var updateSequenceNumberOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.PageBlobUpdateSequenceNumberHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobUpdateSequenceNumberExceptionHeaders
			}
		},
		queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.blobSequenceNumber,
			Parameters.sequenceNumberAction
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var copyIncrementalOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			202: { headersMapper: Mappers.PageBlobCopyIncrementalHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.PageBlobCopyIncrementalExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp21],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.copySource
		],
		isXML: true,
		serializer: xmlSerializer
	};
}));
var require_appendBlob$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AppendBlobImpl = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var coreClient = tslib_1.__importStar(require_commonjs$10());
	var Mappers = tslib_1.__importStar(require_mappers());
	var Parameters = tslib_1.__importStar(require_parameters());
	var AppendBlobImpl = class {
		client;
		constructor(client) {
			this.client = client;
		}
		create(contentLength, options) {
			return this.client.sendOperationRequest({
				contentLength,
				options
			}, createOperationSpec);
		}
		appendBlock(contentLength, body, options) {
			return this.client.sendOperationRequest({
				contentLength,
				body,
				options
			}, appendBlockOperationSpec);
		}
		appendBlockFromUrl(sourceUrl, contentLength, options) {
			return this.client.sendOperationRequest({
				sourceUrl,
				contentLength,
				options
			}, appendBlockFromUrlOperationSpec);
		}
		seal(options) {
			return this.client.sendOperationRequest({ options }, sealOperationSpec);
		}
	};
	exports.AppendBlobImpl = AppendBlobImpl;
	var xmlSerializer = coreClient.createSerializer(Mappers, true);
	var createOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.AppendBlobCreateHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.AppendBlobCreateExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.contentLength,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.blobCacheControl,
			Parameters.blobContentType,
			Parameters.blobContentMD5,
			Parameters.blobContentEncoding,
			Parameters.blobContentLanguage,
			Parameters.blobContentDisposition,
			Parameters.immutabilityPolicyExpiry,
			Parameters.immutabilityPolicyMode,
			Parameters.encryptionScope,
			Parameters.blobTagsString,
			Parameters.legalHold1,
			Parameters.blobType1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var appendBlockOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.AppendBlobAppendBlockHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.AppendBlobAppendBlockExceptionHeaders
			}
		},
		requestBody: Parameters.body1,
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.contentLength,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.encryptionScope,
			Parameters.transactionalContentMD5,
			Parameters.transactionalContentCrc64,
			Parameters.contentType1,
			Parameters.accept2,
			Parameters.maxSize,
			Parameters.appendPosition
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "binary",
		serializer: xmlSerializer
	};
	var appendBlockFromUrlOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.AppendBlobAppendBlockFromUrlHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.AppendBlobAppendBlockFromUrlExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.contentLength,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.encryptionScope,
			Parameters.sourceIfModifiedSince,
			Parameters.sourceIfUnmodifiedSince,
			Parameters.sourceIfMatch,
			Parameters.sourceIfNoneMatch,
			Parameters.sourceContentMD5,
			Parameters.copySourceAuthorization,
			Parameters.fileRequestIntent,
			Parameters.transactionalContentMD5,
			Parameters.sourceUrl,
			Parameters.sourceContentCrc64,
			Parameters.maxSize,
			Parameters.appendPosition,
			Parameters.sourceRange1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var sealOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			200: { headersMapper: Mappers.AppendBlobSealHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.AppendBlobSealExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp23],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.appendPosition
		],
		isXML: true,
		serializer: xmlSerializer
	};
}));
var require_blockBlob$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlockBlobImpl = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var coreClient = tslib_1.__importStar(require_commonjs$10());
	var Mappers = tslib_1.__importStar(require_mappers());
	var Parameters = tslib_1.__importStar(require_parameters());
	var BlockBlobImpl = class {
		client;
		constructor(client) {
			this.client = client;
		}
		upload(contentLength, body, options) {
			return this.client.sendOperationRequest({
				contentLength,
				body,
				options
			}, uploadOperationSpec);
		}
		putBlobFromUrl(contentLength, copySource, options) {
			return this.client.sendOperationRequest({
				contentLength,
				copySource,
				options
			}, putBlobFromUrlOperationSpec);
		}
		stageBlock(blockId, contentLength, body, options) {
			return this.client.sendOperationRequest({
				blockId,
				contentLength,
				body,
				options
			}, stageBlockOperationSpec);
		}
		stageBlockFromURL(blockId, contentLength, sourceUrl, options) {
			return this.client.sendOperationRequest({
				blockId,
				contentLength,
				sourceUrl,
				options
			}, stageBlockFromURLOperationSpec);
		}
		commitBlockList(blocks, options) {
			return this.client.sendOperationRequest({
				blocks,
				options
			}, commitBlockListOperationSpec);
		}
		getBlockList(listType, options) {
			return this.client.sendOperationRequest({
				listType,
				options
			}, getBlockListOperationSpec);
		}
	};
	exports.BlockBlobImpl = BlockBlobImpl;
	var xmlSerializer = coreClient.createSerializer(Mappers, true);
	var uploadOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.BlockBlobUploadHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlockBlobUploadExceptionHeaders
			}
		},
		requestBody: Parameters.body1,
		queryParameters: [Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.contentLength,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.blobCacheControl,
			Parameters.blobContentType,
			Parameters.blobContentMD5,
			Parameters.blobContentEncoding,
			Parameters.blobContentLanguage,
			Parameters.blobContentDisposition,
			Parameters.immutabilityPolicyExpiry,
			Parameters.immutabilityPolicyMode,
			Parameters.encryptionScope,
			Parameters.tier,
			Parameters.blobTagsString,
			Parameters.legalHold1,
			Parameters.transactionalContentMD5,
			Parameters.transactionalContentCrc64,
			Parameters.contentType1,
			Parameters.accept2,
			Parameters.blobType2
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "binary",
		serializer: xmlSerializer
	};
	var putBlobFromUrlOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.BlockBlobPutBlobFromUrlHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlockBlobPutBlobFromUrlExceptionHeaders
			}
		},
		queryParameters: [Parameters.timeoutInSeconds],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.contentLength,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.blobCacheControl,
			Parameters.blobContentType,
			Parameters.blobContentMD5,
			Parameters.blobContentEncoding,
			Parameters.blobContentLanguage,
			Parameters.blobContentDisposition,
			Parameters.encryptionScope,
			Parameters.tier,
			Parameters.sourceIfModifiedSince,
			Parameters.sourceIfUnmodifiedSince,
			Parameters.sourceIfMatch,
			Parameters.sourceIfNoneMatch,
			Parameters.sourceIfTags,
			Parameters.copySource,
			Parameters.blobTagsString,
			Parameters.sourceContentMD5,
			Parameters.copySourceAuthorization,
			Parameters.copySourceTags,
			Parameters.fileRequestIntent,
			Parameters.transactionalContentMD5,
			Parameters.blobType2,
			Parameters.copySourceBlobProperties
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var stageBlockOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.BlockBlobStageBlockHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlockBlobStageBlockExceptionHeaders
			}
		},
		requestBody: Parameters.body1,
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.comp24,
			Parameters.blockId
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.contentLength,
			Parameters.leaseId,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.encryptionScope,
			Parameters.transactionalContentMD5,
			Parameters.transactionalContentCrc64,
			Parameters.contentType1,
			Parameters.accept2
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "binary",
		serializer: xmlSerializer
	};
	var stageBlockFromURLOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.BlockBlobStageBlockFromURLHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlockBlobStageBlockFromURLExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.comp24,
			Parameters.blockId
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.contentLength,
			Parameters.leaseId,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.encryptionScope,
			Parameters.sourceIfModifiedSince,
			Parameters.sourceIfUnmodifiedSince,
			Parameters.sourceIfMatch,
			Parameters.sourceIfNoneMatch,
			Parameters.sourceContentMD5,
			Parameters.copySourceAuthorization,
			Parameters.fileRequestIntent,
			Parameters.sourceUrl,
			Parameters.sourceContentCrc64,
			Parameters.sourceRange1
		],
		isXML: true,
		serializer: xmlSerializer
	};
	var commitBlockListOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "PUT",
		responses: {
			201: { headersMapper: Mappers.BlockBlobCommitBlockListHeaders },
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlockBlobCommitBlockListExceptionHeaders
			}
		},
		requestBody: Parameters.blocks,
		queryParameters: [Parameters.timeoutInSeconds, Parameters.comp25],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.contentType,
			Parameters.accept,
			Parameters.version,
			Parameters.requestId,
			Parameters.metadata,
			Parameters.leaseId,
			Parameters.ifModifiedSince,
			Parameters.ifUnmodifiedSince,
			Parameters.encryptionKey,
			Parameters.encryptionKeySha256,
			Parameters.encryptionAlgorithm,
			Parameters.ifMatch,
			Parameters.ifNoneMatch,
			Parameters.ifTags,
			Parameters.blobCacheControl,
			Parameters.blobContentType,
			Parameters.blobContentMD5,
			Parameters.blobContentEncoding,
			Parameters.blobContentLanguage,
			Parameters.blobContentDisposition,
			Parameters.immutabilityPolicyExpiry,
			Parameters.immutabilityPolicyMode,
			Parameters.encryptionScope,
			Parameters.tier,
			Parameters.blobTagsString,
			Parameters.legalHold1,
			Parameters.transactionalContentMD5,
			Parameters.transactionalContentCrc64
		],
		isXML: true,
		contentType: "application/xml; charset=utf-8",
		mediaType: "xml",
		serializer: xmlSerializer
	};
	var getBlockListOperationSpec = {
		path: "/{containerName}/{blob}",
		httpMethod: "GET",
		responses: {
			200: {
				bodyMapper: Mappers.BlockList,
				headersMapper: Mappers.BlockBlobGetBlockListHeaders
			},
			default: {
				bodyMapper: Mappers.StorageError,
				headersMapper: Mappers.BlockBlobGetBlockListExceptionHeaders
			}
		},
		queryParameters: [
			Parameters.timeoutInSeconds,
			Parameters.snapshot,
			Parameters.comp25,
			Parameters.listType
		],
		urlParameters: [Parameters.url],
		headerParameters: [
			Parameters.version,
			Parameters.requestId,
			Parameters.accept1,
			Parameters.leaseId,
			Parameters.ifTags
		],
		isXML: true,
		serializer: xmlSerializer
	};
}));
var require_operations = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	tslib_1.__exportStar(require_service$1(), exports);
	tslib_1.__exportStar(require_container$1(), exports);
	tslib_1.__exportStar(require_blob$1(), exports);
	tslib_1.__exportStar(require_pageBlob$1(), exports);
	tslib_1.__exportStar(require_appendBlob$1(), exports);
	tslib_1.__exportStar(require_blockBlob$1(), exports);
}));
var require_storageClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageClient = void 0;
	var coreHttpCompat = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importStar(require_commonjs$9());
	var index_js_1 = require_operations();
	var StorageClient = class extends coreHttpCompat.ExtendedServiceClient {
		url;
		version;
		constructor(url, options) {
			if (url === void 0) throw new Error("'url' cannot be null");
			if (!options) options = {};
			const defaults = { requestContentType: "application/json; charset=utf-8" };
			const packageDetails = `azsdk-js-azure-storage-blob/12.29.1`;
			const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
			const optionsWithDefaults = {
				...defaults,
				...options,
				userAgentOptions: { userAgentPrefix },
				endpoint: options.endpoint ?? options.baseUri ?? "{url}"
			};
			super(optionsWithDefaults);
			this.url = url;
			this.version = options.version || "2025-11-05";
			this.service = new index_js_1.ServiceImpl(this);
			this.container = new index_js_1.ContainerImpl(this);
			this.blob = new index_js_1.BlobImpl(this);
			this.pageBlob = new index_js_1.PageBlobImpl(this);
			this.appendBlob = new index_js_1.AppendBlobImpl(this);
			this.blockBlob = new index_js_1.BlockBlobImpl(this);
		}
		service;
		container;
		blob;
		pageBlob;
		appendBlob;
		blockBlob;
	};
	exports.StorageClient = StorageClient;
}));
var require_service = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_container = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_blob = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_pageBlob = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_appendBlob = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_blockBlob = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_operationsInterfaces = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	tslib_1.__exportStar(require_service(), exports);
	tslib_1.__exportStar(require_container(), exports);
	tslib_1.__exportStar(require_blob(), exports);
	tslib_1.__exportStar(require_pageBlob(), exports);
	tslib_1.__exportStar(require_appendBlob(), exports);
	tslib_1.__exportStar(require_blockBlob(), exports);
}));
var require_src = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageClient = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	tslib_1.__exportStar(require_models$1(), exports);
	var storageClient_js_1 = require_storageClient();
	Object.defineProperty(exports, "StorageClient", {
		enumerable: true,
		get: function() {
			return storageClient_js_1.StorageClient;
		}
	});
	tslib_1.__exportStar(require_operationsInterfaces(), exports);
}));
var require_StorageContextClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageContextClient = void 0;
	var index_js_1 = require_src();
	var StorageContextClient = class extends index_js_1.StorageClient {
		async sendOperationRequest(operationArguments, operationSpec) {
			const operationSpecToSend = { ...operationSpec };
			if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}") operationSpecToSend.path = "";
			return super.sendOperationRequest(operationArguments, operationSpecToSend);
		}
	};
	exports.StorageContextClient = StorageContextClient;
}));
var require_StorageClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageClient = void 0;
	var StorageContextClient_js_1 = require_StorageContextClient();
	var Pipeline_js_1 = require_Pipeline();
	var utils_common_js_1 = require_utils_common$2();
	var StorageClient = class {
		url;
		accountName;
		pipeline;
		credential;
		storageClientContext;
		isHttps;
		constructor(url, pipeline) {
			this.url = (0, utils_common_js_1.escapeURLPath)(url);
			this.accountName = (0, utils_common_js_1.getAccountNameFromUrl)(url);
			this.pipeline = pipeline;
			this.storageClientContext = new StorageContextClient_js_1.StorageContextClient(this.url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline));
			this.isHttps = (0, utils_common_js_1.iEqual)((0, utils_common_js_1.getURLScheme)(this.url) || "", "https");
			this.credential = (0, Pipeline_js_1.getCredentialFromPipeline)(pipeline);
			const storageClientContext = this.storageClientContext;
			storageClientContext.requestContentType = void 0;
		}
	};
	exports.StorageClient = StorageClient;
}));
var require_tracing = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.tracingClient = void 0;
	var core_tracing_1 = require_commonjs$13();
	var constants_js_1 = require_constants$4();
	exports.tracingClient = (0, core_tracing_1.createTracingClient)({
		packageName: "@azure/storage-blob",
		packageVersion: constants_js_1.SDK_VERSION,
		namespace: "Microsoft.Storage"
	});
}));
var require_BlobSASPermissions = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobSASPermissions = void 0;
	exports.BlobSASPermissions = class BlobSASPermissions {
		static parse(permissions) {
			const blobSASPermissions = new BlobSASPermissions();
			for (const char of permissions) switch (char) {
				case "r":
					blobSASPermissions.read = true;
					break;
				case "a":
					blobSASPermissions.add = true;
					break;
				case "c":
					blobSASPermissions.create = true;
					break;
				case "w":
					blobSASPermissions.write = true;
					break;
				case "d":
					blobSASPermissions.delete = true;
					break;
				case "x":
					blobSASPermissions.deleteVersion = true;
					break;
				case "t":
					blobSASPermissions.tag = true;
					break;
				case "m":
					blobSASPermissions.move = true;
					break;
				case "e":
					blobSASPermissions.execute = true;
					break;
				case "i":
					blobSASPermissions.setImmutabilityPolicy = true;
					break;
				case "y":
					blobSASPermissions.permanentDelete = true;
					break;
				default: throw new RangeError(`Invalid permission: ${char}`);
			}
			return blobSASPermissions;
		}
		static from(permissionLike) {
			const blobSASPermissions = new BlobSASPermissions();
			if (permissionLike.read) blobSASPermissions.read = true;
			if (permissionLike.add) blobSASPermissions.add = true;
			if (permissionLike.create) blobSASPermissions.create = true;
			if (permissionLike.write) blobSASPermissions.write = true;
			if (permissionLike.delete) blobSASPermissions.delete = true;
			if (permissionLike.deleteVersion) blobSASPermissions.deleteVersion = true;
			if (permissionLike.tag) blobSASPermissions.tag = true;
			if (permissionLike.move) blobSASPermissions.move = true;
			if (permissionLike.execute) blobSASPermissions.execute = true;
			if (permissionLike.setImmutabilityPolicy) blobSASPermissions.setImmutabilityPolicy = true;
			if (permissionLike.permanentDelete) blobSASPermissions.permanentDelete = true;
			return blobSASPermissions;
		}
		read = false;
		add = false;
		create = false;
		write = false;
		delete = false;
		deleteVersion = false;
		tag = false;
		move = false;
		execute = false;
		setImmutabilityPolicy = false;
		permanentDelete = false;
		toString() {
			const permissions = [];
			if (this.read) permissions.push("r");
			if (this.add) permissions.push("a");
			if (this.create) permissions.push("c");
			if (this.write) permissions.push("w");
			if (this.delete) permissions.push("d");
			if (this.deleteVersion) permissions.push("x");
			if (this.tag) permissions.push("t");
			if (this.move) permissions.push("m");
			if (this.execute) permissions.push("e");
			if (this.setImmutabilityPolicy) permissions.push("i");
			if (this.permanentDelete) permissions.push("y");
			return permissions.join("");
		}
	};
}));
var require_ContainerSASPermissions = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ContainerSASPermissions = void 0;
	exports.ContainerSASPermissions = class ContainerSASPermissions {
		static parse(permissions) {
			const containerSASPermissions = new ContainerSASPermissions();
			for (const char of permissions) switch (char) {
				case "r":
					containerSASPermissions.read = true;
					break;
				case "a":
					containerSASPermissions.add = true;
					break;
				case "c":
					containerSASPermissions.create = true;
					break;
				case "w":
					containerSASPermissions.write = true;
					break;
				case "d":
					containerSASPermissions.delete = true;
					break;
				case "l":
					containerSASPermissions.list = true;
					break;
				case "t":
					containerSASPermissions.tag = true;
					break;
				case "x":
					containerSASPermissions.deleteVersion = true;
					break;
				case "m":
					containerSASPermissions.move = true;
					break;
				case "e":
					containerSASPermissions.execute = true;
					break;
				case "i":
					containerSASPermissions.setImmutabilityPolicy = true;
					break;
				case "y":
					containerSASPermissions.permanentDelete = true;
					break;
				case "f":
					containerSASPermissions.filterByTags = true;
					break;
				default: throw new RangeError(`Invalid permission ${char}`);
			}
			return containerSASPermissions;
		}
		static from(permissionLike) {
			const containerSASPermissions = new ContainerSASPermissions();
			if (permissionLike.read) containerSASPermissions.read = true;
			if (permissionLike.add) containerSASPermissions.add = true;
			if (permissionLike.create) containerSASPermissions.create = true;
			if (permissionLike.write) containerSASPermissions.write = true;
			if (permissionLike.delete) containerSASPermissions.delete = true;
			if (permissionLike.list) containerSASPermissions.list = true;
			if (permissionLike.deleteVersion) containerSASPermissions.deleteVersion = true;
			if (permissionLike.tag) containerSASPermissions.tag = true;
			if (permissionLike.move) containerSASPermissions.move = true;
			if (permissionLike.execute) containerSASPermissions.execute = true;
			if (permissionLike.setImmutabilityPolicy) containerSASPermissions.setImmutabilityPolicy = true;
			if (permissionLike.permanentDelete) containerSASPermissions.permanentDelete = true;
			if (permissionLike.filterByTags) containerSASPermissions.filterByTags = true;
			return containerSASPermissions;
		}
		read = false;
		add = false;
		create = false;
		write = false;
		delete = false;
		deleteVersion = false;
		list = false;
		tag = false;
		move = false;
		execute = false;
		setImmutabilityPolicy = false;
		permanentDelete = false;
		filterByTags = false;
		toString() {
			const permissions = [];
			if (this.read) permissions.push("r");
			if (this.add) permissions.push("a");
			if (this.create) permissions.push("c");
			if (this.write) permissions.push("w");
			if (this.delete) permissions.push("d");
			if (this.deleteVersion) permissions.push("x");
			if (this.list) permissions.push("l");
			if (this.tag) permissions.push("t");
			if (this.move) permissions.push("m");
			if (this.execute) permissions.push("e");
			if (this.setImmutabilityPolicy) permissions.push("i");
			if (this.permanentDelete) permissions.push("y");
			if (this.filterByTags) permissions.push("f");
			return permissions.join("");
		}
	};
}));
var require_UserDelegationKeyCredential = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.UserDelegationKeyCredential = void 0;
	var node_crypto_1 = __require("node:crypto");
	var UserDelegationKeyCredential = class {
		accountName;
		userDelegationKey;
		key;
		constructor(accountName, userDelegationKey) {
			this.accountName = accountName;
			this.userDelegationKey = userDelegationKey;
			this.key = Buffer.from(userDelegationKey.value, "base64");
		}
		computeHMACSHA256(stringToSign) {
			return (0, node_crypto_1.createHmac)("sha256", this.key).update(stringToSign, "utf8").digest("base64");
		}
	};
	exports.UserDelegationKeyCredential = UserDelegationKeyCredential;
}));
var require_SasIPRange = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ipRangeToString = ipRangeToString;
	function ipRangeToString(ipRange) {
		return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
	}
}));
var require_SASQueryParameters = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SASQueryParameters = exports.SASProtocol = void 0;
	var SasIPRange_js_1 = require_SasIPRange();
	var utils_common_js_1 = require_utils_common$2();
	var SASProtocol;
	(function(SASProtocol) {
		SASProtocol["Https"] = "https";
		SASProtocol["HttpsAndHttp"] = "https,http";
	})(SASProtocol || (exports.SASProtocol = SASProtocol = {}));
	var SASQueryParameters = class {
		version;
		protocol;
		startsOn;
		expiresOn;
		permissions;
		services;
		resourceTypes;
		identifier;
		encryptionScope;
		resource;
		signature;
		cacheControl;
		contentDisposition;
		contentEncoding;
		contentLanguage;
		contentType;
		ipRangeInner;
		signedOid;
		signedTenantId;
		signedStartsOn;
		signedExpiresOn;
		signedService;
		signedVersion;
		preauthorizedAgentObjectId;
		correlationId;
		get ipRange() {
			if (this.ipRangeInner) return {
				end: this.ipRangeInner.end,
				start: this.ipRangeInner.start
			};
		}
		constructor(version$1, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope) {
			this.version = version$1;
			this.signature = signature;
			if (permissionsOrOptions !== void 0 && typeof permissionsOrOptions !== "string") {
				this.permissions = permissionsOrOptions.permissions;
				this.services = permissionsOrOptions.services;
				this.resourceTypes = permissionsOrOptions.resourceTypes;
				this.protocol = permissionsOrOptions.protocol;
				this.startsOn = permissionsOrOptions.startsOn;
				this.expiresOn = permissionsOrOptions.expiresOn;
				this.ipRangeInner = permissionsOrOptions.ipRange;
				this.identifier = permissionsOrOptions.identifier;
				this.encryptionScope = permissionsOrOptions.encryptionScope;
				this.resource = permissionsOrOptions.resource;
				this.cacheControl = permissionsOrOptions.cacheControl;
				this.contentDisposition = permissionsOrOptions.contentDisposition;
				this.contentEncoding = permissionsOrOptions.contentEncoding;
				this.contentLanguage = permissionsOrOptions.contentLanguage;
				this.contentType = permissionsOrOptions.contentType;
				if (permissionsOrOptions.userDelegationKey) {
					this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
					this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
					this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
					this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
					this.signedService = permissionsOrOptions.userDelegationKey.signedService;
					this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
					this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
					this.correlationId = permissionsOrOptions.correlationId;
				}
			} else {
				this.services = services;
				this.resourceTypes = resourceTypes;
				this.expiresOn = expiresOn;
				this.permissions = permissionsOrOptions;
				this.protocol = protocol;
				this.startsOn = startsOn;
				this.ipRangeInner = ipRange;
				this.encryptionScope = encryptionScope;
				this.identifier = identifier;
				this.resource = resource;
				this.cacheControl = cacheControl;
				this.contentDisposition = contentDisposition;
				this.contentEncoding = contentEncoding;
				this.contentLanguage = contentLanguage;
				this.contentType = contentType;
				if (userDelegationKey) {
					this.signedOid = userDelegationKey.signedObjectId;
					this.signedTenantId = userDelegationKey.signedTenantId;
					this.signedStartsOn = userDelegationKey.signedStartsOn;
					this.signedExpiresOn = userDelegationKey.signedExpiresOn;
					this.signedService = userDelegationKey.signedService;
					this.signedVersion = userDelegationKey.signedVersion;
					this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
					this.correlationId = correlationId;
				}
			}
		}
		toString() {
			const params = [
				"sv",
				"ss",
				"srt",
				"spr",
				"st",
				"se",
				"sip",
				"si",
				"ses",
				"skoid",
				"sktid",
				"skt",
				"ske",
				"sks",
				"skv",
				"sr",
				"sp",
				"sig",
				"rscc",
				"rscd",
				"rsce",
				"rscl",
				"rsct",
				"saoid",
				"scid"
			];
			const queries = [];
			for (const param of params) switch (param) {
				case "sv":
					this.tryAppendQueryParameter(queries, param, this.version);
					break;
				case "ss":
					this.tryAppendQueryParameter(queries, param, this.services);
					break;
				case "srt":
					this.tryAppendQueryParameter(queries, param, this.resourceTypes);
					break;
				case "spr":
					this.tryAppendQueryParameter(queries, param, this.protocol);
					break;
				case "st":
					this.tryAppendQueryParameter(queries, param, this.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.startsOn, false) : void 0);
					break;
				case "se":
					this.tryAppendQueryParameter(queries, param, this.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.expiresOn, false) : void 0);
					break;
				case "sip":
					this.tryAppendQueryParameter(queries, param, this.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(this.ipRange) : void 0);
					break;
				case "si":
					this.tryAppendQueryParameter(queries, param, this.identifier);
					break;
				case "ses":
					this.tryAppendQueryParameter(queries, param, this.encryptionScope);
					break;
				case "skoid":
					this.tryAppendQueryParameter(queries, param, this.signedOid);
					break;
				case "sktid":
					this.tryAppendQueryParameter(queries, param, this.signedTenantId);
					break;
				case "skt":
					this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedStartsOn, false) : void 0);
					break;
				case "ske":
					this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedExpiresOn, false) : void 0);
					break;
				case "sks":
					this.tryAppendQueryParameter(queries, param, this.signedService);
					break;
				case "skv":
					this.tryAppendQueryParameter(queries, param, this.signedVersion);
					break;
				case "sr":
					this.tryAppendQueryParameter(queries, param, this.resource);
					break;
				case "sp":
					this.tryAppendQueryParameter(queries, param, this.permissions);
					break;
				case "sig":
					this.tryAppendQueryParameter(queries, param, this.signature);
					break;
				case "rscc":
					this.tryAppendQueryParameter(queries, param, this.cacheControl);
					break;
				case "rscd":
					this.tryAppendQueryParameter(queries, param, this.contentDisposition);
					break;
				case "rsce":
					this.tryAppendQueryParameter(queries, param, this.contentEncoding);
					break;
				case "rscl":
					this.tryAppendQueryParameter(queries, param, this.contentLanguage);
					break;
				case "rsct":
					this.tryAppendQueryParameter(queries, param, this.contentType);
					break;
				case "saoid":
					this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
					break;
				case "scid":
					this.tryAppendQueryParameter(queries, param, this.correlationId);
					break;
			}
			return queries.join("&");
		}
		tryAppendQueryParameter(queries, key, value$1) {
			if (!value$1) return;
			key = encodeURIComponent(key);
			value$1 = encodeURIComponent(value$1);
			if (key.length > 0 && value$1.length > 0) queries.push(`${key}=${value$1}`);
		}
	};
	exports.SASQueryParameters = SASQueryParameters;
}));
var require_BlobSASSignatureValues = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateBlobSASQueryParameters = generateBlobSASQueryParameters;
	exports.generateBlobSASQueryParametersInternal = generateBlobSASQueryParametersInternal;
	var BlobSASPermissions_js_1 = require_BlobSASPermissions();
	var ContainerSASPermissions_js_1 = require_ContainerSASPermissions();
	var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential$1();
	var UserDelegationKeyCredential_js_1 = require_UserDelegationKeyCredential();
	var SasIPRange_js_1 = require_SasIPRange();
	var SASQueryParameters_js_1 = require_SASQueryParameters();
	var constants_js_1 = require_constants$4();
	var utils_common_js_1 = require_utils_common$2();
	function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
		return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;
	}
	function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
		const version$1 = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
		const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : void 0;
		let userDelegationKeyCredential;
		if (sharedKeyCredential === void 0 && accountName !== void 0) userDelegationKeyCredential = new UserDelegationKeyCredential_js_1.UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
		if (sharedKeyCredential === void 0 && userDelegationKeyCredential === void 0) throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
		if (version$1 >= "2020-12-06") if (sharedKeyCredential !== void 0) return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
		else if (version$1 >= "2025-07-05") return generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential);
		else return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
		if (version$1 >= "2018-11-09") if (sharedKeyCredential !== void 0) return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
		else if (version$1 >= "2020-02-10") return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
		else return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
		if (version$1 >= "2015-04-05") if (sharedKeyCredential !== void 0) return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
		else throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
		throw new RangeError("'version' must be >= '2015-04-05'.");
	}
	function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
		blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
		if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
		let resource = "c";
		if (blobSASSignatureValues.blobName) resource = "b";
		let verifiedPermissions;
		if (blobSASSignatureValues.permissions) if (blobSASSignatureValues.blobName) verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		else verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		const stringToSign = [
			verifiedPermissions ? verifiedPermissions : "",
			blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
			blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
			getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
			blobSASSignatureValues.identifier,
			blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
			blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
			blobSASSignatureValues.version,
			blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
			blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
			blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
			blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
			blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
		].join("\n");
		const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
		return {
			sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
			stringToSign
		};
	}
	function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
		blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
		if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
		let resource = "c";
		let timestamp = blobSASSignatureValues.snapshotTime;
		if (blobSASSignatureValues.blobName) {
			resource = "b";
			if (blobSASSignatureValues.snapshotTime) resource = "bs";
			else if (blobSASSignatureValues.versionId) {
				resource = "bv";
				timestamp = blobSASSignatureValues.versionId;
			}
		}
		let verifiedPermissions;
		if (blobSASSignatureValues.permissions) if (blobSASSignatureValues.blobName) verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		else verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		const stringToSign = [
			verifiedPermissions ? verifiedPermissions : "",
			blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
			blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
			getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
			blobSASSignatureValues.identifier,
			blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
			blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
			blobSASSignatureValues.version,
			resource,
			timestamp,
			blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
			blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
			blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
			blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
			blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
		].join("\n");
		const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
		return {
			sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
			stringToSign
		};
	}
	function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
		blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
		if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
		let resource = "c";
		let timestamp = blobSASSignatureValues.snapshotTime;
		if (blobSASSignatureValues.blobName) {
			resource = "b";
			if (blobSASSignatureValues.snapshotTime) resource = "bs";
			else if (blobSASSignatureValues.versionId) {
				resource = "bv";
				timestamp = blobSASSignatureValues.versionId;
			}
		}
		let verifiedPermissions;
		if (blobSASSignatureValues.permissions) if (blobSASSignatureValues.blobName) verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		else verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		const stringToSign = [
			verifiedPermissions ? verifiedPermissions : "",
			blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
			blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
			getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
			blobSASSignatureValues.identifier,
			blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
			blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
			blobSASSignatureValues.version,
			resource,
			timestamp,
			blobSASSignatureValues.encryptionScope,
			blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
			blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
			blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
			blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
			blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
		].join("\n");
		const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
		return {
			sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, void 0, void 0, void 0, blobSASSignatureValues.encryptionScope),
			stringToSign
		};
	}
	function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
		blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
		if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
		let resource = "c";
		let timestamp = blobSASSignatureValues.snapshotTime;
		if (blobSASSignatureValues.blobName) {
			resource = "b";
			if (blobSASSignatureValues.snapshotTime) resource = "bs";
			else if (blobSASSignatureValues.versionId) {
				resource = "bv";
				timestamp = blobSASSignatureValues.versionId;
			}
		}
		let verifiedPermissions;
		if (blobSASSignatureValues.permissions) if (blobSASSignatureValues.blobName) verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		else verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		const stringToSign = [
			verifiedPermissions ? verifiedPermissions : "",
			blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
			blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
			getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
			userDelegationKeyCredential.userDelegationKey.signedObjectId,
			userDelegationKeyCredential.userDelegationKey.signedTenantId,
			userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
			userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
			userDelegationKeyCredential.userDelegationKey.signedService,
			userDelegationKeyCredential.userDelegationKey.signedVersion,
			blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
			blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
			blobSASSignatureValues.version,
			resource,
			timestamp,
			blobSASSignatureValues.cacheControl,
			blobSASSignatureValues.contentDisposition,
			blobSASSignatureValues.contentEncoding,
			blobSASSignatureValues.contentLanguage,
			blobSASSignatureValues.contentType
		].join("\n");
		const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
		return {
			sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),
			stringToSign
		};
	}
	function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
		blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
		if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
		let resource = "c";
		let timestamp = blobSASSignatureValues.snapshotTime;
		if (blobSASSignatureValues.blobName) {
			resource = "b";
			if (blobSASSignatureValues.snapshotTime) resource = "bs";
			else if (blobSASSignatureValues.versionId) {
				resource = "bv";
				timestamp = blobSASSignatureValues.versionId;
			}
		}
		let verifiedPermissions;
		if (blobSASSignatureValues.permissions) if (blobSASSignatureValues.blobName) verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		else verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		const stringToSign = [
			verifiedPermissions ? verifiedPermissions : "",
			blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
			blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
			getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
			userDelegationKeyCredential.userDelegationKey.signedObjectId,
			userDelegationKeyCredential.userDelegationKey.signedTenantId,
			userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
			userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
			userDelegationKeyCredential.userDelegationKey.signedService,
			userDelegationKeyCredential.userDelegationKey.signedVersion,
			blobSASSignatureValues.preauthorizedAgentObjectId,
			void 0,
			blobSASSignatureValues.correlationId,
			blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
			blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
			blobSASSignatureValues.version,
			resource,
			timestamp,
			blobSASSignatureValues.cacheControl,
			blobSASSignatureValues.contentDisposition,
			blobSASSignatureValues.contentEncoding,
			blobSASSignatureValues.contentLanguage,
			blobSASSignatureValues.contentType
		].join("\n");
		const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
		return {
			sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),
			stringToSign
		};
	}
	function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
		blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
		if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
		let resource = "c";
		let timestamp = blobSASSignatureValues.snapshotTime;
		if (blobSASSignatureValues.blobName) {
			resource = "b";
			if (blobSASSignatureValues.snapshotTime) resource = "bs";
			else if (blobSASSignatureValues.versionId) {
				resource = "bv";
				timestamp = blobSASSignatureValues.versionId;
			}
		}
		let verifiedPermissions;
		if (blobSASSignatureValues.permissions) if (blobSASSignatureValues.blobName) verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		else verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		const stringToSign = [
			verifiedPermissions ? verifiedPermissions : "",
			blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
			blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
			getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
			userDelegationKeyCredential.userDelegationKey.signedObjectId,
			userDelegationKeyCredential.userDelegationKey.signedTenantId,
			userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
			userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
			userDelegationKeyCredential.userDelegationKey.signedService,
			userDelegationKeyCredential.userDelegationKey.signedVersion,
			blobSASSignatureValues.preauthorizedAgentObjectId,
			void 0,
			blobSASSignatureValues.correlationId,
			blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
			blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
			blobSASSignatureValues.version,
			resource,
			timestamp,
			blobSASSignatureValues.encryptionScope,
			blobSASSignatureValues.cacheControl,
			blobSASSignatureValues.contentDisposition,
			blobSASSignatureValues.contentEncoding,
			blobSASSignatureValues.contentLanguage,
			blobSASSignatureValues.contentType
		].join("\n");
		const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
		return {
			sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
			stringToSign
		};
	}
	function generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential) {
		blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
		if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
		let resource = "c";
		let timestamp = blobSASSignatureValues.snapshotTime;
		if (blobSASSignatureValues.blobName) {
			resource = "b";
			if (blobSASSignatureValues.snapshotTime) resource = "bs";
			else if (blobSASSignatureValues.versionId) {
				resource = "bv";
				timestamp = blobSASSignatureValues.versionId;
			}
		}
		let verifiedPermissions;
		if (blobSASSignatureValues.permissions) if (blobSASSignatureValues.blobName) verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		else verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
		const stringToSign = [
			verifiedPermissions ? verifiedPermissions : "",
			blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, false) : "",
			blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, false) : "",
			getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
			userDelegationKeyCredential.userDelegationKey.signedObjectId,
			userDelegationKeyCredential.userDelegationKey.signedTenantId,
			userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
			userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
			userDelegationKeyCredential.userDelegationKey.signedService,
			userDelegationKeyCredential.userDelegationKey.signedVersion,
			blobSASSignatureValues.preauthorizedAgentObjectId,
			void 0,
			blobSASSignatureValues.correlationId,
			void 0,
			void 0,
			blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
			blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
			blobSASSignatureValues.version,
			resource,
			timestamp,
			blobSASSignatureValues.encryptionScope,
			blobSASSignatureValues.cacheControl,
			blobSASSignatureValues.contentDisposition,
			blobSASSignatureValues.contentEncoding,
			blobSASSignatureValues.contentLanguage,
			blobSASSignatureValues.contentType
		].join("\n");
		const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
		return {
			sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
			stringToSign
		};
	}
	function getCanonicalName(accountName, containerName, blobName) {
		const elements = [`/blob/${accountName}/${containerName}`];
		if (blobName) elements.push(`/${blobName}`);
		return elements.join("");
	}
	function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
		const version$1 = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
		if (blobSASSignatureValues.snapshotTime && version$1 < "2018-11-09") throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
		if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.snapshotTime) throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
		if (blobSASSignatureValues.versionId && version$1 < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
		if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.versionId) throw RangeError("Must provide 'blobName' when providing 'versionId'.");
		if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version$1 < "2020-08-04") throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
		if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version$1 < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
		if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version$1 < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
		if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version$1 < "2019-12-12") throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
		if (version$1 < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
		if (version$1 < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
		if (version$1 < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
		if (blobSASSignatureValues.encryptionScope && version$1 < "2020-12-06") throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
		blobSASSignatureValues.version = version$1;
		return blobSASSignatureValues;
	}
}));
var require_BlobLeaseClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobLeaseClient = void 0;
	var core_util_1 = require_commonjs$14();
	var constants_js_1 = require_constants$4();
	var tracing_js_1 = require_tracing();
	var utils_common_js_1 = require_utils_common$2();
	var BlobLeaseClient = class {
		_leaseId;
		_url;
		_containerOrBlobOperation;
		_isContainer;
		get leaseId() {
			return this._leaseId;
		}
		get url() {
			return this._url;
		}
		constructor(client, leaseId) {
			const clientContext = client.storageClientContext;
			this._url = client.url;
			if (client.name === void 0) {
				this._isContainer = true;
				this._containerOrBlobOperation = clientContext.container;
			} else {
				this._isContainer = false;
				this._containerOrBlobOperation = clientContext.blob;
			}
			if (!leaseId) leaseId = (0, core_util_1.randomUUID)();
			this._leaseId = leaseId;
		}
		async acquireLease(duration, options = {}) {
			if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
			return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-acquireLease", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.acquireLease({
					abortSignal: options.abortSignal,
					duration,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					proposedLeaseId: this._leaseId,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async changeLease(proposedLeaseId, options = {}) {
			if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
			return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-changeLease", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId, {
					abortSignal: options.abortSignal,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
				this._leaseId = proposedLeaseId;
				return response;
			});
		}
		async releaseLease(options = {}) {
			if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
			return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-releaseLease", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
					abortSignal: options.abortSignal,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async renewLease(options = {}) {
			if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
			return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-renewLease", options, async (updatedOptions) => {
				return this._containerOrBlobOperation.renewLease(this._leaseId, {
					abortSignal: options.abortSignal,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				});
			});
		}
		async breakLease(breakPeriod, options = {}) {
			if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions)) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
			return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-breakLease", options, async (updatedOptions) => {
				const operationOptions = {
					abortSignal: options.abortSignal,
					breakPeriod,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				};
				return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.breakLease(operationOptions));
			});
		}
	};
	exports.BlobLeaseClient = BlobLeaseClient;
}));
var require_RetriableReadableStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.RetriableReadableStream = void 0;
	var abort_controller_1 = require_commonjs$15();
	var node_stream_1$2 = __require("node:stream");
	var RetriableReadableStream = class extends node_stream_1$2.Readable {
		start;
		offset;
		end;
		getter;
		source;
		retries = 0;
		maxRetryRequests;
		onProgress;
		options;
		constructor(source, getter, offset, count, options = {}) {
			super({ highWaterMark: options.highWaterMark });
			this.getter = getter;
			this.source = source;
			this.start = offset;
			this.offset = offset;
			this.end = offset + count - 1;
			this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
			this.onProgress = options.onProgress;
			this.options = options;
			this.setSourceEventHandlers();
		}
		_read() {
			this.source.resume();
		}
		setSourceEventHandlers() {
			this.source.on("data", this.sourceDataHandler);
			this.source.on("end", this.sourceErrorOrEndHandler);
			this.source.on("error", this.sourceErrorOrEndHandler);
			this.source.on("aborted", this.sourceAbortedHandler);
		}
		removeSourceEventHandlers() {
			this.source.removeListener("data", this.sourceDataHandler);
			this.source.removeListener("end", this.sourceErrorOrEndHandler);
			this.source.removeListener("error", this.sourceErrorOrEndHandler);
			this.source.removeListener("aborted", this.sourceAbortedHandler);
		}
		sourceDataHandler = (data) => {
			if (this.options.doInjectErrorOnce) {
				this.options.doInjectErrorOnce = void 0;
				this.source.pause();
				this.sourceErrorOrEndHandler();
				this.source.destroy();
				return;
			}
			this.offset += data.length;
			if (this.onProgress) this.onProgress({ loadedBytes: this.offset - this.start });
			if (!this.push(data)) this.source.pause();
		};
		sourceAbortedHandler = () => {
			const abortError = new abort_controller_1.AbortError("The operation was aborted.");
			this.destroy(abortError);
		};
		sourceErrorOrEndHandler = (err) => {
			if (err && err.name === "AbortError") {
				this.destroy(err);
				return;
			}
			this.removeSourceEventHandlers();
			if (this.offset - 1 === this.end) this.push(null);
			else if (this.offset <= this.end) if (this.retries < this.maxRetryRequests) {
				this.retries += 1;
				this.getter(this.offset).then((newSource) => {
					this.source = newSource;
					this.setSourceEventHandlers();
				}).catch((error) => {
					this.destroy(error);
				});
			} else this.destroy(/* @__PURE__ */ new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
			else this.destroy(/* @__PURE__ */ new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
		};
		_destroy(error, callback) {
			this.removeSourceEventHandlers();
			this.source.destroy();
			callback(error === null ? void 0 : error);
		}
	};
	exports.RetriableReadableStream = RetriableReadableStream;
}));
var require_BlobDownloadResponse = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobDownloadResponse = void 0;
	var core_util_1 = require_commonjs$14();
	var RetriableReadableStream_js_1 = require_RetriableReadableStream();
	var BlobDownloadResponse = class {
		get acceptRanges() {
			return this.originalResponse.acceptRanges;
		}
		get cacheControl() {
			return this.originalResponse.cacheControl;
		}
		get contentDisposition() {
			return this.originalResponse.contentDisposition;
		}
		get contentEncoding() {
			return this.originalResponse.contentEncoding;
		}
		get contentLanguage() {
			return this.originalResponse.contentLanguage;
		}
		get blobSequenceNumber() {
			return this.originalResponse.blobSequenceNumber;
		}
		get blobType() {
			return this.originalResponse.blobType;
		}
		get contentLength() {
			return this.originalResponse.contentLength;
		}
		get contentMD5() {
			return this.originalResponse.contentMD5;
		}
		get contentRange() {
			return this.originalResponse.contentRange;
		}
		get contentType() {
			return this.originalResponse.contentType;
		}
		get copyCompletedOn() {
			return this.originalResponse.copyCompletedOn;
		}
		get copyId() {
			return this.originalResponse.copyId;
		}
		get copyProgress() {
			return this.originalResponse.copyProgress;
		}
		get copySource() {
			return this.originalResponse.copySource;
		}
		get copyStatus() {
			return this.originalResponse.copyStatus;
		}
		get copyStatusDescription() {
			return this.originalResponse.copyStatusDescription;
		}
		get leaseDuration() {
			return this.originalResponse.leaseDuration;
		}
		get leaseState() {
			return this.originalResponse.leaseState;
		}
		get leaseStatus() {
			return this.originalResponse.leaseStatus;
		}
		get date() {
			return this.originalResponse.date;
		}
		get blobCommittedBlockCount() {
			return this.originalResponse.blobCommittedBlockCount;
		}
		get etag() {
			return this.originalResponse.etag;
		}
		get tagCount() {
			return this.originalResponse.tagCount;
		}
		get errorCode() {
			return this.originalResponse.errorCode;
		}
		get isServerEncrypted() {
			return this.originalResponse.isServerEncrypted;
		}
		get blobContentMD5() {
			return this.originalResponse.blobContentMD5;
		}
		get lastModified() {
			return this.originalResponse.lastModified;
		}
		get lastAccessed() {
			return this.originalResponse.lastAccessed;
		}
		get createdOn() {
			return this.originalResponse.createdOn;
		}
		get metadata() {
			return this.originalResponse.metadata;
		}
		get requestId() {
			return this.originalResponse.requestId;
		}
		get clientRequestId() {
			return this.originalResponse.clientRequestId;
		}
		get version() {
			return this.originalResponse.version;
		}
		get versionId() {
			return this.originalResponse.versionId;
		}
		get isCurrentVersion() {
			return this.originalResponse.isCurrentVersion;
		}
		get encryptionKeySha256() {
			return this.originalResponse.encryptionKeySha256;
		}
		get contentCrc64() {
			return this.originalResponse.contentCrc64;
		}
		get objectReplicationDestinationPolicyId() {
			return this.originalResponse.objectReplicationDestinationPolicyId;
		}
		get objectReplicationSourceProperties() {
			return this.originalResponse.objectReplicationSourceProperties;
		}
		get isSealed() {
			return this.originalResponse.isSealed;
		}
		get immutabilityPolicyExpiresOn() {
			return this.originalResponse.immutabilityPolicyExpiresOn;
		}
		get immutabilityPolicyMode() {
			return this.originalResponse.immutabilityPolicyMode;
		}
		get legalHold() {
			return this.originalResponse.legalHold;
		}
		get contentAsBlob() {
			return this.originalResponse.blobBody;
		}
		get readableStreamBody() {
			return core_util_1.isNodeLike ? this.blobDownloadStream : void 0;
		}
		get _response() {
			return this.originalResponse._response;
		}
		originalResponse;
		blobDownloadStream;
		constructor(originalResponse, getter, offset, count, options = {}) {
			this.originalResponse = originalResponse;
			this.blobDownloadStream = new RetriableReadableStream_js_1.RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
		}
	};
	exports.BlobDownloadResponse = BlobDownloadResponse;
}));
var require_AvroConstants = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AVRO_SCHEMA_KEY = exports.AVRO_CODEC_KEY = exports.AVRO_INIT_BYTES = exports.AVRO_SYNC_MARKER_SIZE = void 0;
	exports.AVRO_SYNC_MARKER_SIZE = 16;
	exports.AVRO_INIT_BYTES = new Uint8Array([
		79,
		98,
		106,
		1
	]);
	exports.AVRO_CODEC_KEY = "avro.codec";
	exports.AVRO_SCHEMA_KEY = "avro.schema";
}));
var require_AvroParser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AvroType = exports.AvroParser = void 0;
	var AvroParser = class AvroParser {
		static async readFixedBytes(stream$5, length, options = {}) {
			const bytes = await stream$5.read(length, { abortSignal: options.abortSignal });
			if (bytes.length !== length) throw new Error("Hit stream end.");
			return bytes;
		}
		static async readByte(stream$5, options = {}) {
			return (await AvroParser.readFixedBytes(stream$5, 1, options))[0];
		}
		static async readZigZagLong(stream$5, options = {}) {
			let zigZagEncoded = 0;
			let significanceInBit = 0;
			let byte, haveMoreByte, significanceInFloat;
			do {
				byte = await AvroParser.readByte(stream$5, options);
				haveMoreByte = byte & 128;
				zigZagEncoded |= (byte & 127) << significanceInBit;
				significanceInBit += 7;
			} while (haveMoreByte && significanceInBit < 28);
			if (haveMoreByte) {
				zigZagEncoded = zigZagEncoded;
				significanceInFloat = 268435456;
				do {
					byte = await AvroParser.readByte(stream$5, options);
					zigZagEncoded += (byte & 127) * significanceInFloat;
					significanceInFloat *= 128;
				} while (byte & 128);
				const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
				if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) throw new Error("Integer overflow.");
				return res;
			}
			return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
		}
		static async readLong(stream$5, options = {}) {
			return AvroParser.readZigZagLong(stream$5, options);
		}
		static async readInt(stream$5, options = {}) {
			return AvroParser.readZigZagLong(stream$5, options);
		}
		static async readNull() {
			return null;
		}
		static async readBoolean(stream$5, options = {}) {
			const b = await AvroParser.readByte(stream$5, options);
			if (b === 1) return true;
			else if (b === 0) return false;
			else throw new Error("Byte was not a boolean.");
		}
		static async readFloat(stream$5, options = {}) {
			const u8arr = await AvroParser.readFixedBytes(stream$5, 4, options);
			return new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength).getFloat32(0, true);
		}
		static async readDouble(stream$5, options = {}) {
			const u8arr = await AvroParser.readFixedBytes(stream$5, 8, options);
			return new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength).getFloat64(0, true);
		}
		static async readBytes(stream$5, options = {}) {
			const size = await AvroParser.readLong(stream$5, options);
			if (size < 0) throw new Error("Bytes size was negative.");
			return stream$5.read(size, { abortSignal: options.abortSignal });
		}
		static async readString(stream$5, options = {}) {
			const u8arr = await AvroParser.readBytes(stream$5, options);
			return new TextDecoder().decode(u8arr);
		}
		static async readMapPair(stream$5, readItemMethod, options = {}) {
			return {
				key: await AvroParser.readString(stream$5, options),
				value: await readItemMethod(stream$5, options)
			};
		}
		static async readMap(stream$5, readItemMethod, options = {}) {
			const readPairMethod = (s, opts = {}) => {
				return AvroParser.readMapPair(s, readItemMethod, opts);
			};
			const pairs = await AvroParser.readArray(stream$5, readPairMethod, options);
			const dict = {};
			for (const pair of pairs) dict[pair.key] = pair.value;
			return dict;
		}
		static async readArray(stream$5, readItemMethod, options = {}) {
			const items = [];
			for (let count = await AvroParser.readLong(stream$5, options); count !== 0; count = await AvroParser.readLong(stream$5, options)) {
				if (count < 0) {
					await AvroParser.readLong(stream$5, options);
					count = -count;
				}
				while (count--) {
					const item = await readItemMethod(stream$5, options);
					items.push(item);
				}
			}
			return items;
		}
	};
	exports.AvroParser = AvroParser;
	var AvroComplex;
	(function(AvroComplex) {
		AvroComplex["RECORD"] = "record";
		AvroComplex["ENUM"] = "enum";
		AvroComplex["ARRAY"] = "array";
		AvroComplex["MAP"] = "map";
		AvroComplex["UNION"] = "union";
		AvroComplex["FIXED"] = "fixed";
	})(AvroComplex || (AvroComplex = {}));
	var AvroPrimitive;
	(function(AvroPrimitive) {
		AvroPrimitive["NULL"] = "null";
		AvroPrimitive["BOOLEAN"] = "boolean";
		AvroPrimitive["INT"] = "int";
		AvroPrimitive["LONG"] = "long";
		AvroPrimitive["FLOAT"] = "float";
		AvroPrimitive["DOUBLE"] = "double";
		AvroPrimitive["BYTES"] = "bytes";
		AvroPrimitive["STRING"] = "string";
	})(AvroPrimitive || (AvroPrimitive = {}));
	var AvroType = class AvroType {
		static fromSchema(schema) {
			if (typeof schema === "string") return AvroType.fromStringSchema(schema);
			else if (Array.isArray(schema)) return AvroType.fromArraySchema(schema);
			else return AvroType.fromObjectSchema(schema);
		}
		static fromStringSchema(schema) {
			switch (schema) {
				case AvroPrimitive.NULL:
				case AvroPrimitive.BOOLEAN:
				case AvroPrimitive.INT:
				case AvroPrimitive.LONG:
				case AvroPrimitive.FLOAT:
				case AvroPrimitive.DOUBLE:
				case AvroPrimitive.BYTES:
				case AvroPrimitive.STRING: return new AvroPrimitiveType(schema);
				default: throw new Error(`Unexpected Avro type ${schema}`);
			}
		}
		static fromArraySchema(schema) {
			return new AvroUnionType(schema.map(AvroType.fromSchema));
		}
		static fromObjectSchema(schema) {
			const type = schema.type;
			try {
				return AvroType.fromStringSchema(type);
			} catch {}
			switch (type) {
				case AvroComplex.RECORD:
					if (schema.aliases) throw new Error(`aliases currently is not supported, schema: ${schema}`);
					if (!schema.name) throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
					const fields = {};
					if (!schema.fields) throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
					for (const field of schema.fields) fields[field.name] = AvroType.fromSchema(field.type);
					return new AvroRecordType(fields, schema.name);
				case AvroComplex.ENUM:
					if (schema.aliases) throw new Error(`aliases currently is not supported, schema: ${schema}`);
					if (!schema.symbols) throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
					return new AvroEnumType(schema.symbols);
				case AvroComplex.MAP:
					if (!schema.values) throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
					return new AvroMapType(AvroType.fromSchema(schema.values));
				case AvroComplex.ARRAY:
				case AvroComplex.FIXED:
				default: throw new Error(`Unexpected Avro type ${type} in ${schema}`);
			}
		}
	};
	exports.AvroType = AvroType;
	var AvroPrimitiveType = class extends AvroType {
		_primitive;
		constructor(primitive) {
			super();
			this._primitive = primitive;
		}
		read(stream$5, options = {}) {
			switch (this._primitive) {
				case AvroPrimitive.NULL: return AvroParser.readNull();
				case AvroPrimitive.BOOLEAN: return AvroParser.readBoolean(stream$5, options);
				case AvroPrimitive.INT: return AvroParser.readInt(stream$5, options);
				case AvroPrimitive.LONG: return AvroParser.readLong(stream$5, options);
				case AvroPrimitive.FLOAT: return AvroParser.readFloat(stream$5, options);
				case AvroPrimitive.DOUBLE: return AvroParser.readDouble(stream$5, options);
				case AvroPrimitive.BYTES: return AvroParser.readBytes(stream$5, options);
				case AvroPrimitive.STRING: return AvroParser.readString(stream$5, options);
				default: throw new Error("Unknown Avro Primitive");
			}
		}
	};
	var AvroEnumType = class extends AvroType {
		_symbols;
		constructor(symbols) {
			super();
			this._symbols = symbols;
		}
		async read(stream$5, options = {}) {
			const value$1 = await AvroParser.readInt(stream$5, options);
			return this._symbols[value$1];
		}
	};
	var AvroUnionType = class extends AvroType {
		_types;
		constructor(types$1) {
			super();
			this._types = types$1;
		}
		async read(stream$5, options = {}) {
			const typeIndex = await AvroParser.readInt(stream$5, options);
			return this._types[typeIndex].read(stream$5, options);
		}
	};
	var AvroMapType = class extends AvroType {
		_itemType;
		constructor(itemType) {
			super();
			this._itemType = itemType;
		}
		read(stream$5, options = {}) {
			const readItemMethod = (s, opts) => {
				return this._itemType.read(s, opts);
			};
			return AvroParser.readMap(stream$5, readItemMethod, options);
		}
	};
	var AvroRecordType = class extends AvroType {
		_name;
		_fields;
		constructor(fields, name$1) {
			super();
			this._fields = fields;
			this._name = name$1;
		}
		async read(stream$5, options = {}) {
			const record = {};
			record["$schema"] = this._name;
			for (const key in this._fields) if (Object.prototype.hasOwnProperty.call(this._fields, key)) record[key] = await this._fields[key].read(stream$5, options);
			return record;
		}
	};
}));
var require_utils_common = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.arraysEqual = arraysEqual;
	function arraysEqual(a, b) {
		if (a === b) return true;
		if (a == null || b == null) return false;
		if (a.length !== b.length) return false;
		for (let i = 0; i < a.length; ++i) if (a[i] !== b[i]) return false;
		return true;
	}
}));
var require_AvroReader = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AvroReader = void 0;
	var AvroConstants_js_1 = require_AvroConstants();
	var AvroParser_js_1 = require_AvroParser();
	var utils_common_js_1 = require_utils_common();
	var AvroReader = class {
		_dataStream;
		_headerStream;
		_syncMarker;
		_metadata;
		_itemType;
		_itemsRemainingInBlock;
		_initialBlockOffset;
		_blockOffset;
		get blockOffset() {
			return this._blockOffset;
		}
		_objectIndex;
		get objectIndex() {
			return this._objectIndex;
		}
		_initialized;
		constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
			this._dataStream = dataStream;
			this._headerStream = headerStream || dataStream;
			this._initialized = false;
			this._blockOffset = currentBlockOffset || 0;
			this._objectIndex = indexWithinCurrentBlock || 0;
			this._initialBlockOffset = currentBlockOffset || 0;
		}
		async initialize(options = {}) {
			const header = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_INIT_BYTES.length, { abortSignal: options.abortSignal });
			if (!(0, utils_common_js_1.arraysEqual)(header, AvroConstants_js_1.AVRO_INIT_BYTES)) throw new Error("Stream is not an Avro file.");
			this._metadata = await AvroParser_js_1.AvroParser.readMap(this._headerStream, AvroParser_js_1.AvroParser.readString, { abortSignal: options.abortSignal });
			const codec = this._metadata[AvroConstants_js_1.AVRO_CODEC_KEY];
			if (!(codec === void 0 || codec === null || codec === "null")) throw new Error("Codecs are not supported");
			this._syncMarker = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, { abortSignal: options.abortSignal });
			const schema = JSON.parse(this._metadata[AvroConstants_js_1.AVRO_SCHEMA_KEY]);
			this._itemType = AvroParser_js_1.AvroType.fromSchema(schema);
			if (this._blockOffset === 0) this._blockOffset = this._initialBlockOffset + this._dataStream.position;
			this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
			await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
			this._initialized = true;
			if (this._objectIndex && this._objectIndex > 0) for (let i = 0; i < this._objectIndex; i++) {
				await this._itemType.read(this._dataStream, { abortSignal: options.abortSignal });
				this._itemsRemainingInBlock--;
			}
		}
		hasNext() {
			return !this._initialized || this._itemsRemainingInBlock > 0;
		}
		async *parseObjects(options = {}) {
			if (!this._initialized) await this.initialize(options);
			while (this.hasNext()) {
				const result = await this._itemType.read(this._dataStream, { abortSignal: options.abortSignal });
				this._itemsRemainingInBlock--;
				this._objectIndex++;
				if (this._itemsRemainingInBlock === 0) {
					const marker = await AvroParser_js_1.AvroParser.readFixedBytes(this._dataStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, { abortSignal: options.abortSignal });
					this._blockOffset = this._initialBlockOffset + this._dataStream.position;
					this._objectIndex = 0;
					if (!(0, utils_common_js_1.arraysEqual)(this._syncMarker, marker)) throw new Error("Stream is not a valid Avro file.");
					try {
						this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
					} catch {
						this._itemsRemainingInBlock = 0;
					}
					if (this._itemsRemainingInBlock > 0) await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
				}
				yield result;
			}
		}
	};
	exports.AvroReader = AvroReader;
}));
var require_AvroReadable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AvroReadable = void 0;
	var AvroReadable = class {};
	exports.AvroReadable = AvroReadable;
}));
var require_AvroReadableFromStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AvroReadableFromStream = void 0;
	var AvroReadable_js_1 = require_AvroReadable();
	var abort_controller_1 = require_commonjs$15();
	var buffer_1 = __require("buffer");
	var ABORT_ERROR = new abort_controller_1.AbortError("Reading from the avro stream was aborted.");
	var AvroReadableFromStream = class extends AvroReadable_js_1.AvroReadable {
		_position;
		_readable;
		toUint8Array(data) {
			if (typeof data === "string") return buffer_1.Buffer.from(data);
			return data;
		}
		constructor(readable) {
			super();
			this._readable = readable;
			this._position = 0;
		}
		get position() {
			return this._position;
		}
		async read(size, options = {}) {
			if (options.abortSignal?.aborted) throw ABORT_ERROR;
			if (size < 0) throw new Error(`size parameter should be positive: ${size}`);
			if (size === 0) return new Uint8Array();
			if (!this._readable.readable) throw new Error("Stream no longer readable.");
			const chunk = this._readable.read(size);
			if (chunk) {
				this._position += chunk.length;
				return this.toUint8Array(chunk);
			} else return new Promise((resolve$1, reject$3) => {
				const cleanUp = () => {
					this._readable.removeListener("readable", readableCallback);
					this._readable.removeListener("error", rejectCallback);
					this._readable.removeListener("end", rejectCallback);
					this._readable.removeListener("close", rejectCallback);
					if (options.abortSignal) options.abortSignal.removeEventListener("abort", abortHandler);
				};
				const readableCallback = () => {
					const callbackChunk = this._readable.read(size);
					if (callbackChunk) {
						this._position += callbackChunk.length;
						cleanUp();
						resolve$1(this.toUint8Array(callbackChunk));
					}
				};
				const rejectCallback = () => {
					cleanUp();
					reject$3();
				};
				const abortHandler = () => {
					cleanUp();
					reject$3(ABORT_ERROR);
				};
				this._readable.on("readable", readableCallback);
				this._readable.once("error", rejectCallback);
				this._readable.once("end", rejectCallback);
				this._readable.once("close", rejectCallback);
				if (options.abortSignal) options.abortSignal.addEventListener("abort", abortHandler);
			});
		}
	};
	exports.AvroReadableFromStream = AvroReadableFromStream;
}));
var require_internal_avro = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AvroReadableFromStream = exports.AvroReadable = exports.AvroReader = void 0;
	var AvroReader_js_1 = require_AvroReader();
	Object.defineProperty(exports, "AvroReader", {
		enumerable: true,
		get: function() {
			return AvroReader_js_1.AvroReader;
		}
	});
	var AvroReadable_js_1 = require_AvroReadable();
	Object.defineProperty(exports, "AvroReadable", {
		enumerable: true,
		get: function() {
			return AvroReadable_js_1.AvroReadable;
		}
	});
	var AvroReadableFromStream_js_1 = require_AvroReadableFromStream();
	Object.defineProperty(exports, "AvroReadableFromStream", {
		enumerable: true,
		get: function() {
			return AvroReadableFromStream_js_1.AvroReadableFromStream;
		}
	});
}));
var require_BlobQuickQueryStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobQuickQueryStream = void 0;
	var node_stream_1$1 = __require("node:stream");
	var index_js_1 = require_internal_avro();
	var BlobQuickQueryStream = class extends node_stream_1$1.Readable {
		source;
		avroReader;
		avroIter;
		avroPaused = true;
		onProgress;
		onError;
		constructor(source, options = {}) {
			super();
			this.source = source;
			this.onProgress = options.onProgress;
			this.onError = options.onError;
			this.avroReader = new index_js_1.AvroReader(new index_js_1.AvroReadableFromStream(this.source));
			this.avroIter = this.avroReader.parseObjects({ abortSignal: options.abortSignal });
		}
		_read() {
			if (this.avroPaused) this.readInternal().catch((err) => {
				this.emit("error", err);
			});
		}
		async readInternal() {
			this.avroPaused = false;
			let avroNext;
			do {
				avroNext = await this.avroIter.next();
				if (avroNext.done) break;
				const obj = avroNext.value;
				const schema = obj.$schema;
				if (typeof schema !== "string") throw Error("Missing schema in avro record.");
				switch (schema) {
					case "com.microsoft.azure.storage.queryBlobContents.resultData":
						{
							const data = obj.data;
							if (data instanceof Uint8Array === false) throw Error("Invalid data in avro result record.");
							if (!this.push(Buffer.from(data))) this.avroPaused = true;
						}
						break;
					case "com.microsoft.azure.storage.queryBlobContents.progress":
						{
							const bytesScanned = obj.bytesScanned;
							if (typeof bytesScanned !== "number") throw Error("Invalid bytesScanned in avro progress record.");
							if (this.onProgress) this.onProgress({ loadedBytes: bytesScanned });
						}
						break;
					case "com.microsoft.azure.storage.queryBlobContents.end":
						if (this.onProgress) {
							const totalBytes = obj.totalBytes;
							if (typeof totalBytes !== "number") throw Error("Invalid totalBytes in avro end record.");
							this.onProgress({ loadedBytes: totalBytes });
						}
						this.push(null);
						break;
					case "com.microsoft.azure.storage.queryBlobContents.error":
						if (this.onError) {
							const fatal = obj.fatal;
							if (typeof fatal !== "boolean") throw Error("Invalid fatal in avro error record.");
							const name$1 = obj.name;
							if (typeof name$1 !== "string") throw Error("Invalid name in avro error record.");
							const description$1 = obj.description;
							if (typeof description$1 !== "string") throw Error("Invalid description in avro error record.");
							const position = obj.position;
							if (typeof position !== "number") throw Error("Invalid position in avro error record.");
							this.onError({
								position,
								name: name$1,
								isFatal: fatal,
								description: description$1
							});
						}
						break;
					default: throw Error(`Unknown schema ${schema} in avro progress record.`);
				}
			} while (!avroNext.done && !this.avroPaused);
		}
	};
	exports.BlobQuickQueryStream = BlobQuickQueryStream;
}));
var require_BlobQueryResponse = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobQueryResponse = void 0;
	var core_util_1 = require_commonjs$14();
	var BlobQuickQueryStream_js_1 = require_BlobQuickQueryStream();
	var BlobQueryResponse = class {
		get acceptRanges() {
			return this.originalResponse.acceptRanges;
		}
		get cacheControl() {
			return this.originalResponse.cacheControl;
		}
		get contentDisposition() {
			return this.originalResponse.contentDisposition;
		}
		get contentEncoding() {
			return this.originalResponse.contentEncoding;
		}
		get contentLanguage() {
			return this.originalResponse.contentLanguage;
		}
		get blobSequenceNumber() {
			return this.originalResponse.blobSequenceNumber;
		}
		get blobType() {
			return this.originalResponse.blobType;
		}
		get contentLength() {
			return this.originalResponse.contentLength;
		}
		get contentMD5() {
			return this.originalResponse.contentMD5;
		}
		get contentRange() {
			return this.originalResponse.contentRange;
		}
		get contentType() {
			return this.originalResponse.contentType;
		}
		get copyCompletedOn() {}
		get copyId() {
			return this.originalResponse.copyId;
		}
		get copyProgress() {
			return this.originalResponse.copyProgress;
		}
		get copySource() {
			return this.originalResponse.copySource;
		}
		get copyStatus() {
			return this.originalResponse.copyStatus;
		}
		get copyStatusDescription() {
			return this.originalResponse.copyStatusDescription;
		}
		get leaseDuration() {
			return this.originalResponse.leaseDuration;
		}
		get leaseState() {
			return this.originalResponse.leaseState;
		}
		get leaseStatus() {
			return this.originalResponse.leaseStatus;
		}
		get date() {
			return this.originalResponse.date;
		}
		get blobCommittedBlockCount() {
			return this.originalResponse.blobCommittedBlockCount;
		}
		get etag() {
			return this.originalResponse.etag;
		}
		get errorCode() {
			return this.originalResponse.errorCode;
		}
		get isServerEncrypted() {
			return this.originalResponse.isServerEncrypted;
		}
		get blobContentMD5() {
			return this.originalResponse.blobContentMD5;
		}
		get lastModified() {
			return this.originalResponse.lastModified;
		}
		get metadata() {
			return this.originalResponse.metadata;
		}
		get requestId() {
			return this.originalResponse.requestId;
		}
		get clientRequestId() {
			return this.originalResponse.clientRequestId;
		}
		get version() {
			return this.originalResponse.version;
		}
		get encryptionKeySha256() {
			return this.originalResponse.encryptionKeySha256;
		}
		get contentCrc64() {
			return this.originalResponse.contentCrc64;
		}
		get blobBody() {}
		get readableStreamBody() {
			return core_util_1.isNodeLike ? this.blobDownloadStream : void 0;
		}
		get _response() {
			return this.originalResponse._response;
		}
		originalResponse;
		blobDownloadStream;
		constructor(originalResponse, options = {}) {
			this.originalResponse = originalResponse;
			this.blobDownloadStream = new BlobQuickQueryStream_js_1.BlobQuickQueryStream(this.originalResponse.readableStreamBody, options);
		}
	};
	exports.BlobQueryResponse = BlobQueryResponse;
}));
var require_models = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = void 0;
	exports.toAccessTier = toAccessTier;
	exports.ensureCpkIfSpecified = ensureCpkIfSpecified;
	exports.getBlobServiceAccountAudience = getBlobServiceAccountAudience;
	var constants_js_1 = require_constants$4();
	var BlockBlobTier;
	(function(BlockBlobTier) {
		BlockBlobTier["Hot"] = "Hot";
		BlockBlobTier["Cool"] = "Cool";
		BlockBlobTier["Cold"] = "Cold";
		BlockBlobTier["Archive"] = "Archive";
	})(BlockBlobTier || (exports.BlockBlobTier = BlockBlobTier = {}));
	var PremiumPageBlobTier;
	(function(PremiumPageBlobTier) {
		PremiumPageBlobTier["P4"] = "P4";
		PremiumPageBlobTier["P6"] = "P6";
		PremiumPageBlobTier["P10"] = "P10";
		PremiumPageBlobTier["P15"] = "P15";
		PremiumPageBlobTier["P20"] = "P20";
		PremiumPageBlobTier["P30"] = "P30";
		PremiumPageBlobTier["P40"] = "P40";
		PremiumPageBlobTier["P50"] = "P50";
		PremiumPageBlobTier["P60"] = "P60";
		PremiumPageBlobTier["P70"] = "P70";
		PremiumPageBlobTier["P80"] = "P80";
	})(PremiumPageBlobTier || (exports.PremiumPageBlobTier = PremiumPageBlobTier = {}));
	function toAccessTier(tier) {
		if (tier === void 0) return;
		return tier;
	}
	function ensureCpkIfSpecified(cpk, isHttps) {
		if (cpk && !isHttps) throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
		if (cpk && !cpk.encryptionAlgorithm) cpk.encryptionAlgorithm = constants_js_1.EncryptionAlgorithmAES25;
	}
	var StorageBlobAudience;
	(function(StorageBlobAudience) {
		StorageBlobAudience["StorageOAuthScopes"] = "https://storage.azure.com/.default";
		StorageBlobAudience["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
	})(StorageBlobAudience || (exports.StorageBlobAudience = StorageBlobAudience = {}));
	function getBlobServiceAccountAudience(storageAccountName) {
		return `https://${storageAccountName}.blob.core.windows.net/.default`;
	}
}));
var require_PageBlobRangeResponse = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.rangeResponseFromModel = rangeResponseFromModel;
	function rangeResponseFromModel(response) {
		const pageRange = (response._response.parsedBody.pageRange || []).map((x) => ({
			offset: x.start,
			count: x.end - x.start
		}));
		const clearRange = (response._response.parsedBody.clearRange || []).map((x) => ({
			offset: x.start,
			count: x.end - x.start
		}));
		return {
			...response,
			pageRange,
			clearRange,
			_response: {
				...response._response,
				parsedBody: {
					pageRange,
					clearRange
				}
			}
		};
	}
}));
var require_logger = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logger = void 0;
	exports.logger = (0, require_commonjs$16().createClientLogger)("core-lro");
}));
var require_constants$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.terminalStates = exports.POLL_INTERVAL_IN_MS = void 0;
	exports.POLL_INTERVAL_IN_MS = 2e3;
	exports.terminalStates = [
		"succeeded",
		"canceled",
		"failed"
	];
}));
var require_operation$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.pollOperation = exports.initOperation = exports.deserializeState = void 0;
	var logger_js_1 = require_logger();
	var constants_js_1 = require_constants$2();
	function deserializeState(serializedState) {
		try {
			return JSON.parse(serializedState).state;
		} catch (e$1) {
			throw new Error(`Unable to deserialize input state: ${serializedState}`);
		}
	}
	exports.deserializeState = deserializeState;
	function setStateError(inputs) {
		const { state, stateProxy, isOperationError } = inputs;
		return (error) => {
			if (isOperationError(error)) {
				stateProxy.setError(state, error);
				stateProxy.setFailed(state);
			}
			throw error;
		};
	}
	function appendReadableErrorMessage(currentMessage, innerMessage) {
		let message = currentMessage;
		if (message.slice(-1) !== ".") message = message + ".";
		return message + " " + innerMessage;
	}
	function simplifyError(err) {
		let message = err.message;
		let code = err.code;
		let curErr = err;
		while (curErr.innererror) {
			curErr = curErr.innererror;
			code = curErr.code;
			message = appendReadableErrorMessage(message, curErr.message);
		}
		return {
			code,
			message
		};
	}
	function processOperationStatus(result) {
		const { state, stateProxy, status, isDone, processResult, getError, response, setErrorAsResult } = result;
		switch (status) {
			case "succeeded":
				stateProxy.setSucceeded(state);
				break;
			case "failed": {
				const err = getError === null || getError === void 0 ? void 0 : getError(response);
				let postfix = "";
				if (err) {
					const { code, message } = simplifyError(err);
					postfix = `. ${code}. ${message}`;
				}
				const errStr = `The long-running operation has failed${postfix}`;
				stateProxy.setError(state, new Error(errStr));
				stateProxy.setFailed(state);
				logger_js_1.logger.warning(errStr);
				break;
			}
			case "canceled":
				stateProxy.setCanceled(state);
				break;
		}
		if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === void 0 && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) stateProxy.setResult(state, buildResult({
			response,
			state,
			processResult
		}));
	}
	function buildResult(inputs) {
		const { processResult, response, state } = inputs;
		return processResult ? processResult(response, state) : response;
	}
	async function initOperation(inputs) {
		const { init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } = inputs;
		const { operationLocation, resourceLocation, metadata, response } = await init();
		if (operationLocation) withOperationLocation === null || withOperationLocation === void 0 || withOperationLocation(operationLocation, false);
		const config = {
			metadata,
			operationLocation,
			resourceLocation
		};
		logger_js_1.logger.verbose(`LRO: Operation description:`, config);
		const state = stateProxy.initState(config);
		processOperationStatus({
			state,
			status: getOperationStatus({
				response,
				state,
				operationLocation
			}),
			stateProxy,
			response,
			setErrorAsResult,
			processResult
		});
		return state;
	}
	exports.initOperation = initOperation;
	async function pollOperationHelper(inputs) {
		const { poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options } = inputs;
		const response = await poll(operationLocation, options).catch(setStateError({
			state,
			stateProxy,
			isOperationError
		}));
		const status = getOperationStatus(response, state);
		logger_js_1.logger.verbose(`LRO: Status:\n\tPolling from: ${state.config.operationLocation}\n\tOperation status: ${status}\n\tPolling status: ${constants_js_1.terminalStates.includes(status) ? "Stopped" : "Running"}`);
		if (status === "succeeded") {
			const resourceLocation = getResourceLocation(response, state);
			if (resourceLocation !== void 0) return {
				response: await poll(resourceLocation).catch(setStateError({
					state,
					stateProxy,
					isOperationError
				})),
				status
			};
		}
		return {
			response,
			status
		};
	}
	async function pollOperation(inputs) {
		const { poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult } = inputs;
		const { operationLocation } = state.config;
		if (operationLocation !== void 0) {
			const { response, status } = await pollOperationHelper({
				poll,
				getOperationStatus,
				state,
				stateProxy,
				operationLocation,
				getResourceLocation,
				isOperationError,
				options
			});
			processOperationStatus({
				status,
				response,
				state,
				stateProxy,
				isDone,
				processResult,
				getError,
				setErrorAsResult
			});
			if (!constants_js_1.terminalStates.includes(status)) {
				const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);
				if (intervalInMs) setDelay(intervalInMs);
				const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);
				if (location !== void 0) {
					const isUpdated = operationLocation !== location;
					state.config.operationLocation = location;
					withOperationLocation === null || withOperationLocation === void 0 || withOperationLocation(location, isUpdated);
				} else withOperationLocation === null || withOperationLocation === void 0 || withOperationLocation(operationLocation, false);
			}
			updateState === null || updateState === void 0 || updateState(state, response);
		}
	}
	exports.pollOperation = pollOperation;
}));
var require_operation$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.pollHttpOperation = exports.isOperationError = exports.getResourceLocation = exports.getOperationStatus = exports.getOperationLocation = exports.initHttpOperation = exports.getStatusFromInitialResponse = exports.getErrorFromResponse = exports.parseRetryAfter = exports.inferLroMode = void 0;
	var operation_js_1 = require_operation$2();
	var logger_js_1 = require_logger();
	function getOperationLocationPollingUrl(inputs) {
		const { azureAsyncOperation, operationLocation } = inputs;
		return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;
	}
	function getLocationHeader(rawResponse) {
		return rawResponse.headers["location"];
	}
	function getOperationLocationHeader(rawResponse) {
		return rawResponse.headers["operation-location"];
	}
	function getAzureAsyncOperationHeader(rawResponse) {
		return rawResponse.headers["azure-asyncoperation"];
	}
	function findResourceLocation(inputs) {
		var _a;
		const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
		switch (requestMethod) {
			case "PUT": return requestPath;
			case "DELETE": return;
			case "PATCH": return (_a = getDefault()) !== null && _a !== void 0 ? _a : requestPath;
			default: return getDefault();
		}
		function getDefault() {
			switch (resourceLocationConfig) {
				case "azure-async-operation": return;
				case "original-uri": return requestPath;
				case "location":
				default: return location;
			}
		}
	}
	function inferLroMode(inputs) {
		const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
		const pollingUrl = getOperationLocationPollingUrl({
			operationLocation: getOperationLocationHeader(rawResponse),
			azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
		});
		const location = getLocationHeader(rawResponse);
		const normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();
		if (pollingUrl !== void 0) return {
			mode: "OperationLocation",
			operationLocation: pollingUrl,
			resourceLocation: findResourceLocation({
				requestMethod: normalizedRequestMethod,
				location,
				requestPath,
				resourceLocationConfig
			})
		};
		else if (location !== void 0) return {
			mode: "ResourceLocation",
			operationLocation: location
		};
		else if (normalizedRequestMethod === "PUT" && requestPath) return {
			mode: "Body",
			operationLocation: requestPath
		};
		else return;
	}
	exports.inferLroMode = inferLroMode;
	function transformStatus(inputs) {
		const { status, statusCode } = inputs;
		if (typeof status !== "string" && status !== void 0) throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
		switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {
			case void 0: return toOperationStatus(statusCode);
			case "succeeded": return "succeeded";
			case "failed": return "failed";
			case "running":
			case "accepted":
			case "started":
			case "canceling":
			case "cancelling": return "running";
			case "canceled":
			case "cancelled": return "canceled";
			default:
				logger_js_1.logger.verbose(`LRO: unrecognized operation status: ${status}`);
				return status;
		}
	}
	function getStatus(rawResponse) {
		var _a;
		const { status } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
		return transformStatus({
			status,
			statusCode: rawResponse.statusCode
		});
	}
	function getProvisioningState(rawResponse) {
		var _a, _b;
		const { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
		return transformStatus({
			status: (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState,
			statusCode: rawResponse.statusCode
		});
	}
	function toOperationStatus(statusCode) {
		if (statusCode === 202) return "running";
		else if (statusCode < 300) return "succeeded";
		else return "failed";
	}
	function parseRetryAfter({ rawResponse }) {
		const retryAfter = rawResponse.headers["retry-after"];
		if (retryAfter !== void 0) {
			const retryAfterInSeconds = parseInt(retryAfter);
			return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1e3;
		}
	}
	exports.parseRetryAfter = parseRetryAfter;
	function getErrorFromResponse(response) {
		const error = accessBodyProperty(response, "error");
		if (!error) {
			logger_js_1.logger.warning(`The long-running operation failed but there is no error property in the response's body`);
			return;
		}
		if (!error.code || !error.message) {
			logger_js_1.logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);
			return;
		}
		return error;
	}
	exports.getErrorFromResponse = getErrorFromResponse;
	function calculatePollingIntervalFromDate(retryAfterDate) {
		const timeNow = Math.floor((/* @__PURE__ */ new Date()).getTime());
		const retryAfterTime = retryAfterDate.getTime();
		if (timeNow < retryAfterTime) return retryAfterTime - timeNow;
	}
	function getStatusFromInitialResponse(inputs) {
		const { response, state, operationLocation } = inputs;
		function helper() {
			var _a;
			switch ((_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"]) {
				case void 0: return toOperationStatus(response.rawResponse.statusCode);
				case "Body": return getOperationStatus(response, state);
				default: return "running";
			}
		}
		const status = helper();
		return status === "running" && operationLocation === void 0 ? "succeeded" : status;
	}
	exports.getStatusFromInitialResponse = getStatusFromInitialResponse;
	async function initHttpOperation(inputs) {
		const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;
		return (0, operation_js_1.initOperation)({
			init: async () => {
				const response = await lro.sendInitialRequest();
				const config = inferLroMode({
					rawResponse: response.rawResponse,
					requestPath: lro.requestPath,
					requestMethod: lro.requestMethod,
					resourceLocationConfig
				});
				return Object.assign({
					response,
					operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,
					resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation
				}, (config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {});
			},
			stateProxy,
			processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse,
			getOperationStatus: getStatusFromInitialResponse,
			setErrorAsResult
		});
	}
	exports.initHttpOperation = initHttpOperation;
	function getOperationLocation({ rawResponse }, state) {
		var _a;
		switch ((_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"]) {
			case "OperationLocation": return getOperationLocationPollingUrl({
				operationLocation: getOperationLocationHeader(rawResponse),
				azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
			});
			case "ResourceLocation": return getLocationHeader(rawResponse);
			case "Body":
			default: return;
		}
	}
	exports.getOperationLocation = getOperationLocation;
	function getOperationStatus({ rawResponse }, state) {
		var _a;
		const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
		switch (mode) {
			case "OperationLocation": return getStatus(rawResponse);
			case "ResourceLocation": return toOperationStatus(rawResponse.statusCode);
			case "Body": return getProvisioningState(rawResponse);
			default: throw new Error(`Internal error: Unexpected operation mode: ${mode}`);
		}
	}
	exports.getOperationStatus = getOperationStatus;
	function accessBodyProperty({ flatResponse, rawResponse }, prop) {
		var _a, _b;
		return (_a = flatResponse === null || flatResponse === void 0 ? void 0 : flatResponse[prop]) !== null && _a !== void 0 ? _a : (_b = rawResponse.body) === null || _b === void 0 ? void 0 : _b[prop];
	}
	function getResourceLocation(res, state) {
		const loc = accessBodyProperty(res, "resourceLocation");
		if (loc && typeof loc === "string") state.config.resourceLocation = loc;
		return state.config.resourceLocation;
	}
	exports.getResourceLocation = getResourceLocation;
	function isOperationError(e$1) {
		return e$1.name === "RestError";
	}
	exports.isOperationError = isOperationError;
	async function pollHttpOperation(inputs) {
		const { lro, stateProxy, options, processResult, updateState, setDelay, state, setErrorAsResult } = inputs;
		return (0, operation_js_1.pollOperation)({
			state,
			stateProxy,
			setDelay,
			processResult: processResult ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState) : ({ flatResponse }) => flatResponse,
			getError: getErrorFromResponse,
			updateState,
			getPollingInterval: parseRetryAfter,
			getOperationLocation,
			getOperationStatus,
			isOperationError,
			getResourceLocation,
			options,
			poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
			setErrorAsResult
		});
	}
	exports.pollHttpOperation = pollHttpOperation;
}));
var require_poller$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.buildCreatePoller = void 0;
	var operation_js_1 = require_operation$2();
	var constants_js_1 = require_constants$2();
	var core_util_1 = require_commonjs$14();
	var createStateProxy = () => ({
		initState: (config) => ({
			status: "running",
			config
		}),
		setCanceled: (state) => state.status = "canceled",
		setError: (state, error) => state.error = error,
		setResult: (state, result) => state.result = result,
		setRunning: (state) => state.status = "running",
		setSucceeded: (state) => state.status = "succeeded",
		setFailed: (state) => state.status = "failed",
		getError: (state) => state.error,
		getResult: (state) => state.result,
		isCanceled: (state) => state.status === "canceled",
		isFailed: (state) => state.status === "failed",
		isRunning: (state) => state.status === "running",
		isSucceeded: (state) => state.status === "succeeded"
	});
	function buildCreatePoller(inputs) {
		const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, isOperationError, getResourceLocation, getPollingInterval, getError, resolveOnUnsuccessful } = inputs;
		return async ({ init, poll }, options) => {
			const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, restoreFrom } = options || {};
			const stateProxy = createStateProxy();
			const withOperationLocation = withOperationLocationCallback ? (() => {
				let called = false;
				return (operationLocation, isUpdated) => {
					if (isUpdated) withOperationLocationCallback(operationLocation);
					else if (!called) withOperationLocationCallback(operationLocation);
					called = true;
				};
			})() : void 0;
			const state = restoreFrom ? (0, operation_js_1.deserializeState)(restoreFrom) : await (0, operation_js_1.initOperation)({
				init,
				stateProxy,
				processResult,
				getOperationStatus: getStatusFromInitialResponse,
				withOperationLocation,
				setErrorAsResult: !resolveOnUnsuccessful
			});
			let resultPromise;
			const abortController = new AbortController();
			const handlers = /* @__PURE__ */ new Map();
			const handleProgressEvents = async () => handlers.forEach((h) => h(state));
			const cancelErrMsg = "Operation was canceled";
			let currentPollIntervalInMs = intervalInMs;
			const poller = {
				getOperationState: () => state,
				getResult: () => state.result,
				isDone: () => [
					"succeeded",
					"failed",
					"canceled"
				].includes(state.status),
				isStopped: () => resultPromise === void 0,
				stopPolling: () => {
					abortController.abort();
				},
				toString: () => JSON.stringify({ state }),
				onProgress: (callback) => {
					const s = Symbol();
					handlers.set(s, callback);
					return () => handlers.delete(s);
				},
				pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {
					const { abortSignal: inputAbortSignal } = pollOptions || {};
					function abortListener() {
						abortController.abort();
					}
					const abortSignal$1 = abortController.signal;
					if (inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.aborted) abortController.abort();
					else if (!abortSignal$1.aborted) inputAbortSignal === null || inputAbortSignal === void 0 || inputAbortSignal.addEventListener("abort", abortListener, { once: true });
					try {
						if (!poller.isDone()) {
							await poller.poll({ abortSignal: abortSignal$1 });
							while (!poller.isDone()) {
								await (0, core_util_1.delay)(currentPollIntervalInMs, { abortSignal: abortSignal$1 });
								await poller.poll({ abortSignal: abortSignal$1 });
							}
						}
					} finally {
						inputAbortSignal === null || inputAbortSignal === void 0 || inputAbortSignal.removeEventListener("abort", abortListener);
					}
					if (resolveOnUnsuccessful) return poller.getResult();
					else switch (state.status) {
						case "succeeded": return poller.getResult();
						case "canceled": throw new Error(cancelErrMsg);
						case "failed": throw state.error;
						case "notStarted":
						case "running": throw new Error(`Polling completed without succeeding or failing`);
					}
				})().finally(() => {
					resultPromise = void 0;
				}),
				async poll(pollOptions) {
					if (resolveOnUnsuccessful) {
						if (poller.isDone()) return;
					} else switch (state.status) {
						case "succeeded": return;
						case "canceled": throw new Error(cancelErrMsg);
						case "failed": throw state.error;
					}
					await (0, operation_js_1.pollOperation)({
						poll,
						state,
						stateProxy,
						getOperationLocation,
						isOperationError,
						withOperationLocation,
						getPollingInterval,
						getOperationStatus: getStatusFromPollResponse,
						getResourceLocation,
						processResult,
						getError,
						updateState,
						options: pollOptions,
						setDelay: (pollIntervalInMs) => {
							currentPollIntervalInMs = pollIntervalInMs;
						},
						setErrorAsResult: !resolveOnUnsuccessful
					});
					await handleProgressEvents();
					if (!resolveOnUnsuccessful) switch (state.status) {
						case "canceled": throw new Error(cancelErrMsg);
						case "failed": throw state.error;
					}
				}
			};
			return poller;
		};
	}
	exports.buildCreatePoller = buildCreatePoller;
}));
var require_poller$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createHttpPoller = void 0;
	var operation_js_1 = require_operation$1();
	var poller_js_1 = require_poller$2();
	async function createHttpPoller(lro, options) {
		const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = false } = options || {};
		return (0, poller_js_1.buildCreatePoller)({
			getStatusFromInitialResponse: operation_js_1.getStatusFromInitialResponse,
			getStatusFromPollResponse: operation_js_1.getOperationStatus,
			isOperationError: operation_js_1.isOperationError,
			getOperationLocation: operation_js_1.getOperationLocation,
			getResourceLocation: operation_js_1.getResourceLocation,
			getPollingInterval: operation_js_1.parseRetryAfter,
			getError: operation_js_1.getErrorFromResponse,
			resolveOnUnsuccessful
		})({
			init: async () => {
				const response = await lro.sendInitialRequest();
				const config = (0, operation_js_1.inferLroMode)({
					rawResponse: response.rawResponse,
					requestPath: lro.requestPath,
					requestMethod: lro.requestMethod,
					resourceLocationConfig
				});
				return Object.assign({
					response,
					operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,
					resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation
				}, (config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {});
			},
			poll: lro.sendPollRequest
		}, {
			intervalInMs,
			withOperationLocation,
			restoreFrom,
			updateState,
			processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse
		});
	}
	exports.createHttpPoller = createHttpPoller;
}));
var require_operation = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GenericPollOperation = void 0;
	var operation_js_1 = require_operation$1();
	var logger_js_1 = require_logger();
	var createStateProxy = () => ({
		initState: (config) => ({
			config,
			isStarted: true
		}),
		setCanceled: (state) => state.isCancelled = true,
		setError: (state, error) => state.error = error,
		setResult: (state, result) => state.result = result,
		setRunning: (state) => state.isStarted = true,
		setSucceeded: (state) => state.isCompleted = true,
		setFailed: () => {},
		getError: (state) => state.error,
		getResult: (state) => state.result,
		isCanceled: (state) => !!state.isCancelled,
		isFailed: (state) => !!state.error,
		isRunning: (state) => !!state.isStarted,
		isSucceeded: (state) => Boolean(state.isCompleted && !state.isCancelled && !state.error)
	});
	var GenericPollOperation = class {
		constructor(state, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
			this.state = state;
			this.lro = lro;
			this.setErrorAsResult = setErrorAsResult;
			this.lroResourceLocationConfig = lroResourceLocationConfig;
			this.processResult = processResult;
			this.updateState = updateState;
			this.isDone = isDone;
		}
		setPollerConfig(pollerConfig) {
			this.pollerConfig = pollerConfig;
		}
		async update(options) {
			var _a;
			const stateProxy = createStateProxy();
			if (!this.state.isStarted) this.state = Object.assign(Object.assign({}, this.state), await (0, operation_js_1.initHttpOperation)({
				lro: this.lro,
				stateProxy,
				resourceLocationConfig: this.lroResourceLocationConfig,
				processResult: this.processResult,
				setErrorAsResult: this.setErrorAsResult
			}));
			const updateState = this.updateState;
			const isDone = this.isDone;
			if (!this.state.isCompleted && this.state.error === void 0) await (0, operation_js_1.pollHttpOperation)({
				lro: this.lro,
				state: this.state,
				stateProxy,
				processResult: this.processResult,
				updateState: updateState ? (state, { rawResponse }) => updateState(state, rawResponse) : void 0,
				isDone: isDone ? ({ flatResponse }, state) => isDone(flatResponse, state) : void 0,
				options,
				setDelay: (intervalInMs) => {
					this.pollerConfig.intervalInMs = intervalInMs;
				},
				setErrorAsResult: this.setErrorAsResult
			});
			(_a = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _a === void 0 || _a.call(options, this.state);
			return this;
		}
		async cancel() {
			logger_js_1.logger.error("`cancelOperation` is deprecated because it wasn't implemented");
			return this;
		}
		toString() {
			return JSON.stringify({ state: this.state });
		}
	};
	exports.GenericPollOperation = GenericPollOperation;
}));
var require_poller = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Poller = exports.PollerCancelledError = exports.PollerStoppedError = void 0;
	var PollerStoppedError = class PollerStoppedError extends Error {
		constructor(message) {
			super(message);
			this.name = "PollerStoppedError";
			Object.setPrototypeOf(this, PollerStoppedError.prototype);
		}
	};
	exports.PollerStoppedError = PollerStoppedError;
	var PollerCancelledError = class PollerCancelledError extends Error {
		constructor(message) {
			super(message);
			this.name = "PollerCancelledError";
			Object.setPrototypeOf(this, PollerCancelledError.prototype);
		}
	};
	exports.PollerCancelledError = PollerCancelledError;
	var Poller = class {
		constructor(operation) {
			this.resolveOnUnsuccessful = false;
			this.stopped = true;
			this.pollProgressCallbacks = [];
			this.operation = operation;
			this.promise = new Promise((resolve$1, reject$3) => {
				this.resolve = resolve$1;
				this.reject = reject$3;
			});
			this.promise.catch(() => {});
		}
		async startPolling(pollOptions = {}) {
			if (this.stopped) this.stopped = false;
			while (!this.isStopped() && !this.isDone()) {
				await this.poll(pollOptions);
				await this.delay();
			}
		}
		async pollOnce(options = {}) {
			if (!this.isDone()) this.operation = await this.operation.update({
				abortSignal: options.abortSignal,
				fireProgress: this.fireProgress.bind(this)
			});
			this.processUpdatedState();
		}
		fireProgress(state) {
			for (const callback of this.pollProgressCallbacks) callback(state);
		}
		async cancelOnce(options = {}) {
			this.operation = await this.operation.cancel(options);
		}
		poll(options = {}) {
			if (!this.pollOncePromise) {
				this.pollOncePromise = this.pollOnce(options);
				const clearPollOncePromise = () => {
					this.pollOncePromise = void 0;
				};
				this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
			}
			return this.pollOncePromise;
		}
		processUpdatedState() {
			if (this.operation.state.error) {
				this.stopped = true;
				if (!this.resolveOnUnsuccessful) {
					this.reject(this.operation.state.error);
					throw this.operation.state.error;
				}
			}
			if (this.operation.state.isCancelled) {
				this.stopped = true;
				if (!this.resolveOnUnsuccessful) {
					const error = new PollerCancelledError("Operation was canceled");
					this.reject(error);
					throw error;
				}
			}
			if (this.isDone() && this.resolve) this.resolve(this.getResult());
		}
		async pollUntilDone(pollOptions = {}) {
			if (this.stopped) this.startPolling(pollOptions).catch(this.reject);
			this.processUpdatedState();
			return this.promise;
		}
		onProgress(callback) {
			this.pollProgressCallbacks.push(callback);
			return () => {
				this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);
			};
		}
		isDone() {
			const state = this.operation.state;
			return Boolean(state.isCompleted || state.isCancelled || state.error);
		}
		stopPolling() {
			if (!this.stopped) {
				this.stopped = true;
				if (this.reject) this.reject(new PollerStoppedError("This poller is already stopped"));
			}
		}
		isStopped() {
			return this.stopped;
		}
		cancelOperation(options = {}) {
			if (!this.cancelPromise) this.cancelPromise = this.cancelOnce(options);
			else if (options.abortSignal) throw new Error("A cancel request is currently pending");
			return this.cancelPromise;
		}
		getOperationState() {
			return this.operation.state;
		}
		getResult() {
			return this.operation.state.result;
		}
		toString() {
			return this.operation.toString();
		}
	};
	exports.Poller = Poller;
}));
var require_lroEngine$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LroEngine = void 0;
	var operation_js_1 = require_operation();
	var constants_js_1 = require_constants$2();
	var poller_js_1 = require_poller();
	var operation_js_2 = require_operation$2();
	var LroEngine = class extends poller_js_1.Poller {
		constructor(lro, options) {
			const { intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, resumeFrom, resolveOnUnsuccessful = false, isDone, lroResourceLocationConfig, processResult, updateState } = options || {};
			const state = resumeFrom ? (0, operation_js_2.deserializeState)(resumeFrom) : {};
			const operation = new operation_js_1.GenericPollOperation(state, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
			super(operation);
			this.resolveOnUnsuccessful = resolveOnUnsuccessful;
			this.config = { intervalInMs };
			operation.setPollerConfig(this.config);
		}
		delay() {
			return new Promise((resolve$1) => setTimeout(() => resolve$1(), this.config.intervalInMs));
		}
	};
	exports.LroEngine = LroEngine;
}));
var require_lroEngine = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LroEngine = void 0;
	var lroEngine_js_1 = require_lroEngine$1();
	Object.defineProperty(exports, "LroEngine", {
		enumerable: true,
		get: function() {
			return lroEngine_js_1.LroEngine;
		}
	});
}));
var require_pollOperation = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_commonjs$6 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createHttpPoller = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var poller_js_1 = require_poller$1();
	Object.defineProperty(exports, "createHttpPoller", {
		enumerable: true,
		get: function() {
			return poller_js_1.createHttpPoller;
		}
	});
	tslib_1.__exportStar(require_lroEngine(), exports);
	tslib_1.__exportStar(require_poller(), exports);
	tslib_1.__exportStar(require_pollOperation(), exports);
}));
var require_BlobStartCopyFromUrlPoller = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobBeginCopyFromUrlPoller = void 0;
	var core_util_1 = require_commonjs$14();
	var core_lro_1 = require_commonjs$6();
	var BlobBeginCopyFromUrlPoller = class extends core_lro_1.Poller {
		intervalInMs;
		constructor(options) {
			const { blobClient, copySource, intervalInMs = 15e3, onProgress, resumeFrom, startCopyFromURLOptions } = options;
			let state;
			if (resumeFrom) state = JSON.parse(resumeFrom).state;
			const operation = makeBlobBeginCopyFromURLPollOperation({
				...state,
				blobClient,
				copySource,
				startCopyFromURLOptions
			});
			super(operation);
			if (typeof onProgress === "function") this.onProgress(onProgress);
			this.intervalInMs = intervalInMs;
		}
		delay() {
			return (0, core_util_1.delay)(this.intervalInMs);
		}
	};
	exports.BlobBeginCopyFromUrlPoller = BlobBeginCopyFromUrlPoller;
	var cancel = async function cancel(options = {}) {
		const state = this.state;
		const { copyId } = state;
		if (state.isCompleted) return makeBlobBeginCopyFromURLPollOperation(state);
		if (!copyId) {
			state.isCancelled = true;
			return makeBlobBeginCopyFromURLPollOperation(state);
		}
		await state.blobClient.abortCopyFromURL(copyId, { abortSignal: options.abortSignal });
		state.isCancelled = true;
		return makeBlobBeginCopyFromURLPollOperation(state);
	};
	var update = async function update(options = {}) {
		const state = this.state;
		const { blobClient, copySource, startCopyFromURLOptions } = state;
		if (!state.isStarted) {
			state.isStarted = true;
			const result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);
			state.copyId = result.copyId;
			if (result.copyStatus === "success") {
				state.result = result;
				state.isCompleted = true;
			}
		} else if (!state.isCompleted) try {
			const result = await state.blobClient.getProperties({ abortSignal: options.abortSignal });
			const { copyStatus, copyProgress } = result;
			const prevCopyProgress = state.copyProgress;
			if (copyProgress) state.copyProgress = copyProgress;
			if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options.fireProgress === "function") options.fireProgress(state);
			else if (copyStatus === "success") {
				state.result = result;
				state.isCompleted = true;
			} else if (copyStatus === "failed") {
				state.error = /* @__PURE__ */ new Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`);
				state.isCompleted = true;
			}
		} catch (err) {
			state.error = err;
			state.isCompleted = true;
		}
		return makeBlobBeginCopyFromURLPollOperation(state);
	};
	var toString = function toString() {
		return JSON.stringify({ state: this.state }, (key, value$1) => {
			if (key === "blobClient") return;
			return value$1;
		});
	};
	function makeBlobBeginCopyFromURLPollOperation(state) {
		return {
			state: { ...state },
			cancel,
			toString,
			update
		};
	}
}));
var require_Range = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.rangeToString = rangeToString;
	function rangeToString(iRange) {
		if (iRange.offset < 0) throw new RangeError(`Range.offset cannot be smaller than 0.`);
		if (iRange.count && iRange.count <= 0) throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
		return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
	}
}));
var require_Batch = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Batch = void 0;
	var events_1 = __require("events");
	var BatchStates;
	(function(BatchStates) {
		BatchStates[BatchStates["Good"] = 0] = "Good";
		BatchStates[BatchStates["Error"] = 1] = "Error";
	})(BatchStates || (BatchStates = {}));
	var Batch = class {
		concurrency;
		actives = 0;
		completed = 0;
		offset = 0;
		operations = [];
		state = BatchStates.Good;
		emitter;
		constructor(concurrency = 5) {
			if (concurrency < 1) throw new RangeError("concurrency must be larger than 0");
			this.concurrency = concurrency;
			this.emitter = new events_1.EventEmitter();
		}
		addOperation(operation) {
			this.operations.push(async () => {
				try {
					this.actives++;
					await operation();
					this.actives--;
					this.completed++;
					this.parallelExecute();
				} catch (error) {
					this.emitter.emit("error", error);
				}
			});
		}
		async do() {
			if (this.operations.length === 0) return Promise.resolve();
			this.parallelExecute();
			return new Promise((resolve$1, reject$3) => {
				this.emitter.on("finish", resolve$1);
				this.emitter.on("error", (error) => {
					this.state = BatchStates.Error;
					reject$3(error);
				});
			});
		}
		nextOperation() {
			if (this.offset < this.operations.length) return this.operations[this.offset++];
			return null;
		}
		parallelExecute() {
			if (this.state === BatchStates.Error) return;
			if (this.completed >= this.operations.length) {
				this.emitter.emit("finish");
				return;
			}
			while (this.actives < this.concurrency) {
				const operation = this.nextOperation();
				if (operation) operation();
				else return;
			}
		}
	};
	exports.Batch = Batch;
}));
var require_utils$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fsCreateReadStream = exports.fsStat = void 0;
	exports.streamToBuffer = streamToBuffer;
	exports.streamToBuffer2 = streamToBuffer2;
	exports.streamToBuffer3 = streamToBuffer3;
	exports.readStreamToLocalFile = readStreamToLocalFile;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var node_fs_1 = tslib_1.__importDefault(__require("node:fs"));
	var node_util_1 = tslib_1.__importDefault(__require("node:util"));
	var constants_js_1 = require_constants$4();
	async function streamToBuffer(stream$5, buffer$2, offset, end, encoding) {
		let pos = 0;
		const count = end - offset;
		return new Promise((resolve$1, reject$3) => {
			const timeout$1 = setTimeout(() => reject$3(/* @__PURE__ */ new Error(`The operation cannot be completed in timeout.`)), constants_js_1.REQUEST_TIMEOUT);
			stream$5.on("readable", () => {
				if (pos >= count) {
					clearTimeout(timeout$1);
					resolve$1();
					return;
				}
				let chunk = stream$5.read();
				if (!chunk) return;
				if (typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
				const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
				buffer$2.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
				pos += chunkLength;
			});
			stream$5.on("end", () => {
				clearTimeout(timeout$1);
				if (pos < count) reject$3(/* @__PURE__ */ new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
				resolve$1();
			});
			stream$5.on("error", (msg) => {
				clearTimeout(timeout$1);
				reject$3(msg);
			});
		});
	}
	async function streamToBuffer2(stream$5, buffer$2, encoding) {
		let pos = 0;
		const bufferSize = buffer$2.length;
		return new Promise((resolve$1, reject$3) => {
			stream$5.on("readable", () => {
				let chunk = stream$5.read();
				if (!chunk) return;
				if (typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
				if (pos + chunk.length > bufferSize) {
					reject$3(/* @__PURE__ */ new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
					return;
				}
				buffer$2.fill(chunk, pos, pos + chunk.length);
				pos += chunk.length;
			});
			stream$5.on("end", () => {
				resolve$1(pos);
			});
			stream$5.on("error", reject$3);
		});
	}
	async function streamToBuffer3(readableStream, encoding) {
		return new Promise((resolve$1, reject$3) => {
			const chunks = [];
			readableStream.on("data", (data) => {
				chunks.push(typeof data === "string" ? Buffer.from(data, encoding) : data);
			});
			readableStream.on("end", () => {
				resolve$1(Buffer.concat(chunks));
			});
			readableStream.on("error", reject$3);
		});
	}
	async function readStreamToLocalFile(rs, file) {
		return new Promise((resolve$1, reject$3) => {
			const ws = node_fs_1.default.createWriteStream(file);
			rs.on("error", (err) => {
				reject$3(err);
			});
			ws.on("error", (err) => {
				reject$3(err);
			});
			ws.on("close", resolve$1);
			rs.pipe(ws);
		});
	}
	exports.fsStat = node_util_1.default.promisify(node_fs_1.default.stat);
	exports.fsCreateReadStream = node_fs_1.default.createReadStream;
}));
var require_Clients = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PageBlobClient = exports.BlockBlobClient = exports.AppendBlobClient = exports.BlobClient = void 0;
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_auth_1 = require_commonjs$11();
	var core_util_1 = require_commonjs$14();
	var core_util_2 = require_commonjs$14();
	var BlobDownloadResponse_js_1 = require_BlobDownloadResponse();
	var BlobQueryResponse_js_1 = require_BlobQueryResponse();
	var AnonymousCredential_js_1 = require_AnonymousCredential$1();
	var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential$1();
	var models_js_1 = require_models();
	var PageBlobRangeResponse_js_1 = require_PageBlobRangeResponse();
	var Pipeline_js_1 = require_Pipeline();
	var BlobStartCopyFromUrlPoller_js_1 = require_BlobStartCopyFromUrlPoller();
	var Range_js_1 = require_Range();
	var StorageClient_js_1 = require_StorageClient();
	var Batch_js_1 = require_Batch();
	var storage_common_1 = require_commonjs$7();
	var constants_js_1 = require_constants$4();
	var tracing_js_1 = require_tracing();
	var utils_common_js_1 = require_utils_common$2();
	var utils_js_1 = require_utils$1();
	var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
	var BlobLeaseClient_js_1 = require_BlobLeaseClient();
	var BlobClient = class BlobClient extends StorageClient_js_1.StorageClient {
		blobContext;
		_name;
		_containerName;
		_versionId;
		_snapshot;
		get name() {
			return this._name;
		}
		get containerName() {
			return this._containerName;
		}
		constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
			options = options || {};
			let pipeline;
			let url;
			if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				pipeline = credentialOrPipelineOrContainerName;
			} else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				options = blobNameOrOptions;
				pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
			} else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
				url = urlOrConnectionString;
				if (blobNameOrOptions && typeof blobNameOrOptions !== "string") options = blobNameOrOptions;
				pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
			} else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
				const containerName = credentialOrPipelineOrContainerName;
				const blobName = blobNameOrOptions;
				const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
				if (extractedCreds.kind === "AccountConnString") if (core_util_1.isNodeLike) {
					const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
					url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
					if (!options.proxyOptions) options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
					pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
				} else throw new Error("Account connection string is only supported in Node.js environment");
				else if (extractedCreds.kind === "SASConnString") {
					url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
					pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
				} else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
			} else throw new Error("Expecting non-empty strings for containerName and blobName parameters");
			super(url, pipeline);
			({blobName: this._name, containerName: this._containerName} = this.getBlobAndContainerNamesFromUrl());
			this.blobContext = this.storageClientContext.blob;
			this._snapshot = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT);
			this._versionId = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID);
		}
		withSnapshot(snapshot) {
			return new BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
		}
		withVersion(versionId) {
			return new BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID, versionId.length === 0 ? void 0 : versionId), this.pipeline);
		}
		getAppendBlobClient() {
			return new AppendBlobClient(this.url, this.pipeline);
		}
		getBlockBlobClient() {
			return new BlockBlobClient(this.url, this.pipeline);
		}
		getPageBlobClient() {
			return new PageBlobClient(this.url, this.pipeline);
		}
		async download(offset = 0, count, options = {}) {
			options.conditions = options.conditions || {};
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlobClient-download", options, async (updatedOptions) => {
				const res = (0, utils_common_js_1.assertResponse)(await this.blobContext.download({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					requestOptions: { onDownloadProgress: core_util_1.isNodeLike ? void 0 : options.onProgress },
					range: offset === 0 && !count ? void 0 : (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					rangeGetContentMD5: options.rangeGetContentMD5,
					rangeGetContentCRC64: options.rangeGetContentCrc64,
					snapshot: options.snapshot,
					cpkInfo: options.customerProvidedKey,
					tracingOptions: updatedOptions.tracingOptions
				}));
				const wrappedRes = {
					...res,
					_response: res._response,
					objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
					objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
				};
				if (!core_util_1.isNodeLike) return wrappedRes;
				if (options.maxRetryRequests === void 0 || options.maxRetryRequests < 0) options.maxRetryRequests = constants_js_1.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
				if (res.contentLength === void 0) throw new RangeError(`File download response doesn't contain valid content length header`);
				if (!res.etag) throw new RangeError(`File download response doesn't contain valid etag header`);
				return new BlobDownloadResponse_js_1.BlobDownloadResponse(wrappedRes, async (start) => {
					const updatedDownloadOptions = {
						leaseAccessConditions: options.conditions,
						modifiedAccessConditions: {
							ifMatch: options.conditions.ifMatch || res.etag,
							ifModifiedSince: options.conditions.ifModifiedSince,
							ifNoneMatch: options.conditions.ifNoneMatch,
							ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,
							ifTags: options.conditions?.tagConditions
						},
						range: (0, Range_js_1.rangeToString)({
							count: offset + res.contentLength - start,
							offset: start
						}),
						rangeGetContentMD5: options.rangeGetContentMD5,
						rangeGetContentCRC64: options.rangeGetContentCrc64,
						snapshot: options.snapshot,
						cpkInfo: options.customerProvidedKey
					};
					return (await this.blobContext.download({
						abortSignal: options.abortSignal,
						...updatedDownloadOptions
					})).readableStreamBody;
				}, offset, res.contentLength, {
					maxRetryRequests: options.maxRetryRequests,
					onProgress: options.onProgress
				});
			});
		}
		async exists(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-exists", options, async (updatedOptions) => {
				try {
					(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
					await this.getProperties({
						abortSignal: options.abortSignal,
						customerProvidedKey: options.customerProvidedKey,
						conditions: options.conditions,
						tracingOptions: updatedOptions.tracingOptions
					});
					return true;
				} catch (e$1) {
					if (e$1.statusCode === 404) return false;
					else if (e$1.statusCode === 409 && (e$1.details.errorCode === constants_js_1.BlobUsesCustomerSpecifiedEncryptionMsg || e$1.details.errorCode === constants_js_1.BlobDoesNotUseCustomerSpecifiedEncryption)) return true;
					throw e$1;
				}
			});
		}
		async getProperties(options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlobClient-getProperties", options, async (updatedOptions) => {
				const res = (0, utils_common_js_1.assertResponse)(await this.blobContext.getProperties({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					cpkInfo: options.customerProvidedKey,
					tracingOptions: updatedOptions.tracingOptions
				}));
				return {
					...res,
					_response: res._response,
					objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
					objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
				};
			});
		}
		async delete(options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("BlobClient-delete", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.delete({
					abortSignal: options.abortSignal,
					deleteSnapshots: options.deleteSnapshots,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async deleteIfExists(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-deleteIfExists", options, async (updatedOptions) => {
				try {
					const res = (0, utils_common_js_1.assertResponse)(await this.delete(updatedOptions));
					return {
						succeeded: true,
						...res,
						_response: res._response
					};
				} catch (e$1) {
					if (e$1.details?.errorCode === "BlobNotFound") return {
						succeeded: false,
						...e$1.response?.parsedHeaders,
						_response: e$1.response
					};
					throw e$1;
				}
			});
		}
		async undelete(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-undelete", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.undelete({
					abortSignal: options.abortSignal,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async setHTTPHeaders(blobHTTPHeaders, options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlobClient-setHTTPHeaders", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.setHttpHeaders({
					abortSignal: options.abortSignal,
					blobHttpHeaders: blobHTTPHeaders,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async setMetadata(metadata, options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlobClient-setMetadata", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.setMetadata({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					metadata,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async setTags(tags, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-setTags", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTags({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions,
					tags: (0, utils_common_js_1.toBlobTags)(tags)
				}));
			});
		}
		async getTags(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-getTags", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this.blobContext.getTags({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
				return {
					...response,
					_response: response._response,
					tags: (0, utils_common_js_1.toTags)({ blobTagSet: response.blobTagSet }) || {}
				};
			});
		}
		getBlobLeaseClient(proposeLeaseId) {
			return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
		}
		async createSnapshot(options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlobClient-createSnapshot", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.createSnapshot({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					metadata: options.metadata,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async beginCopyFromURL(copySource, options = {}) {
			const poller = new BlobStartCopyFromUrlPoller_js_1.BlobBeginCopyFromUrlPoller({
				blobClient: {
					abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),
					getProperties: (...args) => this.getProperties(...args),
					startCopyFromURL: (...args) => this.startCopyFromURL(...args)
				},
				copySource,
				intervalInMs: options.intervalInMs,
				onProgress: options.onProgress,
				resumeFrom: options.resumeFrom,
				startCopyFromURLOptions: options
			});
			await poller.poll();
			return poller;
		}
		async abortCopyFromURL(copyId, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-abortCopyFromURL", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.abortCopyFromURL(copyId, {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async syncCopyFromURL(copySource, options = {}) {
			options.conditions = options.conditions || {};
			options.sourceConditions = options.sourceConditions || {};
			return tracing_js_1.tracingClient.withSpan("BlobClient-syncCopyFromURL", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.copyFromURL(copySource, {
					abortSignal: options.abortSignal,
					metadata: options.metadata,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					sourceModifiedAccessConditions: {
						sourceIfMatch: options.sourceConditions?.ifMatch,
						sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
						sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
						sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
					},
					sourceContentMD5: options.sourceContentMD5,
					copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
					tier: (0, models_js_1.toAccessTier)(options.tier),
					blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
					immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
					immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
					legalHold: options.legalHold,
					encryptionScope: options.encryptionScope,
					copySourceTags: options.copySourceTags,
					fileRequestIntent: options.sourceShareTokenIntent,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async setAccessTier(tier, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-setAccessTier", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTier((0, models_js_1.toAccessTier)(tier), {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					rehydratePriority: options.rehydratePriority,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async downloadToBuffer(param1, param2, param3, param4 = {}) {
			let buffer$2;
			let offset = 0;
			let count = 0;
			let options = param4;
			if (param1 instanceof Buffer) {
				buffer$2 = param1;
				offset = param2 || 0;
				count = typeof param3 === "number" ? param3 : 0;
			} else {
				offset = typeof param1 === "number" ? param1 : 0;
				count = typeof param2 === "number" ? param2 : 0;
				options = param3 || {};
			}
			let blockSize = options.blockSize ?? 0;
			if (blockSize < 0) throw new RangeError("blockSize option must be >= 0");
			if (blockSize === 0) blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
			if (offset < 0) throw new RangeError("offset option must be >= 0");
			if (count && count <= 0) throw new RangeError("count option must be greater than 0");
			if (!options.conditions) options.conditions = {};
			return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToBuffer", options, async (updatedOptions) => {
				if (!count) {
					const response = await this.getProperties({
						...options,
						tracingOptions: updatedOptions.tracingOptions
					});
					count = response.contentLength - offset;
					if (count < 0) throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);
				}
				if (!buffer$2) try {
					buffer$2 = Buffer.alloc(count);
				} catch (error) {
					throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".\t ${error.message}`);
				}
				if (buffer$2.length < count) throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
				let transferProgress = 0;
				const batch = new Batch_js_1.Batch(options.concurrency);
				for (let off = offset; off < offset + count; off = off + blockSize) batch.addOperation(async () => {
					let chunkEnd = offset + count;
					if (off + blockSize < chunkEnd) chunkEnd = off + blockSize;
					const stream$5 = (await this.download(off, chunkEnd - off, {
						abortSignal: options.abortSignal,
						conditions: options.conditions,
						maxRetryRequests: options.maxRetryRequestsPerBlock,
						customerProvidedKey: options.customerProvidedKey,
						tracingOptions: updatedOptions.tracingOptions
					})).readableStreamBody;
					await (0, utils_js_1.streamToBuffer)(stream$5, buffer$2, off - offset, chunkEnd - offset);
					transferProgress += chunkEnd - off;
					if (options.onProgress) options.onProgress({ loadedBytes: transferProgress });
				});
				await batch.do();
				return buffer$2;
			});
		}
		async downloadToFile(filePath, offset = 0, count, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToFile", options, async (updatedOptions) => {
				const response = await this.download(offset, count, {
					...options,
					tracingOptions: updatedOptions.tracingOptions
				});
				if (response.readableStreamBody) await (0, utils_js_1.readStreamToLocalFile)(response.readableStreamBody, filePath);
				response.blobDownloadStream = void 0;
				return response;
			});
		}
		getBlobAndContainerNamesFromUrl() {
			let containerName;
			let blobName;
			try {
				const parsedUrl = new URL(this.url);
				if (parsedUrl.host.split(".")[1] === "blob") {
					const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
					containerName = pathComponents[1];
					blobName = pathComponents[3];
				} else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) {
					const pathComponents = parsedUrl.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
					containerName = pathComponents[2];
					blobName = pathComponents[4];
				} else {
					const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
					containerName = pathComponents[1];
					blobName = pathComponents[3];
				}
				containerName = decodeURIComponent(containerName);
				blobName = decodeURIComponent(blobName);
				blobName = blobName.replace(/\\/g, "/");
				if (!containerName) throw new Error("Provided containerName is invalid.");
				return {
					blobName,
					containerName
				};
			} catch (error) {
				throw new Error("Unable to extract blobName and containerName with provided information.");
			}
		}
		async startCopyFromURL(copySource, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-startCopyFromURL", options, async (updatedOptions) => {
				options.conditions = options.conditions || {};
				options.sourceConditions = options.sourceConditions || {};
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.startCopyFromURL(copySource, {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					metadata: options.metadata,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					sourceModifiedAccessConditions: {
						sourceIfMatch: options.sourceConditions.ifMatch,
						sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
						sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
						sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,
						sourceIfTags: options.sourceConditions.tagConditions
					},
					immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
					immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
					legalHold: options.legalHold,
					rehydratePriority: options.rehydratePriority,
					tier: (0, models_js_1.toAccessTier)(options.tier),
					blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
					sealBlob: options.sealBlob,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		generateSasUrl(options) {
			return new Promise((resolve$1) => {
				if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
				const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
					containerName: this._containerName,
					blobName: this._name,
					snapshotTime: this._snapshot,
					versionId: this._versionId,
					...options
				}, this.credential).toString();
				resolve$1((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
			});
		}
		generateSasStringToSign(options) {
			if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
			return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
				containerName: this._containerName,
				blobName: this._name,
				snapshotTime: this._snapshot,
				versionId: this._versionId,
				...options
			}, this.credential).stringToSign;
		}
		generateUserDelegationSasUrl(options, userDelegationKey) {
			return new Promise((resolve$1) => {
				const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
					containerName: this._containerName,
					blobName: this._name,
					snapshotTime: this._snapshot,
					versionId: this._versionId,
					...options
				}, userDelegationKey, this.accountName).toString();
				resolve$1((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
			});
		}
		generateUserDelegationSasStringToSign(options, userDelegationKey) {
			return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
				containerName: this._containerName,
				blobName: this._name,
				snapshotTime: this._snapshot,
				versionId: this._versionId,
				...options
			}, userDelegationKey, this.accountName).stringToSign;
		}
		async deleteImmutabilityPolicy(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-deleteImmutabilityPolicy", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.deleteImmutabilityPolicy({ tracingOptions: updatedOptions.tracingOptions }));
			});
		}
		async setImmutabilityPolicy(immutabilityPolicy, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-setImmutabilityPolicy", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.setImmutabilityPolicy({
					immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
					immutabilityPolicyMode: immutabilityPolicy.policyMode,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async setLegalHold(legalHoldEnabled, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-setLegalHold", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.setLegalHold(legalHoldEnabled, { tracingOptions: updatedOptions.tracingOptions }));
			});
		}
		async getAccountInfo(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobClient-getAccountInfo", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blobContext.getAccountInfo({
					abortSignal: options.abortSignal,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
	};
	exports.BlobClient = BlobClient;
	var AppendBlobClient = class AppendBlobClient extends BlobClient {
		appendBlobContext;
		constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
			let pipeline;
			let url;
			options = options || {};
			if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				pipeline = credentialOrPipelineOrContainerName;
			} else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				options = blobNameOrOptions;
				pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
			} else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
				url = urlOrConnectionString;
				pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
			} else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
				const containerName = credentialOrPipelineOrContainerName;
				const blobName = blobNameOrOptions;
				const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
				if (extractedCreds.kind === "AccountConnString") if (core_util_1.isNodeLike) {
					const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
					url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
					if (!options.proxyOptions) options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
					pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
				} else throw new Error("Account connection string is only supported in Node.js environment");
				else if (extractedCreds.kind === "SASConnString") {
					url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
					pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
				} else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
			} else throw new Error("Expecting non-empty strings for containerName and blobName parameters");
			super(url, pipeline);
			this.appendBlobContext = this.storageClientContext.appendBlob;
		}
		withSnapshot(snapshot) {
			return new AppendBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
		}
		async create(options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("AppendBlobClient-create", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.create(0, {
					abortSignal: options.abortSignal,
					blobHttpHeaders: options.blobHTTPHeaders,
					leaseAccessConditions: options.conditions,
					metadata: options.metadata,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
					immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
					legalHold: options.legalHold,
					blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async createIfNotExists(options = {}) {
			const conditions = { ifNoneMatch: constants_js_1.ETagAny };
			return tracing_js_1.tracingClient.withSpan("AppendBlobClient-createIfNotExists", options, async (updatedOptions) => {
				try {
					const res = (0, utils_common_js_1.assertResponse)(await this.create({
						...updatedOptions,
						conditions
					}));
					return {
						succeeded: true,
						...res,
						_response: res._response
					};
				} catch (e$1) {
					if (e$1.details?.errorCode === "BlobAlreadyExists") return {
						succeeded: false,
						...e$1.response?.parsedHeaders,
						_response: e$1.response
					};
					throw e$1;
				}
			});
		}
		async seal(options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("AppendBlobClient-seal", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.seal({
					abortSignal: options.abortSignal,
					appendPositionAccessConditions: options.conditions,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async appendBlock(body, contentLength, options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlock", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlock(contentLength, body, {
					abortSignal: options.abortSignal,
					appendPositionAccessConditions: options.conditions,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					requestOptions: { onUploadProgress: options.onProgress },
					transactionalContentMD5: options.transactionalContentMD5,
					transactionalContentCrc64: options.transactionalContentCrc64,
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {
			options.conditions = options.conditions || {};
			options.sourceConditions = options.sourceConditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlockFromURL", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
					abortSignal: options.abortSignal,
					sourceRange: (0, Range_js_1.rangeToString)({
						offset: sourceOffset,
						count
					}),
					sourceContentMD5: options.sourceContentMD5,
					sourceContentCrc64: options.sourceContentCrc64,
					leaseAccessConditions: options.conditions,
					appendPositionAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					sourceModifiedAccessConditions: {
						sourceIfMatch: options.sourceConditions?.ifMatch,
						sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
						sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
						sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
					},
					copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					fileRequestIntent: options.sourceShareTokenIntent,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
	};
	exports.AppendBlobClient = AppendBlobClient;
	var BlockBlobClient = class BlockBlobClient extends BlobClient {
		_blobContext;
		blockBlobContext;
		constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
			let pipeline;
			let url;
			options = options || {};
			if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				pipeline = credentialOrPipelineOrContainerName;
			} else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				options = blobNameOrOptions;
				pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
			} else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
				url = urlOrConnectionString;
				if (blobNameOrOptions && typeof blobNameOrOptions !== "string") options = blobNameOrOptions;
				pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
			} else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
				const containerName = credentialOrPipelineOrContainerName;
				const blobName = blobNameOrOptions;
				const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
				if (extractedCreds.kind === "AccountConnString") if (core_util_1.isNodeLike) {
					const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
					url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
					if (!options.proxyOptions) options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
					pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
				} else throw new Error("Account connection string is only supported in Node.js environment");
				else if (extractedCreds.kind === "SASConnString") {
					url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
					pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
				} else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
			} else throw new Error("Expecting non-empty strings for containerName and blobName parameters");
			super(url, pipeline);
			this.blockBlobContext = this.storageClientContext.blockBlob;
			this._blobContext = this.storageClientContext.blob;
		}
		withSnapshot(snapshot) {
			return new BlockBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
		}
		async query(query, options = {}) {
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			if (!core_util_1.isNodeLike) throw new Error("This operation currently is only supported in Node.js.");
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-query", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this._blobContext.query({
					abortSignal: options.abortSignal,
					queryRequest: {
						queryType: "SQL",
						expression: query,
						inputSerialization: (0, utils_common_js_1.toQuerySerialization)(options.inputTextConfiguration),
						outputSerialization: (0, utils_common_js_1.toQuerySerialization)(options.outputTextConfiguration)
					},
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					cpkInfo: options.customerProvidedKey,
					tracingOptions: updatedOptions.tracingOptions
				}));
				return new BlobQueryResponse_js_1.BlobQueryResponse(response, {
					abortSignal: options.abortSignal,
					onProgress: options.onProgress,
					onError: options.onError
				});
			});
		}
		async upload(body, contentLength, options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-upload", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.upload(contentLength, body, {
					abortSignal: options.abortSignal,
					blobHttpHeaders: options.blobHTTPHeaders,
					leaseAccessConditions: options.conditions,
					metadata: options.metadata,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					requestOptions: { onUploadProgress: options.onProgress },
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
					immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
					legalHold: options.legalHold,
					tier: (0, models_js_1.toAccessTier)(options.tier),
					blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async syncUploadFromURL(sourceURL, options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-syncUploadFromURL", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.putBlobFromUrl(0, sourceURL, {
					...options,
					blobHttpHeaders: options.blobHTTPHeaders,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					sourceModifiedAccessConditions: {
						sourceIfMatch: options.sourceConditions?.ifMatch,
						sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
						sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
						sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince,
						sourceIfTags: options.sourceConditions?.tagConditions
					},
					cpkInfo: options.customerProvidedKey,
					copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
					tier: (0, models_js_1.toAccessTier)(options.tier),
					blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
					copySourceTags: options.copySourceTags,
					fileRequestIntent: options.sourceShareTokenIntent,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async stageBlock(blockId, body, contentLength, options = {}) {
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlock", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlock(blockId, contentLength, body, {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					requestOptions: { onUploadProgress: options.onProgress },
					transactionalContentMD5: options.transactionalContentMD5,
					transactionalContentCrc64: options.transactionalContentCrc64,
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlockFromURL", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					sourceContentMD5: options.sourceContentMD5,
					sourceContentCrc64: options.sourceContentCrc64,
					sourceRange: offset === 0 && !count ? void 0 : (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
					fileRequestIntent: options.sourceShareTokenIntent,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async commitBlockList(blocks, options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-commitBlockList", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.commitBlockList({ latest: blocks }, {
					abortSignal: options.abortSignal,
					blobHttpHeaders: options.blobHTTPHeaders,
					leaseAccessConditions: options.conditions,
					metadata: options.metadata,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
					immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
					legalHold: options.legalHold,
					tier: (0, models_js_1.toAccessTier)(options.tier),
					blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async getBlockList(listType, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-getBlockList", options, async (updatedOptions) => {
				const res = (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.getBlockList(listType, {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
				if (!res.committedBlocks) res.committedBlocks = [];
				if (!res.uncommittedBlocks) res.uncommittedBlocks = [];
				return res;
			});
		}
		async uploadData(data, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadData", options, async (updatedOptions) => {
				if (core_util_1.isNodeLike) {
					let buffer$2;
					if (data instanceof Buffer) buffer$2 = data;
					else if (data instanceof ArrayBuffer) buffer$2 = Buffer.from(data);
					else {
						data = data;
						buffer$2 = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
					}
					return this.uploadSeekableInternal((offset, size) => buffer$2.slice(offset, offset + size), buffer$2.byteLength, updatedOptions);
				} else {
					const browserBlob = new Blob([data]);
					return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
				}
			});
		}
		async uploadBrowserData(browserData, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadBrowserData", options, async (updatedOptions) => {
				const browserBlob = new Blob([browserData]);
				return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
			});
		}
		async uploadSeekableInternal(bodyFactory, size, options = {}) {
			let blockSize = options.blockSize ?? 0;
			if (blockSize < 0 || blockSize > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) throw new RangeError(`blockSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
			const maxSingleShotSize = options.maxSingleShotSize ?? constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
			if (maxSingleShotSize < 0 || maxSingleShotSize > constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
			if (blockSize === 0) {
				if (size > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * constants_js_1.BLOCK_BLOB_MAX_BLOCKS) throw new RangeError(`${size} is too larger to upload to a block blob.`);
				if (size > maxSingleShotSize) {
					blockSize = Math.ceil(size / constants_js_1.BLOCK_BLOB_MAX_BLOCKS);
					if (blockSize < constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
				}
			}
			if (!options.blobHTTPHeaders) options.blobHTTPHeaders = {};
			if (!options.conditions) options.conditions = {};
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadSeekableInternal", options, async (updatedOptions) => {
				if (size <= maxSingleShotSize) return (0, utils_common_js_1.assertResponse)(await this.upload(bodyFactory(0, size), size, updatedOptions));
				const numBlocks = Math.floor((size - 1) / blockSize) + 1;
				if (numBlocks > constants_js_1.BLOCK_BLOB_MAX_BLOCKS) throw new RangeError(`The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= ${constants_js_1.BLOCK_BLOB_MAX_BLOCKS}`);
				const blockList = [];
				const blockIDPrefix = (0, core_util_2.randomUUID)();
				let transferProgress = 0;
				const batch = new Batch_js_1.Batch(options.concurrency);
				for (let i = 0; i < numBlocks; i++) batch.addOperation(async () => {
					const blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, i);
					const start = blockSize * i;
					const contentLength = (i === numBlocks - 1 ? size : start + blockSize) - start;
					blockList.push(blockID);
					await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {
						abortSignal: options.abortSignal,
						conditions: options.conditions,
						encryptionScope: options.encryptionScope,
						tracingOptions: updatedOptions.tracingOptions
					});
					transferProgress += contentLength;
					if (options.onProgress) options.onProgress({ loadedBytes: transferProgress });
				});
				await batch.do();
				return this.commitBlockList(blockList, updatedOptions);
			});
		}
		async uploadFile(filePath, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadFile", options, async (updatedOptions) => {
				const size = (await (0, utils_js_1.fsStat)(filePath)).size;
				return this.uploadSeekableInternal((offset, count) => {
					return () => (0, utils_js_1.fsCreateReadStream)(filePath, {
						autoClose: true,
						end: count ? offset + count - 1 : Infinity,
						start: offset
					});
				}, size, {
					...options,
					tracingOptions: updatedOptions.tracingOptions
				});
			});
		}
		async uploadStream(stream$5, bufferSize = constants_js_1.DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {
			if (!options.blobHTTPHeaders) options.blobHTTPHeaders = {};
			if (!options.conditions) options.conditions = {};
			return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadStream", options, async (updatedOptions) => {
				let blockNum = 0;
				const blockIDPrefix = (0, core_util_2.randomUUID)();
				let transferProgress = 0;
				const blockList = [];
				await new storage_common_1.BufferScheduler(stream$5, bufferSize, maxConcurrency, async (body, length) => {
					const blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, blockNum);
					blockList.push(blockID);
					blockNum++;
					await this.stageBlock(blockID, body, length, {
						customerProvidedKey: options.customerProvidedKey,
						conditions: options.conditions,
						encryptionScope: options.encryptionScope,
						tracingOptions: updatedOptions.tracingOptions
					});
					transferProgress += length;
					if (options.onProgress) options.onProgress({ loadedBytes: transferProgress });
				}, Math.ceil(maxConcurrency / 4 * 3)).do();
				return (0, utils_common_js_1.assertResponse)(await this.commitBlockList(blockList, {
					...options,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
	};
	exports.BlockBlobClient = BlockBlobClient;
	var PageBlobClient = class PageBlobClient extends BlobClient {
		pageBlobContext;
		constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
			let pipeline;
			let url;
			options = options || {};
			if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				pipeline = credentialOrPipelineOrContainerName;
			} else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				options = blobNameOrOptions;
				pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
			} else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
				url = urlOrConnectionString;
				pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
			} else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
				const containerName = credentialOrPipelineOrContainerName;
				const blobName = blobNameOrOptions;
				const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
				if (extractedCreds.kind === "AccountConnString") if (core_util_1.isNodeLike) {
					const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
					url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
					if (!options.proxyOptions) options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
					pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
				} else throw new Error("Account connection string is only supported in Node.js environment");
				else if (extractedCreds.kind === "SASConnString") {
					url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
					pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
				} else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
			} else throw new Error("Expecting non-empty strings for containerName and blobName parameters");
			super(url, pipeline);
			this.pageBlobContext = this.storageClientContext.pageBlob;
		}
		withSnapshot(snapshot) {
			return new PageBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
		}
		async create(size, options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-create", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.create(0, size, {
					abortSignal: options.abortSignal,
					blobHttpHeaders: options.blobHTTPHeaders,
					blobSequenceNumber: options.blobSequenceNumber,
					leaseAccessConditions: options.conditions,
					metadata: options.metadata,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
					immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
					legalHold: options.legalHold,
					tier: (0, models_js_1.toAccessTier)(options.tier),
					blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async createIfNotExists(size, options = {}) {
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-createIfNotExists", options, async (updatedOptions) => {
				try {
					const conditions = { ifNoneMatch: constants_js_1.ETagAny };
					const res = (0, utils_common_js_1.assertResponse)(await this.create(size, {
						...options,
						conditions,
						tracingOptions: updatedOptions.tracingOptions
					}));
					return {
						succeeded: true,
						...res,
						_response: res._response
					};
				} catch (e$1) {
					if (e$1.details?.errorCode === "BlobAlreadyExists") return {
						succeeded: false,
						...e$1.response?.parsedHeaders,
						_response: e$1.response
					};
					throw e$1;
				}
			});
		}
		async uploadPages(body, offset, count, options = {}) {
			options.conditions = options.conditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPages", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPages(count, body, {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					requestOptions: { onUploadProgress: options.onProgress },
					range: (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					sequenceNumberAccessConditions: options.conditions,
					transactionalContentMD5: options.transactionalContentMD5,
					transactionalContentCrc64: options.transactionalContentCrc64,
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
			options.conditions = options.conditions || {};
			options.sourceConditions = options.sourceConditions || {};
			(0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps);
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPagesFromURL", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPagesFromURL(sourceURL, (0, Range_js_1.rangeToString)({
					offset: sourceOffset,
					count
				}), 0, (0, Range_js_1.rangeToString)({
					offset: destOffset,
					count
				}), {
					abortSignal: options.abortSignal,
					sourceContentMD5: options.sourceContentMD5,
					sourceContentCrc64: options.sourceContentCrc64,
					leaseAccessConditions: options.conditions,
					sequenceNumberAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					sourceModifiedAccessConditions: {
						sourceIfMatch: options.sourceConditions?.ifMatch,
						sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
						sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
						sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
					},
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
					fileRequestIntent: options.sourceShareTokenIntent,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async clearPages(offset = 0, count, options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-clearPages", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.clearPages(0, {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					range: (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					sequenceNumberAccessConditions: options.conditions,
					cpkInfo: options.customerProvidedKey,
					encryptionScope: options.encryptionScope,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async getPageRanges(offset = 0, count, options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRanges", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					range: (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					tracingOptions: updatedOptions.tracingOptions
				}));
				return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response);
			});
		}
		async listPageRangesSegment(offset = 0, count, marker, options = {}) {
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesSegment", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					range: (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					marker,
					maxPageSize: options.maxPageSize,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async *listPageRangeItemSegments(offset = 0, count, marker, options = {}) {
			let getPageRangeItemSegmentsResponse;
			if (!!marker || marker === void 0) do {
				getPageRangeItemSegmentsResponse = await this.listPageRangesSegment(offset, count, marker, options);
				marker = getPageRangeItemSegmentsResponse.continuationToken;
				yield await getPageRangeItemSegmentsResponse;
			} while (marker);
		}
		async *listPageRangeItems(offset = 0, count, options = {}) {
			let marker;
			for await (const getPageRangesSegment of this.listPageRangeItemSegments(offset, count, marker, options)) yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
		}
		listPageRanges(offset = 0, count, options = {}) {
			options.conditions = options.conditions || {};
			const iter = this.listPageRangeItems(offset, count, options);
			return {
				next() {
					return iter.next();
				},
				[Symbol.asyncIterator]() {
					return this;
				},
				byPage: (settings = {}) => {
					return this.listPageRangeItemSegments(offset, count, settings.continuationToken, {
						maxPageSize: settings.maxPageSize,
						...options
					});
				}
			};
		}
		async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiff", options, async (updatedOptions) => {
				const result = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					prevsnapshot: prevSnapshot,
					range: (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					tracingOptions: updatedOptions.tracingOptions
				}));
				return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(result);
			});
		}
		async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options = {}) {
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiffSegment", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
					abortSignal: options?.abortSignal,
					leaseAccessConditions: options?.conditions,
					modifiedAccessConditions: {
						...options?.conditions,
						ifTags: options?.conditions?.tagConditions
					},
					prevsnapshot: prevSnapshotOrUrl,
					range: (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					marker,
					maxPageSize: options?.maxPageSize,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async *listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options) {
			let getPageRangeItemSegmentsResponse;
			if (!!marker || marker === void 0) do {
				getPageRangeItemSegmentsResponse = await this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options);
				marker = getPageRangeItemSegmentsResponse.continuationToken;
				yield await getPageRangeItemSegmentsResponse;
			} while (marker);
		}
		async *listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {
			let marker;
			for await (const getPageRangesSegment of this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options)) yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
		}
		listPageRangesDiff(offset, count, prevSnapshot, options = {}) {
			options.conditions = options.conditions || {};
			const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, { ...options });
			return {
				next() {
					return iter.next();
				},
				[Symbol.asyncIterator]() {
					return this;
				},
				byPage: (settings = {}) => {
					return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, {
						maxPageSize: settings.maxPageSize,
						...options
					});
				}
			};
		}
		async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					prevSnapshotUrl,
					range: (0, Range_js_1.rangeToString)({
						offset,
						count
					}),
					tracingOptions: updatedOptions.tracingOptions
				}));
				return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response);
			});
		}
		async resize(size, options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-resize", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.resize(size, {
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					encryptionScope: options.encryptionScope,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-updateSequenceNumber", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, {
					abortSignal: options.abortSignal,
					blobSequenceNumber: sequenceNumber,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async startCopyIncremental(copySource, options = {}) {
			return tracing_js_1.tracingClient.withSpan("PageBlobClient-startCopyIncremental", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.copyIncremental(copySource, {
					abortSignal: options.abortSignal,
					modifiedAccessConditions: {
						...options.conditions,
						ifTags: options.conditions?.tagConditions
					},
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
	};
	exports.PageBlobClient = PageBlobClient;
}));
var require_BatchUtils = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getBodyAsText = getBodyAsText;
	exports.utf8ByteLength = utf8ByteLength;
	var utils_js_1 = require_utils$1();
	var constants_js_1 = require_constants$4();
	async function getBodyAsText(batchResponse) {
		let buffer$2 = Buffer.alloc(constants_js_1.BATCH_MAX_PAYLOAD_IN_BYTES);
		const responseLength = await (0, utils_js_1.streamToBuffer2)(batchResponse.readableStreamBody, buffer$2);
		buffer$2 = buffer$2.slice(0, responseLength);
		return buffer$2.toString();
	}
	function utf8ByteLength(str) {
		return Buffer.byteLength(str);
	}
}));
var require_BatchResponseParser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BatchResponseParser = void 0;
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_http_compat_1 = require_commonjs$9();
	var constants_js_1 = require_constants$4();
	var BatchUtils_js_1 = require_BatchUtils();
	var log_js_1 = require_log$2();
	var HTTP_HEADER_DELIMITER = ": ";
	var SPACE_DELIMITER = " ";
	var NOT_FOUND = -1;
	var BatchResponseParser = class {
		batchResponse;
		responseBatchBoundary;
		perResponsePrefix;
		batchResponseEnding;
		subRequests;
		constructor(batchResponse, subRequests) {
			if (!batchResponse || !batchResponse.contentType) throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
			if (!subRequests || subRequests.size === 0) throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
			this.batchResponse = batchResponse;
			this.subRequests = subRequests;
			this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
			this.perResponsePrefix = `--${this.responseBatchBoundary}${constants_js_1.HTTP_LINE_ENDING}`;
			this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
		}
		async parseBatchResponse() {
			if (this.batchResponse._response.status !== constants_js_1.HTTPURLConnection.HTTP_ACCEPTED) throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
			const subResponses = (await (0, BatchUtils_js_1.getBodyAsText)(this.batchResponse)).split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1);
			const subResponseCount = subResponses.length;
			if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
			const deserializedSubResponses = new Array(subResponseCount);
			let subResponsesSucceededCount = 0;
			let subResponsesFailedCount = 0;
			for (let index$1 = 0; index$1 < subResponseCount; index$1++) {
				const subResponse = subResponses[index$1];
				const deserializedSubResponse = {};
				deserializedSubResponse.headers = (0, core_http_compat_1.toHttpHeadersLike)((0, core_rest_pipeline_1.createHttpHeaders)());
				const responseLines = subResponse.split(`${constants_js_1.HTTP_LINE_ENDING}`);
				let subRespHeaderStartFound = false;
				let subRespHeaderEndFound = false;
				let subRespFailed = false;
				let contentId = NOT_FOUND;
				for (const responseLine of responseLines) {
					if (!subRespHeaderStartFound) {
						if (responseLine.startsWith(constants_js_1.HeaderConstants.CONTENT_ID)) contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
						if (responseLine.startsWith(constants_js_1.HTTP_VERSION_1_1)) {
							subRespHeaderStartFound = true;
							const tokens = responseLine.split(SPACE_DELIMITER);
							deserializedSubResponse.status = parseInt(tokens[1]);
							deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
						}
						continue;
					}
					if (responseLine.trim() === "") {
						if (!subRespHeaderEndFound) subRespHeaderEndFound = true;
						continue;
					}
					if (!subRespHeaderEndFound) {
						if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
						const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
						deserializedSubResponse.headers.set(tokens[0], tokens[1]);
						if (tokens[0] === constants_js_1.HeaderConstants.X_MS_ERROR_CODE) {
							deserializedSubResponse.errorCode = tokens[1];
							subRespFailed = true;
						}
					} else {
						if (!deserializedSubResponse.bodyAsText) deserializedSubResponse.bodyAsText = "";
						deserializedSubResponse.bodyAsText += responseLine;
					}
				}
				if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === void 0) {
					deserializedSubResponse._request = this.subRequests.get(contentId);
					deserializedSubResponses[contentId] = deserializedSubResponse;
				} else log_js_1.logger.error(`subResponses[${index$1}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
				if (subRespFailed) subResponsesFailedCount++;
				else subResponsesSucceededCount++;
			}
			return {
				subResponses: deserializedSubResponses,
				subResponsesSucceededCount,
				subResponsesFailedCount
			};
		}
	};
	exports.BatchResponseParser = BatchResponseParser;
}));
var require_Mutex = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Mutex = void 0;
	var MutexLockStatus;
	(function(MutexLockStatus) {
		MutexLockStatus[MutexLockStatus["LOCKED"] = 0] = "LOCKED";
		MutexLockStatus[MutexLockStatus["UNLOCKED"] = 1] = "UNLOCKED";
	})(MutexLockStatus || (MutexLockStatus = {}));
	var Mutex = class {
		static async lock(key) {
			return new Promise((resolve$1) => {
				if (this.keys[key] === void 0 || this.keys[key] === MutexLockStatus.UNLOCKED) {
					this.keys[key] = MutexLockStatus.LOCKED;
					resolve$1();
				} else this.onUnlockEvent(key, () => {
					this.keys[key] = MutexLockStatus.LOCKED;
					resolve$1();
				});
			});
		}
		static async unlock(key) {
			return new Promise((resolve$1) => {
				if (this.keys[key] === MutexLockStatus.LOCKED) this.emitUnlockEvent(key);
				delete this.keys[key];
				resolve$1();
			});
		}
		static keys = {};
		static listeners = {};
		static onUnlockEvent(key, handler$1) {
			if (this.listeners[key] === void 0) this.listeners[key] = [handler$1];
			else this.listeners[key].push(handler$1);
		}
		static emitUnlockEvent(key) {
			if (this.listeners[key] !== void 0 && this.listeners[key].length > 0) {
				const handler$1 = this.listeners[key].shift();
				setImmediate(() => {
					handler$1.call(this);
				});
			}
		}
	};
	exports.Mutex = Mutex;
}));
var require_BlobBatch = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobBatch = void 0;
	var core_util_1 = require_commonjs$14();
	var core_auth_1 = require_commonjs$11();
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_util_2 = require_commonjs$14();
	var AnonymousCredential_js_1 = require_AnonymousCredential$1();
	var Clients_js_1 = require_Clients();
	var Mutex_js_1 = require_Mutex();
	var Pipeline_js_1 = require_Pipeline();
	var utils_common_js_1 = require_utils_common$2();
	var core_xml_1 = require_commonjs$8();
	var constants_js_1 = require_constants$4();
	var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential$1();
	var tracing_js_1 = require_tracing();
	var core_client_1 = require_commonjs$10();
	var StorageSharedKeyCredentialPolicyV2_js_1 = require_StorageSharedKeyCredentialPolicyV2();
	var BlobBatch = class {
		batchRequest;
		batch = "batch";
		batchType;
		constructor() {
			this.batchRequest = new InnerBatchRequest();
		}
		getMultiPartContentType() {
			return this.batchRequest.getMultipartContentType();
		}
		getHttpRequestBody() {
			return this.batchRequest.getHttpRequestBody();
		}
		getSubRequests() {
			return this.batchRequest.getSubRequests();
		}
		async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
			await Mutex_js_1.Mutex.lock(this.batch);
			try {
				this.batchRequest.preAddSubRequest(subRequest);
				await assembleSubRequestFunc();
				this.batchRequest.postAddSubRequest(subRequest);
			} finally {
				await Mutex_js_1.Mutex.unlock(this.batch);
			}
		}
		setBatchType(batchType) {
			if (!this.batchType) this.batchType = batchType;
			if (this.batchType !== batchType) throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
		}
		async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {
			let url;
			let credential;
			if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrOptions instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrOptions))) {
				url = urlOrBlobClient;
				credential = credentialOrOptions;
			} else if (urlOrBlobClient instanceof Clients_js_1.BlobClient) {
				url = urlOrBlobClient.url;
				credential = urlOrBlobClient.credential;
				options = credentialOrOptions;
			} else throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
			if (!options) options = {};
			return tracing_js_1.tracingClient.withSpan("BatchDeleteRequest-addSubRequest", options, async (updatedOptions) => {
				this.setBatchType("delete");
				await this.addSubRequestInternal({
					url,
					credential
				}, async () => {
					await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
				});
			});
		}
		async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
			let url;
			let credential;
			let tier;
			if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrTier instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrTier))) {
				url = urlOrBlobClient;
				credential = credentialOrTier;
				tier = tierOrOptions;
			} else if (urlOrBlobClient instanceof Clients_js_1.BlobClient) {
				url = urlOrBlobClient.url;
				credential = urlOrBlobClient.credential;
				tier = credentialOrTier;
				options = tierOrOptions;
			} else throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
			if (!options) options = {};
			return tracing_js_1.tracingClient.withSpan("BatchSetTierRequest-addSubRequest", options, async (updatedOptions) => {
				this.setBatchType("setAccessTier");
				await this.addSubRequestInternal({
					url,
					credential
				}, async () => {
					await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);
				});
			});
		}
	};
	exports.BlobBatch = BlobBatch;
	var InnerBatchRequest = class {
		operationCount;
		body;
		subRequests;
		boundary;
		subRequestPrefix;
		multipartContentType;
		batchRequestEnding;
		constructor() {
			this.operationCount = 0;
			this.body = "";
			this.boundary = `batch_${(0, core_util_1.randomUUID)()}`;
			this.subRequestPrefix = `--${this.boundary}${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TYPE}: application/http${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
			this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
			this.batchRequestEnding = `--${this.boundary}--`;
			this.subRequests = /* @__PURE__ */ new Map();
		}
		createPipeline(credential) {
			const corePipeline = (0, core_rest_pipeline_1.createEmptyPipeline)();
			corePipeline.addPolicy((0, core_client_1.serializationPolicy)({
				stringifyXML: core_xml_1.stringifyXML,
				serializerOptions: { xml: { xmlCharKey: "#" } }
			}), { phase: "Serialize" });
			corePipeline.addPolicy(batchHeaderFilterPolicy());
			corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: "Sign" });
			if ((0, core_auth_1.isTokenCredential)(credential)) corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
				credential,
				scopes: constants_js_1.StorageOAuthScopes,
				challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
			}), { phase: "Sign" });
			else if (credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential) corePipeline.addPolicy((0, StorageSharedKeyCredentialPolicyV2_js_1.storageSharedKeyCredentialPolicy)({
				accountName: credential.accountName,
				accountKey: credential.accountKey
			}), { phase: "Sign" });
			const pipeline = new Pipeline_js_1.Pipeline([]);
			pipeline._credential = credential;
			pipeline._corePipeline = corePipeline;
			return pipeline;
		}
		appendSubRequestToBody(request$1) {
			this.body += [
				this.subRequestPrefix,
				`${constants_js_1.HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
				"",
				`${request$1.method.toString()} ${(0, utils_common_js_1.getURLPathAndQuery)(request$1.url)} ${constants_js_1.HTTP_VERSION_1_1}${constants_js_1.HTTP_LINE_ENDING}`
			].join(constants_js_1.HTTP_LINE_ENDING);
			for (const [name$1, value$1] of request$1.headers) this.body += `${name$1}: ${value$1}${constants_js_1.HTTP_LINE_ENDING}`;
			this.body += constants_js_1.HTTP_LINE_ENDING;
		}
		preAddSubRequest(subRequest) {
			if (this.operationCount >= constants_js_1.BATCH_MAX_REQUEST) throw new RangeError(`Cannot exceed ${constants_js_1.BATCH_MAX_REQUEST} sub requests in a single batch`);
			const path$5 = (0, utils_common_js_1.getURLPath)(subRequest.url);
			if (!path$5 || path$5 === "") throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
		}
		postAddSubRequest(subRequest) {
			this.subRequests.set(this.operationCount, subRequest);
			this.operationCount++;
		}
		getHttpRequestBody() {
			return `${this.body}${this.batchRequestEnding}${constants_js_1.HTTP_LINE_ENDING}`;
		}
		getMultipartContentType() {
			return this.multipartContentType;
		}
		getSubRequests() {
			return this.subRequests;
		}
	};
	function batchRequestAssemblePolicy(batchRequest) {
		return {
			name: "batchRequestAssemblePolicy",
			async sendRequest(request$1) {
				batchRequest.appendSubRequestToBody(request$1);
				return {
					request: request$1,
					status: 200,
					headers: (0, core_rest_pipeline_1.createHttpHeaders)()
				};
			}
		};
	}
	function batchHeaderFilterPolicy() {
		return {
			name: "batchHeaderFilterPolicy",
			async sendRequest(request$1, next) {
				let xMsHeaderName = "";
				for (const [name$1] of request$1.headers) if ((0, utils_common_js_1.iEqual)(name$1, constants_js_1.HeaderConstants.X_MS_VERSION)) xMsHeaderName = name$1;
				if (xMsHeaderName !== "") request$1.headers.delete(xMsHeaderName);
				return next(request$1);
			}
		};
	}
}));
var require_BlobBatchClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobBatchClient = void 0;
	var BatchResponseParser_js_1 = require_BatchResponseParser();
	var BatchUtils_js_1 = require_BatchUtils();
	var BlobBatch_js_1 = require_BlobBatch();
	var tracing_js_1 = require_tracing();
	var AnonymousCredential_js_1 = require_AnonymousCredential$1();
	var StorageContextClient_js_1 = require_StorageContextClient();
	var Pipeline_js_1 = require_Pipeline();
	var utils_common_js_1 = require_utils_common$2();
	var BlobBatchClient = class {
		serviceOrContainerContext;
		constructor(url, credentialOrPipeline, options) {
			let pipeline;
			if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline)) pipeline = credentialOrPipeline;
			else if (!credentialOrPipeline) pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
			else pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options);
			const storageClientContext = new StorageContextClient_js_1.StorageContextClient(url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline));
			const path$5 = (0, utils_common_js_1.getURLPath)(url);
			if (path$5 && path$5 !== "/") this.serviceOrContainerContext = storageClientContext.container;
			else this.serviceOrContainerContext = storageClientContext.service;
		}
		createBatch() {
			return new BlobBatch_js_1.BlobBatch();
		}
		async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options) {
			const batch = new BlobBatch_js_1.BlobBatch();
			for (const urlOrBlobClient of urlsOrBlobClients) if (typeof urlOrBlobClient === "string") await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options);
			else await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
			return this.submitBatch(batch);
		}
		async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
			const batch = new BlobBatch_js_1.BlobBatch();
			for (const urlOrBlobClient of urlsOrBlobClients) if (typeof urlOrBlobClient === "string") await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options);
			else await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
			return this.submitBatch(batch);
		}
		async submitBatch(batchRequest, options = {}) {
			if (!batchRequest || batchRequest.getSubRequests().size === 0) throw new RangeError("Batch request should contain one or more sub requests.");
			return tracing_js_1.tracingClient.withSpan("BlobBatchClient-submitBatch", options, async (updatedOptions) => {
				const batchRequestBody = batchRequest.getHttpRequestBody();
				const rawBatchResponse = (0, utils_common_js_1.assertResponse)(await this.serviceOrContainerContext.submitBatch((0, BatchUtils_js_1.utf8ByteLength)(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, { ...updatedOptions }));
				const responseSummary = await new BatchResponseParser_js_1.BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests()).parseBatchResponse();
				return {
					_response: rawBatchResponse._response,
					contentType: rawBatchResponse.contentType,
					errorCode: rawBatchResponse.errorCode,
					requestId: rawBatchResponse.requestId,
					clientRequestId: rawBatchResponse.clientRequestId,
					version: rawBatchResponse.version,
					subResponses: responseSummary.subResponses,
					subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
					subResponsesFailedCount: responseSummary.subResponsesFailedCount
				};
			});
		}
	};
	exports.BlobBatchClient = BlobBatchClient;
}));
var require_ContainerClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ContainerClient = void 0;
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_util_1 = require_commonjs$14();
	var core_auth_1 = require_commonjs$11();
	var AnonymousCredential_js_1 = require_AnonymousCredential$1();
	var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential$1();
	var Pipeline_js_1 = require_Pipeline();
	var StorageClient_js_1 = require_StorageClient();
	var tracing_js_1 = require_tracing();
	var utils_common_js_1 = require_utils_common$2();
	var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
	var BlobLeaseClient_js_1 = require_BlobLeaseClient();
	var Clients_js_1 = require_Clients();
	var BlobBatchClient_js_1 = require_BlobBatchClient();
	var ContainerClient = class extends StorageClient_js_1.StorageClient {
		containerContext;
		_containerName;
		get containerName() {
			return this._containerName;
		}
		constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options) {
			let pipeline;
			let url;
			options = options || {};
			if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				pipeline = credentialOrPipelineOrContainerName;
			} else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName)) {
				url = urlOrConnectionString;
				pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
			} else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
				url = urlOrConnectionString;
				pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
			} else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
				const containerName = credentialOrPipelineOrContainerName;
				const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
				if (extractedCreds.kind === "AccountConnString") if (core_util_1.isNodeLike) {
					const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
					url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName));
					if (!options.proxyOptions) options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
					pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
				} else throw new Error("Account connection string is only supported in Node.js environment");
				else if (extractedCreds.kind === "SASConnString") {
					url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
					pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
				} else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
			} else throw new Error("Expecting non-empty strings for containerName parameter");
			super(url, pipeline);
			this._containerName = this.getContainerNameFromUrl();
			this.containerContext = this.storageClientContext.container;
		}
		async create(options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-create", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.containerContext.create(updatedOptions));
			});
		}
		async createIfNotExists(options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-createIfNotExists", options, async (updatedOptions) => {
				try {
					const res = await this.create(updatedOptions);
					return {
						succeeded: true,
						...res,
						_response: res._response
					};
				} catch (e$1) {
					if (e$1.details?.errorCode === "ContainerAlreadyExists") return {
						succeeded: false,
						...e$1.response?.parsedHeaders,
						_response: e$1.response
					};
					else throw e$1;
				}
			});
		}
		async exists(options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-exists", options, async (updatedOptions) => {
				try {
					await this.getProperties({
						abortSignal: options.abortSignal,
						tracingOptions: updatedOptions.tracingOptions
					});
					return true;
				} catch (e$1) {
					if (e$1.statusCode === 404) return false;
					throw e$1;
				}
			});
		}
		getBlobClient(blobName) {
			return new Clients_js_1.BlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
		}
		getAppendBlobClient(blobName) {
			return new Clients_js_1.AppendBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
		}
		getBlockBlobClient(blobName) {
			return new Clients_js_1.BlockBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
		}
		getPageBlobClient(blobName) {
			return new Clients_js_1.PageBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
		}
		async getProperties(options = {}) {
			if (!options.conditions) options.conditions = {};
			return tracing_js_1.tracingClient.withSpan("ContainerClient-getProperties", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.containerContext.getProperties({
					abortSignal: options.abortSignal,
					...options.conditions,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async delete(options = {}) {
			if (!options.conditions) options.conditions = {};
			return tracing_js_1.tracingClient.withSpan("ContainerClient-delete", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.containerContext.delete({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: options.conditions,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async deleteIfExists(options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteIfExists", options, async (updatedOptions) => {
				try {
					const res = await this.delete(updatedOptions);
					return {
						succeeded: true,
						...res,
						_response: res._response
					};
				} catch (e$1) {
					if (e$1.details?.errorCode === "ContainerNotFound") return {
						succeeded: false,
						...e$1.response?.parsedHeaders,
						_response: e$1.response
					};
					throw e$1;
				}
			});
		}
		async setMetadata(metadata, options = {}) {
			if (!options.conditions) options.conditions = {};
			if (options.conditions.ifUnmodifiedSince) throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
			return tracing_js_1.tracingClient.withSpan("ContainerClient-setMetadata", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.containerContext.setMetadata({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					metadata,
					modifiedAccessConditions: options.conditions,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async getAccessPolicy(options = {}) {
			if (!options.conditions) options.conditions = {};
			return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccessPolicy", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccessPolicy({
					abortSignal: options.abortSignal,
					leaseAccessConditions: options.conditions,
					tracingOptions: updatedOptions.tracingOptions
				}));
				const res = {
					_response: response._response,
					blobPublicAccess: response.blobPublicAccess,
					date: response.date,
					etag: response.etag,
					errorCode: response.errorCode,
					lastModified: response.lastModified,
					requestId: response.requestId,
					clientRequestId: response.clientRequestId,
					signedIdentifiers: [],
					version: response.version
				};
				for (const identifier of response) {
					let accessPolicy = void 0;
					if (identifier.accessPolicy) {
						accessPolicy = { permissions: identifier.accessPolicy.permissions };
						if (identifier.accessPolicy.expiresOn) accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
						if (identifier.accessPolicy.startsOn) accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
					}
					res.signedIdentifiers.push({
						accessPolicy,
						id: identifier.id
					});
				}
				return res;
			});
		}
		async setAccessPolicy(access, containerAcl, options = {}) {
			options.conditions = options.conditions || {};
			return tracing_js_1.tracingClient.withSpan("ContainerClient-setAccessPolicy", options, async (updatedOptions) => {
				const acl = [];
				for (const identifier of containerAcl || []) acl.push({
					accessPolicy: {
						expiresOn: identifier.accessPolicy.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.expiresOn) : "",
						permissions: identifier.accessPolicy.permissions,
						startsOn: identifier.accessPolicy.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.startsOn) : ""
					},
					id: identifier.id
				});
				return (0, utils_common_js_1.assertResponse)(await this.containerContext.setAccessPolicy({
					abortSignal: options.abortSignal,
					access,
					containerAcl: acl,
					leaseAccessConditions: options.conditions,
					modifiedAccessConditions: options.conditions,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		getBlobLeaseClient(proposeLeaseId) {
			return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
		}
		async uploadBlockBlob(blobName, body, contentLength, options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-uploadBlockBlob", options, async (updatedOptions) => {
				const blockBlobClient = this.getBlockBlobClient(blobName);
				return {
					blockBlobClient,
					response: await blockBlobClient.upload(body, contentLength, updatedOptions)
				};
			});
		}
		async deleteBlob(blobName, options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteBlob", options, async (updatedOptions) => {
				let blobClient = this.getBlobClient(blobName);
				if (options.versionId) blobClient = blobClient.withVersion(options.versionId);
				return blobClient.delete(updatedOptions);
			});
		}
		async listBlobFlatSegment(marker, options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobFlatSegment", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobFlatSegment({
					marker,
					...options,
					tracingOptions: updatedOptions.tracingOptions
				}));
				return {
					...response,
					_response: {
						...response._response,
						parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobFlat)(response._response.parsedBody)
					},
					segment: {
						...response.segment,
						blobItems: response.segment.blobItems.map((blobItemInternal) => {
							return {
								...blobItemInternal,
								name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
								tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
								objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
							};
						})
					}
				};
			});
		}
		async listBlobHierarchySegment(delimiter, marker, options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobHierarchySegment", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobHierarchySegment(delimiter, {
					marker,
					...options,
					tracingOptions: updatedOptions.tracingOptions
				}));
				return {
					...response,
					_response: {
						...response._response,
						parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobHierarchy)(response._response.parsedBody)
					},
					segment: {
						...response.segment,
						blobItems: response.segment.blobItems.map((blobItemInternal) => {
							return {
								...blobItemInternal,
								name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
								tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
								objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
							};
						}),
						blobPrefixes: response.segment.blobPrefixes?.map((blobPrefixInternal) => {
							return {
								...blobPrefixInternal,
								name: (0, utils_common_js_1.BlobNameToString)(blobPrefixInternal.name)
							};
						})
					}
				};
			});
		}
		async *listSegments(marker, options = {}) {
			let listBlobsFlatSegmentResponse;
			if (!!marker || marker === void 0) do {
				listBlobsFlatSegmentResponse = await this.listBlobFlatSegment(marker, options);
				marker = listBlobsFlatSegmentResponse.continuationToken;
				yield await listBlobsFlatSegmentResponse;
			} while (marker);
		}
		async *listItems(options = {}) {
			let marker;
			for await (const listBlobsFlatSegmentResponse of this.listSegments(marker, options)) yield* listBlobsFlatSegmentResponse.segment.blobItems;
		}
		listBlobsFlat(options = {}) {
			const include = [];
			if (options.includeCopy) include.push("copy");
			if (options.includeDeleted) include.push("deleted");
			if (options.includeMetadata) include.push("metadata");
			if (options.includeSnapshots) include.push("snapshots");
			if (options.includeVersions) include.push("versions");
			if (options.includeUncommitedBlobs) include.push("uncommittedblobs");
			if (options.includeTags) include.push("tags");
			if (options.includeDeletedWithVersions) include.push("deletedwithversions");
			if (options.includeImmutabilityPolicy) include.push("immutabilitypolicy");
			if (options.includeLegalHold) include.push("legalhold");
			if (options.prefix === "") options.prefix = void 0;
			const updatedOptions = {
				...options,
				...include.length > 0 ? { include } : {}
			};
			const iter = this.listItems(updatedOptions);
			return {
				next() {
					return iter.next();
				},
				[Symbol.asyncIterator]() {
					return this;
				},
				byPage: (settings = {}) => {
					return this.listSegments(settings.continuationToken, {
						maxPageSize: settings.maxPageSize,
						...updatedOptions
					});
				}
			};
		}
		async *listHierarchySegments(delimiter, marker, options = {}) {
			let listBlobsHierarchySegmentResponse;
			if (!!marker || marker === void 0) do {
				listBlobsHierarchySegmentResponse = await this.listBlobHierarchySegment(delimiter, marker, options);
				marker = listBlobsHierarchySegmentResponse.continuationToken;
				yield await listBlobsHierarchySegmentResponse;
			} while (marker);
		}
		async *listItemsByHierarchy(delimiter, options = {}) {
			let marker;
			for await (const listBlobsHierarchySegmentResponse of this.listHierarchySegments(delimiter, marker, options)) {
				const segment = listBlobsHierarchySegmentResponse.segment;
				if (segment.blobPrefixes) for (const prefix of segment.blobPrefixes) yield {
					kind: "prefix",
					...prefix
				};
				for (const blob of segment.blobItems) yield {
					kind: "blob",
					...blob
				};
			}
		}
		listBlobsByHierarchy(delimiter, options = {}) {
			if (delimiter === "") throw new RangeError("delimiter should contain one or more characters");
			const include = [];
			if (options.includeCopy) include.push("copy");
			if (options.includeDeleted) include.push("deleted");
			if (options.includeMetadata) include.push("metadata");
			if (options.includeSnapshots) include.push("snapshots");
			if (options.includeVersions) include.push("versions");
			if (options.includeUncommitedBlobs) include.push("uncommittedblobs");
			if (options.includeTags) include.push("tags");
			if (options.includeDeletedWithVersions) include.push("deletedwithversions");
			if (options.includeImmutabilityPolicy) include.push("immutabilitypolicy");
			if (options.includeLegalHold) include.push("legalhold");
			if (options.prefix === "") options.prefix = void 0;
			const updatedOptions = {
				...options,
				...include.length > 0 ? { include } : {}
			};
			const iter = this.listItemsByHierarchy(delimiter, updatedOptions);
			return {
				async next() {
					return iter.next();
				},
				[Symbol.asyncIterator]() {
					return this;
				},
				byPage: (settings = {}) => {
					return this.listHierarchySegments(delimiter, settings.continuationToken, {
						maxPageSize: settings.maxPageSize,
						...updatedOptions
					});
				}
			};
		}
		async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
				const response = (0, utils_common_js_1.assertResponse)(await this.containerContext.filterBlobs({
					abortSignal: options.abortSignal,
					where: tagFilterSqlExpression,
					marker,
					maxPageSize: options.maxPageSize,
					tracingOptions: updatedOptions.tracingOptions
				}));
				return {
					...response,
					_response: response._response,
					blobs: response.blobs.map((blob) => {
						let tagValue = "";
						if (blob.tags?.blobTagSet.length === 1) tagValue = blob.tags.blobTagSet[0].value;
						return {
							...blob,
							tags: (0, utils_common_js_1.toTags)(blob.tags),
							tagValue
						};
					})
				};
			});
		}
		async *findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
			let response;
			if (!!marker || marker === void 0) do {
				response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);
				response.blobs = response.blobs || [];
				marker = response.continuationToken;
				yield response;
			} while (marker);
		}
		async *findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
			let marker;
			for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)) yield* segment.blobs;
		}
		findBlobsByTags(tagFilterSqlExpression, options = {}) {
			const listSegmentOptions = { ...options };
			const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
			return {
				next() {
					return iter.next();
				},
				[Symbol.asyncIterator]() {
					return this;
				},
				byPage: (settings = {}) => {
					return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
						maxPageSize: settings.maxPageSize,
						...listSegmentOptions
					});
				}
			};
		}
		async getAccountInfo(options = {}) {
			return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccountInfo", options, async (updatedOptions) => {
				return (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccountInfo({
					abortSignal: options.abortSignal,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		getContainerNameFromUrl() {
			let containerName;
			try {
				const parsedUrl = new URL(this.url);
				if (parsedUrl.hostname.split(".")[1] === "blob") containerName = parsedUrl.pathname.split("/")[1];
				else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) containerName = parsedUrl.pathname.split("/")[2];
				else containerName = parsedUrl.pathname.split("/")[1];
				containerName = decodeURIComponent(containerName);
				if (!containerName) throw new Error("Provided containerName is invalid.");
				return containerName;
			} catch (error) {
				throw new Error("Unable to extract containerName with provided information.");
			}
		}
		generateSasUrl(options) {
			return new Promise((resolve$1) => {
				if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
				const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
					containerName: this._containerName,
					...options
				}, this.credential).toString();
				resolve$1((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
			});
		}
		generateSasStringToSign(options) {
			if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
			return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
				containerName: this._containerName,
				...options
			}, this.credential).stringToSign;
		}
		generateUserDelegationSasUrl(options, userDelegationKey) {
			return new Promise((resolve$1) => {
				const sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
					containerName: this._containerName,
					...options
				}, userDelegationKey, this.accountName).toString();
				resolve$1((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
			});
		}
		generateUserDelegationSasStringToSign(options, userDelegationKey) {
			return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
				containerName: this._containerName,
				...options
			}, userDelegationKey, this.accountName).stringToSign;
		}
		getBlobBatchClient() {
			return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
		}
	};
	exports.ContainerClient = ContainerClient;
}));
var require_AccountSASPermissions = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AccountSASPermissions = void 0;
	exports.AccountSASPermissions = class AccountSASPermissions {
		static parse(permissions) {
			const accountSASPermissions = new AccountSASPermissions();
			for (const c of permissions) switch (c) {
				case "r":
					accountSASPermissions.read = true;
					break;
				case "w":
					accountSASPermissions.write = true;
					break;
				case "d":
					accountSASPermissions.delete = true;
					break;
				case "x":
					accountSASPermissions.deleteVersion = true;
					break;
				case "l":
					accountSASPermissions.list = true;
					break;
				case "a":
					accountSASPermissions.add = true;
					break;
				case "c":
					accountSASPermissions.create = true;
					break;
				case "u":
					accountSASPermissions.update = true;
					break;
				case "p":
					accountSASPermissions.process = true;
					break;
				case "t":
					accountSASPermissions.tag = true;
					break;
				case "f":
					accountSASPermissions.filter = true;
					break;
				case "i":
					accountSASPermissions.setImmutabilityPolicy = true;
					break;
				case "y":
					accountSASPermissions.permanentDelete = true;
					break;
				default: throw new RangeError(`Invalid permission character: ${c}`);
			}
			return accountSASPermissions;
		}
		static from(permissionLike) {
			const accountSASPermissions = new AccountSASPermissions();
			if (permissionLike.read) accountSASPermissions.read = true;
			if (permissionLike.write) accountSASPermissions.write = true;
			if (permissionLike.delete) accountSASPermissions.delete = true;
			if (permissionLike.deleteVersion) accountSASPermissions.deleteVersion = true;
			if (permissionLike.filter) accountSASPermissions.filter = true;
			if (permissionLike.tag) accountSASPermissions.tag = true;
			if (permissionLike.list) accountSASPermissions.list = true;
			if (permissionLike.add) accountSASPermissions.add = true;
			if (permissionLike.create) accountSASPermissions.create = true;
			if (permissionLike.update) accountSASPermissions.update = true;
			if (permissionLike.process) accountSASPermissions.process = true;
			if (permissionLike.setImmutabilityPolicy) accountSASPermissions.setImmutabilityPolicy = true;
			if (permissionLike.permanentDelete) accountSASPermissions.permanentDelete = true;
			return accountSASPermissions;
		}
		read = false;
		write = false;
		delete = false;
		deleteVersion = false;
		list = false;
		add = false;
		create = false;
		update = false;
		process = false;
		tag = false;
		filter = false;
		setImmutabilityPolicy = false;
		permanentDelete = false;
		toString() {
			const permissions = [];
			if (this.read) permissions.push("r");
			if (this.write) permissions.push("w");
			if (this.delete) permissions.push("d");
			if (this.deleteVersion) permissions.push("x");
			if (this.filter) permissions.push("f");
			if (this.tag) permissions.push("t");
			if (this.list) permissions.push("l");
			if (this.add) permissions.push("a");
			if (this.create) permissions.push("c");
			if (this.update) permissions.push("u");
			if (this.process) permissions.push("p");
			if (this.setImmutabilityPolicy) permissions.push("i");
			if (this.permanentDelete) permissions.push("y");
			return permissions.join("");
		}
	};
}));
var require_AccountSASResourceTypes = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AccountSASResourceTypes = void 0;
	exports.AccountSASResourceTypes = class AccountSASResourceTypes {
		static parse(resourceTypes) {
			const accountSASResourceTypes = new AccountSASResourceTypes();
			for (const c of resourceTypes) switch (c) {
				case "s":
					accountSASResourceTypes.service = true;
					break;
				case "c":
					accountSASResourceTypes.container = true;
					break;
				case "o":
					accountSASResourceTypes.object = true;
					break;
				default: throw new RangeError(`Invalid resource type: ${c}`);
			}
			return accountSASResourceTypes;
		}
		service = false;
		container = false;
		object = false;
		toString() {
			const resourceTypes = [];
			if (this.service) resourceTypes.push("s");
			if (this.container) resourceTypes.push("c");
			if (this.object) resourceTypes.push("o");
			return resourceTypes.join("");
		}
	};
}));
var require_AccountSASServices = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AccountSASServices = void 0;
	exports.AccountSASServices = class AccountSASServices {
		static parse(services) {
			const accountSASServices = new AccountSASServices();
			for (const c of services) switch (c) {
				case "b":
					accountSASServices.blob = true;
					break;
				case "f":
					accountSASServices.file = true;
					break;
				case "q":
					accountSASServices.queue = true;
					break;
				case "t":
					accountSASServices.table = true;
					break;
				default: throw new RangeError(`Invalid service character: ${c}`);
			}
			return accountSASServices;
		}
		blob = false;
		file = false;
		queue = false;
		table = false;
		toString() {
			const services = [];
			if (this.blob) services.push("b");
			if (this.table) services.push("t");
			if (this.queue) services.push("q");
			if (this.file) services.push("f");
			return services.join("");
		}
	};
}));
var require_AccountSASSignatureValues = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
	exports.generateAccountSASQueryParametersInternal = generateAccountSASQueryParametersInternal;
	var AccountSASPermissions_js_1 = require_AccountSASPermissions();
	var AccountSASResourceTypes_js_1 = require_AccountSASResourceTypes();
	var AccountSASServices_js_1 = require_AccountSASServices();
	var SasIPRange_js_1 = require_SasIPRange();
	var SASQueryParameters_js_1 = require_SASQueryParameters();
	var constants_js_1 = require_constants$4();
	var utils_common_js_1 = require_utils_common$2();
	function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
		return generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential).sasQueryParameters;
	}
	function generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential) {
		const version$1 = accountSASSignatureValues.version ? accountSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
		if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version$1 < "2020-08-04") throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
		if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version$1 < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
		if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version$1 < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
		if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version$1 < "2019-12-12") throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
		if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version$1 < "2019-12-12") throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
		if (accountSASSignatureValues.encryptionScope && version$1 < "2020-12-06") throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
		const parsedPermissions = AccountSASPermissions_js_1.AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
		const parsedServices = AccountSASServices_js_1.AccountSASServices.parse(accountSASSignatureValues.services).toString();
		const parsedResourceTypes = AccountSASResourceTypes_js_1.AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
		let stringToSign;
		if (version$1 >= "2020-12-06") stringToSign = [
			sharedKeyCredential.accountName,
			parsedPermissions,
			parsedServices,
			parsedResourceTypes,
			accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, false) : "",
			(0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, false),
			accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
			accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
			version$1,
			accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
			""
		].join("\n");
		else stringToSign = [
			sharedKeyCredential.accountName,
			parsedPermissions,
			parsedServices,
			parsedResourceTypes,
			accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, false) : "",
			(0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, false),
			accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
			accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
			version$1,
			""
		].join("\n");
		const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
		return {
			sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(version$1, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, accountSASSignatureValues.encryptionScope),
			stringToSign
		};
	}
}));
var require_BlobServiceClient = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BlobServiceClient = void 0;
	var core_auth_1 = require_commonjs$11();
	var core_rest_pipeline_1 = require_commonjs$12();
	var core_util_1 = require_commonjs$14();
	var Pipeline_js_1 = require_Pipeline();
	var ContainerClient_js_1 = require_ContainerClient();
	var utils_common_js_1 = require_utils_common$2();
	var StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential$1();
	var AnonymousCredential_js_1 = require_AnonymousCredential$1();
	var utils_common_js_2 = require_utils_common$2();
	var tracing_js_1 = require_tracing();
	var BlobBatchClient_js_1 = require_BlobBatchClient();
	var StorageClient_js_1 = require_StorageClient();
	var AccountSASPermissions_js_1 = require_AccountSASPermissions();
	var AccountSASSignatureValues_js_1 = require_AccountSASSignatureValues();
	var AccountSASServices_js_1 = require_AccountSASServices();
	exports.BlobServiceClient = class BlobServiceClient extends StorageClient_js_1.StorageClient {
		serviceContext;
		static fromConnectionString(connectionString, options) {
			options = options || {};
			const extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(connectionString);
			if (extractedCreds.kind === "AccountConnString") if (core_util_1.isNodeLike) {
				const sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
				if (!options.proxyOptions) options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
				const pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
				return new BlobServiceClient(extractedCreds.url, pipeline);
			} else throw new Error("Account connection string is only supported in Node.js environment");
			else if (extractedCreds.kind === "SASConnString") {
				const pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
				return new BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
			} else throw new Error("Connection string must be either an Account connection string or a SAS connection string");
		}
		constructor(url, credentialOrPipeline, options) {
			let pipeline;
			if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline)) pipeline = credentialOrPipeline;
			else if (core_util_1.isNodeLike && credentialOrPipeline instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipeline)) pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options);
			else pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential(), options);
			super(url, pipeline);
			this.serviceContext = this.storageClientContext.service;
		}
		getContainerClient(containerName) {
			return new ContainerClient_js_1.ContainerClient((0, utils_common_js_1.appendToURLPath)(this.url, encodeURIComponent(containerName)), this.pipeline);
		}
		async createContainer(containerName, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-createContainer", options, async (updatedOptions) => {
				const containerClient = this.getContainerClient(containerName);
				return {
					containerClient,
					containerCreateResponse: await containerClient.create(updatedOptions)
				};
			});
		}
		async deleteContainer(containerName, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-deleteContainer", options, async (updatedOptions) => {
				return this.getContainerClient(containerName).delete(updatedOptions);
			});
		}
		async undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-undeleteContainer", options, async (updatedOptions) => {
				const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName);
				const containerContext = containerClient["storageClientContext"].container;
				return {
					containerClient,
					containerUndeleteResponse: (0, utils_common_js_2.assertResponse)(await containerContext.restore({
						deletedContainerName,
						deletedContainerVersion,
						tracingOptions: updatedOptions.tracingOptions
					}))
				};
			});
		}
		async getProperties(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getProperties", options, async (updatedOptions) => {
				return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getProperties({
					abortSignal: options.abortSignal,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async setProperties(properties, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-setProperties", options, async (updatedOptions) => {
				return (0, utils_common_js_2.assertResponse)(await this.serviceContext.setProperties(properties, {
					abortSignal: options.abortSignal,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async getStatistics(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getStatistics", options, async (updatedOptions) => {
				return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getStatistics({
					abortSignal: options.abortSignal,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async getAccountInfo(options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getAccountInfo", options, async (updatedOptions) => {
				return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getAccountInfo({
					abortSignal: options.abortSignal,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async listContainersSegment(marker, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-listContainersSegment", options, async (updatedOptions) => {
				return (0, utils_common_js_2.assertResponse)(await this.serviceContext.listContainersSegment({
					abortSignal: options.abortSignal,
					marker,
					...options,
					include: typeof options.include === "string" ? [options.include] : options.include,
					tracingOptions: updatedOptions.tracingOptions
				}));
			});
		}
		async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
				const response = (0, utils_common_js_2.assertResponse)(await this.serviceContext.filterBlobs({
					abortSignal: options.abortSignal,
					where: tagFilterSqlExpression,
					marker,
					maxPageSize: options.maxPageSize,
					tracingOptions: updatedOptions.tracingOptions
				}));
				return {
					...response,
					_response: response._response,
					blobs: response.blobs.map((blob) => {
						let tagValue = "";
						if (blob.tags?.blobTagSet.length === 1) tagValue = blob.tags.blobTagSet[0].value;
						return {
							...blob,
							tags: (0, utils_common_js_1.toTags)(blob.tags),
							tagValue
						};
					})
				};
			});
		}
		async *findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
			let response;
			if (!!marker || marker === void 0) do {
				response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);
				response.blobs = response.blobs || [];
				marker = response.continuationToken;
				yield response;
			} while (marker);
		}
		async *findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
			let marker;
			for await (const segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)) yield* segment.blobs;
		}
		findBlobsByTags(tagFilterSqlExpression, options = {}) {
			const listSegmentOptions = { ...options };
			const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
			return {
				next() {
					return iter.next();
				},
				[Symbol.asyncIterator]() {
					return this;
				},
				byPage: (settings = {}) => {
					return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
						maxPageSize: settings.maxPageSize,
						...listSegmentOptions
					});
				}
			};
		}
		async *listSegments(marker, options = {}) {
			let listContainersSegmentResponse;
			if (!!marker || marker === void 0) do {
				listContainersSegmentResponse = await this.listContainersSegment(marker, options);
				listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
				marker = listContainersSegmentResponse.continuationToken;
				yield await listContainersSegmentResponse;
			} while (marker);
		}
		async *listItems(options = {}) {
			let marker;
			for await (const segment of this.listSegments(marker, options)) yield* segment.containerItems;
		}
		listContainers(options = {}) {
			if (options.prefix === "") options.prefix = void 0;
			const include = [];
			if (options.includeDeleted) include.push("deleted");
			if (options.includeMetadata) include.push("metadata");
			if (options.includeSystem) include.push("system");
			const listSegmentOptions = {
				...options,
				...include.length > 0 ? { include } : {}
			};
			const iter = this.listItems(listSegmentOptions);
			return {
				next() {
					return iter.next();
				},
				[Symbol.asyncIterator]() {
					return this;
				},
				byPage: (settings = {}) => {
					return this.listSegments(settings.continuationToken, {
						maxPageSize: settings.maxPageSize,
						...listSegmentOptions
					});
				}
			};
		}
		async getUserDelegationKey(startsOn, expiresOn, options = {}) {
			return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getUserDelegationKey", options, async (updatedOptions) => {
				const response = (0, utils_common_js_2.assertResponse)(await this.serviceContext.getUserDelegationKey({
					startsOn: (0, utils_common_js_2.truncatedISO8061Date)(startsOn, false),
					expiresOn: (0, utils_common_js_2.truncatedISO8061Date)(expiresOn, false)
				}, {
					abortSignal: options.abortSignal,
					tracingOptions: updatedOptions.tracingOptions
				}));
				const userDelegationKey = {
					signedObjectId: response.signedObjectId,
					signedTenantId: response.signedTenantId,
					signedStartsOn: new Date(response.signedStartsOn),
					signedExpiresOn: new Date(response.signedExpiresOn),
					signedService: response.signedService,
					signedVersion: response.signedVersion,
					value: response.value
				};
				return {
					_response: response._response,
					requestId: response.requestId,
					clientRequestId: response.clientRequestId,
					version: response.version,
					date: response.date,
					errorCode: response.errorCode,
					...userDelegationKey
				};
			});
		}
		getBlobBatchClient() {
			return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
		}
		generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
			if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
			if (expiresOn === void 0) {
				const now = /* @__PURE__ */ new Date();
				expiresOn = new Date(now.getTime() + 3600 * 1e3);
			}
			const sas = (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParameters)({
				permissions,
				expiresOn,
				resourceTypes,
				services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
				...options
			}, this.credential).toString();
			return (0, utils_common_js_1.appendToURLQuery)(this.url, sas);
		}
		generateSasStringToSign(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
			if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)) throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
			if (expiresOn === void 0) {
				const now = /* @__PURE__ */ new Date();
				expiresOn = new Date(now.getTime() + 3600 * 1e3);
			}
			return (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParametersInternal)({
				permissions,
				expiresOn,
				resourceTypes,
				services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
				...options
			}, this.credential).stringToSign;
		}
	};
}));
var require_BatchResponse = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var require_generatedModels = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.KnownEncryptionAlgorithmType = void 0;
	var KnownEncryptionAlgorithmType;
	(function(KnownEncryptionAlgorithmType) {
		KnownEncryptionAlgorithmType["AES256"] = "AES256";
	})(KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
}));
var require_commonjs$5 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.logger = exports.RestError = exports.BaseRequestPolicy = exports.StorageOAuthScopes = exports.newPipeline = exports.isPipelineLike = exports.Pipeline = exports.getBlobServiceAccountAudience = exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = exports.generateBlobSASQueryParameters = exports.generateAccountSASQueryParameters = void 0;
	var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	var core_rest_pipeline_1 = require_commonjs$12();
	Object.defineProperty(exports, "RestError", {
		enumerable: true,
		get: function() {
			return core_rest_pipeline_1.RestError;
		}
	});
	tslib_1.__exportStar(require_BlobServiceClient(), exports);
	tslib_1.__exportStar(require_Clients(), exports);
	tslib_1.__exportStar(require_ContainerClient(), exports);
	tslib_1.__exportStar(require_BlobLeaseClient(), exports);
	tslib_1.__exportStar(require_AccountSASPermissions(), exports);
	tslib_1.__exportStar(require_AccountSASResourceTypes(), exports);
	tslib_1.__exportStar(require_AccountSASServices(), exports);
	var AccountSASSignatureValues_js_1 = require_AccountSASSignatureValues();
	Object.defineProperty(exports, "generateAccountSASQueryParameters", {
		enumerable: true,
		get: function() {
			return AccountSASSignatureValues_js_1.generateAccountSASQueryParameters;
		}
	});
	tslib_1.__exportStar(require_BlobBatch(), exports);
	tslib_1.__exportStar(require_BlobBatchClient(), exports);
	tslib_1.__exportStar(require_BatchResponse(), exports);
	tslib_1.__exportStar(require_BlobSASPermissions(), exports);
	var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
	Object.defineProperty(exports, "generateBlobSASQueryParameters", {
		enumerable: true,
		get: function() {
			return BlobSASSignatureValues_js_1.generateBlobSASQueryParameters;
		}
	});
	tslib_1.__exportStar(require_StorageBrowserPolicyFactory(), exports);
	tslib_1.__exportStar(require_ContainerSASPermissions(), exports);
	tslib_1.__exportStar(require_AnonymousCredential$1(), exports);
	tslib_1.__exportStar(require_Credential$1(), exports);
	tslib_1.__exportStar(require_StorageSharedKeyCredential$1(), exports);
	var models_js_1 = require_models();
	Object.defineProperty(exports, "BlockBlobTier", {
		enumerable: true,
		get: function() {
			return models_js_1.BlockBlobTier;
		}
	});
	Object.defineProperty(exports, "PremiumPageBlobTier", {
		enumerable: true,
		get: function() {
			return models_js_1.PremiumPageBlobTier;
		}
	});
	Object.defineProperty(exports, "StorageBlobAudience", {
		enumerable: true,
		get: function() {
			return models_js_1.StorageBlobAudience;
		}
	});
	Object.defineProperty(exports, "getBlobServiceAccountAudience", {
		enumerable: true,
		get: function() {
			return models_js_1.getBlobServiceAccountAudience;
		}
	});
	var Pipeline_js_1 = require_Pipeline();
	Object.defineProperty(exports, "Pipeline", {
		enumerable: true,
		get: function() {
			return Pipeline_js_1.Pipeline;
		}
	});
	Object.defineProperty(exports, "isPipelineLike", {
		enumerable: true,
		get: function() {
			return Pipeline_js_1.isPipelineLike;
		}
	});
	Object.defineProperty(exports, "newPipeline", {
		enumerable: true,
		get: function() {
			return Pipeline_js_1.newPipeline;
		}
	});
	Object.defineProperty(exports, "StorageOAuthScopes", {
		enumerable: true,
		get: function() {
			return Pipeline_js_1.StorageOAuthScopes;
		}
	});
	tslib_1.__exportStar(require_StorageRetryPolicyFactory$1(), exports);
	var RequestPolicy_js_1 = require_RequestPolicy$1();
	Object.defineProperty(exports, "BaseRequestPolicy", {
		enumerable: true,
		get: function() {
			return RequestPolicy_js_1.BaseRequestPolicy;
		}
	});
	tslib_1.__exportStar(require_AnonymousCredentialPolicy$1(), exports);
	tslib_1.__exportStar(require_CredentialPolicy$1(), exports);
	tslib_1.__exportStar(require_StorageRetryPolicyFactory$1(), exports);
	tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicy$1(), exports);
	tslib_1.__exportStar(require_SASQueryParameters(), exports);
	tslib_1.__exportStar(require_generatedModels(), exports);
	var log_js_1 = require_log$2();
	Object.defineProperty(exports, "logger", {
		enumerable: true,
		get: function() {
			return log_js_1.logger;
		}
	});
}));
var require_blob_upload = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.uploadZipToBlobStorage = uploadZipToBlobStorage;
	var storage_blob_1 = require_commonjs$5();
	var config_1 = require_config();
	var core = __importStar(require_core$1());
	var crypto$3 = __importStar(__require("crypto"));
	var stream$4 = __importStar(__require("stream"));
	var errors_1 = require_errors$2();
	function uploadZipToBlobStorage(authenticatedUploadURL, zipUploadStream) {
		return __awaiter(this, void 0, void 0, function* () {
			let uploadByteCount = 0;
			let lastProgressTime = Date.now();
			const abortController = new AbortController();
			const chunkTimer = (interval) => __awaiter(this, void 0, void 0, function* () {
				return new Promise((resolve$1, reject$3) => {
					const timer = setInterval(() => {
						if (Date.now() - lastProgressTime > interval) reject$3(/* @__PURE__ */ new Error("Upload progress stalled."));
					}, interval);
					abortController.signal.addEventListener("abort", () => {
						clearInterval(timer);
						resolve$1();
					});
				});
			});
			const maxConcurrency = (0, config_1.getConcurrency)();
			const bufferSize = (0, config_1.getUploadChunkSize)();
			const blockBlobClient = new storage_blob_1.BlobClient(authenticatedUploadURL).getBlockBlobClient();
			core.debug(`Uploading artifact zip to blob storage with maxConcurrency: ${maxConcurrency}, bufferSize: ${bufferSize}`);
			const uploadCallback = (progress) => {
				core.info(`Uploaded bytes ${progress.loadedBytes}`);
				uploadByteCount = progress.loadedBytes;
				lastProgressTime = Date.now();
			};
			const options = {
				blobHTTPHeaders: { blobContentType: "zip" },
				onProgress: uploadCallback,
				abortSignal: abortController.signal
			};
			let sha256Hash = void 0;
			const uploadStream = new stream$4.PassThrough();
			const hashStream = crypto$3.createHash("sha256");
			zipUploadStream.pipe(uploadStream);
			zipUploadStream.pipe(hashStream).setEncoding("hex");
			core.info("Beginning upload of artifact content to blob storage");
			try {
				yield Promise.race([blockBlobClient.uploadStream(uploadStream, bufferSize, maxConcurrency, options), chunkTimer((0, config_1.getUploadChunkTimeout)())]);
			} catch (error) {
				if (errors_1.NetworkError.isNetworkErrorCode(error === null || error === void 0 ? void 0 : error.code)) throw new errors_1.NetworkError(error === null || error === void 0 ? void 0 : error.code);
				throw error;
			} finally {
				abortController.abort();
			}
			core.info("Finished uploading artifact content to blob storage!");
			hashStream.end();
			sha256Hash = hashStream.read();
			core.info(`SHA256 digest of uploaded artifact zip is ${sha256Hash}`);
			if (uploadByteCount === 0) core.warning(`No data was uploaded to blob storage. Reported upload byte count is 0.`);
			return {
				uploadSize: uploadByteCount,
				sha256Hash
			};
		});
	}
}));
var require_path = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = typeof process === "object" && process && process.platform === "win32" ? { sep: "\\" } : { sep: "/" };
}));
var require_balanced_match = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = balanced;
	function balanced(a, b, str) {
		if (a instanceof RegExp) a = maybeMatch(a, str);
		if (b instanceof RegExp) b = maybeMatch(b, str);
		var r$1 = range(a, b, str);
		return r$1 && {
			start: r$1[0],
			end: r$1[1],
			pre: str.slice(0, r$1[0]),
			body: str.slice(r$1[0] + a.length, r$1[1]),
			post: str.slice(r$1[1] + b.length)
		};
	}
	function maybeMatch(reg, str) {
		var m = str.match(reg);
		return m ? m[0] : null;
	}
	balanced.range = range;
	function range(a, b, str) {
		var begs, beg, left, right, result;
		var ai = str.indexOf(a);
		var bi = str.indexOf(b, ai + 1);
		var i = ai;
		if (ai >= 0 && bi > 0) {
			if (a === b) return [ai, bi];
			begs = [];
			left = str.length;
			while (i >= 0 && !result) {
				if (i == ai) {
					begs.push(i);
					ai = str.indexOf(a, i + 1);
				} else if (begs.length == 1) result = [begs.pop(), bi];
				else {
					beg = begs.pop();
					if (beg < left) {
						left = beg;
						right = bi;
					}
					bi = str.indexOf(b, i + 1);
				}
				i = ai < bi && ai >= 0 ? ai : bi;
			}
			if (begs.length) result = [left, right];
		}
		return result;
	}
}));
var require_brace_expansion$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var balanced = require_balanced_match();
	module.exports = expandTop;
	var escSlash = "\0SLASH" + Math.random() + "\0";
	var escOpen = "\0OPEN" + Math.random() + "\0";
	var escClose = "\0CLOSE" + Math.random() + "\0";
	var escComma = "\0COMMA" + Math.random() + "\0";
	var escPeriod = "\0PERIOD" + Math.random() + "\0";
	function numeric(str) {
		return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
	}
	function escapeBraces(str) {
		return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
	}
	function unescapeBraces(str) {
		return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
	}
	function parseCommaParts(str) {
		if (!str) return [""];
		var parts = [];
		var m = balanced("{", "}", str);
		if (!m) return str.split(",");
		var pre = m.pre;
		var body = m.body;
		var post = m.post;
		var p = pre.split(",");
		p[p.length - 1] += "{" + body + "}";
		var postParts = parseCommaParts(post);
		if (post.length) {
			p[p.length - 1] += postParts.shift();
			p.push.apply(p, postParts);
		}
		parts.push.apply(parts, p);
		return parts;
	}
	function expandTop(str) {
		if (!str) return [];
		if (str.substr(0, 2) === "{}") str = "\\{\\}" + str.substr(2);
		return expand(escapeBraces(str), true).map(unescapeBraces);
	}
	function embrace(str) {
		return "{" + str + "}";
	}
	function isPadded(el) {
		return /^-?0\d/.test(el);
	}
	function lte(i, y) {
		return i <= y;
	}
	function gte(i, y) {
		return i >= y;
	}
	function expand(str, isTop) {
		var expansions = [];
		var m = balanced("{", "}", str);
		if (!m) return [str];
		var pre = m.pre;
		var post = m.post.length ? expand(m.post, false) : [""];
		if (/\$$/.test(m.pre)) for (var k = 0; k < post.length; k++) {
			var expansion = pre + "{" + m.body + "}" + post[k];
			expansions.push(expansion);
		}
		else {
			var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
			var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
			var isSequence = isNumericSequence || isAlphaSequence;
			var isOptions = m.body.indexOf(",") >= 0;
			if (!isSequence && !isOptions) {
				if (m.post.match(/,(?!,).*\}/)) {
					str = m.pre + "{" + m.body + escClose + m.post;
					return expand(str);
				}
				return [str];
			}
			var n$1;
			if (isSequence) n$1 = m.body.split(/\.\./);
			else {
				n$1 = parseCommaParts(m.body);
				if (n$1.length === 1) {
					n$1 = expand(n$1[0], false).map(embrace);
					if (n$1.length === 1) return post.map(function(p) {
						return m.pre + n$1[0] + p;
					});
				}
			}
			var N;
			if (isSequence) {
				var x = numeric(n$1[0]);
				var y = numeric(n$1[1]);
				var width = Math.max(n$1[0].length, n$1[1].length);
				var incr = n$1.length == 3 ? Math.abs(numeric(n$1[2])) : 1;
				var test = lte;
				if (y < x) {
					incr *= -1;
					test = gte;
				}
				var pad = n$1.some(isPadded);
				N = [];
				for (var i = x; test(i, y); i += incr) {
					var c;
					if (isAlphaSequence) {
						c = String.fromCharCode(i);
						if (c === "\\") c = "";
					} else {
						c = String(i);
						if (pad) {
							var need = width - c.length;
							if (need > 0) {
								var z = new Array(need + 1).join("0");
								if (i < 0) c = "-" + z + c.slice(1);
								else c = z + c;
							}
						}
					}
					N.push(c);
				}
			} else {
				N = [];
				for (var j = 0; j < n$1.length; j++) N.push.apply(N, expand(n$1[j], false));
			}
			for (var j = 0; j < N.length; j++) for (var k = 0; k < post.length; k++) {
				var expansion = pre + N[j] + post[k];
				if (!isTop || isSequence || expansion) expansions.push(expansion);
			}
		}
		return expansions;
	}
}));
var require_minimatch = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var minimatch = module.exports = (p, pattern$1, options = {}) => {
		assertValidPattern(pattern$1);
		if (!options.nocomment && pattern$1.charAt(0) === "#") return false;
		return new Minimatch(pattern$1, options).match(p);
	};
	module.exports = minimatch;
	var path = require_path();
	minimatch.sep = path.sep;
	var GLOBSTAR = Symbol("globstar **");
	minimatch.GLOBSTAR = GLOBSTAR;
	var expand = require_brace_expansion$1();
	var plTypes = {
		"!": {
			open: "(?:(?!(?:",
			close: "))[^/]*?)"
		},
		"?": {
			open: "(?:",
			close: ")?"
		},
		"+": {
			open: "(?:",
			close: ")+"
		},
		"*": {
			open: "(?:",
			close: ")*"
		},
		"@": {
			open: "(?:",
			close: ")"
		}
	};
	var qmark = "[^/]";
	var star = qmark + "*?";
	var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
	var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
	var charSet = (s) => s.split("").reduce((set$1, c) => {
		set$1[c] = true;
		return set$1;
	}, {});
	var reSpecials = charSet("().*{}+?[]^$\\!");
	var addPatternStartSet = charSet("[.(");
	var slashSplit = /\/+/;
	minimatch.filter = (pattern$1, options = {}) => (p, i, list) => minimatch(p, pattern$1, options);
	var ext = (a, b = {}) => {
		const t$1 = {};
		Object.keys(a).forEach((k) => t$1[k] = a[k]);
		Object.keys(b).forEach((k) => t$1[k] = b[k]);
		return t$1;
	};
	minimatch.defaults = (def) => {
		if (!def || typeof def !== "object" || !Object.keys(def).length) return minimatch;
		const orig = minimatch;
		const m = (p, pattern$1, options) => orig(p, pattern$1, ext(def, options));
		m.Minimatch = class Minimatch extends orig.Minimatch {
			constructor(pattern$1, options) {
				super(pattern$1, ext(def, options));
			}
		};
		m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
		m.filter = (pattern$1, options) => orig.filter(pattern$1, ext(def, options));
		m.defaults = (options) => orig.defaults(ext(def, options));
		m.makeRe = (pattern$1, options) => orig.makeRe(pattern$1, ext(def, options));
		m.braceExpand = (pattern$1, options) => orig.braceExpand(pattern$1, ext(def, options));
		m.match = (list, pattern$1, options) => orig.match(list, pattern$1, ext(def, options));
		return m;
	};
	minimatch.braceExpand = (pattern$1, options) => braceExpand(pattern$1, options);
	var braceExpand = (pattern$1, options = {}) => {
		assertValidPattern(pattern$1);
		if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern$1)) return [pattern$1];
		return expand(pattern$1);
	};
	var MAX_PATTERN_LENGTH = 1024 * 64;
	var assertValidPattern = (pattern$1) => {
		if (typeof pattern$1 !== "string") throw new TypeError("invalid pattern");
		if (pattern$1.length > MAX_PATTERN_LENGTH) throw new TypeError("pattern is too long");
	};
	var SUBPARSE = Symbol("subparse");
	minimatch.makeRe = (pattern$1, options) => new Minimatch(pattern$1, options || {}).makeRe();
	minimatch.match = (list, pattern$1, options = {}) => {
		const mm = new Minimatch(pattern$1, options);
		list = list.filter((f) => mm.match(f));
		if (mm.options.nonull && !list.length) list.push(pattern$1);
		return list;
	};
	var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
	var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
	var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
	var Minimatch = class {
		constructor(pattern$1, options) {
			assertValidPattern(pattern$1);
			if (!options) options = {};
			this.options = options;
			this.set = [];
			this.pattern = pattern$1;
			this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
			if (this.windowsPathsNoEscape) this.pattern = this.pattern.replace(/\\/g, "/");
			this.regexp = null;
			this.negate = false;
			this.comment = false;
			this.empty = false;
			this.partial = !!options.partial;
			this.make();
		}
		debug() {}
		make() {
			const pattern$1 = this.pattern;
			const options = this.options;
			if (!options.nocomment && pattern$1.charAt(0) === "#") {
				this.comment = true;
				return;
			}
			if (!pattern$1) {
				this.empty = true;
				return;
			}
			this.parseNegate();
			let set$1 = this.globSet = this.braceExpand();
			if (options.debug) this.debug = (...args) => console.error(...args);
			this.debug(this.pattern, set$1);
			set$1 = this.globParts = set$1.map((s) => s.split(slashSplit));
			this.debug(this.pattern, set$1);
			set$1 = set$1.map((s, si, set$2) => s.map(this.parse, this));
			this.debug(this.pattern, set$1);
			set$1 = set$1.filter((s) => s.indexOf(false) === -1);
			this.debug(this.pattern, set$1);
			this.set = set$1;
		}
		parseNegate() {
			if (this.options.nonegate) return;
			const pattern$1 = this.pattern;
			let negate = false;
			let negateOffset = 0;
			for (let i = 0; i < pattern$1.length && pattern$1.charAt(i) === "!"; i++) {
				negate = !negate;
				negateOffset++;
			}
			if (negateOffset) this.pattern = pattern$1.slice(negateOffset);
			this.negate = negate;
		}
		matchOne(file, pattern$1, partial) {
			var options = this.options;
			this.debug("matchOne", {
				"this": this,
				file,
				pattern: pattern$1
			});
			this.debug("matchOne", file.length, pattern$1.length);
			for (var fi = 0, pi = 0, fl = file.length, pl = pattern$1.length; fi < fl && pi < pl; fi++, pi++) {
				this.debug("matchOne loop");
				var p = pattern$1[pi];
				var f = file[fi];
				this.debug(pattern$1, p, f);
				/* istanbul ignore if */
				if (p === false) return false;
				if (p === GLOBSTAR) {
					this.debug("GLOBSTAR", [
						pattern$1,
						p,
						f
					]);
					var fr = fi;
					var pr = pi + 1;
					if (pr === pl) {
						this.debug("** at the end");
						for (; fi < fl; fi++) if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
						return true;
					}
					while (fr < fl) {
						var swallowee = file[fr];
						this.debug("\nglobstar while", file, fr, pattern$1, pr, swallowee);
						if (this.matchOne(file.slice(fr), pattern$1.slice(pr), partial)) {
							this.debug("globstar found match!", fr, fl, swallowee);
							return true;
						} else {
							if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
								this.debug("dot detected!", file, fr, pattern$1, pr);
								break;
							}
							this.debug("globstar swallow a segment, and continue");
							fr++;
						}
					}
					/* istanbul ignore if */
					if (partial) {
						this.debug("\n>>> no match, partial?", file, fr, pattern$1, pr);
						if (fr === fl) return true;
					}
					return false;
				}
				var hit;
				if (typeof p === "string") {
					hit = f === p;
					this.debug("string match", p, f, hit);
				} else {
					hit = f.match(p);
					this.debug("pattern match", p, f, hit);
				}
				if (!hit) return false;
			}
			if (fi === fl && pi === pl) return true;
			else if (fi === fl) return partial;
			else if (pi === pl) return fi === fl - 1 && file[fi] === "";
			/* istanbul ignore next */
			throw new Error("wtf?");
		}
		braceExpand() {
			return braceExpand(this.pattern, this.options);
		}
		parse(pattern$1, isSub) {
			assertValidPattern(pattern$1);
			const options = this.options;
			if (pattern$1 === "**") if (!options.noglobstar) return GLOBSTAR;
			else pattern$1 = "*";
			if (pattern$1 === "") return "";
			let re = "";
			let hasMagic = false;
			let escaping = false;
			const patternListStack = [];
			const negativeLists = [];
			let stateChar;
			let inClass = false;
			let reClassStart = -1;
			let classStart = -1;
			let cs;
			let pl;
			let sp;
			let dotTravAllowed = pattern$1.charAt(0) === ".";
			let dotFileAllowed = options.dot || dotTravAllowed;
			const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
			const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
			const clearStateChar = () => {
				if (stateChar) {
					switch (stateChar) {
						case "*":
							re += star;
							hasMagic = true;
							break;
						case "?":
							re += qmark;
							hasMagic = true;
							break;
						default:
							re += "\\" + stateChar;
							break;
					}
					this.debug("clearStateChar %j %j", stateChar, re);
					stateChar = false;
				}
			};
			for (let i = 0, c; i < pattern$1.length && (c = pattern$1.charAt(i)); i++) {
				this.debug("%s	%s %s %j", pattern$1, i, re, c);
				if (escaping) {
					/* istanbul ignore next - completely not allowed, even escaped. */
					if (c === "/") return false;
					if (reSpecials[c]) re += "\\";
					re += c;
					escaping = false;
					continue;
				}
				switch (c) {
					case "/": return false;
					case "\\":
						if (inClass && pattern$1.charAt(i + 1) === "-") {
							re += c;
							continue;
						}
						clearStateChar();
						escaping = true;
						continue;
					case "?":
					case "*":
					case "+":
					case "@":
					case "!":
						this.debug("%s	%s %s %j <-- stateChar", pattern$1, i, re, c);
						if (inClass) {
							this.debug("  in class");
							if (c === "!" && i === classStart + 1) c = "^";
							re += c;
							continue;
						}
						this.debug("call clearStateChar %j", stateChar);
						clearStateChar();
						stateChar = c;
						if (options.noext) clearStateChar();
						continue;
					case "(": {
						if (inClass) {
							re += "(";
							continue;
						}
						if (!stateChar) {
							re += "\\(";
							continue;
						}
						const plEntry = {
							type: stateChar,
							start: i - 1,
							reStart: re.length,
							open: plTypes[stateChar].open,
							close: plTypes[stateChar].close
						};
						this.debug(this.pattern, "	", plEntry);
						patternListStack.push(plEntry);
						re += plEntry.open;
						if (plEntry.start === 0 && plEntry.type !== "!") {
							dotTravAllowed = true;
							re += subPatternStart(pattern$1.slice(i + 1));
						}
						this.debug("plType %j %j", stateChar, re);
						stateChar = false;
						continue;
					}
					case ")": {
						const plEntry = patternListStack[patternListStack.length - 1];
						if (inClass || !plEntry) {
							re += "\\)";
							continue;
						}
						patternListStack.pop();
						clearStateChar();
						hasMagic = true;
						pl = plEntry;
						re += pl.close;
						if (pl.type === "!") negativeLists.push(Object.assign(pl, { reEnd: re.length }));
						continue;
					}
					case "|": {
						const plEntry = patternListStack[patternListStack.length - 1];
						if (inClass || !plEntry) {
							re += "\\|";
							continue;
						}
						clearStateChar();
						re += "|";
						if (plEntry.start === 0 && plEntry.type !== "!") {
							dotTravAllowed = true;
							re += subPatternStart(pattern$1.slice(i + 1));
						}
						continue;
					}
					case "[":
						clearStateChar();
						if (inClass) {
							re += "\\" + c;
							continue;
						}
						inClass = true;
						classStart = i;
						reClassStart = re.length;
						re += c;
						continue;
					case "]":
						if (i === classStart + 1 || !inClass) {
							re += "\\" + c;
							continue;
						}
						cs = pattern$1.substring(classStart + 1, i);
						try {
							RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
							re += c;
						} catch (er) {
							re = re.substring(0, reClassStart) + "(?:$.)";
						}
						hasMagic = true;
						inClass = false;
						continue;
					default:
						clearStateChar();
						if (reSpecials[c] && !(c === "^" && inClass)) re += "\\";
						re += c;
						break;
				}
			}
			if (inClass) {
				cs = pattern$1.slice(classStart + 1);
				sp = this.parse(cs, SUBPARSE);
				re = re.substring(0, reClassStart) + "\\[" + sp[0];
				hasMagic = hasMagic || sp[1];
			}
			for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
				let tail;
				tail = re.slice(pl.reStart + pl.open.length);
				this.debug("setting tail", re, pl);
				tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_$1, $1, $2) => {
					/* istanbul ignore else - should already be done */
					if (!$2) $2 = "\\";
					return $1 + $1 + $2 + "|";
				});
				this.debug("tail=%j\n   %s", tail, tail, pl, re);
				const t$1 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
				hasMagic = true;
				re = re.slice(0, pl.reStart) + t$1 + "\\(" + tail;
			}
			clearStateChar();
			if (escaping) re += "\\\\";
			const addPatternStart = addPatternStartSet[re.charAt(0)];
			for (let n$1 = negativeLists.length - 1; n$1 > -1; n$1--) {
				const nl = negativeLists[n$1];
				const nlBefore = re.slice(0, nl.reStart);
				const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
				let nlAfter = re.slice(nl.reEnd);
				const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
				const closeParensBefore = nlBefore.split(")").length;
				const openParensBefore = nlBefore.split("(").length - closeParensBefore;
				let cleanAfter = nlAfter;
				for (let i = 0; i < openParensBefore; i++) cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
				nlAfter = cleanAfter;
				const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
				re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
			}
			if (re !== "" && hasMagic) re = "(?=.)" + re;
			if (addPatternStart) re = patternStart() + re;
			if (isSub === SUBPARSE) return [re, hasMagic];
			if (options.nocase && !hasMagic) hasMagic = pattern$1.toUpperCase() !== pattern$1.toLowerCase();
			if (!hasMagic) return globUnescape(pattern$1);
			const flags = options.nocase ? "i" : "";
			try {
				return Object.assign(new RegExp("^" + re + "$", flags), {
					_glob: pattern$1,
					_src: re
				});
			} catch (er) 			/* istanbul ignore next - should be impossible */ {
				return /* @__PURE__ */ new RegExp("$.");
			}
		}
		makeRe() {
			if (this.regexp || this.regexp === false) return this.regexp;
			const set$1 = this.set;
			if (!set$1.length) {
				this.regexp = false;
				return this.regexp;
			}
			const options = this.options;
			const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
			const flags = options.nocase ? "i" : "";
			let re = set$1.map((pattern$1) => {
				pattern$1 = pattern$1.map((p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set$2, p) => {
					if (!(set$2[set$2.length - 1] === GLOBSTAR && p === GLOBSTAR)) set$2.push(p);
					return set$2;
				}, []);
				pattern$1.forEach((p, i) => {
					if (p !== GLOBSTAR || pattern$1[i - 1] === GLOBSTAR) return;
					if (i === 0) if (pattern$1.length > 1) pattern$1[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern$1[i + 1];
					else pattern$1[i] = twoStar;
					else if (i === pattern$1.length - 1) pattern$1[i - 1] += "(?:\\/|" + twoStar + ")?";
					else {
						pattern$1[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern$1[i + 1];
						pattern$1[i + 1] = GLOBSTAR;
					}
				});
				return pattern$1.filter((p) => p !== GLOBSTAR).join("/");
			}).join("|");
			re = "^(?:" + re + ")$";
			if (this.negate) re = "^(?!" + re + ").*$";
			try {
				this.regexp = new RegExp(re, flags);
			} catch (ex) 			/* istanbul ignore next - should be impossible */ {
				this.regexp = false;
			}
			return this.regexp;
		}
		match(f, partial = this.partial) {
			this.debug("match", f, this.pattern);
			if (this.comment) return false;
			if (this.empty) return f === "";
			if (f === "/" && partial) return true;
			const options = this.options;
			if (path.sep !== "/") f = f.split(path.sep).join("/");
			f = f.split(slashSplit);
			this.debug(this.pattern, "split", f);
			const set$1 = this.set;
			this.debug(this.pattern, "set", set$1);
			let filename;
			for (let i = f.length - 1; i >= 0; i--) {
				filename = f[i];
				if (filename) break;
			}
			for (let i = 0; i < set$1.length; i++) {
				const pattern$1 = set$1[i];
				let file = f;
				if (options.matchBase && pattern$1.length === 1) file = [filename];
				if (this.matchOne(file, pattern$1, partial)) {
					if (options.flipNegate) return true;
					return !this.negate;
				}
			}
			if (options.flipNegate) return false;
			return this.negate;
		}
		static defaults(def) {
			return minimatch.defaults(def).Minimatch;
		}
	};
	minimatch.Minimatch = Minimatch;
}));
var require_readdir_glob = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = readdirGlob;
	var fs$5 = __require("fs");
	var { EventEmitter: EventEmitter$2 } = __require("events");
	var { Minimatch } = require_minimatch();
	var { resolve } = __require("path");
	function readdir(dir$1, strict) {
		return new Promise((resolve$1, reject$3) => {
			fs$5.readdir(dir$1, { withFileTypes: true }, (err, files$1) => {
				if (err) switch (err.code) {
					case "ENOTDIR":
						if (strict) reject$3(err);
						else resolve$1([]);
						break;
					case "ENOTSUP":
					case "ENOENT":
					case "ENAMETOOLONG":
					case "UNKNOWN":
						resolve$1([]);
						break;
					case "ELOOP":
					default:
						reject$3(err);
						break;
				}
				else resolve$1(files$1);
			});
		});
	}
	function stat(file, followSymlinks) {
		return new Promise((resolve$1, reject$3) => {
			(followSymlinks ? fs$5.stat : fs$5.lstat)(file, (err, stats) => {
				if (err) switch (err.code) {
					case "ENOENT":
						if (followSymlinks) resolve$1(stat(file, false));
						else resolve$1(null);
						break;
					default:
						resolve$1(null);
						break;
				}
				else resolve$1(stats);
			});
		});
	}
	async function* exploreWalkAsync(dir$1, path$5, followSymlinks, useStat, shouldSkip, strict) {
		let files$1 = await readdir(path$5 + dir$1, strict);
		for (const file of files$1) {
			let name$1 = file.name;
			if (name$1 === void 0) {
				name$1 = file;
				useStat = true;
			}
			const filename = dir$1 + "/" + name$1;
			const relative = filename.slice(1);
			const absolute = path$5 + "/" + relative;
			let stats = null;
			if (useStat || followSymlinks) stats = await stat(absolute, followSymlinks);
			if (!stats && file.name !== void 0) stats = file;
			if (stats === null) stats = { isDirectory: () => false };
			if (stats.isDirectory()) {
				if (!shouldSkip(relative)) {
					yield {
						relative,
						absolute,
						stats
					};
					yield* exploreWalkAsync(filename, path$5, followSymlinks, useStat, shouldSkip, false);
				}
			} else yield {
				relative,
				absolute,
				stats
			};
		}
	}
	async function* explore(path$5, followSymlinks, useStat, shouldSkip) {
		yield* exploreWalkAsync("", path$5, followSymlinks, useStat, shouldSkip, true);
	}
	function readOptions(options) {
		return {
			pattern: options.pattern,
			dot: !!options.dot,
			noglobstar: !!options.noglobstar,
			matchBase: !!options.matchBase,
			nocase: !!options.nocase,
			ignore: options.ignore,
			skip: options.skip,
			follow: !!options.follow,
			stat: !!options.stat,
			nodir: !!options.nodir,
			mark: !!options.mark,
			silent: !!options.silent,
			absolute: !!options.absolute
		};
	}
	var ReaddirGlob = class extends EventEmitter$2 {
		constructor(cwd, options, cb) {
			super();
			if (typeof options === "function") {
				cb = options;
				options = null;
			}
			this.options = readOptions(options || {});
			this.matchers = [];
			if (this.options.pattern) this.matchers = (Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern]).map((m) => new Minimatch(m, {
				dot: this.options.dot,
				noglobstar: this.options.noglobstar,
				matchBase: this.options.matchBase,
				nocase: this.options.nocase
			}));
			this.ignoreMatchers = [];
			if (this.options.ignore) this.ignoreMatchers = (Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore]).map((ignore) => new Minimatch(ignore, { dot: true }));
			this.skipMatchers = [];
			if (this.options.skip) this.skipMatchers = (Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip]).map((skip) => new Minimatch(skip, { dot: true }));
			this.iterator = explore(resolve(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
			this.paused = false;
			this.inactive = false;
			this.aborted = false;
			if (cb) {
				this._matches = [];
				this.on("match", (match$3) => this._matches.push(this.options.absolute ? match$3.absolute : match$3.relative));
				this.on("error", (err) => cb(err));
				this.on("end", () => cb(null, this._matches));
			}
			setTimeout(() => this._next(), 0);
		}
		_shouldSkipDirectory(relative) {
			return this.skipMatchers.some((m) => m.match(relative));
		}
		_fileMatches(relative, isDirectory) {
			const file = relative + (isDirectory ? "/" : "");
			return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file))) && !this.ignoreMatchers.some((m) => m.match(file)) && (!this.options.nodir || !isDirectory);
		}
		_next() {
			if (!this.paused && !this.aborted) this.iterator.next().then((obj) => {
				if (!obj.done) {
					const isDirectory = obj.value.stats.isDirectory();
					if (this._fileMatches(obj.value.relative, isDirectory)) {
						let relative = obj.value.relative;
						let absolute = obj.value.absolute;
						if (this.options.mark && isDirectory) {
							relative += "/";
							absolute += "/";
						}
						if (this.options.stat) this.emit("match", {
							relative,
							absolute,
							stat: obj.value.stats
						});
						else this.emit("match", {
							relative,
							absolute
						});
					}
					this._next(this.iterator);
				} else this.emit("end");
			}).catch((err) => {
				this.abort();
				this.emit("error", err);
				if (!err.code && !this.options.silent) console.error(err);
			});
			else this.inactive = true;
		}
		abort() {
			this.aborted = true;
		}
		pause() {
			this.paused = true;
		}
		resume() {
			this.paused = false;
			if (this.inactive) {
				this.inactive = false;
				this._next();
			}
		}
	};
	function readdirGlob(pattern$1, options, cb) {
		return new ReaddirGlob(pattern$1, options, cb);
	}
	readdirGlob.ReaddirGlob = ReaddirGlob;
}));
var async_exports = /* @__PURE__ */ __export({
	all: () => every$1,
	allLimit: () => everyLimit$1,
	allSeries: () => everySeries$1,
	any: () => some$1,
	anyLimit: () => someLimit$1,
	anySeries: () => someSeries$1,
	apply: () => apply,
	applyEach: () => applyEach,
	applyEachSeries: () => applyEachSeries,
	asyncify: () => asyncify,
	auto: () => auto,
	autoInject: () => autoInject,
	cargo: () => cargo$1,
	cargoQueue: () => cargo,
	compose: () => compose,
	concat: () => concat$1,
	concatLimit: () => concatLimit$1,
	concatSeries: () => concatSeries$1,
	constant: () => constant$1,
	default: () => index,
	detect: () => detect$1,
	detectLimit: () => detectLimit$1,
	detectSeries: () => detectSeries$1,
	dir: () => dir,
	doDuring: () => doWhilst$1,
	doUntil: () => doUntil,
	doWhilst: () => doWhilst$1,
	during: () => whilst$1,
	each: () => each,
	eachLimit: () => eachLimit$1,
	eachOf: () => eachOf$1,
	eachOfLimit: () => eachOfLimit$1,
	eachOfSeries: () => eachOfSeries$1,
	eachSeries: () => eachSeries$1,
	ensureAsync: () => ensureAsync,
	every: () => every$1,
	everyLimit: () => everyLimit$1,
	everySeries: () => everySeries$1,
	filter: () => filter$1,
	filterLimit: () => filterLimit$1,
	filterSeries: () => filterSeries$1,
	find: () => detect$1,
	findLimit: () => detectLimit$1,
	findSeries: () => detectSeries$1,
	flatMap: () => concat$1,
	flatMapLimit: () => concatLimit$1,
	flatMapSeries: () => concatSeries$1,
	foldl: () => reduce$1,
	foldr: () => reduceRight,
	forEach: () => each,
	forEachLimit: () => eachLimit$1,
	forEachOf: () => eachOf$1,
	forEachOfLimit: () => eachOfLimit$1,
	forEachOfSeries: () => eachOfSeries$1,
	forEachSeries: () => eachSeries$1,
	forever: () => forever$1,
	groupBy: () => groupBy,
	groupByLimit: () => groupByLimit$1,
	groupBySeries: () => groupBySeries,
	inject: () => reduce$1,
	log: () => log,
	map: () => map$1,
	mapLimit: () => mapLimit$1,
	mapSeries: () => mapSeries$1,
	mapValues: () => mapValues,
	mapValuesLimit: () => mapValuesLimit$1,
	mapValuesSeries: () => mapValuesSeries,
	memoize: () => memoize,
	nextTick: () => nextTick,
	parallel: () => parallel,
	parallelLimit: () => parallelLimit,
	priorityQueue: () => priorityQueue,
	queue: () => queue,
	race: () => race$1,
	reduce: () => reduce$1,
	reduceRight: () => reduceRight,
	reflect: () => reflect,
	reflectAll: () => reflectAll,
	reject: () => reject$1,
	rejectLimit: () => rejectLimit$1,
	rejectSeries: () => rejectSeries$1,
	retry: () => retry$1,
	retryable: () => retryable,
	select: () => filter$1,
	selectLimit: () => filterLimit$1,
	selectSeries: () => filterSeries$1,
	seq: () => seq,
	series: () => series,
	setImmediate: () => setImmediate$1,
	some: () => some$1,
	someLimit: () => someLimit$1,
	someSeries: () => someSeries$1,
	sortBy: () => sortBy$1,
	timeout: () => timeout,
	times: () => times,
	timesLimit: () => timesLimit,
	timesSeries: () => timesSeries,
	transform: () => transform,
	tryEach: () => tryEach$1,
	unmemoize: () => unmemoize,
	until: () => until,
	waterfall: () => waterfall$1,
	whilst: () => whilst$1,
	wrapSync: () => asyncify
}, 1);
function apply(fn, ...args) {
	return (...callArgs) => fn(...args, ...callArgs);
}
function initialParams(fn) {
	return function(...args) {
		var callback = args.pop();
		return fn.call(this, args, callback);
	};
}
function fallback(fn) {
	setTimeout(fn, 0);
}
function wrap(defer) {
	return (fn, ...args) => defer(() => fn(...args));
}
function asyncify(func) {
	if (isAsync(func)) return function(...args) {
		const callback = args.pop();
		return handlePromise(func.apply(this, args), callback);
	};
	return initialParams(function(args, callback) {
		var result;
		try {
			result = func.apply(this, args);
		} catch (e$1) {
			return callback(e$1);
		}
		if (result && typeof result.then === "function") return handlePromise(result, callback);
		else callback(null, result);
	});
}
function handlePromise(promise, callback) {
	return promise.then((value$1) => {
		invokeCallback(callback, null, value$1);
	}, (err) => {
		invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
	});
}
function invokeCallback(callback, error, value$1) {
	try {
		callback(error, value$1);
	} catch (err) {
		setImmediate$1((e$1) => {
			throw e$1;
		}, err);
	}
}
function isAsync(fn) {
	return fn[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn) {
	return fn[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
	return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
	if (typeof asyncFn !== "function") throw new Error("expected a function");
	return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}
function awaitify(asyncFn, arity) {
	if (!arity) arity = asyncFn.length;
	if (!arity) throw new Error("arity is undefined");
	function awaitable(...args) {
		if (typeof args[arity - 1] === "function") return asyncFn.apply(this, args);
		return new Promise((resolve$1, reject$3) => {
			args[arity - 1] = (err, ...cbArgs) => {
				if (err) return reject$3(err);
				resolve$1(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
			};
			asyncFn.apply(this, args);
		});
	}
	return awaitable;
}
function applyEach$1(eachfn) {
	return function applyEach$2(fns, ...callArgs) {
		return awaitify(function(callback) {
			var that = this;
			return eachfn(fns, (fn, cb) => {
				wrapAsync(fn).apply(that, callArgs.concat(cb));
			}, callback);
		});
	};
}
function _asyncMap(eachfn, arr, iteratee, callback) {
	arr = arr || [];
	var results = [];
	var counter = 0;
	var _iteratee = wrapAsync(iteratee);
	return eachfn(arr, (value$1, _$1, iterCb) => {
		var index$1 = counter++;
		_iteratee(value$1, (err, v) => {
			results[index$1] = v;
			iterCb(err);
		});
	}, (err) => {
		callback(err, results);
	});
}
function isArrayLike(value$1) {
	return value$1 && typeof value$1.length === "number" && value$1.length >= 0 && value$1.length % 1 === 0;
}
function once(fn) {
	function wrapper(...args) {
		if (fn === null) return;
		var callFn = fn;
		fn = null;
		callFn.apply(this, args);
	}
	Object.assign(wrapper, fn);
	return wrapper;
}
function getIterator(coll) {
	return coll[Symbol.iterator] && coll[Symbol.iterator]();
}
function createArrayIterator(coll) {
	var i = -1;
	var len = coll.length;
	return function next() {
		return ++i < len ? {
			value: coll[i],
			key: i
		} : null;
	};
}
function createES2015Iterator(iterator$1) {
	var i = -1;
	return function next() {
		var item = iterator$1.next();
		if (item.done) return null;
		i++;
		return {
			value: item.value,
			key: i
		};
	};
}
function createObjectIterator(obj) {
	var okeys = obj ? Object.keys(obj) : [];
	var i = -1;
	var len = okeys.length;
	return function next() {
		var key = okeys[++i];
		if (key === "__proto__") return next();
		return i < len ? {
			value: obj[key],
			key
		} : null;
	};
}
function createIterator(coll) {
	if (isArrayLike(coll)) return createArrayIterator(coll);
	var iterator$1 = getIterator(coll);
	return iterator$1 ? createES2015Iterator(iterator$1) : createObjectIterator(coll);
}
function onlyOnce(fn) {
	return function(...args) {
		if (fn === null) throw new Error("Callback was already called.");
		var callFn = fn;
		fn = null;
		callFn.apply(this, args);
	};
}
function asyncEachOfLimit(generator, limit, iteratee, callback) {
	let done = false;
	let canceled = false;
	let awaiting = false;
	let running = 0;
	let idx = 0;
	function replenish() {
		if (running >= limit || awaiting || done) return;
		awaiting = true;
		generator.next().then(({ value: value$1, done: iterDone }) => {
			if (canceled || done) return;
			awaiting = false;
			if (iterDone) {
				done = true;
				if (running <= 0) callback(null);
				return;
			}
			running++;
			iteratee(value$1, idx, iterateeCallback);
			idx++;
			replenish();
		}).catch(handleError);
	}
	function iterateeCallback(err, result) {
		running -= 1;
		if (canceled) return;
		if (err) return handleError(err);
		if (err === false) {
			done = true;
			canceled = true;
			return;
		}
		if (result === breakLoop || done && running <= 0) {
			done = true;
			return callback(null);
		}
		replenish();
	}
	function handleError(err) {
		if (canceled) return;
		awaiting = false;
		done = true;
		callback(err);
	}
	replenish();
}
function eachOfLimit(coll, limit, iteratee, callback) {
	return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
}
function eachOfArrayLike(coll, iteratee, callback) {
	callback = once(callback);
	var index$1 = 0, completed = 0, { length } = coll, canceled = false;
	if (length === 0) callback(null);
	function iteratorCallback(err, value$1) {
		if (err === false) canceled = true;
		if (canceled === true) return;
		if (err) callback(err);
		else if (++completed === length || value$1 === breakLoop) callback(null);
	}
	for (; index$1 < length; index$1++) iteratee(coll[index$1], index$1, onlyOnce(iteratorCallback));
}
function eachOfGeneric(coll, iteratee, callback) {
	return eachOfLimit$1(coll, Infinity, iteratee, callback);
}
function eachOf(coll, iteratee, callback) {
	return (isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric)(coll, wrapAsync(iteratee), callback);
}
function map(coll, iteratee, callback) {
	return _asyncMap(eachOf$1, coll, iteratee, callback);
}
function eachOfSeries(coll, iteratee, callback) {
	return eachOfLimit$1(coll, 1, iteratee, callback);
}
function mapSeries(coll, iteratee, callback) {
	return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
}
function promiseCallback() {
	let resolve$1, reject$3;
	function callback(err, ...args) {
		if (err) return reject$3(err);
		resolve$1(args.length > 1 ? args : args[0]);
	}
	callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
		resolve$1 = res, reject$3 = rej;
	});
	return callback;
}
function auto(tasks, concurrency, callback) {
	if (typeof concurrency !== "number") {
		callback = concurrency;
		concurrency = null;
	}
	callback = once(callback || promiseCallback());
	var numTasks = Object.keys(tasks).length;
	if (!numTasks) return callback(null);
	if (!concurrency) concurrency = numTasks;
	var results = {};
	var runningTasks = 0;
	var canceled = false;
	var hasError = false;
	var listeners = Object.create(null);
	var readyTasks = [];
	var readyToCheck = [];
	var uncheckedDependencies = {};
	Object.keys(tasks).forEach((key) => {
		var task = tasks[key];
		if (!Array.isArray(task)) {
			enqueueTask(key, [task]);
			readyToCheck.push(key);
			return;
		}
		var dependencies$1 = task.slice(0, task.length - 1);
		var remainingDependencies = dependencies$1.length;
		if (remainingDependencies === 0) {
			enqueueTask(key, task);
			readyToCheck.push(key);
			return;
		}
		uncheckedDependencies[key] = remainingDependencies;
		dependencies$1.forEach((dependencyName) => {
			if (!tasks[dependencyName]) throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies$1.join(", "));
			addListener(dependencyName, () => {
				remainingDependencies--;
				if (remainingDependencies === 0) enqueueTask(key, task);
			});
		});
	});
	checkForDeadlocks();
	processQueue();
	function enqueueTask(key, task) {
		readyTasks.push(() => runTask(key, task));
	}
	function processQueue() {
		if (canceled) return;
		if (readyTasks.length === 0 && runningTasks === 0) return callback(null, results);
		while (readyTasks.length && runningTasks < concurrency) readyTasks.shift()();
	}
	function addListener(taskName, fn) {
		var taskListeners = listeners[taskName];
		if (!taskListeners) taskListeners = listeners[taskName] = [];
		taskListeners.push(fn);
	}
	function taskComplete(taskName) {
		(listeners[taskName] || []).forEach((fn) => fn());
		processQueue();
	}
	function runTask(key, task) {
		if (hasError) return;
		var taskCallback = onlyOnce((err, ...result) => {
			runningTasks--;
			if (err === false) {
				canceled = true;
				return;
			}
			if (result.length < 2) [result] = result;
			if (err) {
				var safeResults = {};
				Object.keys(results).forEach((rkey) => {
					safeResults[rkey] = results[rkey];
				});
				safeResults[key] = result;
				hasError = true;
				listeners = Object.create(null);
				if (canceled) return;
				callback(err, safeResults);
			} else {
				results[key] = result;
				taskComplete(key);
			}
		});
		runningTasks++;
		var taskFn = wrapAsync(task[task.length - 1]);
		if (task.length > 1) taskFn(results, taskCallback);
		else taskFn(taskCallback);
	}
	function checkForDeadlocks() {
		var currentTask;
		var counter = 0;
		while (readyToCheck.length) {
			currentTask = readyToCheck.pop();
			counter++;
			getDependents(currentTask).forEach((dependent) => {
				if (--uncheckedDependencies[dependent] === 0) readyToCheck.push(dependent);
			});
		}
		if (counter !== numTasks) throw new Error("async.auto cannot execute tasks due to a recursive dependency");
	}
	function getDependents(taskName) {
		var result = [];
		Object.keys(tasks).forEach((key) => {
			const task = tasks[key];
			if (Array.isArray(task) && task.indexOf(taskName) >= 0) result.push(key);
		});
		return result;
	}
	return callback[PROMISE_SYMBOL];
}
function stripComments(string$1) {
	let stripped = "";
	let index$1 = 0;
	let endBlockComment = string$1.indexOf("*/");
	while (index$1 < string$1.length) if (string$1[index$1] === "/" && string$1[index$1 + 1] === "/") {
		let endIndex = string$1.indexOf("\n", index$1);
		index$1 = endIndex === -1 ? string$1.length : endIndex;
	} else if (endBlockComment !== -1 && string$1[index$1] === "/" && string$1[index$1 + 1] === "*") {
		let endIndex = string$1.indexOf("*/", index$1);
		if (endIndex !== -1) {
			index$1 = endIndex + 2;
			endBlockComment = string$1.indexOf("*/", index$1);
		} else {
			stripped += string$1[index$1];
			index$1++;
		}
	} else {
		stripped += string$1[index$1];
		index$1++;
	}
	return stripped;
}
function parseParams(func) {
	const src = stripComments(func.toString());
	let match$3 = src.match(FN_ARGS);
	if (!match$3) match$3 = src.match(ARROW_FN_ARGS);
	if (!match$3) throw new Error("could not parse args in autoInject\nSource:\n" + src);
	let [, args] = match$3;
	return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
}
function autoInject(tasks, callback) {
	var newTasks = {};
	Object.keys(tasks).forEach((key) => {
		var taskFn = tasks[key];
		var params;
		var fnIsAsync = isAsync(taskFn);
		var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
		if (Array.isArray(taskFn)) {
			params = [...taskFn];
			taskFn = params.pop();
			newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
		} else if (hasNoDeps) newTasks[key] = taskFn;
		else {
			params = parseParams(taskFn);
			if (taskFn.length === 0 && !fnIsAsync && params.length === 0) throw new Error("autoInject task functions require explicit parameters.");
			if (!fnIsAsync) params.pop();
			newTasks[key] = params.concat(newTask);
		}
		function newTask(results, taskCb) {
			var newArgs = params.map((name$1) => results[name$1]);
			newArgs.push(taskCb);
			wrapAsync(taskFn)(...newArgs);
		}
	});
	return auto(newTasks, callback);
}
function setInitial(dll, node) {
	dll.length = 1;
	dll.head = dll.tail = node;
}
function queue$1(worker, concurrency, payload) {
	if (concurrency == null) concurrency = 1;
	else if (concurrency === 0) throw new RangeError("Concurrency must not be zero");
	var _worker = wrapAsync(worker);
	var numRunning = 0;
	var workersList = [];
	const events = {
		error: [],
		drain: [],
		saturated: [],
		unsaturated: [],
		empty: []
	};
	function on(event, handler$1) {
		events[event].push(handler$1);
	}
	function once$2(event, handler$1) {
		const handleAndRemove = (...args) => {
			off(event, handleAndRemove);
			handler$1(...args);
		};
		events[event].push(handleAndRemove);
	}
	function off(event, handler$1) {
		if (!event) return Object.keys(events).forEach((ev) => events[ev] = []);
		if (!handler$1) return events[event] = [];
		events[event] = events[event].filter((ev) => ev !== handler$1);
	}
	function trigger(event, ...args) {
		events[event].forEach((handler$1) => handler$1(...args));
	}
	var processingScheduled = false;
	function _insert(data, insertAtFront, rejectOnError, callback) {
		if (callback != null && typeof callback !== "function") throw new Error("task callback must be a function");
		q.started = true;
		var res, rej;
		function promiseCallback$1(err, ...args) {
			if (err) return rejectOnError ? rej(err) : res();
			if (args.length <= 1) return res(args[0]);
			res(args);
		}
		var item = q._createTaskItem(data, rejectOnError ? promiseCallback$1 : callback || promiseCallback$1);
		if (insertAtFront) q._tasks.unshift(item);
		else q._tasks.push(item);
		if (!processingScheduled) {
			processingScheduled = true;
			setImmediate$1(() => {
				processingScheduled = false;
				q.process();
			});
		}
		if (rejectOnError || !callback) return new Promise((resolve$1, reject$3) => {
			res = resolve$1;
			rej = reject$3;
		});
	}
	function _createCB(tasks) {
		return function(err, ...args) {
			numRunning -= 1;
			for (var i = 0, l = tasks.length; i < l; i++) {
				var task = tasks[i];
				var index$1 = workersList.indexOf(task);
				if (index$1 === 0) workersList.shift();
				else if (index$1 > 0) workersList.splice(index$1, 1);
				task.callback(err, ...args);
				if (err != null) trigger("error", err, task.data);
			}
			if (numRunning <= q.concurrency - q.buffer) trigger("unsaturated");
			if (q.idle()) trigger("drain");
			q.process();
		};
	}
	function _maybeDrain(data) {
		if (data.length === 0 && q.idle()) {
			setImmediate$1(() => trigger("drain"));
			return true;
		}
		return false;
	}
	const eventMethod = (name$1) => (handler$1) => {
		if (!handler$1) return new Promise((resolve$1, reject$3) => {
			once$2(name$1, (err, data) => {
				if (err) return reject$3(err);
				resolve$1(data);
			});
		});
		off(name$1);
		on(name$1, handler$1);
	};
	var isProcessing = false;
	var q = {
		_tasks: new DLL(),
		_createTaskItem(data, callback) {
			return {
				data,
				callback
			};
		},
		*[Symbol.iterator]() {
			yield* q._tasks[Symbol.iterator]();
		},
		concurrency,
		payload,
		buffer: concurrency / 4,
		started: false,
		paused: false,
		push(data, callback) {
			if (Array.isArray(data)) {
				if (_maybeDrain(data)) return;
				return data.map((datum) => _insert(datum, false, false, callback));
			}
			return _insert(data, false, false, callback);
		},
		pushAsync(data, callback) {
			if (Array.isArray(data)) {
				if (_maybeDrain(data)) return;
				return data.map((datum) => _insert(datum, false, true, callback));
			}
			return _insert(data, false, true, callback);
		},
		kill() {
			off();
			q._tasks.empty();
		},
		unshift(data, callback) {
			if (Array.isArray(data)) {
				if (_maybeDrain(data)) return;
				return data.map((datum) => _insert(datum, true, false, callback));
			}
			return _insert(data, true, false, callback);
		},
		unshiftAsync(data, callback) {
			if (Array.isArray(data)) {
				if (_maybeDrain(data)) return;
				return data.map((datum) => _insert(datum, true, true, callback));
			}
			return _insert(data, true, true, callback);
		},
		remove(testFn) {
			q._tasks.remove(testFn);
		},
		process() {
			if (isProcessing) return;
			isProcessing = true;
			while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
				var tasks = [], data = [];
				var l = q._tasks.length;
				if (q.payload) l = Math.min(l, q.payload);
				for (var i = 0; i < l; i++) {
					var node = q._tasks.shift();
					tasks.push(node);
					workersList.push(node);
					data.push(node.data);
				}
				numRunning += 1;
				if (q._tasks.length === 0) trigger("empty");
				if (numRunning === q.concurrency) trigger("saturated");
				_worker(data, onlyOnce(_createCB(tasks)));
			}
			isProcessing = false;
		},
		length() {
			return q._tasks.length;
		},
		running() {
			return numRunning;
		},
		workersList() {
			return workersList;
		},
		idle() {
			return q._tasks.length + numRunning === 0;
		},
		pause() {
			q.paused = true;
		},
		resume() {
			if (q.paused === false) return;
			q.paused = false;
			setImmediate$1(q.process);
		}
	};
	Object.defineProperties(q, {
		saturated: {
			writable: false,
			value: eventMethod("saturated")
		},
		unsaturated: {
			writable: false,
			value: eventMethod("unsaturated")
		},
		empty: {
			writable: false,
			value: eventMethod("empty")
		},
		drain: {
			writable: false,
			value: eventMethod("drain")
		},
		error: {
			writable: false,
			value: eventMethod("error")
		}
	});
	return q;
}
function cargo$1(worker, payload) {
	return queue$1(worker, 1, payload);
}
function cargo(worker, concurrency, payload) {
	return queue$1(worker, concurrency, payload);
}
function reduce(coll, memo, iteratee, callback) {
	callback = once(callback);
	var _iteratee = wrapAsync(iteratee);
	return eachOfSeries$1(coll, (x, i, iterCb) => {
		_iteratee(memo, x, (err, v) => {
			memo = v;
			iterCb(err);
		});
	}, (err) => callback(err, memo));
}
function seq(...functions) {
	var _functions = functions.map(wrapAsync);
	return function(...args) {
		var that = this;
		var cb = args[args.length - 1];
		if (typeof cb == "function") args.pop();
		else cb = promiseCallback();
		reduce$1(_functions, args, (newargs, fn, iterCb) => {
			fn.apply(that, newargs.concat((err, ...nextargs) => {
				iterCb(err, nextargs);
			}));
		}, (err, results) => cb(err, ...results));
		return cb[PROMISE_SYMBOL];
	};
}
function compose(...args) {
	return seq(...args.reverse());
}
function mapLimit(coll, limit, iteratee, callback) {
	return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
}
function concatLimit(coll, limit, iteratee, callback) {
	var _iteratee = wrapAsync(iteratee);
	return mapLimit$1(coll, limit, (val, iterCb) => {
		_iteratee(val, (err, ...args) => {
			if (err) return iterCb(err);
			return iterCb(err, args);
		});
	}, (err, mapResults) => {
		var result = [];
		for (var i = 0; i < mapResults.length; i++) if (mapResults[i]) result = result.concat(...mapResults[i]);
		return callback(err, result);
	});
}
function concat(coll, iteratee, callback) {
	return concatLimit$1(coll, Infinity, iteratee, callback);
}
function concatSeries(coll, iteratee, callback) {
	return concatLimit$1(coll, 1, iteratee, callback);
}
function constant$1(...args) {
	return function(...ignoredArgs) {
		return ignoredArgs.pop()(null, ...args);
	};
}
function _createTester(check, getResult) {
	return (eachfn, arr, _iteratee, cb) => {
		var testPassed = false;
		var testResult;
		const iteratee = wrapAsync(_iteratee);
		eachfn(arr, (value$1, _$1, callback) => {
			iteratee(value$1, (err, result) => {
				if (err || err === false) return callback(err);
				if (check(result) && !testResult) {
					testPassed = true;
					testResult = getResult(true, value$1);
					return callback(null, breakLoop);
				}
				callback();
			});
		}, (err) => {
			if (err) return cb(err);
			cb(null, testPassed ? testResult : getResult(false));
		});
	};
}
function detect(coll, iteratee, callback) {
	return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
}
function detectLimit(coll, limit, iteratee, callback) {
	return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
}
function detectSeries(coll, iteratee, callback) {
	return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
}
function consoleFunc(name$1) {
	return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
		/* istanbul ignore else */
		if (typeof console === "object") {
			/* istanbul ignore else */
			if (err) {
				/* istanbul ignore else */
				if (console.error) console.error(err);
			} else if (console[name$1]) resultArgs.forEach((x) => console[name$1](x));
		}
	});
}
function doWhilst(iteratee, test, callback) {
	callback = onlyOnce(callback);
	var _fn = wrapAsync(iteratee);
	var _test = wrapAsync(test);
	var results;
	function next(err, ...args) {
		if (err) return callback(err);
		if (err === false) return;
		results = args;
		_test(...args, check);
	}
	function check(err, truth) {
		if (err) return callback(err);
		if (err === false) return;
		if (!truth) return callback(null, ...results);
		_fn(next);
	}
	return check(null, true);
}
function doUntil(iteratee, test, callback) {
	const _test = wrapAsync(test);
	return doWhilst$1(iteratee, (...args) => {
		const cb = args.pop();
		_test(...args, (err, truth) => cb(err, !truth));
	}, callback);
}
function _withoutIndex(iteratee) {
	return (value$1, index$1, callback) => iteratee(value$1, callback);
}
function eachLimit$2(coll, iteratee, callback) {
	return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
function eachLimit(coll, limit, iteratee, callback) {
	return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
function eachSeries(coll, iteratee, callback) {
	return eachLimit$1(coll, 1, iteratee, callback);
}
function ensureAsync(fn) {
	if (isAsync(fn)) return fn;
	return function(...args) {
		var callback = args.pop();
		var sync$3 = true;
		args.push((...innerArgs) => {
			if (sync$3) setImmediate$1(() => callback(...innerArgs));
			else callback(...innerArgs);
		});
		fn.apply(this, args);
		sync$3 = false;
	};
}
function every(coll, iteratee, callback) {
	return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
}
function everyLimit(coll, limit, iteratee, callback) {
	return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
function everySeries(coll, iteratee, callback) {
	return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
}
function filterArray(eachfn, arr, iteratee, callback) {
	var truthValues = new Array(arr.length);
	eachfn(arr, (x, index$1, iterCb) => {
		iteratee(x, (err, v) => {
			truthValues[index$1] = !!v;
			iterCb(err);
		});
	}, (err) => {
		if (err) return callback(err);
		var results = [];
		for (var i = 0; i < arr.length; i++) if (truthValues[i]) results.push(arr[i]);
		callback(null, results);
	});
}
function filterGeneric(eachfn, coll, iteratee, callback) {
	var results = [];
	eachfn(coll, (x, index$1, iterCb) => {
		iteratee(x, (err, v) => {
			if (err) return iterCb(err);
			if (v) results.push({
				index: index$1,
				value: x
			});
			iterCb(err);
		});
	}, (err) => {
		if (err) return callback(err);
		callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
	});
}
function _filter(eachfn, coll, iteratee, callback) {
	return (isArrayLike(coll) ? filterArray : filterGeneric)(eachfn, coll, wrapAsync(iteratee), callback);
}
function filter(coll, iteratee, callback) {
	return _filter(eachOf$1, coll, iteratee, callback);
}
function filterLimit(coll, limit, iteratee, callback) {
	return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
}
function filterSeries(coll, iteratee, callback) {
	return _filter(eachOfSeries$1, coll, iteratee, callback);
}
function forever(fn, errback) {
	var done = onlyOnce(errback);
	var task = wrapAsync(ensureAsync(fn));
	function next(err) {
		if (err) return done(err);
		if (err === false) return;
		task(next);
	}
	return next();
}
function groupByLimit(coll, limit, iteratee, callback) {
	var _iteratee = wrapAsync(iteratee);
	return mapLimit$1(coll, limit, (val, iterCb) => {
		_iteratee(val, (err, key) => {
			if (err) return iterCb(err);
			return iterCb(err, {
				key,
				val
			});
		});
	}, (err, mapResults) => {
		var result = {};
		var { hasOwnProperty } = Object.prototype;
		for (var i = 0; i < mapResults.length; i++) if (mapResults[i]) {
			var { key } = mapResults[i];
			var { val } = mapResults[i];
			if (hasOwnProperty.call(result, key)) result[key].push(val);
			else result[key] = [val];
		}
		return callback(err, result);
	});
}
function groupBy(coll, iteratee, callback) {
	return groupByLimit$1(coll, Infinity, iteratee, callback);
}
function groupBySeries(coll, iteratee, callback) {
	return groupByLimit$1(coll, 1, iteratee, callback);
}
function mapValuesLimit(obj, limit, iteratee, callback) {
	callback = once(callback);
	var newObj = {};
	var _iteratee = wrapAsync(iteratee);
	return eachOfLimit$2(limit)(obj, (val, key, next) => {
		_iteratee(val, key, (err, result) => {
			if (err) return next(err);
			newObj[key] = result;
			next(err);
		});
	}, (err) => callback(err, newObj));
}
function mapValues(obj, iteratee, callback) {
	return mapValuesLimit$1(obj, Infinity, iteratee, callback);
}
function mapValuesSeries(obj, iteratee, callback) {
	return mapValuesLimit$1(obj, 1, iteratee, callback);
}
function memoize(fn, hasher = (v) => v) {
	var memo = Object.create(null);
	var queues = Object.create(null);
	var _fn = wrapAsync(fn);
	var memoized = initialParams((args, callback) => {
		var key = hasher(...args);
		if (key in memo) setImmediate$1(() => callback(null, ...memo[key]));
		else if (key in queues) queues[key].push(callback);
		else {
			queues[key] = [callback];
			_fn(...args, (err, ...resultArgs) => {
				if (!err) memo[key] = resultArgs;
				var q = queues[key];
				delete queues[key];
				for (var i = 0, l = q.length; i < l; i++) q[i](err, ...resultArgs);
			});
		}
	});
	memoized.memo = memo;
	memoized.unmemoized = fn;
	return memoized;
}
function parallel(tasks, callback) {
	return _parallel(eachOf$1, tasks, callback);
}
function parallelLimit(tasks, limit, callback) {
	return _parallel(eachOfLimit$2(limit), tasks, callback);
}
function queue(worker, concurrency) {
	var _worker = wrapAsync(worker);
	return queue$1((items, cb) => {
		_worker(items[0], cb);
	}, concurrency, 1);
}
function leftChi(i) {
	return (i << 1) + 1;
}
function parent(i) {
	return (i + 1 >> 1) - 1;
}
function smaller(x, y) {
	if (x.priority !== y.priority) return x.priority < y.priority;
	else return x.pushCount < y.pushCount;
}
function priorityQueue(worker, concurrency) {
	var q = queue(worker, concurrency);
	var { push, pushAsync } = q;
	q._tasks = new Heap();
	q._createTaskItem = ({ data, priority }, callback) => {
		return {
			data,
			priority,
			callback
		};
	};
	function createDataItems(tasks, priority) {
		if (!Array.isArray(tasks)) return {
			data: tasks,
			priority
		};
		return tasks.map((data) => {
			return {
				data,
				priority
			};
		});
	}
	q.push = function(data, priority = 0, callback) {
		return push(createDataItems(data, priority), callback);
	};
	q.pushAsync = function(data, priority = 0, callback) {
		return pushAsync(createDataItems(data, priority), callback);
	};
	delete q.unshift;
	delete q.unshiftAsync;
	return q;
}
function race(tasks, callback) {
	callback = once(callback);
	if (!Array.isArray(tasks)) return callback(/* @__PURE__ */ new TypeError("First argument to race must be an array of functions"));
	if (!tasks.length) return callback();
	for (var i = 0, l = tasks.length; i < l; i++) wrapAsync(tasks[i])(callback);
}
function reduceRight(array, memo, iteratee, callback) {
	return reduce$1([...array].reverse(), memo, iteratee, callback);
}
function reflect(fn) {
	var _fn = wrapAsync(fn);
	return initialParams(function reflectOn(args, reflectCallback) {
		args.push((error, ...cbArgs) => {
			let retVal = {};
			if (error) retVal.error = error;
			if (cbArgs.length > 0) {
				var value$1 = cbArgs;
				if (cbArgs.length <= 1) [value$1] = cbArgs;
				retVal.value = value$1;
			}
			reflectCallback(null, retVal);
		});
		return _fn.apply(this, args);
	});
}
function reflectAll(tasks) {
	var results;
	if (Array.isArray(tasks)) results = tasks.map(reflect);
	else {
		results = {};
		Object.keys(tasks).forEach((key) => {
			results[key] = reflect.call(this, tasks[key]);
		});
	}
	return results;
}
function reject$2(eachfn, arr, _iteratee, callback) {
	const iteratee = wrapAsync(_iteratee);
	return _filter(eachfn, arr, (value$1, cb) => {
		iteratee(value$1, (err, v) => {
			cb(err, !v);
		});
	}, callback);
}
function reject(coll, iteratee, callback) {
	return reject$2(eachOf$1, coll, iteratee, callback);
}
function rejectLimit(coll, limit, iteratee, callback) {
	return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
}
function rejectSeries(coll, iteratee, callback) {
	return reject$2(eachOfSeries$1, coll, iteratee, callback);
}
function constant(value$1) {
	return function() {
		return value$1;
	};
}
function retry$1(opts, task, callback) {
	var options = {
		times: DEFAULT_TIMES,
		intervalFunc: constant(DEFAULT_INTERVAL)
	};
	if (arguments.length < 3 && typeof opts === "function") {
		callback = task || promiseCallback();
		task = opts;
	} else {
		parseTimes(options, opts);
		callback = callback || promiseCallback();
	}
	if (typeof task !== "function") throw new Error("Invalid arguments for async.retry");
	var _task = wrapAsync(task);
	var attempt = 1;
	function retryAttempt() {
		_task((err, ...args) => {
			if (err === false) return;
			if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
			else callback(err, ...args);
		});
	}
	retryAttempt();
	return callback[PROMISE_SYMBOL];
}
function parseTimes(acc, t$1) {
	if (typeof t$1 === "object") {
		acc.times = +t$1.times || DEFAULT_TIMES;
		acc.intervalFunc = typeof t$1.interval === "function" ? t$1.interval : constant(+t$1.interval || DEFAULT_INTERVAL);
		acc.errorFilter = t$1.errorFilter;
	} else if (typeof t$1 === "number" || typeof t$1 === "string") acc.times = +t$1 || DEFAULT_TIMES;
	else throw new Error("Invalid arguments for async.retry");
}
function retryable(opts, task) {
	if (!task) {
		task = opts;
		opts = null;
	}
	let arity = opts && opts.arity || task.length;
	if (isAsync(task)) arity += 1;
	var _task = wrapAsync(task);
	return initialParams((args, callback) => {
		if (args.length < arity - 1 || callback == null) {
			args.push(callback);
			callback = promiseCallback();
		}
		function taskFn(cb) {
			_task(...args, cb);
		}
		if (opts) retry$1(opts, taskFn, callback);
		else retry$1(taskFn, callback);
		return callback[PROMISE_SYMBOL];
	});
}
function series(tasks, callback) {
	return _parallel(eachOfSeries$1, tasks, callback);
}
function some(coll, iteratee, callback) {
	return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
}
function someLimit(coll, limit, iteratee, callback) {
	return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
function someSeries(coll, iteratee, callback) {
	return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
}
function sortBy(coll, iteratee, callback) {
	var _iteratee = wrapAsync(iteratee);
	return map$1(coll, (x, iterCb) => {
		_iteratee(x, (err, criteria) => {
			if (err) return iterCb(err);
			iterCb(err, {
				value: x,
				criteria
			});
		});
	}, (err, results) => {
		if (err) return callback(err);
		callback(null, results.sort(comparator).map((v) => v.value));
	});
	function comparator(left, right) {
		var a = left.criteria, b = right.criteria;
		return a < b ? -1 : a > b ? 1 : 0;
	}
}
function timeout(asyncFn, milliseconds, info) {
	var fn = wrapAsync(asyncFn);
	return initialParams((args, callback) => {
		var timedOut = false;
		var timer;
		function timeoutCallback() {
			var name$1 = asyncFn.name || "anonymous";
			var error = /* @__PURE__ */ new Error("Callback function \"" + name$1 + "\" timed out.");
			error.code = "ETIMEDOUT";
			if (info) error.info = info;
			timedOut = true;
			callback(error);
		}
		args.push((...cbArgs) => {
			if (!timedOut) {
				callback(...cbArgs);
				clearTimeout(timer);
			}
		});
		timer = setTimeout(timeoutCallback, milliseconds);
		fn(...args);
	});
}
function range(size) {
	var result = Array(size);
	while (size--) result[size] = size;
	return result;
}
function timesLimit(count, limit, iteratee, callback) {
	var _iteratee = wrapAsync(iteratee);
	return mapLimit$1(range(count), limit, _iteratee, callback);
}
function times(n$1, iteratee, callback) {
	return timesLimit(n$1, Infinity, iteratee, callback);
}
function timesSeries(n$1, iteratee, callback) {
	return timesLimit(n$1, 1, iteratee, callback);
}
function transform(coll, accumulator, iteratee, callback) {
	if (arguments.length <= 3 && typeof accumulator === "function") {
		callback = iteratee;
		iteratee = accumulator;
		accumulator = Array.isArray(coll) ? [] : {};
	}
	callback = once(callback || promiseCallback());
	var _iteratee = wrapAsync(iteratee);
	eachOf$1(coll, (v, k, cb) => {
		_iteratee(accumulator, v, k, cb);
	}, (err) => callback(err, accumulator));
	return callback[PROMISE_SYMBOL];
}
function tryEach(tasks, callback) {
	var error = null;
	var result;
	return eachSeries$1(tasks, (task, taskCb) => {
		wrapAsync(task)((err, ...args) => {
			if (err === false) return taskCb(err);
			if (args.length < 2) [result] = args;
			else result = args;
			error = err;
			taskCb(err ? null : {});
		});
	}, () => callback(error, result));
}
function unmemoize(fn) {
	return (...args) => {
		return (fn.unmemoized || fn)(...args);
	};
}
function whilst(test, iteratee, callback) {
	callback = onlyOnce(callback);
	var _fn = wrapAsync(iteratee);
	var _test = wrapAsync(test);
	var results = [];
	function next(err, ...rest) {
		if (err) return callback(err);
		results = rest;
		if (err === false) return;
		_test(check);
	}
	function check(err, truth) {
		if (err) return callback(err);
		if (err === false) return;
		if (!truth) return callback(null, ...results);
		_fn(next);
	}
	return _test(check);
}
function until(test, iteratee, callback) {
	const _test = wrapAsync(test);
	return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
}
function waterfall(tasks, callback) {
	callback = once(callback);
	if (!Array.isArray(tasks)) return callback(/* @__PURE__ */ new Error("First argument to waterfall must be an array of functions"));
	if (!tasks.length) return callback();
	var taskIndex = 0;
	function nextTask(args) {
		wrapAsync(tasks[taskIndex++])(...args, onlyOnce(next));
	}
	function next(err, ...args) {
		if (err === false) return;
		if (err || taskIndex === tasks.length) return callback(err, ...args);
		nextTask(args);
	}
	nextTask([]);
}
var hasQueueMicrotask, hasSetImmediate, hasNextTick, _defer$1, setImmediate$1, breakLoop, eachOfLimit$2, eachOfLimit$1, eachOf$1, map$1, applyEach, eachOfSeries$1, mapSeries$1, applyEachSeries, PROMISE_SYMBOL, FN_ARGS, ARROW_FN_ARGS, FN_ARG_SPLIT, FN_ARG, DLL, reduce$1, mapLimit$1, concatLimit$1, concat$1, concatSeries$1, detect$1, detectLimit$1, detectSeries$1, dir, doWhilst$1, each, eachLimit$1, eachSeries$1, every$1, everyLimit$1, everySeries$1, filter$1, filterLimit$1, filterSeries$1, forever$1, groupByLimit$1, log, mapValuesLimit$1, _defer, nextTick, _parallel, Heap, race$1, reject$1, rejectLimit$1, rejectSeries$1, DEFAULT_TIMES, DEFAULT_INTERVAL, some$1, someLimit$1, someSeries$1, sortBy$1, tryEach$1, whilst$1, waterfall$1, index;
var init_async = __esmMin((() => {
	hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
	hasSetImmediate = typeof setImmediate === "function" && setImmediate;
	hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
	if (hasQueueMicrotask) _defer$1 = queueMicrotask;
	else if (hasSetImmediate) _defer$1 = setImmediate;
	else if (hasNextTick) _defer$1 = process.nextTick;
	else _defer$1 = fallback;
	setImmediate$1 = wrap(_defer$1);
	breakLoop = {};
	eachOfLimit$2 = (limit) => {
		return (obj, iteratee, callback) => {
			callback = once(callback);
			if (limit <= 0) throw new RangeError("concurrency limit cannot be less than 1");
			if (!obj) return callback(null);
			if (isAsyncGenerator(obj)) return asyncEachOfLimit(obj, limit, iteratee, callback);
			if (isAsyncIterable(obj)) return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
			var nextElem = createIterator(obj);
			var done = false;
			var canceled = false;
			var running = 0;
			var looping = false;
			function iterateeCallback(err, value$1) {
				if (canceled) return;
				running -= 1;
				if (err) {
					done = true;
					callback(err);
				} else if (err === false) {
					done = true;
					canceled = true;
				} else if (value$1 === breakLoop || done && running <= 0) {
					done = true;
					return callback(null);
				} else if (!looping) replenish();
			}
			function replenish() {
				looping = true;
				while (running < limit && !done) {
					var elem = nextElem();
					if (elem === null) {
						done = true;
						if (running <= 0) callback(null);
						return;
					}
					running += 1;
					iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
				}
				looping = false;
			}
			replenish();
		};
	};
	eachOfLimit$1 = awaitify(eachOfLimit, 4);
	eachOf$1 = awaitify(eachOf, 3);
	map$1 = awaitify(map, 3);
	applyEach = applyEach$1(map$1);
	eachOfSeries$1 = awaitify(eachOfSeries, 3);
	mapSeries$1 = awaitify(mapSeries, 3);
	applyEachSeries = applyEach$1(mapSeries$1);
	PROMISE_SYMBOL = Symbol("promiseCallback");
	FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
	ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
	FN_ARG_SPLIT = /,/;
	FN_ARG = /(=.+)?(\s*)$/;
	DLL = class {
		constructor() {
			this.head = this.tail = null;
			this.length = 0;
		}
		removeLink(node) {
			if (node.prev) node.prev.next = node.next;
			else this.head = node.next;
			if (node.next) node.next.prev = node.prev;
			else this.tail = node.prev;
			node.prev = node.next = null;
			this.length -= 1;
			return node;
		}
		empty() {
			while (this.head) this.shift();
			return this;
		}
		insertAfter(node, newNode) {
			newNode.prev = node;
			newNode.next = node.next;
			if (node.next) node.next.prev = newNode;
			else this.tail = newNode;
			node.next = newNode;
			this.length += 1;
		}
		insertBefore(node, newNode) {
			newNode.prev = node.prev;
			newNode.next = node;
			if (node.prev) node.prev.next = newNode;
			else this.head = newNode;
			node.prev = newNode;
			this.length += 1;
		}
		unshift(node) {
			if (this.head) this.insertBefore(this.head, node);
			else setInitial(this, node);
		}
		push(node) {
			if (this.tail) this.insertAfter(this.tail, node);
			else setInitial(this, node);
		}
		shift() {
			return this.head && this.removeLink(this.head);
		}
		pop() {
			return this.tail && this.removeLink(this.tail);
		}
		toArray() {
			return [...this];
		}
		*[Symbol.iterator]() {
			var cur = this.head;
			while (cur) {
				yield cur.data;
				cur = cur.next;
			}
		}
		remove(testFn) {
			var curr = this.head;
			while (curr) {
				var { next } = curr;
				if (testFn(curr)) this.removeLink(curr);
				curr = next;
			}
			return this;
		}
	};
	reduce$1 = awaitify(reduce, 4);
	mapLimit$1 = awaitify(mapLimit, 4);
	concatLimit$1 = awaitify(concatLimit, 4);
	concat$1 = awaitify(concat, 3);
	concatSeries$1 = awaitify(concatSeries, 3);
	detect$1 = awaitify(detect, 3);
	detectLimit$1 = awaitify(detectLimit, 4);
	detectSeries$1 = awaitify(detectSeries, 3);
	dir = consoleFunc("dir");
	doWhilst$1 = awaitify(doWhilst, 3);
	each = awaitify(eachLimit$2, 3);
	eachLimit$1 = awaitify(eachLimit, 4);
	eachSeries$1 = awaitify(eachSeries, 3);
	every$1 = awaitify(every, 3);
	everyLimit$1 = awaitify(everyLimit, 4);
	everySeries$1 = awaitify(everySeries, 3);
	filter$1 = awaitify(filter, 3);
	filterLimit$1 = awaitify(filterLimit, 4);
	filterSeries$1 = awaitify(filterSeries, 3);
	forever$1 = awaitify(forever, 2);
	groupByLimit$1 = awaitify(groupByLimit, 4);
	log = consoleFunc("log");
	mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
	if (hasNextTick) _defer = process.nextTick;
	else if (hasSetImmediate) _defer = setImmediate;
	else _defer = fallback;
	nextTick = wrap(_defer);
	_parallel = awaitify((eachfn, tasks, callback) => {
		var results = isArrayLike(tasks) ? [] : {};
		eachfn(tasks, (task, key, taskCb) => {
			wrapAsync(task)((err, ...result) => {
				if (result.length < 2) [result] = result;
				results[key] = result;
				taskCb(err);
			});
		}, (err) => callback(err, results));
	}, 3);
	Heap = class {
		constructor() {
			this.heap = [];
			this.pushCount = Number.MIN_SAFE_INTEGER;
		}
		get length() {
			return this.heap.length;
		}
		empty() {
			this.heap = [];
			return this;
		}
		percUp(index$1) {
			let p;
			while (index$1 > 0 && smaller(this.heap[index$1], this.heap[p = parent(index$1)])) {
				let t$1 = this.heap[index$1];
				this.heap[index$1] = this.heap[p];
				this.heap[p] = t$1;
				index$1 = p;
			}
		}
		percDown(index$1) {
			let l;
			while ((l = leftChi(index$1)) < this.heap.length) {
				if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) l = l + 1;
				if (smaller(this.heap[index$1], this.heap[l])) break;
				let t$1 = this.heap[index$1];
				this.heap[index$1] = this.heap[l];
				this.heap[l] = t$1;
				index$1 = l;
			}
		}
		push(node) {
			node.pushCount = ++this.pushCount;
			this.heap.push(node);
			this.percUp(this.heap.length - 1);
		}
		unshift(node) {
			return this.heap.push(node);
		}
		shift() {
			let [top] = this.heap;
			this.heap[0] = this.heap[this.heap.length - 1];
			this.heap.pop();
			this.percDown(0);
			return top;
		}
		toArray() {
			return [...this];
		}
		*[Symbol.iterator]() {
			for (let i = 0; i < this.heap.length; i++) yield this.heap[i].data;
		}
		remove(testFn) {
			let j = 0;
			for (let i = 0; i < this.heap.length; i++) if (!testFn(this.heap[i])) {
				this.heap[j] = this.heap[i];
				j++;
			}
			this.heap.splice(j);
			for (let i = parent(this.heap.length - 1); i >= 0; i--) this.percDown(i);
			return this;
		}
	};
	race$1 = awaitify(race, 2);
	reject$1 = awaitify(reject, 3);
	rejectLimit$1 = awaitify(rejectLimit, 4);
	rejectSeries$1 = awaitify(rejectSeries, 3);
	DEFAULT_TIMES = 5;
	DEFAULT_INTERVAL = 0;
	some$1 = awaitify(some, 3);
	someLimit$1 = awaitify(someLimit, 4);
	someSeries$1 = awaitify(someSeries, 3);
	sortBy$1 = awaitify(sortBy, 3);
	tryEach$1 = awaitify(tryEach);
	whilst$1 = awaitify(whilst, 3);
	waterfall$1 = awaitify(waterfall);
	index = {
		apply,
		applyEach,
		applyEachSeries,
		asyncify,
		auto,
		autoInject,
		cargo: cargo$1,
		cargoQueue: cargo,
		compose,
		concat: concat$1,
		concatLimit: concatLimit$1,
		concatSeries: concatSeries$1,
		constant: constant$1,
		detect: detect$1,
		detectLimit: detectLimit$1,
		detectSeries: detectSeries$1,
		dir,
		doUntil,
		doWhilst: doWhilst$1,
		each,
		eachLimit: eachLimit$1,
		eachOf: eachOf$1,
		eachOfLimit: eachOfLimit$1,
		eachOfSeries: eachOfSeries$1,
		eachSeries: eachSeries$1,
		ensureAsync,
		every: every$1,
		everyLimit: everyLimit$1,
		everySeries: everySeries$1,
		filter: filter$1,
		filterLimit: filterLimit$1,
		filterSeries: filterSeries$1,
		forever: forever$1,
		groupBy,
		groupByLimit: groupByLimit$1,
		groupBySeries,
		log,
		map: map$1,
		mapLimit: mapLimit$1,
		mapSeries: mapSeries$1,
		mapValues,
		mapValuesLimit: mapValuesLimit$1,
		mapValuesSeries,
		memoize,
		nextTick,
		parallel,
		parallelLimit,
		priorityQueue,
		queue,
		race: race$1,
		reduce: reduce$1,
		reduceRight,
		reflect,
		reflectAll,
		reject: reject$1,
		rejectLimit: rejectLimit$1,
		rejectSeries: rejectSeries$1,
		retry: retry$1,
		retryable,
		seq,
		series,
		setImmediate: setImmediate$1,
		some: some$1,
		someLimit: someLimit$1,
		someSeries: someSeries$1,
		sortBy: sortBy$1,
		timeout,
		times,
		timesLimit,
		timesSeries,
		transform,
		tryEach: tryEach$1,
		unmemoize,
		until,
		waterfall: waterfall$1,
		whilst: whilst$1,
		all: every$1,
		allLimit: everyLimit$1,
		allSeries: everySeries$1,
		any: some$1,
		anyLimit: someLimit$1,
		anySeries: someSeries$1,
		find: detect$1,
		findLimit: detectLimit$1,
		findSeries: detectSeries$1,
		flatMap: concat$1,
		flatMapLimit: concatLimit$1,
		flatMapSeries: concatSeries$1,
		forEach: each,
		forEachSeries: eachSeries$1,
		forEachLimit: eachLimit$1,
		forEachOf: eachOf$1,
		forEachOfSeries: eachOfSeries$1,
		forEachOfLimit: eachOfLimit$1,
		inject: reduce$1,
		foldl: reduce$1,
		foldr: reduceRight,
		select: filter$1,
		selectLimit: filterLimit$1,
		selectSeries: filterSeries$1,
		wrapSync: asyncify,
		during: whilst$1,
		doDuring: doWhilst$1
	};
}));
var require_polyfills = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var constants = __require("constants");
	var origCwd = process.cwd;
	var cwd = null;
	var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
	process.cwd = function() {
		if (!cwd) cwd = origCwd.call(process);
		return cwd;
	};
	try {
		process.cwd();
	} catch (er) {}
	if (typeof process.chdir === "function") {
		var chdir = process.chdir;
		process.chdir = function(d) {
			cwd = null;
			chdir.call(process, d);
		};
		if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
	}
	module.exports = patch;
	function patch(fs$7) {
		if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) patchLchmod(fs$7);
		if (!fs$7.lutimes) patchLutimes(fs$7);
		fs$7.chown = chownFix(fs$7.chown);
		fs$7.fchown = chownFix(fs$7.fchown);
		fs$7.lchown = chownFix(fs$7.lchown);
		fs$7.chmod = chmodFix(fs$7.chmod);
		fs$7.fchmod = chmodFix(fs$7.fchmod);
		fs$7.lchmod = chmodFix(fs$7.lchmod);
		fs$7.chownSync = chownFixSync(fs$7.chownSync);
		fs$7.fchownSync = chownFixSync(fs$7.fchownSync);
		fs$7.lchownSync = chownFixSync(fs$7.lchownSync);
		fs$7.chmodSync = chmodFixSync(fs$7.chmodSync);
		fs$7.fchmodSync = chmodFixSync(fs$7.fchmodSync);
		fs$7.lchmodSync = chmodFixSync(fs$7.lchmodSync);
		fs$7.stat = statFix(fs$7.stat);
		fs$7.fstat = statFix(fs$7.fstat);
		fs$7.lstat = statFix(fs$7.lstat);
		fs$7.statSync = statFixSync(fs$7.statSync);
		fs$7.fstatSync = statFixSync(fs$7.fstatSync);
		fs$7.lstatSync = statFixSync(fs$7.lstatSync);
		if (fs$7.chmod && !fs$7.lchmod) {
			fs$7.lchmod = function(path$5, mode, cb) {
				if (cb) process.nextTick(cb);
			};
			fs$7.lchmodSync = function() {};
		}
		if (fs$7.chown && !fs$7.lchown) {
			fs$7.lchown = function(path$5, uid, gid, cb) {
				if (cb) process.nextTick(cb);
			};
			fs$7.lchownSync = function() {};
		}
		if (platform === "win32") fs$7.rename = typeof fs$7.rename !== "function" ? fs$7.rename : (function(fs$rename) {
			function rename(from, to, cb) {
				var start = Date.now();
				var backoff = 0;
				fs$rename(from, to, function CB(er) {
					if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
						setTimeout(function() {
							fs$7.stat(to, function(stater, st) {
								if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
								else cb(er);
							});
						}, backoff);
						if (backoff < 100) backoff += 10;
						return;
					}
					if (cb) cb(er);
				});
			}
			if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
			return rename;
		})(fs$7.rename);
		fs$7.read = typeof fs$7.read !== "function" ? fs$7.read : (function(fs$read) {
			function read(fd, buffer$2, offset, length, position, callback_) {
				var callback;
				if (callback_ && typeof callback_ === "function") {
					var eagCounter = 0;
					callback = function(er, _$1, __) {
						if (er && er.code === "EAGAIN" && eagCounter < 10) {
							eagCounter++;
							return fs$read.call(fs$7, fd, buffer$2, offset, length, position, callback);
						}
						callback_.apply(this, arguments);
					};
				}
				return fs$read.call(fs$7, fd, buffer$2, offset, length, position, callback);
			}
			if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
			return read;
		})(fs$7.read);
		fs$7.readSync = typeof fs$7.readSync !== "function" ? fs$7.readSync : (function(fs$readSync) {
			return function(fd, buffer$2, offset, length, position) {
				var eagCounter = 0;
				while (true) try {
					return fs$readSync.call(fs$7, fd, buffer$2, offset, length, position);
				} catch (er) {
					if (er.code === "EAGAIN" && eagCounter < 10) {
						eagCounter++;
						continue;
					}
					throw er;
				}
			};
		})(fs$7.readSync);
		function patchLchmod(fs$8) {
			fs$8.lchmod = function(path$5, mode, callback) {
				fs$8.open(path$5, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
					if (err) {
						if (callback) callback(err);
						return;
					}
					fs$8.fchmod(fd, mode, function(err$1) {
						fs$8.close(fd, function(err2) {
							if (callback) callback(err$1 || err2);
						});
					});
				});
			};
			fs$8.lchmodSync = function(path$5, mode) {
				var fd = fs$8.openSync(path$5, constants.O_WRONLY | constants.O_SYMLINK, mode);
				var threw = true;
				var ret;
				try {
					ret = fs$8.fchmodSync(fd, mode);
					threw = false;
				} finally {
					if (threw) try {
						fs$8.closeSync(fd);
					} catch (er) {}
					else fs$8.closeSync(fd);
				}
				return ret;
			};
		}
		function patchLutimes(fs$8) {
			if (constants.hasOwnProperty("O_SYMLINK") && fs$8.futimes) {
				fs$8.lutimes = function(path$5, at, mt, cb) {
					fs$8.open(path$5, constants.O_SYMLINK, function(er, fd) {
						if (er) {
							if (cb) cb(er);
							return;
						}
						fs$8.futimes(fd, at, mt, function(er$1) {
							fs$8.close(fd, function(er2) {
								if (cb) cb(er$1 || er2);
							});
						});
					});
				};
				fs$8.lutimesSync = function(path$5, at, mt) {
					var fd = fs$8.openSync(path$5, constants.O_SYMLINK);
					var ret;
					var threw = true;
					try {
						ret = fs$8.futimesSync(fd, at, mt);
						threw = false;
					} finally {
						if (threw) try {
							fs$8.closeSync(fd);
						} catch (er) {}
						else fs$8.closeSync(fd);
					}
					return ret;
				};
			} else if (fs$8.futimes) {
				fs$8.lutimes = function(_a, _b, _c, cb) {
					if (cb) process.nextTick(cb);
				};
				fs$8.lutimesSync = function() {};
			}
		}
		function chmodFix(orig) {
			if (!orig) return orig;
			return function(target, mode, cb) {
				return orig.call(fs$7, target, mode, function(er) {
					if (chownErOk(er)) er = null;
					if (cb) cb.apply(this, arguments);
				});
			};
		}
		function chmodFixSync(orig) {
			if (!orig) return orig;
			return function(target, mode) {
				try {
					return orig.call(fs$7, target, mode);
				} catch (er) {
					if (!chownErOk(er)) throw er;
				}
			};
		}
		function chownFix(orig) {
			if (!orig) return orig;
			return function(target, uid, gid, cb) {
				return orig.call(fs$7, target, uid, gid, function(er) {
					if (chownErOk(er)) er = null;
					if (cb) cb.apply(this, arguments);
				});
			};
		}
		function chownFixSync(orig) {
			if (!orig) return orig;
			return function(target, uid, gid) {
				try {
					return orig.call(fs$7, target, uid, gid);
				} catch (er) {
					if (!chownErOk(er)) throw er;
				}
			};
		}
		function statFix(orig) {
			if (!orig) return orig;
			return function(target, options, cb) {
				if (typeof options === "function") {
					cb = options;
					options = null;
				}
				function callback(er, stats) {
					if (stats) {
						if (stats.uid < 0) stats.uid += 4294967296;
						if (stats.gid < 0) stats.gid += 4294967296;
					}
					if (cb) cb.apply(this, arguments);
				}
				return options ? orig.call(fs$7, target, options, callback) : orig.call(fs$7, target, callback);
			};
		}
		function statFixSync(orig) {
			if (!orig) return orig;
			return function(target, options) {
				var stats = options ? orig.call(fs$7, target, options) : orig.call(fs$7, target);
				if (stats) {
					if (stats.uid < 0) stats.uid += 4294967296;
					if (stats.gid < 0) stats.gid += 4294967296;
				}
				return stats;
			};
		}
		function chownErOk(er) {
			if (!er) return true;
			if (er.code === "ENOSYS") return true;
			if (!process.getuid || process.getuid() !== 0) {
				if (er.code === "EINVAL" || er.code === "EPERM") return true;
			}
			return false;
		}
	}
}));
var require_legacy_streams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stream$3 = __require("stream").Stream;
	module.exports = legacy;
	function legacy(fs$7) {
		return {
			ReadStream,
			WriteStream
		};
		function ReadStream(path$5, options) {
			if (!(this instanceof ReadStream)) return new ReadStream(path$5, options);
			Stream$3.call(this);
			var self$1 = this;
			this.path = path$5;
			this.fd = null;
			this.readable = true;
			this.paused = false;
			this.flags = "r";
			this.mode = 438;
			this.bufferSize = 64 * 1024;
			options = options || {};
			var keys = Object.keys(options);
			for (var index$1 = 0, length = keys.length; index$1 < length; index$1++) {
				var key = keys[index$1];
				this[key] = options[key];
			}
			if (this.encoding) this.setEncoding(this.encoding);
			if (this.start !== void 0) {
				if ("number" !== typeof this.start) throw TypeError("start must be a Number");
				if (this.end === void 0) this.end = Infinity;
				else if ("number" !== typeof this.end) throw TypeError("end must be a Number");
				if (this.start > this.end) throw new Error("start must be <= end");
				this.pos = this.start;
			}
			if (this.fd !== null) {
				process.nextTick(function() {
					self$1._read();
				});
				return;
			}
			fs$7.open(this.path, this.flags, this.mode, function(err, fd) {
				if (err) {
					self$1.emit("error", err);
					self$1.readable = false;
					return;
				}
				self$1.fd = fd;
				self$1.emit("open", fd);
				self$1._read();
			});
		}
		function WriteStream(path$5, options) {
			if (!(this instanceof WriteStream)) return new WriteStream(path$5, options);
			Stream$3.call(this);
			this.path = path$5;
			this.fd = null;
			this.writable = true;
			this.flags = "w";
			this.encoding = "binary";
			this.mode = 438;
			this.bytesWritten = 0;
			options = options || {};
			var keys = Object.keys(options);
			for (var index$1 = 0, length = keys.length; index$1 < length; index$1++) {
				var key = keys[index$1];
				this[key] = options[key];
			}
			if (this.start !== void 0) {
				if ("number" !== typeof this.start) throw TypeError("start must be a Number");
				if (this.start < 0) throw new Error("start must be >= zero");
				this.pos = this.start;
			}
			this.busy = false;
			this._queue = [];
			if (this.fd === null) {
				this._open = fs$7.open;
				this._queue.push([
					this._open,
					this.path,
					this.flags,
					this.mode,
					void 0
				]);
				this.flush();
			}
		}
	}
}));
var require_clone = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = clone;
	var getPrototypeOf = Object.getPrototypeOf || function(obj) {
		return obj.__proto__;
	};
	function clone(obj) {
		if (obj === null || typeof obj !== "object") return obj;
		if (obj instanceof Object) var copy$1 = { __proto__: getPrototypeOf(obj) };
		else var copy$1 = Object.create(null);
		Object.getOwnPropertyNames(obj).forEach(function(key) {
			Object.defineProperty(copy$1, key, Object.getOwnPropertyDescriptor(obj, key));
		});
		return copy$1;
	}
}));
var require_graceful_fs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var fs$4 = __require("fs");
	var polyfills = require_polyfills();
	var legacy = require_legacy_streams();
	var clone = require_clone();
	var util$8 = __require("util");
	/* istanbul ignore next - node 0.x polyfill */
	var gracefulQueue;
	var previousSymbol;
	/* istanbul ignore else - node 0.x polyfill */
	if (typeof Symbol === "function" && typeof Symbol.for === "function") {
		gracefulQueue = Symbol.for("graceful-fs.queue");
		previousSymbol = Symbol.for("graceful-fs.previous");
	} else {
		gracefulQueue = "___graceful-fs.queue";
		previousSymbol = "___graceful-fs.previous";
	}
	function noop() {}
	function publishQueue(context$2, queue$2) {
		Object.defineProperty(context$2, gracefulQueue, { get: function() {
			return queue$2;
		} });
	}
	var debug = noop;
	if (util$8.debuglog) debug = util$8.debuglog("gfs4");
	else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) debug = function() {
		var m = util$8.format.apply(util$8, arguments);
		m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
		console.error(m);
	};
	if (!fs$4[gracefulQueue]) {
		publishQueue(fs$4, global[gracefulQueue] || []);
		fs$4.close = (function(fs$close) {
			function close(fd, cb) {
				return fs$close.call(fs$4, fd, function(err) {
					if (!err) resetQueue();
					if (typeof cb === "function") cb.apply(this, arguments);
				});
			}
			Object.defineProperty(close, previousSymbol, { value: fs$close });
			return close;
		})(fs$4.close);
		fs$4.closeSync = (function(fs$closeSync) {
			function closeSync(fd) {
				fs$closeSync.apply(fs$4, arguments);
				resetQueue();
			}
			Object.defineProperty(closeSync, previousSymbol, { value: fs$closeSync });
			return closeSync;
		})(fs$4.closeSync);
		if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) process.on("exit", function() {
			debug(fs$4[gracefulQueue]);
			__require("assert").equal(fs$4[gracefulQueue].length, 0);
		});
	}
	if (!global[gracefulQueue]) publishQueue(global, fs$4[gracefulQueue]);
	module.exports = patch(clone(fs$4));
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$4.__patched) {
		module.exports = patch(fs$4);
		fs$4.__patched = true;
	}
	function patch(fs$7) {
		polyfills(fs$7);
		fs$7.gracefulify = patch;
		fs$7.createReadStream = createReadStream;
		fs$7.createWriteStream = createWriteStream;
		var fs$readFile = fs$7.readFile;
		fs$7.readFile = readFile;
		function readFile(path$5, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$readFile(path$5, options, cb);
			function go$readFile(path$6, options$1, cb$1, startTime) {
				return fs$readFile(path$6, options$1, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$readFile,
						[
							path$6,
							options$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		var fs$writeFile = fs$7.writeFile;
		fs$7.writeFile = writeFile;
		function writeFile(path$5, data, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$writeFile(path$5, data, options, cb);
			function go$writeFile(path$6, data$1, options$1, cb$1, startTime) {
				return fs$writeFile(path$6, data$1, options$1, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$writeFile,
						[
							path$6,
							data$1,
							options$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		var fs$appendFile = fs$7.appendFile;
		if (fs$appendFile) fs$7.appendFile = appendFile;
		function appendFile(path$5, data, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			return go$appendFile(path$5, data, options, cb);
			function go$appendFile(path$6, data$1, options$1, cb$1, startTime) {
				return fs$appendFile(path$6, data$1, options$1, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$appendFile,
						[
							path$6,
							data$1,
							options$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		var fs$copyFile = fs$7.copyFile;
		if (fs$copyFile) fs$7.copyFile = copyFile;
		function copyFile(src, dest, flags, cb) {
			if (typeof flags === "function") {
				cb = flags;
				flags = 0;
			}
			return go$copyFile(src, dest, flags, cb);
			function go$copyFile(src$1, dest$1, flags$1, cb$1, startTime) {
				return fs$copyFile(src$1, dest$1, flags$1, function(err) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$copyFile,
						[
							src$1,
							dest$1,
							flags$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		var fs$readdir = fs$7.readdir;
		fs$7.readdir = readdir;
		var noReaddirOptionVersions = /^v[0-5]\./;
		function readdir(path$5, options, cb) {
			if (typeof options === "function") cb = options, options = null;
			var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir$1(path$6, options$1, cb$1, startTime) {
				return fs$readdir(path$6, fs$readdirCallback(path$6, options$1, cb$1, startTime));
			} : function go$readdir$1(path$6, options$1, cb$1, startTime) {
				return fs$readdir(path$6, options$1, fs$readdirCallback(path$6, options$1, cb$1, startTime));
			};
			return go$readdir(path$5, options, cb);
			function fs$readdirCallback(path$6, options$1, cb$1, startTime) {
				return function(err, files$1) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$readdir,
						[
							path$6,
							options$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else {
						if (files$1 && files$1.sort) files$1.sort();
						if (typeof cb$1 === "function") cb$1.call(this, err, files$1);
					}
				};
			}
		}
		if (process.version.substr(0, 4) === "v0.8") {
			var legStreams = legacy(fs$7);
			ReadStream = legStreams.ReadStream;
			WriteStream = legStreams.WriteStream;
		}
		var fs$ReadStream = fs$7.ReadStream;
		if (fs$ReadStream) {
			ReadStream.prototype = Object.create(fs$ReadStream.prototype);
			ReadStream.prototype.open = ReadStream$open;
		}
		var fs$WriteStream = fs$7.WriteStream;
		if (fs$WriteStream) {
			WriteStream.prototype = Object.create(fs$WriteStream.prototype);
			WriteStream.prototype.open = WriteStream$open;
		}
		Object.defineProperty(fs$7, "ReadStream", {
			get: function() {
				return ReadStream;
			},
			set: function(val) {
				ReadStream = val;
			},
			enumerable: true,
			configurable: true
		});
		Object.defineProperty(fs$7, "WriteStream", {
			get: function() {
				return WriteStream;
			},
			set: function(val) {
				WriteStream = val;
			},
			enumerable: true,
			configurable: true
		});
		var FileReadStream = ReadStream;
		Object.defineProperty(fs$7, "FileReadStream", {
			get: function() {
				return FileReadStream;
			},
			set: function(val) {
				FileReadStream = val;
			},
			enumerable: true,
			configurable: true
		});
		var FileWriteStream = WriteStream;
		Object.defineProperty(fs$7, "FileWriteStream", {
			get: function() {
				return FileWriteStream;
			},
			set: function(val) {
				FileWriteStream = val;
			},
			enumerable: true,
			configurable: true
		});
		function ReadStream(path$5, options) {
			if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
			else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
		}
		function ReadStream$open() {
			var that = this;
			open(that.path, that.flags, that.mode, function(err, fd) {
				if (err) {
					if (that.autoClose) that.destroy();
					that.emit("error", err);
				} else {
					that.fd = fd;
					that.emit("open", fd);
					that.read();
				}
			});
		}
		function WriteStream(path$5, options) {
			if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
			else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
		}
		function WriteStream$open() {
			var that = this;
			open(that.path, that.flags, that.mode, function(err, fd) {
				if (err) {
					that.destroy();
					that.emit("error", err);
				} else {
					that.fd = fd;
					that.emit("open", fd);
				}
			});
		}
		function createReadStream(path$5, options) {
			return new fs$7.ReadStream(path$5, options);
		}
		function createWriteStream(path$5, options) {
			return new fs$7.WriteStream(path$5, options);
		}
		var fs$open = fs$7.open;
		fs$7.open = open;
		function open(path$5, flags, mode, cb) {
			if (typeof mode === "function") cb = mode, mode = null;
			return go$open(path$5, flags, mode, cb);
			function go$open(path$6, flags$1, mode$1, cb$1, startTime) {
				return fs$open(path$6, flags$1, mode$1, function(err, fd) {
					if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
						go$open,
						[
							path$6,
							flags$1,
							mode$1,
							cb$1
						],
						err,
						startTime || Date.now(),
						Date.now()
					]);
					else if (typeof cb$1 === "function") cb$1.apply(this, arguments);
				});
			}
		}
		return fs$7;
	}
	function enqueue(elem) {
		debug("ENQUEUE", elem[0].name, elem[1]);
		fs$4[gracefulQueue].push(elem);
		retry();
	}
	var retryTimer;
	function resetQueue() {
		var now = Date.now();
		for (var i = 0; i < fs$4[gracefulQueue].length; ++i) if (fs$4[gracefulQueue][i].length > 2) {
			fs$4[gracefulQueue][i][3] = now;
			fs$4[gracefulQueue][i][4] = now;
		}
		retry();
	}
	function retry() {
		clearTimeout(retryTimer);
		retryTimer = void 0;
		if (fs$4[gracefulQueue].length === 0) return;
		var elem = fs$4[gracefulQueue].shift();
		var fn = elem[0];
		var args = elem[1];
		var err = elem[2];
		var startTime = elem[3];
		var lastTime = elem[4];
		if (startTime === void 0) {
			debug("RETRY", fn.name, args);
			fn.apply(null, args);
		} else if (Date.now() - startTime >= 6e4) {
			debug("TIMEOUT", fn.name, args);
			var cb = args.pop();
			if (typeof cb === "function") cb.call(null, err);
		} else {
			var sinceAttempt = Date.now() - lastTime;
			var sinceStart = Math.max(lastTime - startTime, 1);
			if (sinceAttempt >= Math.min(sinceStart * 1.2, 100)) {
				debug("RETRY", fn.name, args);
				fn.apply(null, args.concat([startTime]));
			} else fs$4[gracefulQueue].push(elem);
		}
		if (retryTimer === void 0) retryTimer = setTimeout(retry, 0);
	}
}));
var require_is_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isStream = (stream$5) => stream$5 !== null && typeof stream$5 === "object" && typeof stream$5.pipe === "function";
	isStream.writable = (stream$5) => isStream(stream$5) && stream$5.writable !== false && typeof stream$5._write === "function" && typeof stream$5._writableState === "object";
	isStream.readable = (stream$5) => isStream(stream$5) && stream$5.readable !== false && typeof stream$5._read === "function" && typeof stream$5._readableState === "object";
	isStream.duplex = (stream$5) => isStream.writable(stream$5) && isStream.readable(stream$5);
	isStream.transform = (stream$5) => isStream.duplex(stream$5) && typeof stream$5._transform === "function";
	module.exports = isStream;
}));
var require_process_nextick_args = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) module.exports = { nextTick };
	else module.exports = process;
	function nextTick(fn, arg1, arg2, arg3) {
		if (typeof fn !== "function") throw new TypeError("\"callback\" argument must be a function");
		var len = arguments.length;
		var args, i;
		switch (len) {
			case 0:
			case 1: return process.nextTick(fn);
			case 2: return process.nextTick(function afterTickOne() {
				fn.call(null, arg1);
			});
			case 3: return process.nextTick(function afterTickTwo() {
				fn.call(null, arg1, arg2);
			});
			case 4: return process.nextTick(function afterTickThree() {
				fn.call(null, arg1, arg2, arg3);
			});
			default:
				args = new Array(len - 1);
				i = 0;
				while (i < args.length) args[i++] = arguments[i];
				return process.nextTick(function afterTick() {
					fn.apply(null, args);
				});
		}
	}
}));
var require_isarray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var toString = {}.toString;
	module.exports = Array.isArray || function(arr) {
		return toString.call(arr) == "[object Array]";
	};
}));
var require_stream$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = __require("stream");
}));
var require_safe_buffer$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var buffer$1 = __require("buffer");
	var Buffer = buffer$1.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer$1;
	else {
		copyProps(buffer$1, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer(arg, encodingOrOffset, length);
	}
	copyProps(Buffer, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer(size);
		if (fill !== void 0) if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer$1.SlowBuffer(size);
	};
}));
var require_util$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	function isArray(arg) {
		if (Array.isArray) return Array.isArray(arg);
		return objectToString(arg) === "[object Array]";
	}
	exports.isArray = isArray;
	function isBoolean(arg) {
		return typeof arg === "boolean";
	}
	exports.isBoolean = isBoolean;
	function isNull(arg) {
		return arg === null;
	}
	exports.isNull = isNull;
	function isNullOrUndefined(arg) {
		return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	function isNumber(arg) {
		return typeof arg === "number";
	}
	exports.isNumber = isNumber;
	function isString(arg) {
		return typeof arg === "string";
	}
	exports.isString = isString;
	function isSymbol(arg) {
		return typeof arg === "symbol";
	}
	exports.isSymbol = isSymbol;
	function isUndefined(arg) {
		return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	function isRegExp(re) {
		return objectToString(re) === "[object RegExp]";
	}
	exports.isRegExp = isRegExp;
	function isObject(arg) {
		return typeof arg === "object" && arg !== null;
	}
	exports.isObject = isObject;
	function isDate(d) {
		return objectToString(d) === "[object Date]";
	}
	exports.isDate = isDate;
	function isError(e$1) {
		return objectToString(e$1) === "[object Error]" || e$1 instanceof Error;
	}
	exports.isError = isError;
	function isFunction(arg) {
		return typeof arg === "function";
	}
	exports.isFunction = isFunction;
	function isPrimitive(arg) {
		return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
	}
	exports.isPrimitive = isPrimitive;
	exports.isBuffer = __require("buffer").Buffer.isBuffer;
	function objectToString(o$1) {
		return Object.prototype.toString.call(o$1);
	}
}));
var require_inherits_browser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits$7(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits$7(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}));
var require_inherits = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	try {
		var util$7 = __require("util");
		/* istanbul ignore next */
		if (typeof util$7.inherits !== "function") throw "";
		module.exports = util$7.inherits;
	} catch (e$1) {
		/* istanbul ignore next */
		module.exports = require_inherits_browser();
	}
}));
var require_BufferList = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
	}
	var Buffer = require_safe_buffer$1().Buffer;
	var util$6 = __require("util");
	function copyBuffer(src, target, offset) {
		src.copy(target, offset);
	}
	module.exports = function() {
		function BufferList() {
			_classCallCheck(this, BufferList);
			this.head = null;
			this.tail = null;
			this.length = 0;
		}
		BufferList.prototype.push = function push(v) {
			var entry = {
				data: v,
				next: null
			};
			if (this.length > 0) this.tail.next = entry;
			else this.head = entry;
			this.tail = entry;
			++this.length;
		};
		BufferList.prototype.unshift = function unshift(v) {
			var entry = {
				data: v,
				next: this.head
			};
			if (this.length === 0) this.tail = entry;
			this.head = entry;
			++this.length;
		};
		BufferList.prototype.shift = function shift() {
			if (this.length === 0) return;
			var ret = this.head.data;
			if (this.length === 1) this.head = this.tail = null;
			else this.head = this.head.next;
			--this.length;
			return ret;
		};
		BufferList.prototype.clear = function clear() {
			this.head = this.tail = null;
			this.length = 0;
		};
		BufferList.prototype.join = function join(s) {
			if (this.length === 0) return "";
			var p = this.head;
			var ret = "" + p.data;
			while (p = p.next) ret += s + p.data;
			return ret;
		};
		BufferList.prototype.concat = function concat$2(n$1) {
			if (this.length === 0) return Buffer.alloc(0);
			var ret = Buffer.allocUnsafe(n$1 >>> 0);
			var p = this.head;
			var i = 0;
			while (p) {
				copyBuffer(p.data, ret, i);
				i += p.data.length;
				p = p.next;
			}
			return ret;
		};
		return BufferList;
	}();
	if (util$6 && util$6.inspect && util$6.inspect.custom) module.exports.prototype[util$6.inspect.custom] = function() {
		var obj = util$6.inspect({ length: this.length });
		return this.constructor.name + " " + obj;
	};
}));
var require_destroy$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var pna = require_process_nextick_args();
	function destroy(err, cb) {
		var _this = this;
		var readableDestroyed = this._readableState && this._readableState.destroyed;
		var writableDestroyed = this._writableState && this._writableState.destroyed;
		if (readableDestroyed || writableDestroyed) {
			if (cb) cb(err);
			else if (err) {
				if (!this._writableState) pna.nextTick(emitErrorNT, this, err);
				else if (!this._writableState.errorEmitted) {
					this._writableState.errorEmitted = true;
					pna.nextTick(emitErrorNT, this, err);
				}
			}
			return this;
		}
		if (this._readableState) this._readableState.destroyed = true;
		if (this._writableState) this._writableState.destroyed = true;
		this._destroy(err || null, function(err$1) {
			if (!cb && err$1) {
				if (!_this._writableState) pna.nextTick(emitErrorNT, _this, err$1);
				else if (!_this._writableState.errorEmitted) {
					_this._writableState.errorEmitted = true;
					pna.nextTick(emitErrorNT, _this, err$1);
				}
			} else if (cb) cb(err$1);
		});
		return this;
	}
	function undestroy() {
		if (this._readableState) {
			this._readableState.destroyed = false;
			this._readableState.reading = false;
			this._readableState.ended = false;
			this._readableState.endEmitted = false;
		}
		if (this._writableState) {
			this._writableState.destroyed = false;
			this._writableState.ended = false;
			this._writableState.ending = false;
			this._writableState.finalCalled = false;
			this._writableState.prefinished = false;
			this._writableState.finished = false;
			this._writableState.errorEmitted = false;
		}
	}
	function emitErrorNT(self$1, err) {
		self$1.emit("error", err);
	}
	module.exports = {
		destroy,
		undestroy
	};
}));
var require_node = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = __require("util").deprecate;
}));
var require__stream_writable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var pna = require_process_nextick_args();
	module.exports = Writable;
	function CorkedRequest(state) {
		var _this = this;
		this.next = null;
		this.entry = null;
		this.finish = function() {
			onCorkedFinish(_this, state);
		};
	}
	var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
	var Duplex;
	Writable.WritableState = WritableState;
	var util = Object.create(require_util$3());
	util.inherits = require_inherits();
	var internalUtil = { deprecate: require_node() };
	var Stream = require_stream$1();
	var Buffer = require_safe_buffer$1().Buffer;
	var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
	function _uint8ArrayToBuffer(chunk) {
		return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
		return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var destroyImpl = require_destroy$1();
	util.inherits(Writable, Stream);
	function nop() {}
	function WritableState(options, stream$5) {
		Duplex = Duplex || require__stream_duplex();
		options = options || {};
		var isDuplex = stream$5 instanceof Duplex;
		this.objectMode = !!options.objectMode;
		if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
		var hwm = options.highWaterMark;
		var writableHwm = options.writableHighWaterMark;
		var defaultHwm = this.objectMode ? 16 : 16 * 1024;
		if (hwm || hwm === 0) this.highWaterMark = hwm;
		else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
		else this.highWaterMark = defaultHwm;
		this.highWaterMark = Math.floor(this.highWaterMark);
		this.finalCalled = false;
		this.needDrain = false;
		this.ending = false;
		this.ended = false;
		this.finished = false;
		this.destroyed = false;
		this.decodeStrings = !(options.decodeStrings === false);
		this.defaultEncoding = options.defaultEncoding || "utf8";
		this.length = 0;
		this.writing = false;
		this.corked = 0;
		this.sync = true;
		this.bufferProcessing = false;
		this.onwrite = function(er) {
			onwrite(stream$5, er);
		};
		this.writecb = null;
		this.writelen = 0;
		this.bufferedRequest = null;
		this.lastBufferedRequest = null;
		this.pendingcb = 0;
		this.prefinished = false;
		this.errorEmitted = false;
		this.bufferedRequestCount = 0;
		this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function getBuffer() {
		var current = this.bufferedRequest;
		var out = [];
		while (current) {
			out.push(current);
			current = current.next;
		}
		return out;
	};
	(function() {
		try {
			Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function() {
				return this.getBuffer();
			}, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
		} catch (_$1) {}
	})();
	var realHasInstance;
	if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
		realHasInstance = Function.prototype[Symbol.hasInstance];
		Object.defineProperty(Writable, Symbol.hasInstance, { value: function(object) {
			if (realHasInstance.call(this, object)) return true;
			if (this !== Writable) return false;
			return object && object._writableState instanceof WritableState;
		} });
	} else realHasInstance = function(object) {
		return object instanceof this;
	};
	function Writable(options) {
		Duplex = Duplex || require__stream_duplex();
		if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) return new Writable(options);
		this._writableState = new WritableState(options, this);
		this.writable = true;
		if (options) {
			if (typeof options.write === "function") this._write = options.write;
			if (typeof options.writev === "function") this._writev = options.writev;
			if (typeof options.destroy === "function") this._destroy = options.destroy;
			if (typeof options.final === "function") this._final = options.final;
		}
		Stream.call(this);
	}
	Writable.prototype.pipe = function() {
		this.emit("error", /* @__PURE__ */ new Error("Cannot pipe, not readable"));
	};
	function writeAfterEnd(stream$5, cb) {
		var er = /* @__PURE__ */ new Error("write after end");
		stream$5.emit("error", er);
		pna.nextTick(cb, er);
	}
	function validChunk(stream$5, state, chunk, cb) {
		var valid = true;
		var er = false;
		if (chunk === null) er = /* @__PURE__ */ new TypeError("May not write null values to stream");
		else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) er = /* @__PURE__ */ new TypeError("Invalid non-string/buffer chunk");
		if (er) {
			stream$5.emit("error", er);
			pna.nextTick(cb, er);
			valid = false;
		}
		return valid;
	}
	Writable.prototype.write = function(chunk, encoding, cb) {
		var state = this._writableState;
		var ret = false;
		var isBuf = !state.objectMode && _isUint8Array(chunk);
		if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
		if (typeof encoding === "function") {
			cb = encoding;
			encoding = null;
		}
		if (isBuf) encoding = "buffer";
		else if (!encoding) encoding = state.defaultEncoding;
		if (typeof cb !== "function") cb = nop;
		if (state.ended) writeAfterEnd(this, cb);
		else if (isBuf || validChunk(this, state, chunk, cb)) {
			state.pendingcb++;
			ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
		}
		return ret;
	};
	Writable.prototype.cork = function() {
		var state = this._writableState;
		state.corked++;
	};
	Writable.prototype.uncork = function() {
		var state = this._writableState;
		if (state.corked) {
			state.corked--;
			if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
		}
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
		if (typeof encoding === "string") encoding = encoding.toLowerCase();
		if (!([
			"hex",
			"utf8",
			"utf-8",
			"ascii",
			"binary",
			"base64",
			"ucs2",
			"ucs-2",
			"utf16le",
			"utf-16le",
			"raw"
		].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
		this._writableState.defaultEncoding = encoding;
		return this;
	};
	function decodeChunk(state, chunk, encoding) {
		if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
		return chunk;
	}
	Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
		enumerable: false,
		get: function() {
			return this._writableState.highWaterMark;
		}
	});
	function writeOrBuffer(stream$5, state, isBuf, chunk, encoding, cb) {
		if (!isBuf) {
			var newChunk = decodeChunk(state, chunk, encoding);
			if (chunk !== newChunk) {
				isBuf = true;
				encoding = "buffer";
				chunk = newChunk;
			}
		}
		var len = state.objectMode ? 1 : chunk.length;
		state.length += len;
		var ret = state.length < state.highWaterMark;
		if (!ret) state.needDrain = true;
		if (state.writing || state.corked) {
			var last = state.lastBufferedRequest;
			state.lastBufferedRequest = {
				chunk,
				encoding,
				isBuf,
				callback: cb,
				next: null
			};
			if (last) last.next = state.lastBufferedRequest;
			else state.bufferedRequest = state.lastBufferedRequest;
			state.bufferedRequestCount += 1;
		} else doWrite(stream$5, state, false, len, chunk, encoding, cb);
		return ret;
	}
	function doWrite(stream$5, state, writev, len, chunk, encoding, cb) {
		state.writelen = len;
		state.writecb = cb;
		state.writing = true;
		state.sync = true;
		if (writev) stream$5._writev(chunk, state.onwrite);
		else stream$5._write(chunk, encoding, state.onwrite);
		state.sync = false;
	}
	function onwriteError(stream$5, state, sync$3, er, cb) {
		--state.pendingcb;
		if (sync$3) {
			pna.nextTick(cb, er);
			pna.nextTick(finishMaybe, stream$5, state);
			stream$5._writableState.errorEmitted = true;
			stream$5.emit("error", er);
		} else {
			cb(er);
			stream$5._writableState.errorEmitted = true;
			stream$5.emit("error", er);
			finishMaybe(stream$5, state);
		}
	}
	function onwriteStateUpdate(state) {
		state.writing = false;
		state.writecb = null;
		state.length -= state.writelen;
		state.writelen = 0;
	}
	function onwrite(stream$5, er) {
		var state = stream$5._writableState;
		var sync$3 = state.sync;
		var cb = state.writecb;
		onwriteStateUpdate(state);
		if (er) onwriteError(stream$5, state, sync$3, er, cb);
		else {
			var finished = needFinish(state);
			if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream$5, state);
			if (sync$3) asyncWrite(afterWrite, stream$5, state, finished, cb);
			else afterWrite(stream$5, state, finished, cb);
		}
	}
	function afterWrite(stream$5, state, finished, cb) {
		if (!finished) onwriteDrain(stream$5, state);
		state.pendingcb--;
		cb();
		finishMaybe(stream$5, state);
	}
	function onwriteDrain(stream$5, state) {
		if (state.length === 0 && state.needDrain) {
			state.needDrain = false;
			stream$5.emit("drain");
		}
	}
	function clearBuffer(stream$5, state) {
		state.bufferProcessing = true;
		var entry = state.bufferedRequest;
		if (stream$5._writev && entry && entry.next) {
			var l = state.bufferedRequestCount;
			var buffer$2 = new Array(l);
			var holder = state.corkedRequestsFree;
			holder.entry = entry;
			var count = 0;
			var allBuffers = true;
			while (entry) {
				buffer$2[count] = entry;
				if (!entry.isBuf) allBuffers = false;
				entry = entry.next;
				count += 1;
			}
			buffer$2.allBuffers = allBuffers;
			doWrite(stream$5, state, true, state.length, buffer$2, "", holder.finish);
			state.pendingcb++;
			state.lastBufferedRequest = null;
			if (holder.next) {
				state.corkedRequestsFree = holder.next;
				holder.next = null;
			} else state.corkedRequestsFree = new CorkedRequest(state);
			state.bufferedRequestCount = 0;
		} else {
			while (entry) {
				var chunk = entry.chunk;
				var encoding = entry.encoding;
				var cb = entry.callback;
				doWrite(stream$5, state, false, state.objectMode ? 1 : chunk.length, chunk, encoding, cb);
				entry = entry.next;
				state.bufferedRequestCount--;
				if (state.writing) break;
			}
			if (entry === null) state.lastBufferedRequest = null;
		}
		state.bufferedRequest = entry;
		state.bufferProcessing = false;
	}
	Writable.prototype._write = function(chunk, encoding, cb) {
		cb(/* @__PURE__ */ new Error("_write() is not implemented"));
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function(chunk, encoding, cb) {
		var state = this._writableState;
		if (typeof chunk === "function") {
			cb = chunk;
			chunk = null;
			encoding = null;
		} else if (typeof encoding === "function") {
			cb = encoding;
			encoding = null;
		}
		if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
		if (state.corked) {
			state.corked = 1;
			this.uncork();
		}
		if (!state.ending) endWritable(this, state, cb);
	};
	function needFinish(state) {
		return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream$5, state) {
		stream$5._final(function(err) {
			state.pendingcb--;
			if (err) stream$5.emit("error", err);
			state.prefinished = true;
			stream$5.emit("prefinish");
			finishMaybe(stream$5, state);
		});
	}
	function prefinish(stream$5, state) {
		if (!state.prefinished && !state.finalCalled) if (typeof stream$5._final === "function") {
			state.pendingcb++;
			state.finalCalled = true;
			pna.nextTick(callFinal, stream$5, state);
		} else {
			state.prefinished = true;
			stream$5.emit("prefinish");
		}
	}
	function finishMaybe(stream$5, state) {
		var need = needFinish(state);
		if (need) {
			prefinish(stream$5, state);
			if (state.pendingcb === 0) {
				state.finished = true;
				stream$5.emit("finish");
			}
		}
		return need;
	}
	function endWritable(stream$5, state, cb) {
		state.ending = true;
		finishMaybe(stream$5, state);
		if (cb) if (state.finished) pna.nextTick(cb);
		else stream$5.once("finish", cb);
		state.ended = true;
		stream$5.writable = false;
	}
	function onCorkedFinish(corkReq, state, err) {
		var entry = corkReq.entry;
		corkReq.entry = null;
		while (entry) {
			var cb = entry.callback;
			state.pendingcb--;
			cb(err);
			entry = entry.next;
		}
		state.corkedRequestsFree.next = corkReq;
	}
	Object.defineProperty(Writable.prototype, "destroyed", {
		get: function() {
			if (this._writableState === void 0) return false;
			return this._writableState.destroyed;
		},
		set: function(value$1) {
			if (!this._writableState) return;
			this._writableState.destroyed = value$1;
		}
	});
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function(err, cb) {
		this.end();
		cb(err);
	};
}));
var require__stream_duplex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var pna = require_process_nextick_args();
	var objectKeys = Object.keys || function(obj) {
		var keys = [];
		for (var key in obj) keys.push(key);
		return keys;
	};
	module.exports = Duplex;
	var util = Object.create(require_util$3());
	util.inherits = require_inherits();
	var Readable = require__stream_readable();
	var Writable = require__stream_writable();
	util.inherits(Duplex, Readable);
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
		var method = keys[v];
		if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	function Duplex(options) {
		if (!(this instanceof Duplex)) return new Duplex(options);
		Readable.call(this, options);
		Writable.call(this, options);
		if (options && options.readable === false) this.readable = false;
		if (options && options.writable === false) this.writable = false;
		this.allowHalfOpen = true;
		if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
		this.once("end", onend);
	}
	Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
		enumerable: false,
		get: function() {
			return this._writableState.highWaterMark;
		}
	});
	function onend() {
		if (this.allowHalfOpen || this._writableState.ended) return;
		pna.nextTick(onEndNT, this);
	}
	function onEndNT(self$1) {
		self$1.end();
	}
	Object.defineProperty(Duplex.prototype, "destroyed", {
		get: function() {
			if (this._readableState === void 0 || this._writableState === void 0) return false;
			return this._readableState.destroyed && this._writableState.destroyed;
		},
		set: function(value$1) {
			if (this._readableState === void 0 || this._writableState === void 0) return;
			this._readableState.destroyed = value$1;
			this._writableState.destroyed = value$1;
		}
	});
	Duplex.prototype._destroy = function(err, cb) {
		this.push(null);
		this.end();
		pna.nextTick(cb, err);
	};
}));
var require_string_decoder$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safe_buffer$1().Buffer;
	var isEncoding = Buffer.isEncoding || function(encoding) {
		encoding = "" + encoding;
		switch (encoding && encoding.toLowerCase()) {
			case "hex":
			case "utf8":
			case "utf-8":
			case "ascii":
			case "binary":
			case "base64":
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le":
			case "raw": return true;
			default: return false;
		}
	};
	function _normalizeEncoding(enc) {
		if (!enc) return "utf8";
		var retried;
		while (true) switch (enc) {
			case "utf8":
			case "utf-8": return "utf8";
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return "utf16le";
			case "latin1":
			case "binary": return "latin1";
			case "base64":
			case "ascii":
			case "hex": return enc;
			default:
				if (retried) return;
				enc = ("" + enc).toLowerCase();
				retried = true;
		}
	}
	function normalizeEncoding(enc) {
		var nenc = _normalizeEncoding(enc);
		if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
		return nenc || enc;
	}
	exports.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
		this.encoding = normalizeEncoding(encoding);
		var nb;
		switch (this.encoding) {
			case "utf16le":
				this.text = utf16Text;
				this.end = utf16End;
				nb = 4;
				break;
			case "utf8":
				this.fillLast = utf8FillLast;
				nb = 4;
				break;
			case "base64":
				this.text = base64Text;
				this.end = base64End;
				nb = 3;
				break;
			default:
				this.write = simpleWrite;
				this.end = simpleEnd;
				return;
		}
		this.lastNeed = 0;
		this.lastTotal = 0;
		this.lastChar = Buffer.allocUnsafe(nb);
	}
	StringDecoder.prototype.write = function(buf) {
		if (buf.length === 0) return "";
		var r$1;
		var i;
		if (this.lastNeed) {
			r$1 = this.fillLast(buf);
			if (r$1 === void 0) return "";
			i = this.lastNeed;
			this.lastNeed = 0;
		} else i = 0;
		if (i < buf.length) return r$1 ? r$1 + this.text(buf, i) : this.text(buf, i);
		return r$1 || "";
	};
	StringDecoder.prototype.end = utf8End;
	StringDecoder.prototype.text = utf8Text;
	StringDecoder.prototype.fillLast = function(buf) {
		if (this.lastNeed <= buf.length) {
			buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
			return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		}
		buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
		this.lastNeed -= buf.length;
	};
	function utf8CheckByte(byte) {
		if (byte <= 127) return 0;
		else if (byte >> 5 === 6) return 2;
		else if (byte >> 4 === 14) return 3;
		else if (byte >> 3 === 30) return 4;
		return byte >> 6 === 2 ? -1 : -2;
	}
	function utf8CheckIncomplete(self$1, buf, i) {
		var j = buf.length - 1;
		if (j < i) return 0;
		var nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) self$1.lastNeed = nb - 1;
			return nb;
		}
		if (--j < i || nb === -2) return 0;
		nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) self$1.lastNeed = nb - 2;
			return nb;
		}
		if (--j < i || nb === -2) return 0;
		nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) if (nb === 2) nb = 0;
			else self$1.lastNeed = nb - 3;
			return nb;
		}
		return 0;
	}
	function utf8CheckExtraBytes(self$1, buf, p) {
		if ((buf[0] & 192) !== 128) {
			self$1.lastNeed = 0;
			return "";
		}
		if (self$1.lastNeed > 1 && buf.length > 1) {
			if ((buf[1] & 192) !== 128) {
				self$1.lastNeed = 1;
				return "";
			}
			if (self$1.lastNeed > 2 && buf.length > 2) {
				if ((buf[2] & 192) !== 128) {
					self$1.lastNeed = 2;
					return "";
				}
			}
		}
	}
	function utf8FillLast(buf) {
		var p = this.lastTotal - this.lastNeed;
		var r$1 = utf8CheckExtraBytes(this, buf, p);
		if (r$1 !== void 0) return r$1;
		if (this.lastNeed <= buf.length) {
			buf.copy(this.lastChar, p, 0, this.lastNeed);
			return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		}
		buf.copy(this.lastChar, p, 0, buf.length);
		this.lastNeed -= buf.length;
	}
	function utf8Text(buf, i) {
		var total = utf8CheckIncomplete(this, buf, i);
		if (!this.lastNeed) return buf.toString("utf8", i);
		this.lastTotal = total;
		var end = buf.length - (total - this.lastNeed);
		buf.copy(this.lastChar, 0, end);
		return buf.toString("utf8", i, end);
	}
	function utf8End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) return r$1 + "";
		return r$1;
	}
	function utf16Text(buf, i) {
		if ((buf.length - i) % 2 === 0) {
			var r$1 = buf.toString("utf16le", i);
			if (r$1) {
				var c = r$1.charCodeAt(r$1.length - 1);
				if (c >= 55296 && c <= 56319) {
					this.lastNeed = 2;
					this.lastTotal = 4;
					this.lastChar[0] = buf[buf.length - 2];
					this.lastChar[1] = buf[buf.length - 1];
					return r$1.slice(0, -1);
				}
			}
			return r$1;
		}
		this.lastNeed = 1;
		this.lastTotal = 2;
		this.lastChar[0] = buf[buf.length - 1];
		return buf.toString("utf16le", i, buf.length - 1);
	}
	function utf16End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) {
			var end = this.lastTotal - this.lastNeed;
			return r$1 + this.lastChar.toString("utf16le", 0, end);
		}
		return r$1;
	}
	function base64Text(buf, i) {
		var n$1 = (buf.length - i) % 3;
		if (n$1 === 0) return buf.toString("base64", i);
		this.lastNeed = 3 - n$1;
		this.lastTotal = 3;
		if (n$1 === 1) this.lastChar[0] = buf[buf.length - 1];
		else {
			this.lastChar[0] = buf[buf.length - 2];
			this.lastChar[1] = buf[buf.length - 1];
		}
		return buf.toString("base64", i, buf.length - n$1);
	}
	function base64End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) return r$1 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
		return r$1;
	}
	function simpleWrite(buf) {
		return buf.toString(this.encoding);
	}
	function simpleEnd(buf) {
		return buf && buf.length ? this.write(buf) : "";
	}
}));
var require__stream_readable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var pna = require_process_nextick_args();
	module.exports = Readable;
	var isArray = require_isarray();
	var Duplex;
	Readable.ReadableState = ReadableState;
	__require("events").EventEmitter;
	var EElistenerCount = function(emitter, type) {
		return emitter.listeners(type).length;
	};
	var Stream = require_stream$1();
	var Buffer = require_safe_buffer$1().Buffer;
	var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
	function _uint8ArrayToBuffer(chunk) {
		return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
		return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var util = Object.create(require_util$3());
	util.inherits = require_inherits();
	var debugUtil = __require("util");
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog("stream");
	else debug = function() {};
	var BufferList = require_BufferList();
	var destroyImpl = require_destroy$1();
	var StringDecoder;
	util.inherits(Readable, Stream);
	var kProxyEvents = [
		"error",
		"close",
		"destroy",
		"pause",
		"resume"
	];
	function prependListener(emitter, event, fn) {
		if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
		if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
		else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
		else emitter._events[event] = [fn, emitter._events[event]];
	}
	function ReadableState(options, stream$5) {
		Duplex = Duplex || require__stream_duplex();
		options = options || {};
		var isDuplex = stream$5 instanceof Duplex;
		this.objectMode = !!options.objectMode;
		if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
		var hwm = options.highWaterMark;
		var readableHwm = options.readableHighWaterMark;
		var defaultHwm = this.objectMode ? 16 : 16 * 1024;
		if (hwm || hwm === 0) this.highWaterMark = hwm;
		else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
		else this.highWaterMark = defaultHwm;
		this.highWaterMark = Math.floor(this.highWaterMark);
		this.buffer = new BufferList();
		this.length = 0;
		this.pipes = null;
		this.pipesCount = 0;
		this.flowing = null;
		this.ended = false;
		this.endEmitted = false;
		this.reading = false;
		this.sync = true;
		this.needReadable = false;
		this.emittedReadable = false;
		this.readableListening = false;
		this.resumeScheduled = false;
		this.destroyed = false;
		this.defaultEncoding = options.defaultEncoding || "utf8";
		this.awaitDrain = 0;
		this.readingMore = false;
		this.decoder = null;
		this.encoding = null;
		if (options.encoding) {
			if (!StringDecoder) StringDecoder = require_string_decoder$1().StringDecoder;
			this.decoder = new StringDecoder(options.encoding);
			this.encoding = options.encoding;
		}
	}
	function Readable(options) {
		Duplex = Duplex || require__stream_duplex();
		if (!(this instanceof Readable)) return new Readable(options);
		this._readableState = new ReadableState(options, this);
		this.readable = true;
		if (options) {
			if (typeof options.read === "function") this._read = options.read;
			if (typeof options.destroy === "function") this._destroy = options.destroy;
		}
		Stream.call(this);
	}
	Object.defineProperty(Readable.prototype, "destroyed", {
		get: function() {
			if (this._readableState === void 0) return false;
			return this._readableState.destroyed;
		},
		set: function(value$1) {
			if (!this._readableState) return;
			this._readableState.destroyed = value$1;
		}
	});
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function(err, cb) {
		this.push(null);
		cb(err);
	};
	Readable.prototype.push = function(chunk, encoding) {
		var state = this._readableState;
		var skipChunkCheck;
		if (!state.objectMode) {
			if (typeof chunk === "string") {
				encoding = encoding || state.defaultEncoding;
				if (encoding !== state.encoding) {
					chunk = Buffer.from(chunk, encoding);
					encoding = "";
				}
				skipChunkCheck = true;
			}
		} else skipChunkCheck = true;
		return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};
	Readable.prototype.unshift = function(chunk) {
		return readableAddChunk(this, chunk, null, true, false);
	};
	function readableAddChunk(stream$5, chunk, encoding, addToFront, skipChunkCheck) {
		var state = stream$5._readableState;
		if (chunk === null) {
			state.reading = false;
			onEofChunk(stream$5, state);
		} else {
			var er;
			if (!skipChunkCheck) er = chunkInvalid(state, chunk);
			if (er) stream$5.emit("error", er);
			else if (state.objectMode || chunk && chunk.length > 0) {
				if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
				if (addToFront) if (state.endEmitted) stream$5.emit("error", /* @__PURE__ */ new Error("stream.unshift() after end event"));
				else addChunk(stream$5, state, chunk, true);
				else if (state.ended) stream$5.emit("error", /* @__PURE__ */ new Error("stream.push() after EOF"));
				else {
					state.reading = false;
					if (state.decoder && !encoding) {
						chunk = state.decoder.write(chunk);
						if (state.objectMode || chunk.length !== 0) addChunk(stream$5, state, chunk, false);
						else maybeReadMore(stream$5, state);
					} else addChunk(stream$5, state, chunk, false);
				}
			} else if (!addToFront) state.reading = false;
		}
		return needMoreData(state);
	}
	function addChunk(stream$5, state, chunk, addToFront) {
		if (state.flowing && state.length === 0 && !state.sync) {
			stream$5.emit("data", chunk);
			stream$5.read(0);
		} else {
			state.length += state.objectMode ? 1 : chunk.length;
			if (addToFront) state.buffer.unshift(chunk);
			else state.buffer.push(chunk);
			if (state.needReadable) emitReadable(stream$5);
		}
		maybeReadMore(stream$5, state);
	}
	function chunkInvalid(state, chunk) {
		var er;
		if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) er = /* @__PURE__ */ new TypeError("Invalid non-string/buffer chunk");
		return er;
	}
	function needMoreData(state) {
		return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	Readable.prototype.isPaused = function() {
		return this._readableState.flowing === false;
	};
	Readable.prototype.setEncoding = function(enc) {
		if (!StringDecoder) StringDecoder = require_string_decoder$1().StringDecoder;
		this._readableState.decoder = new StringDecoder(enc);
		this._readableState.encoding = enc;
		return this;
	};
	var MAX_HWM = 8388608;
	function computeNewHighWaterMark(n$1) {
		if (n$1 >= MAX_HWM) n$1 = MAX_HWM;
		else {
			n$1--;
			n$1 |= n$1 >>> 1;
			n$1 |= n$1 >>> 2;
			n$1 |= n$1 >>> 4;
			n$1 |= n$1 >>> 8;
			n$1 |= n$1 >>> 16;
			n$1++;
		}
		return n$1;
	}
	function howMuchToRead(n$1, state) {
		if (n$1 <= 0 || state.length === 0 && state.ended) return 0;
		if (state.objectMode) return 1;
		if (n$1 !== n$1) if (state.flowing && state.length) return state.buffer.head.data.length;
		else return state.length;
		if (n$1 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n$1);
		if (n$1 <= state.length) return n$1;
		if (!state.ended) {
			state.needReadable = true;
			return 0;
		}
		return state.length;
	}
	Readable.prototype.read = function(n$1) {
		debug("read", n$1);
		n$1 = parseInt(n$1, 10);
		var state = this._readableState;
		var nOrig = n$1;
		if (n$1 !== 0) state.emittedReadable = false;
		if (n$1 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
			debug("read: emitReadable", state.length, state.ended);
			if (state.length === 0 && state.ended) endReadable(this);
			else emitReadable(this);
			return null;
		}
		n$1 = howMuchToRead(n$1, state);
		if (n$1 === 0 && state.ended) {
			if (state.length === 0) endReadable(this);
			return null;
		}
		var doRead = state.needReadable;
		debug("need readable", doRead);
		if (state.length === 0 || state.length - n$1 < state.highWaterMark) {
			doRead = true;
			debug("length less than watermark", doRead);
		}
		if (state.ended || state.reading) {
			doRead = false;
			debug("reading or ended", doRead);
		} else if (doRead) {
			debug("do read");
			state.reading = true;
			state.sync = true;
			if (state.length === 0) state.needReadable = true;
			this._read(state.highWaterMark);
			state.sync = false;
			if (!state.reading) n$1 = howMuchToRead(nOrig, state);
		}
		var ret;
		if (n$1 > 0) ret = fromList(n$1, state);
		else ret = null;
		if (ret === null) {
			state.needReadable = true;
			n$1 = 0;
		} else state.length -= n$1;
		if (state.length === 0) {
			if (!state.ended) state.needReadable = true;
			if (nOrig !== n$1 && state.ended) endReadable(this);
		}
		if (ret !== null) this.emit("data", ret);
		return ret;
	};
	function onEofChunk(stream$5, state) {
		if (state.ended) return;
		if (state.decoder) {
			var chunk = state.decoder.end();
			if (chunk && chunk.length) {
				state.buffer.push(chunk);
				state.length += state.objectMode ? 1 : chunk.length;
			}
		}
		state.ended = true;
		emitReadable(stream$5);
	}
	function emitReadable(stream$5) {
		var state = stream$5._readableState;
		state.needReadable = false;
		if (!state.emittedReadable) {
			debug("emitReadable", state.flowing);
			state.emittedReadable = true;
			if (state.sync) pna.nextTick(emitReadable_, stream$5);
			else emitReadable_(stream$5);
		}
	}
	function emitReadable_(stream$5) {
		debug("emit readable");
		stream$5.emit("readable");
		flow(stream$5);
	}
	function maybeReadMore(stream$5, state) {
		if (!state.readingMore) {
			state.readingMore = true;
			pna.nextTick(maybeReadMore_, stream$5, state);
		}
	}
	function maybeReadMore_(stream$5, state) {
		var len = state.length;
		while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
			debug("maybeReadMore read 0");
			stream$5.read(0);
			if (len === state.length) break;
			else len = state.length;
		}
		state.readingMore = false;
	}
	Readable.prototype._read = function(n$1) {
		this.emit("error", /* @__PURE__ */ new Error("_read() is not implemented"));
	};
	Readable.prototype.pipe = function(dest, pipeOpts) {
		var src = this;
		var state = this._readableState;
		switch (state.pipesCount) {
			case 0:
				state.pipes = dest;
				break;
			case 1:
				state.pipes = [state.pipes, dest];
				break;
			default:
				state.pipes.push(dest);
				break;
		}
		state.pipesCount += 1;
		debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
		var endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr ? onend : unpipe;
		if (state.endEmitted) pna.nextTick(endFn);
		else src.once("end", endFn);
		dest.on("unpipe", onunpipe);
		function onunpipe(readable, unpipeInfo) {
			debug("onunpipe");
			if (readable === src) {
				if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
					unpipeInfo.hasUnpiped = true;
					cleanup();
				}
			}
		}
		function onend() {
			debug("onend");
			dest.end();
		}
		var ondrain = pipeOnDrain(src);
		dest.on("drain", ondrain);
		var cleanedUp = false;
		function cleanup() {
			debug("cleanup");
			dest.removeListener("close", onclose);
			dest.removeListener("finish", onfinish);
			dest.removeListener("drain", ondrain);
			dest.removeListener("error", onerror);
			dest.removeListener("unpipe", onunpipe);
			src.removeListener("end", onend);
			src.removeListener("end", unpipe);
			src.removeListener("data", ondata);
			cleanedUp = true;
			if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
		}
		var increasedAwaitDrain = false;
		src.on("data", ondata);
		function ondata(chunk) {
			debug("ondata");
			increasedAwaitDrain = false;
			if (false === dest.write(chunk) && !increasedAwaitDrain) {
				if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
					debug("false write response, pause", state.awaitDrain);
					state.awaitDrain++;
					increasedAwaitDrain = true;
				}
				src.pause();
			}
		}
		function onerror(er) {
			debug("onerror", er);
			unpipe();
			dest.removeListener("error", onerror);
			if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
		}
		prependListener(dest, "error", onerror);
		function onclose() {
			dest.removeListener("finish", onfinish);
			unpipe();
		}
		dest.once("close", onclose);
		function onfinish() {
			debug("onfinish");
			dest.removeListener("close", onclose);
			unpipe();
		}
		dest.once("finish", onfinish);
		function unpipe() {
			debug("unpipe");
			src.unpipe(dest);
		}
		dest.emit("pipe", src);
		if (!state.flowing) {
			debug("pipe resume");
			src.resume();
		}
		return dest;
	};
	function pipeOnDrain(src) {
		return function() {
			var state = src._readableState;
			debug("pipeOnDrain", state.awaitDrain);
			if (state.awaitDrain) state.awaitDrain--;
			if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
				state.flowing = true;
				flow(src);
			}
		};
	}
	Readable.prototype.unpipe = function(dest) {
		var state = this._readableState;
		var unpipeInfo = { hasUnpiped: false };
		if (state.pipesCount === 0) return this;
		if (state.pipesCount === 1) {
			if (dest && dest !== state.pipes) return this;
			if (!dest) dest = state.pipes;
			state.pipes = null;
			state.pipesCount = 0;
			state.flowing = false;
			if (dest) dest.emit("unpipe", this, unpipeInfo);
			return this;
		}
		if (!dest) {
			var dests = state.pipes;
			var len = state.pipesCount;
			state.pipes = null;
			state.pipesCount = 0;
			state.flowing = false;
			for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, { hasUnpiped: false });
			return this;
		}
		var index$1 = indexOf(state.pipes, dest);
		if (index$1 === -1) return this;
		state.pipes.splice(index$1, 1);
		state.pipesCount -= 1;
		if (state.pipesCount === 1) state.pipes = state.pipes[0];
		dest.emit("unpipe", this, unpipeInfo);
		return this;
	};
	Readable.prototype.on = function(ev, fn) {
		var res = Stream.prototype.on.call(this, ev, fn);
		if (ev === "data") {
			if (this._readableState.flowing !== false) this.resume();
		} else if (ev === "readable") {
			var state = this._readableState;
			if (!state.endEmitted && !state.readableListening) {
				state.readableListening = state.needReadable = true;
				state.emittedReadable = false;
				if (!state.reading) pna.nextTick(nReadingNextTick, this);
				else if (state.length) emitReadable(this);
			}
		}
		return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	function nReadingNextTick(self$1) {
		debug("readable nexttick read 0");
		self$1.read(0);
	}
	Readable.prototype.resume = function() {
		var state = this._readableState;
		if (!state.flowing) {
			debug("resume");
			state.flowing = true;
			resume(this, state);
		}
		return this;
	};
	function resume(stream$5, state) {
		if (!state.resumeScheduled) {
			state.resumeScheduled = true;
			pna.nextTick(resume_, stream$5, state);
		}
	}
	function resume_(stream$5, state) {
		if (!state.reading) {
			debug("resume read 0");
			stream$5.read(0);
		}
		state.resumeScheduled = false;
		state.awaitDrain = 0;
		stream$5.emit("resume");
		flow(stream$5);
		if (state.flowing && !state.reading) stream$5.read(0);
	}
	Readable.prototype.pause = function() {
		debug("call pause flowing=%j", this._readableState.flowing);
		if (false !== this._readableState.flowing) {
			debug("pause");
			this._readableState.flowing = false;
			this.emit("pause");
		}
		return this;
	};
	function flow(stream$5) {
		var state = stream$5._readableState;
		debug("flow", state.flowing);
		while (state.flowing && stream$5.read() !== null);
	}
	Readable.prototype.wrap = function(stream$5) {
		var _this = this;
		var state = this._readableState;
		var paused = false;
		stream$5.on("end", function() {
			debug("wrapped end");
			if (state.decoder && !state.ended) {
				var chunk = state.decoder.end();
				if (chunk && chunk.length) _this.push(chunk);
			}
			_this.push(null);
		});
		stream$5.on("data", function(chunk) {
			debug("wrapped data");
			if (state.decoder) chunk = state.decoder.write(chunk);
			if (state.objectMode && (chunk === null || chunk === void 0)) return;
			else if (!state.objectMode && (!chunk || !chunk.length)) return;
			if (!_this.push(chunk)) {
				paused = true;
				stream$5.pause();
			}
		});
		for (var i in stream$5) if (this[i] === void 0 && typeof stream$5[i] === "function") this[i] = function(method) {
			return function() {
				return stream$5[method].apply(stream$5, arguments);
			};
		}(i);
		for (var n$1 = 0; n$1 < kProxyEvents.length; n$1++) stream$5.on(kProxyEvents[n$1], this.emit.bind(this, kProxyEvents[n$1]));
		this._read = function(n$2) {
			debug("wrapped _read", n$2);
			if (paused) {
				paused = false;
				stream$5.resume();
			}
		};
		return this;
	};
	Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
		enumerable: false,
		get: function() {
			return this._readableState.highWaterMark;
		}
	});
	Readable._fromList = fromList;
	function fromList(n$1, state) {
		if (state.length === 0) return null;
		var ret;
		if (state.objectMode) ret = state.buffer.shift();
		else if (!n$1 || n$1 >= state.length) {
			if (state.decoder) ret = state.buffer.join("");
			else if (state.buffer.length === 1) ret = state.buffer.head.data;
			else ret = state.buffer.concat(state.length);
			state.buffer.clear();
		} else ret = fromListPartial(n$1, state.buffer, state.decoder);
		return ret;
	}
	function fromListPartial(n$1, list, hasStrings) {
		var ret;
		if (n$1 < list.head.data.length) {
			ret = list.head.data.slice(0, n$1);
			list.head.data = list.head.data.slice(n$1);
		} else if (n$1 === list.head.data.length) ret = list.shift();
		else ret = hasStrings ? copyFromBufferString(n$1, list) : copyFromBuffer(n$1, list);
		return ret;
	}
	function copyFromBufferString(n$1, list) {
		var p = list.head;
		var c = 1;
		var ret = p.data;
		n$1 -= ret.length;
		while (p = p.next) {
			var str = p.data;
			var nb = n$1 > str.length ? str.length : n$1;
			if (nb === str.length) ret += str;
			else ret += str.slice(0, n$1);
			n$1 -= nb;
			if (n$1 === 0) {
				if (nb === str.length) {
					++c;
					if (p.next) list.head = p.next;
					else list.head = list.tail = null;
				} else {
					list.head = p;
					p.data = str.slice(nb);
				}
				break;
			}
			++c;
		}
		list.length -= c;
		return ret;
	}
	function copyFromBuffer(n$1, list) {
		var ret = Buffer.allocUnsafe(n$1);
		var p = list.head;
		var c = 1;
		p.data.copy(ret);
		n$1 -= p.data.length;
		while (p = p.next) {
			var buf = p.data;
			var nb = n$1 > buf.length ? buf.length : n$1;
			buf.copy(ret, ret.length - n$1, 0, nb);
			n$1 -= nb;
			if (n$1 === 0) {
				if (nb === buf.length) {
					++c;
					if (p.next) list.head = p.next;
					else list.head = list.tail = null;
				} else {
					list.head = p;
					p.data = buf.slice(nb);
				}
				break;
			}
			++c;
		}
		list.length -= c;
		return ret;
	}
	function endReadable(stream$5) {
		var state = stream$5._readableState;
		if (state.length > 0) throw new Error("\"endReadable()\" called on non-empty stream");
		if (!state.endEmitted) {
			state.ended = true;
			pna.nextTick(endReadableNT, state, stream$5);
		}
	}
	function endReadableNT(state, stream$5) {
		if (!state.endEmitted && state.length === 0) {
			state.endEmitted = true;
			stream$5.readable = false;
			stream$5.emit("end");
		}
	}
	function indexOf(xs, x) {
		for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;
		return -1;
	}
}));
var require__stream_transform = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Transform;
	var Duplex = require__stream_duplex();
	var util = Object.create(require_util$3());
	util.inherits = require_inherits();
	util.inherits(Transform, Duplex);
	function afterTransform(er, data) {
		var ts = this._transformState;
		ts.transforming = false;
		var cb = ts.writecb;
		if (!cb) return this.emit("error", /* @__PURE__ */ new Error("write callback called multiple times"));
		ts.writechunk = null;
		ts.writecb = null;
		if (data != null) this.push(data);
		cb(er);
		var rs = this._readableState;
		rs.reading = false;
		if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	}
	function Transform(options) {
		if (!(this instanceof Transform)) return new Transform(options);
		Duplex.call(this, options);
		this._transformState = {
			afterTransform: afterTransform.bind(this),
			needTransform: false,
			transforming: false,
			writecb: null,
			writechunk: null,
			writeencoding: null
		};
		this._readableState.needReadable = true;
		this._readableState.sync = false;
		if (options) {
			if (typeof options.transform === "function") this._transform = options.transform;
			if (typeof options.flush === "function") this._flush = options.flush;
		}
		this.on("prefinish", prefinish);
	}
	function prefinish() {
		var _this = this;
		if (typeof this._flush === "function") this._flush(function(er, data) {
			done(_this, er, data);
		});
		else done(this, null, null);
	}
	Transform.prototype.push = function(chunk, encoding) {
		this._transformState.needTransform = false;
		return Duplex.prototype.push.call(this, chunk, encoding);
	};
	Transform.prototype._transform = function(chunk, encoding, cb) {
		throw new Error("_transform() is not implemented");
	};
	Transform.prototype._write = function(chunk, encoding, cb) {
		var ts = this._transformState;
		ts.writecb = cb;
		ts.writechunk = chunk;
		ts.writeencoding = encoding;
		if (!ts.transforming) {
			var rs = this._readableState;
			if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
		}
	};
	Transform.prototype._read = function(n$1) {
		var ts = this._transformState;
		if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
			ts.transforming = true;
			this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
		} else ts.needTransform = true;
	};
	Transform.prototype._destroy = function(err, cb) {
		var _this2 = this;
		Duplex.prototype._destroy.call(this, err, function(err2) {
			cb(err2);
			_this2.emit("close");
		});
	};
	function done(stream$5, er, data) {
		if (er) return stream$5.emit("error", er);
		if (data != null) stream$5.push(data);
		if (stream$5._writableState.length) throw new Error("Calling transform done when ws.length != 0");
		if (stream$5._transformState.transforming) throw new Error("Calling transform done when still transforming");
		return stream$5.push(null);
	}
}));
var require__stream_passthrough = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = PassThrough;
	var Transform = require__stream_transform();
	var util = Object.create(require_util$3());
	util.inherits = require_inherits();
	util.inherits(PassThrough, Transform);
	function PassThrough(options) {
		if (!(this instanceof PassThrough)) return new PassThrough(options);
		Transform.call(this, options);
	}
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
		cb(null, chunk);
	};
}));
var require_readable$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stream$2 = __require("stream");
	if (process.env.READABLE_STREAM === "disable" && Stream$2) {
		module.exports = Stream$2;
		exports = module.exports = Stream$2.Readable;
		exports.Readable = Stream$2.Readable;
		exports.Writable = Stream$2.Writable;
		exports.Duplex = Stream$2.Duplex;
		exports.Transform = Stream$2.Transform;
		exports.PassThrough = Stream$2.PassThrough;
		exports.Stream = Stream$2;
	} else {
		exports = module.exports = require__stream_readable();
		exports.Stream = Stream$2 || exports;
		exports.Readable = exports;
		exports.Writable = require__stream_writable();
		exports.Duplex = require__stream_duplex();
		exports.Transform = require__stream_transform();
		exports.PassThrough = require__stream_passthrough();
	}
}));
var require_passthrough$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_readable$1().PassThrough;
}));
var require_lazystream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var util$5 = __require("util");
	var PassThrough = require_passthrough$1();
	module.exports = {
		Readable,
		Writable
	};
	util$5.inherits(Readable, PassThrough);
	util$5.inherits(Writable, PassThrough);
	function beforeFirstCall(instance, method, callback) {
		instance[method] = function() {
			delete instance[method];
			callback.apply(this, arguments);
			return this[method].apply(this, arguments);
		};
	}
	function Readable(fn, options) {
		if (!(this instanceof Readable)) return new Readable(fn, options);
		PassThrough.call(this, options);
		beforeFirstCall(this, "_read", function() {
			var source = fn.call(this, options);
			var emit = this.emit.bind(this, "error");
			source.on("error", emit);
			source.pipe(this);
		});
		this.emit("readable");
	}
	function Writable(fn, options) {
		if (!(this instanceof Writable)) return new Writable(fn, options);
		PassThrough.call(this, options);
		beforeFirstCall(this, "_write", function() {
			var destination = fn.call(this, options);
			var emit = this.emit.bind(this, "error");
			destination.on("error", emit);
			this.pipe(destination);
		});
		this.emit("writable");
	}
}));
var require_normalize_path = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(path$5, stripTrailing) {
		if (typeof path$5 !== "string") throw new TypeError("expected path to be a string");
		if (path$5 === "\\" || path$5 === "/") return "/";
		var len = path$5.length;
		if (len <= 1) return path$5;
		var prefix = "";
		if (len > 4 && path$5[3] === "\\") {
			var ch = path$5[2];
			if ((ch === "?" || ch === ".") && path$5.slice(0, 2) === "\\\\") {
				path$5 = path$5.slice(2);
				prefix = "//";
			}
		}
		var segs = path$5.split(/[/\\]+/);
		if (stripTrailing !== false && segs[segs.length - 1] === "") segs.pop();
		return prefix + segs.join("/");
	};
}));
var require_identity$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function identity(value$1) {
		return value$1;
	}
	module.exports = identity;
}));
var require__apply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function apply(func, thisArg, args) {
		switch (args.length) {
			case 0: return func.call(thisArg);
			case 1: return func.call(thisArg, args[0]);
			case 2: return func.call(thisArg, args[0], args[1]);
			case 3: return func.call(thisArg, args[0], args[1], args[2]);
		}
		return func.apply(thisArg, args);
	}
	module.exports = apply;
}));
var require__overRest = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var apply = require__apply();
	var nativeMax = Math.max;
	function overRest(func, start, transform$1) {
		start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
		return function() {
			var args = arguments, index$1 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
			while (++index$1 < length) array[index$1] = args[start + index$1];
			index$1 = -1;
			var otherArgs = Array(start + 1);
			while (++index$1 < start) otherArgs[index$1] = args[index$1];
			otherArgs[start] = transform$1(array);
			return apply(func, this, otherArgs);
		};
	}
	module.exports = overRest;
}));
var require_constant = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function constant(value$1) {
		return function() {
			return value$1;
		};
	}
	module.exports = constant;
}));
var require__freeGlobal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = typeof global == "object" && global && global.Object === Object && global;
}));
var require__root = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var freeGlobal = require__freeGlobal();
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	module.exports = freeGlobal || freeSelf || Function("return this")();
}));
var require__Symbol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__root().Symbol;
}));
var require__getRawTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol = require__Symbol();
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var nativeObjectToString = objectProto.toString;
	var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
	function getRawTag(value$1) {
		var isOwn = hasOwnProperty.call(value$1, symToStringTag), tag = value$1[symToStringTag];
		try {
			value$1[symToStringTag] = void 0;
			var unmasked = true;
		} catch (e$1) {}
		var result = nativeObjectToString.call(value$1);
		if (unmasked) if (isOwn) value$1[symToStringTag] = tag;
		else delete value$1[symToStringTag];
		return result;
	}
	module.exports = getRawTag;
}));
var require__objectToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeObjectToString = Object.prototype.toString;
	function objectToString(value$1) {
		return nativeObjectToString.call(value$1);
	}
	module.exports = objectToString;
}));
var require__baseGetTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol = require__Symbol(), getRawTag = require__getRawTag(), objectToString = require__objectToString();
	var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
	var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
	function baseGetTag(value$1) {
		if (value$1 == null) return value$1 === void 0 ? undefinedTag : nullTag;
		return symToStringTag && symToStringTag in Object(value$1) ? getRawTag(value$1) : objectToString(value$1);
	}
	module.exports = baseGetTag;
}));
var require_isObject = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isObject(value$1) {
		var type = typeof value$1;
		return value$1 != null && (type == "object" || type == "function");
	}
	module.exports = isObject;
}));
var require_isFunction = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag = require__baseGetTag(), isObject = require_isObject();
	var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
	function isFunction(value$1) {
		if (!isObject(value$1)) return false;
		var tag = baseGetTag(value$1);
		return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	module.exports = isFunction;
}));
var require__coreJsData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__root()["__core-js_shared__"];
}));
var require__isMasked = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var coreJsData = require__coreJsData();
	var maskSrcKey = function() {
		var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
		return uid ? "Symbol(src)_1." + uid : "";
	}();
	function isMasked(func) {
		return !!maskSrcKey && maskSrcKey in func;
	}
	module.exports = isMasked;
}));
var require__toSource = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var funcToString = Function.prototype.toString;
	function toSource(func) {
		if (func != null) {
			try {
				return funcToString.call(func);
			} catch (e$1) {}
			try {
				return func + "";
			} catch (e$1) {}
		}
		return "";
	}
	module.exports = toSource;
}));
var require__baseIsNative = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isFunction = require_isFunction(), isMasked = require__isMasked(), isObject = require_isObject(), toSource = require__toSource();
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	var funcProto = Function.prototype, objectProto = Object.prototype;
	var funcToString = funcProto.toString;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	function baseIsNative(value$1) {
		if (!isObject(value$1) || isMasked(value$1)) return false;
		return (isFunction(value$1) ? reIsNative : reIsHostCtor).test(toSource(value$1));
	}
	module.exports = baseIsNative;
}));
var require__getValue = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function getValue(object, key) {
		return object == null ? void 0 : object[key];
	}
	module.exports = getValue;
}));
var require__getNative = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsNative = require__baseIsNative(), getValue = require__getValue();
	function getNative(object, key) {
		var value$1 = getValue(object, key);
		return baseIsNative(value$1) ? value$1 : void 0;
	}
	module.exports = getNative;
}));
var require__defineProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getNative = require__getNative();
	module.exports = function() {
		try {
			var func = getNative(Object, "defineProperty");
			func({}, "", {});
			return func;
		} catch (e$1) {}
	}();
}));
var require__baseSetToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var constant = require_constant(), defineProperty = require__defineProperty(), identity = require_identity$1();
	module.exports = !defineProperty ? identity : function(func, string$1) {
		return defineProperty(func, "toString", {
			"configurable": true,
			"enumerable": false,
			"value": constant(string$1),
			"writable": true
		});
	};
}));
var require__shortOut = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var HOT_COUNT = 800, HOT_SPAN = 16;
	var nativeNow = Date.now;
	function shortOut(func) {
		var count = 0, lastCalled = 0;
		return function() {
			var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
			lastCalled = stamp;
			if (remaining > 0) {
				if (++count >= HOT_COUNT) return arguments[0];
			} else count = 0;
			return func.apply(void 0, arguments);
		};
	}
	module.exports = shortOut;
}));
var require__setToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseSetToString = require__baseSetToString();
	module.exports = require__shortOut()(baseSetToString);
}));
var require__baseRest = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var identity = require_identity$1(), overRest = require__overRest(), setToString = require__setToString();
	function baseRest(func, start) {
		return setToString(overRest(func, start, identity), func + "");
	}
	module.exports = baseRest;
}));
var require_eq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function eq(value$1, other) {
		return value$1 === other || value$1 !== value$1 && other !== other;
	}
	module.exports = eq;
}));
var require_isLength = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MAX_SAFE_INTEGER = 9007199254740991;
	function isLength(value$1) {
		return typeof value$1 == "number" && value$1 > -1 && value$1 % 1 == 0 && value$1 <= MAX_SAFE_INTEGER;
	}
	module.exports = isLength;
}));
var require_isArrayLike = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isFunction = require_isFunction(), isLength = require_isLength();
	function isArrayLike(value$1) {
		return value$1 != null && isLength(value$1.length) && !isFunction(value$1);
	}
	module.exports = isArrayLike;
}));
var require__isIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MAX_SAFE_INTEGER = 9007199254740991;
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	function isIndex(value$1, length) {
		var type = typeof value$1;
		length = length == null ? MAX_SAFE_INTEGER : length;
		return !!length && (type == "number" || type != "symbol" && reIsUint.test(value$1)) && value$1 > -1 && value$1 % 1 == 0 && value$1 < length;
	}
	module.exports = isIndex;
}));
var require__isIterateeCall = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var eq = require_eq(), isArrayLike = require_isArrayLike(), isIndex = require__isIndex(), isObject = require_isObject();
	function isIterateeCall(value$1, index$1, object) {
		if (!isObject(object)) return false;
		var type = typeof index$1;
		if (type == "number" ? isArrayLike(object) && isIndex(index$1, object.length) : type == "string" && index$1 in object) return eq(object[index$1], value$1);
		return false;
	}
	module.exports = isIterateeCall;
}));
var require__baseTimes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseTimes(n$1, iteratee) {
		var index$1 = -1, result = Array(n$1);
		while (++index$1 < n$1) result[index$1] = iteratee(index$1);
		return result;
	}
	module.exports = baseTimes;
}));
var require_isObjectLike = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isObjectLike(value$1) {
		return value$1 != null && typeof value$1 == "object";
	}
	module.exports = isObjectLike;
}));
var require__baseIsArguments = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag = require__baseGetTag(), isObjectLike = require_isObjectLike();
	var argsTag = "[object Arguments]";
	function baseIsArguments(value$1) {
		return isObjectLike(value$1) && baseGetTag(value$1) == argsTag;
	}
	module.exports = baseIsArguments;
}));
var require_isArguments = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsArguments = require__baseIsArguments(), isObjectLike = require_isObjectLike();
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	module.exports = baseIsArguments(function() {
		return arguments;
	}()) ? baseIsArguments : function(value$1) {
		return isObjectLike(value$1) && hasOwnProperty.call(value$1, "callee") && !propertyIsEnumerable.call(value$1, "callee");
	};
}));
var require_isArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Array.isArray;
}));
var require_stubFalse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stubFalse() {
		return false;
	}
	module.exports = stubFalse;
}));
var require_isBuffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var root = require__root(), stubFalse = require_stubFalse();
	var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
	var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
	var Buffer = freeModule && freeModule.exports === freeExports ? root.Buffer : void 0;
	module.exports = (Buffer ? Buffer.isBuffer : void 0) || stubFalse;
}));
var require__baseIsTypedArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag = require__baseGetTag(), isLength = require_isLength(), isObjectLike = require_isObjectLike();
	var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
	var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	function baseIsTypedArray(value$1) {
		return isObjectLike(value$1) && isLength(value$1.length) && !!typedArrayTags[baseGetTag(value$1)];
	}
	module.exports = baseIsTypedArray;
}));
var require__baseUnary = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseUnary(func) {
		return function(value$1) {
			return func(value$1);
		};
	}
	module.exports = baseUnary;
}));
var require__nodeUtil = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var freeGlobal = require__freeGlobal();
	var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
	var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
	var freeProcess = freeModule && freeModule.exports === freeExports && freeGlobal.process;
	module.exports = function() {
		try {
			var types$1 = freeModule && freeModule.require && freeModule.require("util").types;
			if (types$1) return types$1;
			return freeProcess && freeProcess.binding && freeProcess.binding("util");
		} catch (e$1) {}
	}();
}));
var require_isTypedArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsTypedArray = require__baseIsTypedArray(), baseUnary = require__baseUnary(), nodeUtil = require__nodeUtil();
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	module.exports = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
}));
var require__arrayLikeKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseTimes = require__baseTimes(), isArguments = require_isArguments(), isArray = require_isArray(), isBuffer = require_isBuffer(), isIndex = require__isIndex(), isTypedArray = require_isTypedArray();
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function arrayLikeKeys(value$1, inherited) {
		var isArr = isArray(value$1), isArg = !isArr && isArguments(value$1), isBuff = !isArr && !isArg && isBuffer(value$1), isType = !isArr && !isArg && !isBuff && isTypedArray(value$1), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value$1.length, String) : [], length = result.length;
		for (var key in value$1) if ((inherited || hasOwnProperty.call(value$1, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) result.push(key);
		return result;
	}
	module.exports = arrayLikeKeys;
}));
var require__isPrototype = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var objectProto = Object.prototype;
	function isPrototype(value$1) {
		var Ctor = value$1 && value$1.constructor;
		return value$1 === (typeof Ctor == "function" && Ctor.prototype || objectProto);
	}
	module.exports = isPrototype;
}));
var require__nativeKeysIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function nativeKeysIn(object) {
		var result = [];
		if (object != null) for (var key in Object(object)) result.push(key);
		return result;
	}
	module.exports = nativeKeysIn;
}));
var require__baseKeysIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isObject = require_isObject(), isPrototype = require__isPrototype(), nativeKeysIn = require__nativeKeysIn();
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function baseKeysIn(object) {
		if (!isObject(object)) return nativeKeysIn(object);
		var isProto = isPrototype(object), result = [];
		for (var key in object) if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
		return result;
	}
	module.exports = baseKeysIn;
}));
var require_keysIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayLikeKeys = require__arrayLikeKeys(), baseKeysIn = require__baseKeysIn(), isArrayLike = require_isArrayLike();
	function keysIn(object) {
		return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}
	module.exports = keysIn;
}));
var require_defaults = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseRest = require__baseRest(), eq = require_eq(), isIterateeCall = require__isIterateeCall(), keysIn = require_keysIn();
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	module.exports = baseRest(function(object, sources) {
		object = Object(object);
		var index$1 = -1;
		var length = sources.length;
		var guard = length > 2 ? sources[2] : void 0;
		if (guard && isIterateeCall(sources[0], sources[1], guard)) length = 1;
		while (++index$1 < length) {
			var source = sources[index$1];
			var props = keysIn(source);
			var propsIndex = -1;
			var propsLength = props.length;
			while (++propsIndex < propsLength) {
				var key = props[propsIndex];
				var value$1 = object[key];
				if (value$1 === void 0 || eq(value$1, objectProto[key]) && !hasOwnProperty.call(object, key)) object[key] = source[key];
			}
		}
		return object;
	});
}));
var require_primordials = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var AggregateError = class extends Error {
		constructor(errors) {
			if (!Array.isArray(errors)) throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
			let message = "";
			for (let i = 0; i < errors.length; i++) message += `    ${errors[i].stack}\n`;
			super(message);
			this.name = "AggregateError";
			this.errors = errors;
		}
	};
	module.exports = {
		AggregateError,
		ArrayIsArray(self$1) {
			return Array.isArray(self$1);
		},
		ArrayPrototypeIncludes(self$1, el) {
			return self$1.includes(el);
		},
		ArrayPrototypeIndexOf(self$1, el) {
			return self$1.indexOf(el);
		},
		ArrayPrototypeJoin(self$1, sep) {
			return self$1.join(sep);
		},
		ArrayPrototypeMap(self$1, fn) {
			return self$1.map(fn);
		},
		ArrayPrototypePop(self$1, el) {
			return self$1.pop(el);
		},
		ArrayPrototypePush(self$1, el) {
			return self$1.push(el);
		},
		ArrayPrototypeSlice(self$1, start, end) {
			return self$1.slice(start, end);
		},
		Error,
		FunctionPrototypeCall(fn, thisArgs, ...args) {
			return fn.call(thisArgs, ...args);
		},
		FunctionPrototypeSymbolHasInstance(self$1, instance) {
			return Function.prototype[Symbol.hasInstance].call(self$1, instance);
		},
		MathFloor: Math.floor,
		Number,
		NumberIsInteger: Number.isInteger,
		NumberIsNaN: Number.isNaN,
		NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
		NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
		NumberParseInt: Number.parseInt,
		ObjectDefineProperties(self$1, props) {
			return Object.defineProperties(self$1, props);
		},
		ObjectDefineProperty(self$1, name$1, prop) {
			return Object.defineProperty(self$1, name$1, prop);
		},
		ObjectGetOwnPropertyDescriptor(self$1, name$1) {
			return Object.getOwnPropertyDescriptor(self$1, name$1);
		},
		ObjectKeys(obj) {
			return Object.keys(obj);
		},
		ObjectSetPrototypeOf(target, proto) {
			return Object.setPrototypeOf(target, proto);
		},
		Promise,
		PromisePrototypeCatch(self$1, fn) {
			return self$1.catch(fn);
		},
		PromisePrototypeThen(self$1, thenFn, catchFn) {
			return self$1.then(thenFn, catchFn);
		},
		PromiseReject(err) {
			return Promise.reject(err);
		},
		PromiseResolve(val) {
			return Promise.resolve(val);
		},
		ReflectApply: Reflect.apply,
		RegExpPrototypeTest(self$1, value$1) {
			return self$1.test(value$1);
		},
		SafeSet: Set,
		String,
		StringPrototypeSlice(self$1, start, end) {
			return self$1.slice(start, end);
		},
		StringPrototypeToLowerCase(self$1) {
			return self$1.toLowerCase();
		},
		StringPrototypeToUpperCase(self$1) {
			return self$1.toUpperCase();
		},
		StringPrototypeTrim(self$1) {
			return self$1.trim();
		},
		Symbol,
		SymbolFor: Symbol.for,
		SymbolAsyncIterator: Symbol.asyncIterator,
		SymbolHasInstance: Symbol.hasInstance,
		SymbolIterator: Symbol.iterator,
		SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
		SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
		TypedArrayPrototypeSet(self$1, buf, len) {
			return self$1.set(buf, len);
		},
		Boolean,
		Uint8Array
	};
}));
var require_inspect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		format(format, ...args) {
			return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
				const replacement = args.shift();
				if (type === "f") return replacement.toFixed(6);
				else if (type === "j") return JSON.stringify(replacement);
				else if (type === "s" && typeof replacement === "object") return `${replacement.constructor !== Object ? replacement.constructor.name : ""} {}`.trim();
				else return replacement.toString();
			});
		},
		inspect(value$1) {
			switch (typeof value$1) {
				case "string":
					if (value$1.includes("'")) {
						if (!value$1.includes("\"")) return `"${value$1}"`;
						else if (!value$1.includes("`") && !value$1.includes("${")) return `\`${value$1}\``;
					}
					return `'${value$1}'`;
				case "number":
					if (isNaN(value$1)) return "NaN";
					else if (Object.is(value$1, -0)) return String(value$1);
					return value$1;
				case "bigint": return `${String(value$1)}n`;
				case "boolean":
				case "undefined": return String(value$1);
				case "object": return "{}";
			}
		}
	};
}));
var require_errors$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { format, inspect } = require_inspect();
	var { AggregateError: CustomAggregateError } = require_primordials();
	var AggregateError = globalThis.AggregateError || CustomAggregateError;
	var kIsNodeError = Symbol("kIsNodeError");
	var kTypes = [
		"string",
		"function",
		"number",
		"object",
		"Function",
		"Object",
		"boolean",
		"bigint",
		"symbol"
	];
	var classRegExp = /^([A-Z][a-z0-9]*)+$/;
	var nodeInternalPrefix = "__node_internal_";
	var codes = {};
	function assert(value$1, message) {
		if (!value$1) throw new codes.ERR_INTERNAL_ASSERTION(message);
	}
	function addNumericalSeparator(val) {
		let res = "";
		let i = val.length;
		const start = val[0] === "-" ? 1 : 0;
		for (; i >= start + 4; i -= 3) res = `_${val.slice(i - 3, i)}${res}`;
		return `${val.slice(0, i)}${res}`;
	}
	function getMessage(key, msg, args) {
		if (typeof msg === "function") {
			assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);
			return msg(...args);
		}
		const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
		assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);
		if (args.length === 0) return msg;
		return format(msg, ...args);
	}
	function E(code, message, Base) {
		if (!Base) Base = Error;
		class NodeError extends Base {
			constructor(...args) {
				super(getMessage(code, message, args));
			}
			toString() {
				return `${this.name} [${code}]: ${this.message}`;
			}
		}
		Object.defineProperties(NodeError.prototype, {
			name: {
				value: Base.name,
				writable: true,
				enumerable: false,
				configurable: true
			},
			toString: {
				value() {
					return `${this.name} [${code}]: ${this.message}`;
				},
				writable: true,
				enumerable: false,
				configurable: true
			}
		});
		NodeError.prototype.code = code;
		NodeError.prototype[kIsNodeError] = true;
		codes[code] = NodeError;
	}
	function hideStackFrames(fn) {
		const hidden = nodeInternalPrefix + fn.name;
		Object.defineProperty(fn, "name", { value: hidden });
		return fn;
	}
	function aggregateTwoErrors(innerError, outerError) {
		if (innerError && outerError && innerError !== outerError) {
			if (Array.isArray(outerError.errors)) {
				outerError.errors.push(innerError);
				return outerError;
			}
			const err = new AggregateError([outerError, innerError], outerError.message);
			err.code = outerError.code;
			return err;
		}
		return innerError || outerError;
	}
	var AbortError = class extends Error {
		constructor(message = "The operation was aborted", options = void 0) {
			if (options !== void 0 && typeof options !== "object") throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
			super(message, options);
			this.code = "ABORT_ERR";
			this.name = "AbortError";
		}
	};
	E("ERR_ASSERTION", "%s", Error);
	E("ERR_INVALID_ARG_TYPE", (name$1, expected, actual) => {
		assert(typeof name$1 === "string", "'name' must be a string");
		if (!Array.isArray(expected)) expected = [expected];
		let msg = "The ";
		if (name$1.endsWith(" argument")) msg += `${name$1} `;
		else msg += `"${name$1}" ${name$1.includes(".") ? "property" : "argument"} `;
		msg += "must be ";
		const types$1 = [];
		const instances = [];
		const other = [];
		for (const value$1 of expected) {
			assert(typeof value$1 === "string", "All expected entries have to be of type string");
			if (kTypes.includes(value$1)) types$1.push(value$1.toLowerCase());
			else if (classRegExp.test(value$1)) instances.push(value$1);
			else {
				assert(value$1 !== "object", "The value \"object\" should be written as \"Object\"");
				other.push(value$1);
			}
		}
		if (instances.length > 0) {
			const pos = types$1.indexOf("object");
			if (pos !== -1) {
				types$1.splice(types$1, pos, 1);
				instances.push("Object");
			}
		}
		if (types$1.length > 0) {
			switch (types$1.length) {
				case 1:
					msg += `of type ${types$1[0]}`;
					break;
				case 2:
					msg += `one of type ${types$1[0]} or ${types$1[1]}`;
					break;
				default: {
					const last = types$1.pop();
					msg += `one of type ${types$1.join(", ")}, or ${last}`;
				}
			}
			if (instances.length > 0 || other.length > 0) msg += " or ";
		}
		if (instances.length > 0) {
			switch (instances.length) {
				case 1:
					msg += `an instance of ${instances[0]}`;
					break;
				case 2:
					msg += `an instance of ${instances[0]} or ${instances[1]}`;
					break;
				default: {
					const last = instances.pop();
					msg += `an instance of ${instances.join(", ")}, or ${last}`;
				}
			}
			if (other.length > 0) msg += " or ";
		}
		switch (other.length) {
			case 0: break;
			case 1:
				if (other[0].toLowerCase() !== other[0]) msg += "an ";
				msg += `${other[0]}`;
				break;
			case 2:
				msg += `one of ${other[0]} or ${other[1]}`;
				break;
			default: {
				const last = other.pop();
				msg += `one of ${other.join(", ")}, or ${last}`;
			}
		}
		if (actual == null) msg += `. Received ${actual}`;
		else if (typeof actual === "function" && actual.name) msg += `. Received function ${actual.name}`;
		else if (typeof actual === "object") {
			var _actual$constructor;
			if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) msg += `. Received an instance of ${actual.constructor.name}`;
			else {
				const inspected = inspect(actual, { depth: -1 });
				msg += `. Received ${inspected}`;
			}
		} else {
			let inspected = inspect(actual, { colors: false });
			if (inspected.length > 25) inspected = `${inspected.slice(0, 25)}...`;
			msg += `. Received type ${typeof actual} (${inspected})`;
		}
		return msg;
	}, TypeError);
	E("ERR_INVALID_ARG_VALUE", (name$1, value$1, reason = "is invalid") => {
		let inspected = inspect(value$1);
		if (inspected.length > 128) inspected = inspected.slice(0, 128) + "...";
		return `The ${name$1.includes(".") ? "property" : "argument"} '${name$1}' ${reason}. Received ${inspected}`;
	}, TypeError);
	E("ERR_INVALID_RETURN_VALUE", (input, name$1, value$1) => {
		var _value$constructor;
		return `Expected ${input} to be returned from the "${name$1}" function but got ${value$1 !== null && value$1 !== void 0 && (_value$constructor = value$1.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value$1.constructor.name}` : `type ${typeof value$1}`}.`;
	}, TypeError);
	E("ERR_MISSING_ARGS", (...args) => {
		assert(args.length > 0, "At least one arg needs to be specified");
		let msg;
		const len = args.length;
		args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
		switch (len) {
			case 1:
				msg += `The ${args[0]} argument`;
				break;
			case 2:
				msg += `The ${args[0]} and ${args[1]} arguments`;
				break;
			default:
				{
					const last = args.pop();
					msg += `The ${args.join(", ")}, and ${last} arguments`;
				}
				break;
		}
		return `${msg} must be specified`;
	}, TypeError);
	E("ERR_OUT_OF_RANGE", (str, range$1, input) => {
		assert(range$1, "Missing \"range\" argument");
		let received;
		if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
		else if (typeof input === "bigint") {
			received = String(input);
			const limit = BigInt(2) ** BigInt(32);
			if (input > limit || input < -limit) received = addNumericalSeparator(received);
			received += "n";
		} else received = inspect(input);
		return `The value of "${str}" is out of range. It must be ${range$1}. Received ${received}`;
	}, RangeError);
	E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
	E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
	E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
	E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
	E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
	E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
	E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
	E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
	E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
	E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
	E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
	module.exports = {
		AbortError,
		aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
		hideStackFrames,
		codes
	};
}));
function pd(event) {
	const retv = privateData.get(event);
	console.assert(retv != null, "'this' is expected an Event object, but got", event);
	return retv;
}
function setCancelFlag(data) {
	if (data.passiveListener != null) {
		if (typeof console !== "undefined" && typeof console.error === "function") console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
		return;
	}
	if (!data.event.cancelable) return;
	data.canceled = true;
	if (typeof data.event.preventDefault === "function") data.event.preventDefault();
}
function Event(eventTarget, event) {
	privateData.set(this, {
		eventTarget,
		event,
		eventPhase: 2,
		currentTarget: eventTarget,
		canceled: false,
		stopped: false,
		immediateStopped: false,
		passiveListener: null,
		timeStamp: event.timeStamp || Date.now()
	});
	Object.defineProperty(this, "isTrusted", {
		value: false,
		enumerable: true
	});
	const keys = Object.keys(event);
	for (let i = 0; i < keys.length; ++i) {
		const key = keys[i];
		if (!(key in this)) Object.defineProperty(this, key, defineRedirectDescriptor(key));
	}
}
function defineRedirectDescriptor(key) {
	return {
		get() {
			return pd(this).event[key];
		},
		set(value$1) {
			pd(this).event[key] = value$1;
		},
		configurable: true,
		enumerable: true
	};
}
function defineCallDescriptor(key) {
	return {
		value() {
			const event = pd(this).event;
			return event[key].apply(event, arguments);
		},
		configurable: true,
		enumerable: true
	};
}
function defineWrapper(BaseEvent, proto) {
	const keys = Object.keys(proto);
	if (keys.length === 0) return BaseEvent;
	function CustomEvent(eventTarget, event) {
		BaseEvent.call(this, eventTarget, event);
	}
	CustomEvent.prototype = Object.create(BaseEvent.prototype, { constructor: {
		value: CustomEvent,
		configurable: true,
		writable: true
	} });
	for (let i = 0; i < keys.length; ++i) {
		const key = keys[i];
		if (!(key in BaseEvent.prototype)) {
			const isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value === "function";
			Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
		}
	}
	return CustomEvent;
}
function getWrapper(proto) {
	if (proto == null || proto === Object.prototype) return Event;
	let wrapper = wrappers.get(proto);
	if (wrapper == null) {
		wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
		wrappers.set(proto, wrapper);
	}
	return wrapper;
}
function wrapEvent(eventTarget, event) {
	return new (getWrapper(Object.getPrototypeOf(event)))(eventTarget, event);
}
function isStopped(event) {
	return pd(event).immediateStopped;
}
function setEventPhase(event, eventPhase) {
	pd(event).eventPhase = eventPhase;
}
function setCurrentTarget(event, currentTarget) {
	pd(event).currentTarget = currentTarget;
}
function setPassiveListener(event, passiveListener) {
	pd(event).passiveListener = passiveListener;
}
function isObject(x) {
	return x !== null && typeof x === "object";
}
function getListeners(eventTarget) {
	const listeners = listenersMap.get(eventTarget);
	if (listeners == null) throw new TypeError("'this' is expected an EventTarget object, but got another value.");
	return listeners;
}
function defineEventAttributeDescriptor(eventName) {
	return {
		get() {
			let node = getListeners(this).get(eventName);
			while (node != null) {
				if (node.listenerType === ATTRIBUTE) return node.listener;
				node = node.next;
			}
			return null;
		},
		set(listener) {
			if (typeof listener !== "function" && !isObject(listener)) listener = null;
			const listeners = getListeners(this);
			let prev = null;
			let node = listeners.get(eventName);
			while (node != null) {
				if (node.listenerType === ATTRIBUTE) if (prev !== null) prev.next = node.next;
				else if (node.next !== null) listeners.set(eventName, node.next);
				else listeners.delete(eventName);
				else prev = node;
				node = node.next;
			}
			if (listener !== null) {
				const newNode = {
					listener,
					listenerType: ATTRIBUTE,
					passive: false,
					once: false,
					next: null
				};
				if (prev === null) listeners.set(eventName, newNode);
				else prev.next = newNode;
			}
		},
		configurable: true,
		enumerable: true
	};
}
function defineEventAttribute(eventTargetPrototype, eventName) {
	Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
}
function defineCustomEventTarget(eventNames) {
	function CustomEventTarget() {
		EventTarget.call(this);
	}
	CustomEventTarget.prototype = Object.create(EventTarget.prototype, { constructor: {
		value: CustomEventTarget,
		configurable: true,
		writable: true
	} });
	for (let i = 0; i < eventNames.length; ++i) defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
	return CustomEventTarget;
}
function EventTarget() {
	if (this instanceof EventTarget) {
		listenersMap.set(this, /* @__PURE__ */ new Map());
		return;
	}
	if (arguments.length === 1 && Array.isArray(arguments[0])) return defineCustomEventTarget(arguments[0]);
	if (arguments.length > 0) {
		const types$1 = new Array(arguments.length);
		for (let i = 0; i < arguments.length; ++i) types$1[i] = arguments[i];
		return defineCustomEventTarget(types$1);
	}
	throw new TypeError("Cannot call a class as a function");
}
var privateData, wrappers, listenersMap, CAPTURE, BUBBLE, ATTRIBUTE;
var init_event_target_shim = __esmMin((() => {
	privateData = /* @__PURE__ */ new WeakMap();
	wrappers = /* @__PURE__ */ new WeakMap();
	Event.prototype = {
		get type() {
			return pd(this).event.type;
		},
		get target() {
			return pd(this).eventTarget;
		},
		get currentTarget() {
			return pd(this).currentTarget;
		},
		composedPath() {
			const currentTarget = pd(this).currentTarget;
			if (currentTarget == null) return [];
			return [currentTarget];
		},
		get NONE() {
			return 0;
		},
		get CAPTURING_PHASE() {
			return 1;
		},
		get AT_TARGET() {
			return 2;
		},
		get BUBBLING_PHASE() {
			return 3;
		},
		get eventPhase() {
			return pd(this).eventPhase;
		},
		stopPropagation() {
			const data = pd(this);
			data.stopped = true;
			if (typeof data.event.stopPropagation === "function") data.event.stopPropagation();
		},
		stopImmediatePropagation() {
			const data = pd(this);
			data.stopped = true;
			data.immediateStopped = true;
			if (typeof data.event.stopImmediatePropagation === "function") data.event.stopImmediatePropagation();
		},
		get bubbles() {
			return Boolean(pd(this).event.bubbles);
		},
		get cancelable() {
			return Boolean(pd(this).event.cancelable);
		},
		preventDefault() {
			setCancelFlag(pd(this));
		},
		get defaultPrevented() {
			return pd(this).canceled;
		},
		get composed() {
			return Boolean(pd(this).event.composed);
		},
		get timeStamp() {
			return pd(this).timeStamp;
		},
		get srcElement() {
			return pd(this).eventTarget;
		},
		get cancelBubble() {
			return pd(this).stopped;
		},
		set cancelBubble(value$1) {
			if (!value$1) return;
			const data = pd(this);
			data.stopped = true;
			if (typeof data.event.cancelBubble === "boolean") data.event.cancelBubble = true;
		},
		get returnValue() {
			return !pd(this).canceled;
		},
		set returnValue(value$1) {
			if (!value$1) setCancelFlag(pd(this));
		},
		initEvent() {}
	};
	Object.defineProperty(Event.prototype, "constructor", {
		value: Event,
		configurable: true,
		writable: true
	});
	if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
		Object.setPrototypeOf(Event.prototype, window.Event.prototype);
		wrappers.set(window.Event.prototype, Event);
	}
	listenersMap = /* @__PURE__ */ new WeakMap();
	CAPTURE = 1;
	BUBBLE = 2;
	ATTRIBUTE = 3;
	EventTarget.prototype = {
		addEventListener(eventName, listener, options) {
			if (listener == null) return;
			if (typeof listener !== "function" && !isObject(listener)) throw new TypeError("'listener' should be a function or an object.");
			const listeners = getListeners(this);
			const optionsIsObj = isObject(options);
			const listenerType = (optionsIsObj ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE;
			const newNode = {
				listener,
				listenerType,
				passive: optionsIsObj && Boolean(options.passive),
				once: optionsIsObj && Boolean(options.once),
				next: null
			};
			let node = listeners.get(eventName);
			if (node === void 0) {
				listeners.set(eventName, newNode);
				return;
			}
			let prev = null;
			while (node != null) {
				if (node.listener === listener && node.listenerType === listenerType) return;
				prev = node;
				node = node.next;
			}
			prev.next = newNode;
		},
		removeEventListener(eventName, listener, options) {
			if (listener == null) return;
			const listeners = getListeners(this);
			const listenerType = (isObject(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE;
			let prev = null;
			let node = listeners.get(eventName);
			while (node != null) {
				if (node.listener === listener && node.listenerType === listenerType) {
					if (prev !== null) prev.next = node.next;
					else if (node.next !== null) listeners.set(eventName, node.next);
					else listeners.delete(eventName);
					return;
				}
				prev = node;
				node = node.next;
			}
		},
		dispatchEvent(event) {
			if (event == null || typeof event.type !== "string") throw new TypeError("\"event.type\" should be a string.");
			const listeners = getListeners(this);
			const eventName = event.type;
			let node = listeners.get(eventName);
			if (node == null) return true;
			const wrappedEvent = wrapEvent(this, event);
			let prev = null;
			while (node != null) {
				if (node.once) if (prev !== null) prev.next = node.next;
				else if (node.next !== null) listeners.set(eventName, node.next);
				else listeners.delete(eventName);
				else prev = node;
				setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
				if (typeof node.listener === "function") try {
					node.listener.call(this, wrappedEvent);
				} catch (err) {
					if (typeof console !== "undefined" && typeof console.error === "function") console.error(err);
				}
				else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") node.listener.handleEvent(wrappedEvent);
				if (isStopped(wrappedEvent)) break;
				node = node.next;
			}
			setPassiveListener(wrappedEvent, null);
			setEventPhase(wrappedEvent, 0);
			setCurrentTarget(wrappedEvent, null);
			return !wrappedEvent.defaultPrevented;
		}
	};
	Object.defineProperty(EventTarget.prototype, "constructor", {
		value: EventTarget,
		configurable: true,
		writable: true
	});
	if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}));
var abort_controller_exports = /* @__PURE__ */ __export({
	AbortController: () => AbortController$1,
	AbortSignal: () => AbortSignal$1,
	default: () => abort_controller_default
}, 1);
function createAbortSignal() {
	const signal = Object.create(AbortSignal$1.prototype);
	EventTarget.call(signal);
	abortedFlags.set(signal, false);
	return signal;
}
function abortSignal(signal) {
	if (abortedFlags.get(signal) !== false) return;
	abortedFlags.set(signal, true);
	signal.dispatchEvent({ type: "abort" });
}
function getSignal(controller) {
	const signal = signals.get(controller);
	if (signal == null) throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
	return signal;
}
var AbortSignal$1, abortedFlags, AbortController$1, signals, abort_controller_default;
var init_abort_controller = __esmMin((() => {
	init_event_target_shim();
	AbortSignal$1 = class extends EventTarget {
		constructor() {
			super();
			throw new TypeError("AbortSignal cannot be constructed directly");
		}
		get aborted() {
			const aborted = abortedFlags.get(this);
			if (typeof aborted !== "boolean") throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
			return aborted;
		}
	};
	defineEventAttribute(AbortSignal$1.prototype, "abort");
	abortedFlags = /* @__PURE__ */ new WeakMap();
	Object.defineProperties(AbortSignal$1.prototype, { aborted: { enumerable: true } });
	if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") Object.defineProperty(AbortSignal$1.prototype, Symbol.toStringTag, {
		configurable: true,
		value: "AbortSignal"
	});
	AbortController$1 = class {
		constructor() {
			signals.set(this, createAbortSignal());
		}
		get signal() {
			return getSignal(this);
		}
		abort() {
			abortSignal(getSignal(this));
		}
	};
	signals = /* @__PURE__ */ new WeakMap();
	Object.defineProperties(AbortController$1.prototype, {
		signal: { enumerable: true },
		abort: { enumerable: true }
	});
	if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {
		configurable: true,
		value: "AbortController"
	});
	abort_controller_default = AbortController$1;
}));
var require_util$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var bufferModule$1 = __require("buffer");
	var { format, inspect } = require_inspect();
	var { codes: { ERR_INVALID_ARG_TYPE } } = require_errors$1();
	var { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials();
	var AbortSignal = globalThis.AbortSignal || (init_abort_controller(), __toCommonJS(abort_controller_exports)).AbortSignal;
	var AbortController = globalThis.AbortController || (init_abort_controller(), __toCommonJS(abort_controller_exports)).AbortController;
	var AsyncFunction = Object.getPrototypeOf(async function() {}).constructor;
	var Blob = globalThis.Blob || bufferModule$1.Blob;
	var isBlob = typeof Blob !== "undefined" ? function isBlob(b) {
		return b instanceof Blob;
	} : function isBlob(b) {
		return false;
	};
	var validateAbortSignal = (signal, name$1) => {
		if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) throw new ERR_INVALID_ARG_TYPE(name$1, "AbortSignal", signal);
	};
	var validateFunction = (value$1, name$1) => {
		if (typeof value$1 !== "function") throw new ERR_INVALID_ARG_TYPE(name$1, "Function", value$1);
	};
	module.exports = {
		AggregateError,
		kEmptyObject: Object.freeze({}),
		once(callback) {
			let called = false;
			return function(...args) {
				if (called) return;
				called = true;
				callback.apply(this, args);
			};
		},
		createDeferredPromise: function() {
			let resolve$1;
			let reject$3;
			return {
				promise: new Promise((res, rej) => {
					resolve$1 = res;
					reject$3 = rej;
				}),
				resolve: resolve$1,
				reject: reject$3
			};
		},
		promisify(fn) {
			return new Promise((resolve$1, reject$3) => {
				fn((err, ...args) => {
					if (err) return reject$3(err);
					return resolve$1(...args);
				});
			});
		},
		debuglog() {
			return function() {};
		},
		format,
		inspect,
		types: {
			isAsyncFunction(fn) {
				return fn instanceof AsyncFunction;
			},
			isArrayBufferView(arr) {
				return ArrayBuffer.isView(arr);
			}
		},
		isBlob,
		deprecate(fn, message) {
			return fn;
		},
		addAbortListener: __require("events").addAbortListener || function addAbortListener(signal, listener) {
			if (signal === void 0) throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
			validateAbortSignal(signal, "signal");
			validateFunction(listener, "listener");
			let removeEventListener;
			if (signal.aborted) queueMicrotask(() => listener());
			else {
				signal.addEventListener("abort", listener, {
					__proto__: null,
					once: true,
					[kResistStopPropagation]: true
				});
				removeEventListener = () => {
					signal.removeEventListener("abort", listener);
				};
			}
			return {
				__proto__: null,
				[SymbolDispose]() {
					var _removeEventListener;
					(_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 || _removeEventListener();
				}
			};
		},
		AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals$1) {
			if (signals$1.length === 1) return signals$1[0];
			const ac = new AbortController();
			const abort = () => ac.abort();
			signals$1.forEach((signal) => {
				validateAbortSignal(signal, "signals");
				signal.addEventListener("abort", abort, { once: true });
			});
			ac.signal.addEventListener("abort", () => {
				signals$1.forEach((signal) => signal.removeEventListener("abort", abort));
			}, { once: true });
			return ac.signal;
		}
	};
	module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
}));
var require_validators = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { ArrayIsArray, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger, NumberIsNaN, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String, StringPrototypeToUpperCase, StringPrototypeTrim } = require_primordials();
	var { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL } } = require_errors$1();
	var { normalizeEncoding } = require_util$2();
	var { isAsyncFunction, isArrayBufferView } = require_util$2().types;
	var signals = {};
	function isInt32(value$1) {
		return value$1 === (value$1 | 0);
	}
	function isUint32(value$1) {
		return value$1 === value$1 >>> 0;
	}
	var octalReg = /^[0-7]+$/;
	var modeDesc = "must be a 32-bit unsigned integer or an octal string";
	function parseFileMode(value$1, name$1, def) {
		if (typeof value$1 === "undefined") value$1 = def;
		if (typeof value$1 === "string") {
			if (RegExpPrototypeExec(octalReg, value$1) === null) throw new ERR_INVALID_ARG_VALUE(name$1, value$1, modeDesc);
			value$1 = NumberParseInt(value$1, 8);
		}
		validateUint32(value$1, name$1);
		return value$1;
	}
	var validateInteger = hideStackFrames((value$1, name$1, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
		if (typeof value$1 !== "number") throw new ERR_INVALID_ARG_TYPE(name$1, "number", value$1);
		if (!NumberIsInteger(value$1)) throw new ERR_OUT_OF_RANGE(name$1, "an integer", value$1);
		if (value$1 < min || value$1 > max) throw new ERR_OUT_OF_RANGE(name$1, `>= ${min} && <= ${max}`, value$1);
	});
	var validateInt32 = hideStackFrames((value$1, name$1, min = -2147483648, max = 2147483647) => {
		if (typeof value$1 !== "number") throw new ERR_INVALID_ARG_TYPE(name$1, "number", value$1);
		if (!NumberIsInteger(value$1)) throw new ERR_OUT_OF_RANGE(name$1, "an integer", value$1);
		if (value$1 < min || value$1 > max) throw new ERR_OUT_OF_RANGE(name$1, `>= ${min} && <= ${max}`, value$1);
	});
	var validateUint32 = hideStackFrames((value$1, name$1, positive = false) => {
		if (typeof value$1 !== "number") throw new ERR_INVALID_ARG_TYPE(name$1, "number", value$1);
		if (!NumberIsInteger(value$1)) throw new ERR_OUT_OF_RANGE(name$1, "an integer", value$1);
		const min = positive ? 1 : 0;
		const max = 4294967295;
		if (value$1 < min || value$1 > max) throw new ERR_OUT_OF_RANGE(name$1, `>= ${min} && <= ${max}`, value$1);
	});
	function validateString(value$1, name$1) {
		if (typeof value$1 !== "string") throw new ERR_INVALID_ARG_TYPE(name$1, "string", value$1);
	}
	function validateNumber(value$1, name$1, min = void 0, max) {
		if (typeof value$1 !== "number") throw new ERR_INVALID_ARG_TYPE(name$1, "number", value$1);
		if (min != null && value$1 < min || max != null && value$1 > max || (min != null || max != null) && NumberIsNaN(value$1)) throw new ERR_OUT_OF_RANGE(name$1, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value$1);
	}
	var validateOneOf = hideStackFrames((value$1, name$1, oneOf) => {
		if (!ArrayPrototypeIncludes(oneOf, value$1)) throw new ERR_INVALID_ARG_VALUE(name$1, value$1, "must be one of: " + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String(v)), ", "));
	});
	function validateBoolean(value$1, name$1) {
		if (typeof value$1 !== "boolean") throw new ERR_INVALID_ARG_TYPE(name$1, "boolean", value$1);
	}
	function getOwnPropertyValueOrDefault(options, key, defaultValue) {
		return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
	}
	var validateObject = hideStackFrames((value$1, name$1, options = null) => {
		const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
		const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
		if (!getOwnPropertyValueOrDefault(options, "nullable", false) && value$1 === null || !allowArray && ArrayIsArray(value$1) || typeof value$1 !== "object" && (!allowFunction || typeof value$1 !== "function")) throw new ERR_INVALID_ARG_TYPE(name$1, "Object", value$1);
	});
	var validateDictionary = hideStackFrames((value$1, name$1) => {
		if (value$1 != null && typeof value$1 !== "object" && typeof value$1 !== "function") throw new ERR_INVALID_ARG_TYPE(name$1, "a dictionary", value$1);
	});
	var validateArray = hideStackFrames((value$1, name$1, minLength = 0) => {
		if (!ArrayIsArray(value$1)) throw new ERR_INVALID_ARG_TYPE(name$1, "Array", value$1);
		if (value$1.length < minLength) throw new ERR_INVALID_ARG_VALUE(name$1, value$1, `must be longer than ${minLength}`);
	});
	function validateStringArray(value$1, name$1) {
		validateArray(value$1, name$1);
		for (let i = 0; i < value$1.length; i++) validateString(value$1[i], `${name$1}[${i}]`);
	}
	function validateBooleanArray(value$1, name$1) {
		validateArray(value$1, name$1);
		for (let i = 0; i < value$1.length; i++) validateBoolean(value$1[i], `${name$1}[${i}]`);
	}
	function validateAbortSignalArray(value$1, name$1) {
		validateArray(value$1, name$1);
		for (let i = 0; i < value$1.length; i++) {
			const signal = value$1[i];
			const indexedName = `${name$1}[${i}]`;
			if (signal == null) throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
			validateAbortSignal(signal, indexedName);
		}
	}
	function validateSignalName(signal, name$1 = "signal") {
		validateString(signal, name$1);
		if (signals[signal] === void 0) {
			if (signals[StringPrototypeToUpperCase(signal)] !== void 0) throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
			throw new ERR_UNKNOWN_SIGNAL(signal);
		}
	}
	var validateBuffer = hideStackFrames((buffer$2, name$1 = "buffer") => {
		if (!isArrayBufferView(buffer$2)) throw new ERR_INVALID_ARG_TYPE(name$1, [
			"Buffer",
			"TypedArray",
			"DataView"
		], buffer$2);
	});
	function validateEncoding(data, encoding) {
		const normalizedEncoding = normalizeEncoding(encoding);
		const length = data.length;
		if (normalizedEncoding === "hex" && length % 2 !== 0) throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
	}
	function validatePort(port, name$1 = "Port", allowZero = true) {
		if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) throw new ERR_SOCKET_BAD_PORT(name$1, port, allowZero);
		return port | 0;
	}
	var validateAbortSignal = hideStackFrames((signal, name$1) => {
		if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) throw new ERR_INVALID_ARG_TYPE(name$1, "AbortSignal", signal);
	});
	var validateFunction = hideStackFrames((value$1, name$1) => {
		if (typeof value$1 !== "function") throw new ERR_INVALID_ARG_TYPE(name$1, "Function", value$1);
	});
	var validatePlainFunction = hideStackFrames((value$1, name$1) => {
		if (typeof value$1 !== "function" || isAsyncFunction(value$1)) throw new ERR_INVALID_ARG_TYPE(name$1, "Function", value$1);
	});
	var validateUndefined = hideStackFrames((value$1, name$1) => {
		if (value$1 !== void 0) throw new ERR_INVALID_ARG_TYPE(name$1, "undefined", value$1);
	});
	function validateUnion(value$1, name$1, union) {
		if (!ArrayPrototypeIncludes(union, value$1)) throw new ERR_INVALID_ARG_TYPE(name$1, `('${ArrayPrototypeJoin(union, "|")}')`, value$1);
	}
	var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
	function validateLinkHeaderFormat(value$1, name$1) {
		if (typeof value$1 === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value$1)) throw new ERR_INVALID_ARG_VALUE(name$1, value$1, "must be an array or string of format \"</styles.css>; rel=preload; as=style\"");
	}
	function validateLinkHeaderValue(hints) {
		if (typeof hints === "string") {
			validateLinkHeaderFormat(hints, "hints");
			return hints;
		} else if (ArrayIsArray(hints)) {
			const hintsLength = hints.length;
			let result = "";
			if (hintsLength === 0) return result;
			for (let i = 0; i < hintsLength; i++) {
				const link = hints[i];
				validateLinkHeaderFormat(link, "hints");
				result += link;
				if (i !== hintsLength - 1) result += ", ";
			}
			return result;
		}
		throw new ERR_INVALID_ARG_VALUE("hints", hints, "must be an array or string of format \"</styles.css>; rel=preload; as=style\"");
	}
	module.exports = {
		isInt32,
		isUint32,
		parseFileMode,
		validateArray,
		validateStringArray,
		validateBooleanArray,
		validateAbortSignalArray,
		validateBoolean,
		validateBuffer,
		validateDictionary,
		validateEncoding,
		validateFunction,
		validateInt32,
		validateInteger,
		validateNumber,
		validateObject,
		validateOneOf,
		validatePlainFunction,
		validatePort,
		validateSignalName,
		validateString,
		validateUint32,
		validateUndefined,
		validateUnion,
		validateAbortSignal,
		validateLinkHeaderValue
	};
}));
var require_process = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = global.process;
}));
var require_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
	var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
	var kIsErrored = SymbolFor("nodejs.stream.errored");
	var kIsReadable = SymbolFor("nodejs.stream.readable");
	var kIsWritable = SymbolFor("nodejs.stream.writable");
	var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
	var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
	var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
	function isReadableNodeStream(obj, strict = false) {
		var _obj$_readableState;
		return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
	}
	function isWritableNodeStream(obj) {
		var _obj$_writableState;
		return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
	}
	function isDuplexNodeStream(obj) {
		return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
	}
	function isNodeStream(obj) {
		return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
	}
	function isReadableStream(obj) {
		return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
	}
	function isWritableStream(obj) {
		return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
	}
	function isTransformStream(obj) {
		return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
	}
	function isWebStream(obj) {
		return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
	}
	function isIterable(obj, isAsync$1) {
		if (obj == null) return false;
		if (isAsync$1 === true) return typeof obj[SymbolAsyncIterator] === "function";
		if (isAsync$1 === false) return typeof obj[SymbolIterator] === "function";
		return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
	}
	function isDestroyed(stream$5) {
		if (!isNodeStream(stream$5)) return null;
		const wState = stream$5._writableState;
		const rState = stream$5._readableState;
		const state = wState || rState;
		return !!(stream$5.destroyed || stream$5[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
	}
	function isWritableEnded(stream$5) {
		if (!isWritableNodeStream(stream$5)) return null;
		if (stream$5.writableEnded === true) return true;
		const wState = stream$5._writableState;
		if (wState !== null && wState !== void 0 && wState.errored) return false;
		if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
		return wState.ended;
	}
	function isWritableFinished(stream$5, strict) {
		if (!isWritableNodeStream(stream$5)) return null;
		if (stream$5.writableFinished === true) return true;
		const wState = stream$5._writableState;
		if (wState !== null && wState !== void 0 && wState.errored) return false;
		if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
		return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
	}
	function isReadableEnded(stream$5) {
		if (!isReadableNodeStream(stream$5)) return null;
		if (stream$5.readableEnded === true) return true;
		const rState = stream$5._readableState;
		if (!rState || rState.errored) return false;
		if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
		return rState.ended;
	}
	function isReadableFinished(stream$5, strict) {
		if (!isReadableNodeStream(stream$5)) return null;
		const rState = stream$5._readableState;
		if (rState !== null && rState !== void 0 && rState.errored) return false;
		if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
		return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
	}
	function isReadable(stream$5) {
		if (stream$5 && stream$5[kIsReadable] != null) return stream$5[kIsReadable];
		if (typeof (stream$5 === null || stream$5 === void 0 ? void 0 : stream$5.readable) !== "boolean") return null;
		if (isDestroyed(stream$5)) return false;
		return isReadableNodeStream(stream$5) && stream$5.readable && !isReadableFinished(stream$5);
	}
	function isWritable(stream$5) {
		if (stream$5 && stream$5[kIsWritable] != null) return stream$5[kIsWritable];
		if (typeof (stream$5 === null || stream$5 === void 0 ? void 0 : stream$5.writable) !== "boolean") return null;
		if (isDestroyed(stream$5)) return false;
		return isWritableNodeStream(stream$5) && stream$5.writable && !isWritableEnded(stream$5);
	}
	function isFinished(stream$5, opts) {
		if (!isNodeStream(stream$5)) return null;
		if (isDestroyed(stream$5)) return true;
		if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream$5)) return false;
		if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream$5)) return false;
		return true;
	}
	function isWritableErrored(stream$5) {
		var _stream$_writableStat, _stream$_writableStat2;
		if (!isNodeStream(stream$5)) return null;
		if (stream$5.writableErrored) return stream$5.writableErrored;
		return (_stream$_writableStat = (_stream$_writableStat2 = stream$5._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
	}
	function isReadableErrored(stream$5) {
		var _stream$_readableStat, _stream$_readableStat2;
		if (!isNodeStream(stream$5)) return null;
		if (stream$5.readableErrored) return stream$5.readableErrored;
		return (_stream$_readableStat = (_stream$_readableStat2 = stream$5._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
	}
	function isClosed(stream$5) {
		if (!isNodeStream(stream$5)) return null;
		if (typeof stream$5.closed === "boolean") return stream$5.closed;
		const wState = stream$5._writableState;
		const rState = stream$5._readableState;
		if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
		if (typeof stream$5._closed === "boolean" && isOutgoingMessage(stream$5)) return stream$5._closed;
		return null;
	}
	function isOutgoingMessage(stream$5) {
		return typeof stream$5._closed === "boolean" && typeof stream$5._defaultKeepAlive === "boolean" && typeof stream$5._removedConnection === "boolean" && typeof stream$5._removedContLen === "boolean";
	}
	function isServerResponse(stream$5) {
		return typeof stream$5._sent100 === "boolean" && isOutgoingMessage(stream$5);
	}
	function isServerRequest(stream$5) {
		var _stream$req;
		return typeof stream$5._consuming === "boolean" && typeof stream$5._dumped === "boolean" && ((_stream$req = stream$5.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
	}
	function willEmitClose(stream$5) {
		if (!isNodeStream(stream$5)) return null;
		const wState = stream$5._writableState;
		const rState = stream$5._readableState;
		const state = wState || rState;
		return !state && isServerResponse(stream$5) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
	}
	function isDisturbed(stream$5) {
		var _stream$kIsDisturbed;
		return !!(stream$5 && ((_stream$kIsDisturbed = stream$5[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream$5.readableDidRead || stream$5.readableAborted));
	}
	function isErrored(stream$5) {
		var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
		return !!(stream$5 && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream$5[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream$5.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream$5.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream$5._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream$5._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream$5._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream$5._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
	}
	module.exports = {
		isDestroyed,
		kIsDestroyed,
		isDisturbed,
		kIsDisturbed,
		isErrored,
		kIsErrored,
		isReadable,
		kIsReadable,
		kIsClosedPromise,
		kControllerErrorFunction,
		kIsWritable,
		isClosed,
		isDuplexNodeStream,
		isFinished,
		isIterable,
		isReadableNodeStream,
		isReadableStream,
		isReadableEnded,
		isReadableFinished,
		isReadableErrored,
		isNodeStream,
		isWebStream,
		isWritable,
		isWritableNodeStream,
		isWritableStream,
		isWritableEnded,
		isWritableFinished,
		isWritableErrored,
		isServerRequest,
		isServerResponse,
		willEmitClose,
		isTransformStream
	};
}));
var require_end_of_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var process = require_process();
	var { AbortError, codes } = require_errors$1();
	var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
	var { kEmptyObject, once } = require_util$2();
	var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
	var { Promise, PromisePrototypeThen, SymbolDispose } = require_primordials();
	var { isClosed, isReadable, isReadableNodeStream, isReadableStream, isReadableFinished, isReadableErrored, isWritable, isWritableNodeStream, isWritableStream, isWritableFinished, isWritableErrored, isNodeStream, willEmitClose: _willEmitClose, kIsClosedPromise } = require_utils();
	var addAbortListener;
	function isRequest(stream$5) {
		return stream$5.setHeader && typeof stream$5.abort === "function";
	}
	var nop = () => {};
	function eos(stream$5, options, callback) {
		var _options$readable, _options$writable;
		if (arguments.length === 2) {
			callback = options;
			options = kEmptyObject;
		} else if (options == null) options = kEmptyObject;
		else validateObject(options, "options");
		validateFunction(callback, "callback");
		validateAbortSignal(options.signal, "options.signal");
		callback = once(callback);
		if (isReadableStream(stream$5) || isWritableStream(stream$5)) return eosWeb(stream$5, options, callback);
		if (!isNodeStream(stream$5)) throw new ERR_INVALID_ARG_TYPE("stream", [
			"ReadableStream",
			"WritableStream",
			"Stream"
		], stream$5);
		const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream$5);
		const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream$5);
		const wState = stream$5._writableState;
		const rState = stream$5._readableState;
		const onlegacyfinish = () => {
			if (!stream$5.writable) onfinish();
		};
		let willEmitClose = _willEmitClose(stream$5) && isReadableNodeStream(stream$5) === readable && isWritableNodeStream(stream$5) === writable;
		let writableFinished = isWritableFinished(stream$5, false);
		const onfinish = () => {
			writableFinished = true;
			if (stream$5.destroyed) willEmitClose = false;
			if (willEmitClose && (!stream$5.readable || readable)) return;
			if (!readable || readableFinished) callback.call(stream$5);
		};
		let readableFinished = isReadableFinished(stream$5, false);
		const onend = () => {
			readableFinished = true;
			if (stream$5.destroyed) willEmitClose = false;
			if (willEmitClose && (!stream$5.writable || writable)) return;
			if (!writable || writableFinished) callback.call(stream$5);
		};
		const onerror = (err) => {
			callback.call(stream$5, err);
		};
		let closed = isClosed(stream$5);
		const onclose = () => {
			closed = true;
			const errored = isWritableErrored(stream$5) || isReadableErrored(stream$5);
			if (errored && typeof errored !== "boolean") return callback.call(stream$5, errored);
			if (readable && !readableFinished && isReadableNodeStream(stream$5, true)) {
				if (!isReadableFinished(stream$5, false)) return callback.call(stream$5, new ERR_STREAM_PREMATURE_CLOSE());
			}
			if (writable && !writableFinished) {
				if (!isWritableFinished(stream$5, false)) return callback.call(stream$5, new ERR_STREAM_PREMATURE_CLOSE());
			}
			callback.call(stream$5);
		};
		const onclosed = () => {
			closed = true;
			const errored = isWritableErrored(stream$5) || isReadableErrored(stream$5);
			if (errored && typeof errored !== "boolean") return callback.call(stream$5, errored);
			callback.call(stream$5);
		};
		const onrequest = () => {
			stream$5.req.on("finish", onfinish);
		};
		if (isRequest(stream$5)) {
			stream$5.on("complete", onfinish);
			if (!willEmitClose) stream$5.on("abort", onclose);
			if (stream$5.req) onrequest();
			else stream$5.on("request", onrequest);
		} else if (writable && !wState) {
			stream$5.on("end", onlegacyfinish);
			stream$5.on("close", onlegacyfinish);
		}
		if (!willEmitClose && typeof stream$5.aborted === "boolean") stream$5.on("aborted", onclose);
		stream$5.on("end", onend);
		stream$5.on("finish", onfinish);
		if (options.error !== false) stream$5.on("error", onerror);
		stream$5.on("close", onclose);
		if (closed) process.nextTick(onclose);
		else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
			if (!willEmitClose) process.nextTick(onclosed);
		} else if (!readable && (!willEmitClose || isReadable(stream$5)) && (writableFinished || isWritable(stream$5) === false)) process.nextTick(onclosed);
		else if (!writable && (!willEmitClose || isWritable(stream$5)) && (readableFinished || isReadable(stream$5) === false)) process.nextTick(onclosed);
		else if (rState && stream$5.req && stream$5.aborted) process.nextTick(onclosed);
		const cleanup = () => {
			callback = nop;
			stream$5.removeListener("aborted", onclose);
			stream$5.removeListener("complete", onfinish);
			stream$5.removeListener("abort", onclose);
			stream$5.removeListener("request", onrequest);
			if (stream$5.req) stream$5.req.removeListener("finish", onfinish);
			stream$5.removeListener("end", onlegacyfinish);
			stream$5.removeListener("close", onlegacyfinish);
			stream$5.removeListener("finish", onfinish);
			stream$5.removeListener("end", onend);
			stream$5.removeListener("error", onerror);
			stream$5.removeListener("close", onclose);
		};
		if (options.signal && !closed) {
			const abort = () => {
				const endCallback = callback;
				cleanup();
				endCallback.call(stream$5, new AbortError(void 0, { cause: options.signal.reason }));
			};
			if (options.signal.aborted) process.nextTick(abort);
			else {
				addAbortListener = addAbortListener || require_util$2().addAbortListener;
				const disposable = addAbortListener(options.signal, abort);
				const originalCallback = callback;
				callback = once((...args) => {
					disposable[SymbolDispose]();
					originalCallback.apply(stream$5, args);
				});
			}
		}
		return cleanup;
	}
	function eosWeb(stream$5, options, callback) {
		let isAborted = false;
		let abort = nop;
		if (options.signal) {
			abort = () => {
				isAborted = true;
				callback.call(stream$5, new AbortError(void 0, { cause: options.signal.reason }));
			};
			if (options.signal.aborted) process.nextTick(abort);
			else {
				addAbortListener = addAbortListener || require_util$2().addAbortListener;
				const disposable = addAbortListener(options.signal, abort);
				const originalCallback = callback;
				callback = once((...args) => {
					disposable[SymbolDispose]();
					originalCallback.apply(stream$5, args);
				});
			}
		}
		const resolverFn = (...args) => {
			if (!isAborted) process.nextTick(() => callback.apply(stream$5, args));
		};
		PromisePrototypeThen(stream$5[kIsClosedPromise].promise, resolverFn, resolverFn);
		return nop;
	}
	function finished(stream$5, opts) {
		var _opts;
		let autoCleanup = false;
		if (opts === null) opts = kEmptyObject;
		if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
			validateBoolean(opts.cleanup, "cleanup");
			autoCleanup = opts.cleanup;
		}
		return new Promise((resolve$1, reject$3) => {
			const cleanup = eos(stream$5, opts, (err) => {
				if (autoCleanup) cleanup();
				if (err) reject$3(err);
				else resolve$1();
			});
		});
	}
	module.exports = eos;
	module.exports.finished = finished;
}));
var require_destroy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var process = require_process();
	var { aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK }, AbortError } = require_errors$1();
	var { Symbol } = require_primordials();
	var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
	var kDestroy = Symbol("kDestroy");
	var kConstruct = Symbol("kConstruct");
	function checkError(err, w, r$1) {
		if (err) {
			err.stack;
			if (w && !w.errored) w.errored = err;
			if (r$1 && !r$1.errored) r$1.errored = err;
		}
	}
	function destroy(err, cb) {
		const r$1 = this._readableState;
		const w = this._writableState;
		const s = w || r$1;
		if (w !== null && w !== void 0 && w.destroyed || r$1 !== null && r$1 !== void 0 && r$1.destroyed) {
			if (typeof cb === "function") cb();
			return this;
		}
		checkError(err, w, r$1);
		if (w) w.destroyed = true;
		if (r$1) r$1.destroyed = true;
		if (!s.constructed) this.once(kDestroy, function(er) {
			_destroy(this, aggregateTwoErrors(er, err), cb);
		});
		else _destroy(this, err, cb);
		return this;
	}
	function _destroy(self$1, err, cb) {
		let called = false;
		function onDestroy(err$1) {
			if (called) return;
			called = true;
			const r$1 = self$1._readableState;
			const w = self$1._writableState;
			checkError(err$1, w, r$1);
			if (w) w.closed = true;
			if (r$1) r$1.closed = true;
			if (typeof cb === "function") cb(err$1);
			if (err$1) process.nextTick(emitErrorCloseNT, self$1, err$1);
			else process.nextTick(emitCloseNT, self$1);
		}
		try {
			self$1._destroy(err || null, onDestroy);
		} catch (err$1) {
			onDestroy(err$1);
		}
	}
	function emitErrorCloseNT(self$1, err) {
		emitErrorNT(self$1, err);
		emitCloseNT(self$1);
	}
	function emitCloseNT(self$1) {
		const r$1 = self$1._readableState;
		const w = self$1._writableState;
		if (w) w.closeEmitted = true;
		if (r$1) r$1.closeEmitted = true;
		if (w !== null && w !== void 0 && w.emitClose || r$1 !== null && r$1 !== void 0 && r$1.emitClose) self$1.emit("close");
	}
	function emitErrorNT(self$1, err) {
		const r$1 = self$1._readableState;
		const w = self$1._writableState;
		if (w !== null && w !== void 0 && w.errorEmitted || r$1 !== null && r$1 !== void 0 && r$1.errorEmitted) return;
		if (w) w.errorEmitted = true;
		if (r$1) r$1.errorEmitted = true;
		self$1.emit("error", err);
	}
	function undestroy() {
		const r$1 = this._readableState;
		const w = this._writableState;
		if (r$1) {
			r$1.constructed = true;
			r$1.closed = false;
			r$1.closeEmitted = false;
			r$1.destroyed = false;
			r$1.errored = null;
			r$1.errorEmitted = false;
			r$1.reading = false;
			r$1.ended = r$1.readable === false;
			r$1.endEmitted = r$1.readable === false;
		}
		if (w) {
			w.constructed = true;
			w.destroyed = false;
			w.closed = false;
			w.closeEmitted = false;
			w.errored = null;
			w.errorEmitted = false;
			w.finalCalled = false;
			w.prefinished = false;
			w.ended = w.writable === false;
			w.ending = w.writable === false;
			w.finished = w.writable === false;
		}
	}
	function errorOrDestroy(stream$5, err, sync$3) {
		const r$1 = stream$5._readableState;
		const w = stream$5._writableState;
		if (w !== null && w !== void 0 && w.destroyed || r$1 !== null && r$1 !== void 0 && r$1.destroyed) return this;
		if (r$1 !== null && r$1 !== void 0 && r$1.autoDestroy || w !== null && w !== void 0 && w.autoDestroy) stream$5.destroy(err);
		else if (err) {
			err.stack;
			if (w && !w.errored) w.errored = err;
			if (r$1 && !r$1.errored) r$1.errored = err;
			if (sync$3) process.nextTick(emitErrorNT, stream$5, err);
			else emitErrorNT(stream$5, err);
		}
	}
	function construct(stream$5, cb) {
		if (typeof stream$5._construct !== "function") return;
		const r$1 = stream$5._readableState;
		const w = stream$5._writableState;
		if (r$1) r$1.constructed = false;
		if (w) w.constructed = false;
		stream$5.once(kConstruct, cb);
		if (stream$5.listenerCount(kConstruct) > 1) return;
		process.nextTick(constructNT, stream$5);
	}
	function constructNT(stream$5) {
		let called = false;
		function onConstruct(err) {
			if (called) {
				errorOrDestroy(stream$5, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
				return;
			}
			called = true;
			const r$1 = stream$5._readableState;
			const w = stream$5._writableState;
			const s = w || r$1;
			if (r$1) r$1.constructed = true;
			if (w) w.constructed = true;
			if (s.destroyed) stream$5.emit(kDestroy, err);
			else if (err) errorOrDestroy(stream$5, err, true);
			else process.nextTick(emitConstructNT, stream$5);
		}
		try {
			stream$5._construct((err) => {
				process.nextTick(onConstruct, err);
			});
		} catch (err) {
			process.nextTick(onConstruct, err);
		}
	}
	function emitConstructNT(stream$5) {
		stream$5.emit(kConstruct);
	}
	function isRequest(stream$5) {
		return (stream$5 === null || stream$5 === void 0 ? void 0 : stream$5.setHeader) && typeof stream$5.abort === "function";
	}
	function emitCloseLegacy(stream$5) {
		stream$5.emit("close");
	}
	function emitErrorCloseLegacy(stream$5, err) {
		stream$5.emit("error", err);
		process.nextTick(emitCloseLegacy, stream$5);
	}
	function destroyer(stream$5, err) {
		if (!stream$5 || isDestroyed(stream$5)) return;
		if (!err && !isFinished(stream$5)) err = new AbortError();
		if (isServerRequest(stream$5)) {
			stream$5.socket = null;
			stream$5.destroy(err);
		} else if (isRequest(stream$5)) stream$5.abort();
		else if (isRequest(stream$5.req)) stream$5.req.abort();
		else if (typeof stream$5.destroy === "function") stream$5.destroy(err);
		else if (typeof stream$5.close === "function") stream$5.close();
		else if (err) process.nextTick(emitErrorCloseLegacy, stream$5, err);
		else process.nextTick(emitCloseLegacy, stream$5);
		if (!stream$5.destroyed) stream$5[kIsDestroyed] = true;
	}
	module.exports = {
		construct,
		destroyer,
		destroy,
		undestroy,
		errorOrDestroy
	};
}));
var require_legacy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
	var { EventEmitter: EE$2 } = __require("events");
	function Stream(opts) {
		EE$2.call(this, opts);
	}
	ObjectSetPrototypeOf(Stream.prototype, EE$2.prototype);
	ObjectSetPrototypeOf(Stream, EE$2);
	Stream.prototype.pipe = function(dest, options) {
		const source = this;
		function ondata(chunk) {
			if (dest.writable && dest.write(chunk) === false && source.pause) source.pause();
		}
		source.on("data", ondata);
		function ondrain() {
			if (source.readable && source.resume) source.resume();
		}
		dest.on("drain", ondrain);
		if (!dest._isStdio && (!options || options.end !== false)) {
			source.on("end", onend);
			source.on("close", onclose);
		}
		let didOnEnd = false;
		function onend() {
			if (didOnEnd) return;
			didOnEnd = true;
			dest.end();
		}
		function onclose() {
			if (didOnEnd) return;
			didOnEnd = true;
			if (typeof dest.destroy === "function") dest.destroy();
		}
		function onerror(er) {
			cleanup();
			if (EE$2.listenerCount(this, "error") === 0) this.emit("error", er);
		}
		prependListener(source, "error", onerror);
		prependListener(dest, "error", onerror);
		function cleanup() {
			source.removeListener("data", ondata);
			dest.removeListener("drain", ondrain);
			source.removeListener("end", onend);
			source.removeListener("close", onclose);
			source.removeListener("error", onerror);
			dest.removeListener("error", onerror);
			source.removeListener("end", cleanup);
			source.removeListener("close", cleanup);
			dest.removeListener("close", cleanup);
		}
		source.on("end", cleanup);
		source.on("close", cleanup);
		dest.on("close", cleanup);
		dest.emit("pipe", source);
		return dest;
	};
	function prependListener(emitter, event, fn) {
		if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
		if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
		else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
		else emitter._events[event] = [fn, emitter._events[event]];
	}
	module.exports = {
		Stream,
		prependListener
	};
}));
var require_add_abort_signal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { SymbolDispose } = require_primordials();
	var { AbortError, codes } = require_errors$1();
	var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
	var eos = require_end_of_stream();
	var { ERR_INVALID_ARG_TYPE } = codes;
	var addAbortListener;
	var validateAbortSignal = (signal, name$1) => {
		if (typeof signal !== "object" || !("aborted" in signal)) throw new ERR_INVALID_ARG_TYPE(name$1, "AbortSignal", signal);
	};
	module.exports.addAbortSignal = function addAbortSignal(signal, stream$5) {
		validateAbortSignal(signal, "signal");
		if (!isNodeStream(stream$5) && !isWebStream(stream$5)) throw new ERR_INVALID_ARG_TYPE("stream", [
			"ReadableStream",
			"WritableStream",
			"Stream"
		], stream$5);
		return module.exports.addAbortSignalNoValidate(signal, stream$5);
	};
	module.exports.addAbortSignalNoValidate = function(signal, stream$5) {
		if (typeof signal !== "object" || !("aborted" in signal)) return stream$5;
		const onAbort = isNodeStream(stream$5) ? () => {
			stream$5.destroy(new AbortError(void 0, { cause: signal.reason }));
		} : () => {
			stream$5[kControllerErrorFunction](new AbortError(void 0, { cause: signal.reason }));
		};
		if (signal.aborted) onAbort();
		else {
			addAbortListener = addAbortListener || require_util$2().addAbortListener;
			eos(stream$5, addAbortListener(signal, onAbort)[SymbolDispose]);
		}
		return stream$5;
	};
}));
var require_buffer_list = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = require_primordials();
	var { Buffer: Buffer$5 } = __require("buffer");
	var { inspect } = require_util$2();
	module.exports = class BufferList {
		constructor() {
			this.head = null;
			this.tail = null;
			this.length = 0;
		}
		push(v) {
			const entry = {
				data: v,
				next: null
			};
			if (this.length > 0) this.tail.next = entry;
			else this.head = entry;
			this.tail = entry;
			++this.length;
		}
		unshift(v) {
			const entry = {
				data: v,
				next: this.head
			};
			if (this.length === 0) this.tail = entry;
			this.head = entry;
			++this.length;
		}
		shift() {
			if (this.length === 0) return;
			const ret = this.head.data;
			if (this.length === 1) this.head = this.tail = null;
			else this.head = this.head.next;
			--this.length;
			return ret;
		}
		clear() {
			this.head = this.tail = null;
			this.length = 0;
		}
		join(s) {
			if (this.length === 0) return "";
			let p = this.head;
			let ret = "" + p.data;
			while ((p = p.next) !== null) ret += s + p.data;
			return ret;
		}
		concat(n$1) {
			if (this.length === 0) return Buffer$5.alloc(0);
			const ret = Buffer$5.allocUnsafe(n$1 >>> 0);
			let p = this.head;
			let i = 0;
			while (p) {
				TypedArrayPrototypeSet(ret, p.data, i);
				i += p.data.length;
				p = p.next;
			}
			return ret;
		}
		consume(n$1, hasStrings) {
			const data = this.head.data;
			if (n$1 < data.length) {
				const slice = data.slice(0, n$1);
				this.head.data = data.slice(n$1);
				return slice;
			}
			if (n$1 === data.length) return this.shift();
			return hasStrings ? this._getString(n$1) : this._getBuffer(n$1);
		}
		first() {
			return this.head.data;
		}
		*[SymbolIterator]() {
			for (let p = this.head; p; p = p.next) yield p.data;
		}
		_getString(n$1) {
			let ret = "";
			let p = this.head;
			let c = 0;
			do {
				const str = p.data;
				if (n$1 > str.length) {
					ret += str;
					n$1 -= str.length;
				} else {
					if (n$1 === str.length) {
						ret += str;
						++c;
						if (p.next) this.head = p.next;
						else this.head = this.tail = null;
					} else {
						ret += StringPrototypeSlice(str, 0, n$1);
						this.head = p;
						p.data = StringPrototypeSlice(str, n$1);
					}
					break;
				}
				++c;
			} while ((p = p.next) !== null);
			this.length -= c;
			return ret;
		}
		_getBuffer(n$1) {
			const ret = Buffer$5.allocUnsafe(n$1);
			const retLen = n$1;
			let p = this.head;
			let c = 0;
			do {
				const buf = p.data;
				if (n$1 > buf.length) {
					TypedArrayPrototypeSet(ret, buf, retLen - n$1);
					n$1 -= buf.length;
				} else {
					if (n$1 === buf.length) {
						TypedArrayPrototypeSet(ret, buf, retLen - n$1);
						++c;
						if (p.next) this.head = p.next;
						else this.head = this.tail = null;
					} else {
						TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n$1), retLen - n$1);
						this.head = p;
						p.data = buf.slice(n$1);
					}
					break;
				}
				++c;
			} while ((p = p.next) !== null);
			this.length -= c;
			return ret;
		}
		[Symbol.for("nodejs.util.inspect.custom")](_$1, options) {
			return inspect(this, {
				...options,
				depth: 0,
				customInspect: false
			});
		}
	};
}));
var require_state = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { MathFloor, NumberIsInteger } = require_primordials();
	var { validateInteger } = require_validators();
	var { ERR_INVALID_ARG_VALUE } = require_errors$1().codes;
	var defaultHighWaterMarkBytes = 16 * 1024;
	var defaultHighWaterMarkObjectMode = 16;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
		return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getDefaultHighWaterMark(objectMode) {
		return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
	}
	function setDefaultHighWaterMark(objectMode, value$1) {
		validateInteger(value$1, "value", 0);
		if (objectMode) defaultHighWaterMarkObjectMode = value$1;
		else defaultHighWaterMarkBytes = value$1;
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
		const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
		if (hwm != null) {
			if (!NumberIsInteger(hwm) || hwm < 0) throw new ERR_INVALID_ARG_VALUE(isDuplex ? `options.${duplexKey}` : "options.highWaterMark", hwm);
			return MathFloor(hwm);
		}
		return getDefaultHighWaterMark(state.objectMode);
	}
	module.exports = {
		getHighWaterMark,
		getDefaultHighWaterMark,
		setDefaultHighWaterMark
	};
}));
var require_safe_buffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var buffer = __require("buffer");
	var Buffer = buffer.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
	else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer.prototype);
	copyProps(Buffer, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer(size);
		if (fill !== void 0) if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer.SlowBuffer(size);
	};
}));
var require_string_decoder = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Buffer = require_safe_buffer().Buffer;
	var isEncoding = Buffer.isEncoding || function(encoding) {
		encoding = "" + encoding;
		switch (encoding && encoding.toLowerCase()) {
			case "hex":
			case "utf8":
			case "utf-8":
			case "ascii":
			case "binary":
			case "base64":
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le":
			case "raw": return true;
			default: return false;
		}
	};
	function _normalizeEncoding(enc) {
		if (!enc) return "utf8";
		var retried;
		while (true) switch (enc) {
			case "utf8":
			case "utf-8": return "utf8";
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return "utf16le";
			case "latin1":
			case "binary": return "latin1";
			case "base64":
			case "ascii":
			case "hex": return enc;
			default:
				if (retried) return;
				enc = ("" + enc).toLowerCase();
				retried = true;
		}
	}
	function normalizeEncoding(enc) {
		var nenc = _normalizeEncoding(enc);
		if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
		return nenc || enc;
	}
	exports.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
		this.encoding = normalizeEncoding(encoding);
		var nb;
		switch (this.encoding) {
			case "utf16le":
				this.text = utf16Text;
				this.end = utf16End;
				nb = 4;
				break;
			case "utf8":
				this.fillLast = utf8FillLast;
				nb = 4;
				break;
			case "base64":
				this.text = base64Text;
				this.end = base64End;
				nb = 3;
				break;
			default:
				this.write = simpleWrite;
				this.end = simpleEnd;
				return;
		}
		this.lastNeed = 0;
		this.lastTotal = 0;
		this.lastChar = Buffer.allocUnsafe(nb);
	}
	StringDecoder.prototype.write = function(buf) {
		if (buf.length === 0) return "";
		var r$1;
		var i;
		if (this.lastNeed) {
			r$1 = this.fillLast(buf);
			if (r$1 === void 0) return "";
			i = this.lastNeed;
			this.lastNeed = 0;
		} else i = 0;
		if (i < buf.length) return r$1 ? r$1 + this.text(buf, i) : this.text(buf, i);
		return r$1 || "";
	};
	StringDecoder.prototype.end = utf8End;
	StringDecoder.prototype.text = utf8Text;
	StringDecoder.prototype.fillLast = function(buf) {
		if (this.lastNeed <= buf.length) {
			buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
			return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		}
		buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
		this.lastNeed -= buf.length;
	};
	function utf8CheckByte(byte) {
		if (byte <= 127) return 0;
		else if (byte >> 5 === 6) return 2;
		else if (byte >> 4 === 14) return 3;
		else if (byte >> 3 === 30) return 4;
		return byte >> 6 === 2 ? -1 : -2;
	}
	function utf8CheckIncomplete(self$1, buf, i) {
		var j = buf.length - 1;
		if (j < i) return 0;
		var nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) self$1.lastNeed = nb - 1;
			return nb;
		}
		if (--j < i || nb === -2) return 0;
		nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) self$1.lastNeed = nb - 2;
			return nb;
		}
		if (--j < i || nb === -2) return 0;
		nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) if (nb === 2) nb = 0;
			else self$1.lastNeed = nb - 3;
			return nb;
		}
		return 0;
	}
	function utf8CheckExtraBytes(self$1, buf, p) {
		if ((buf[0] & 192) !== 128) {
			self$1.lastNeed = 0;
			return "";
		}
		if (self$1.lastNeed > 1 && buf.length > 1) {
			if ((buf[1] & 192) !== 128) {
				self$1.lastNeed = 1;
				return "";
			}
			if (self$1.lastNeed > 2 && buf.length > 2) {
				if ((buf[2] & 192) !== 128) {
					self$1.lastNeed = 2;
					return "";
				}
			}
		}
	}
	function utf8FillLast(buf) {
		var p = this.lastTotal - this.lastNeed;
		var r$1 = utf8CheckExtraBytes(this, buf, p);
		if (r$1 !== void 0) return r$1;
		if (this.lastNeed <= buf.length) {
			buf.copy(this.lastChar, p, 0, this.lastNeed);
			return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		}
		buf.copy(this.lastChar, p, 0, buf.length);
		this.lastNeed -= buf.length;
	}
	function utf8Text(buf, i) {
		var total = utf8CheckIncomplete(this, buf, i);
		if (!this.lastNeed) return buf.toString("utf8", i);
		this.lastTotal = total;
		var end = buf.length - (total - this.lastNeed);
		buf.copy(this.lastChar, 0, end);
		return buf.toString("utf8", i, end);
	}
	function utf8End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) return r$1 + "";
		return r$1;
	}
	function utf16Text(buf, i) {
		if ((buf.length - i) % 2 === 0) {
			var r$1 = buf.toString("utf16le", i);
			if (r$1) {
				var c = r$1.charCodeAt(r$1.length - 1);
				if (c >= 55296 && c <= 56319) {
					this.lastNeed = 2;
					this.lastTotal = 4;
					this.lastChar[0] = buf[buf.length - 2];
					this.lastChar[1] = buf[buf.length - 1];
					return r$1.slice(0, -1);
				}
			}
			return r$1;
		}
		this.lastNeed = 1;
		this.lastTotal = 2;
		this.lastChar[0] = buf[buf.length - 1];
		return buf.toString("utf16le", i, buf.length - 1);
	}
	function utf16End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) {
			var end = this.lastTotal - this.lastNeed;
			return r$1 + this.lastChar.toString("utf16le", 0, end);
		}
		return r$1;
	}
	function base64Text(buf, i) {
		var n$1 = (buf.length - i) % 3;
		if (n$1 === 0) return buf.toString("base64", i);
		this.lastNeed = 3 - n$1;
		this.lastTotal = 3;
		if (n$1 === 1) this.lastChar[0] = buf[buf.length - 1];
		else {
			this.lastChar[0] = buf[buf.length - 2];
			this.lastChar[1] = buf[buf.length - 1];
		}
		return buf.toString("base64", i, buf.length - n$1);
	}
	function base64End(buf) {
		var r$1 = buf && buf.length ? this.write(buf) : "";
		if (this.lastNeed) return r$1 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
		return r$1;
	}
	function simpleWrite(buf) {
		return buf.toString(this.encoding);
	}
	function simpleEnd(buf) {
		return buf && buf.length ? this.write(buf) : "";
	}
}));
var require_from = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var process = require_process();
	var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
	var { Buffer: Buffer$4 } = __require("buffer");
	var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors$1().codes;
	function from(Readable, iterable, opts) {
		let iterator$1;
		if (typeof iterable === "string" || iterable instanceof Buffer$4) return new Readable({
			objectMode: true,
			...opts,
			read() {
				this.push(iterable);
				this.push(null);
			}
		});
		let isAsync$1;
		if (iterable && iterable[SymbolAsyncIterator]) {
			isAsync$1 = true;
			iterator$1 = iterable[SymbolAsyncIterator]();
		} else if (iterable && iterable[SymbolIterator]) {
			isAsync$1 = false;
			iterator$1 = iterable[SymbolIterator]();
		} else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
		const readable = new Readable({
			objectMode: true,
			highWaterMark: 1,
			...opts
		});
		let reading = false;
		readable._read = function() {
			if (!reading) {
				reading = true;
				next();
			}
		};
		readable._destroy = function(error, cb) {
			PromisePrototypeThen(close(error), () => process.nextTick(cb, error), (e$1) => process.nextTick(cb, e$1 || error));
		};
		async function close(error) {
			const hadError = error !== void 0 && error !== null;
			const hasThrow = typeof iterator$1.throw === "function";
			if (hadError && hasThrow) {
				const { value: value$1, done } = await iterator$1.throw(error);
				await value$1;
				if (done) return;
			}
			if (typeof iterator$1.return === "function") {
				const { value: value$1 } = await iterator$1.return();
				await value$1;
			}
		}
		async function next() {
			for (;;) {
				try {
					const { value: value$1, done } = isAsync$1 ? await iterator$1.next() : iterator$1.next();
					if (done) readable.push(null);
					else {
						const res = value$1 && typeof value$1.then === "function" ? await value$1 : value$1;
						if (res === null) {
							reading = false;
							throw new ERR_STREAM_NULL_VALUES();
						} else if (readable.push(res)) continue;
						else reading = false;
					}
				} catch (err) {
					readable.destroy(err);
				}
				break;
			}
		}
		return readable;
	}
	module.exports = from;
}));
var require_readable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var process = require_process();
	var { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN, NumberParseInt, ObjectDefineProperties, ObjectKeys, ObjectSetPrototypeOf, Promise, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator, Symbol } = require_primordials();
	module.exports = Readable;
	Readable.ReadableState = ReadableState;
	var { EventEmitter: EE$1 } = __require("events");
	var { Stream, prependListener } = require_legacy();
	var { Buffer: Buffer$3 } = __require("buffer");
	var { addAbortSignal } = require_add_abort_signal();
	var eos = require_end_of_stream();
	var debug = require_util$2().debuglog("stream", (fn) => {
		debug = fn;
	});
	var BufferList = require_buffer_list();
	var destroyImpl = require_destroy();
	var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
	var { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError } = require_errors$1();
	var { validateObject } = require_validators();
	var kPaused = Symbol("kPaused");
	var { StringDecoder } = require_string_decoder();
	var from = require_from();
	ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
	ObjectSetPrototypeOf(Readable, Stream);
	var nop = () => {};
	var { errorOrDestroy } = destroyImpl;
	var kObjectMode = 1;
	var kEnded = 2;
	var kEndEmitted = 4;
	var kReading = 8;
	var kConstructed = 16;
	var kSync = 32;
	var kNeedReadable = 64;
	var kEmittedReadable = 128;
	var kReadableListening = 256;
	var kResumeScheduled = 512;
	var kErrorEmitted = 1024;
	var kEmitClose = 2048;
	var kAutoDestroy = 4096;
	var kDestroyed = 8192;
	var kClosed = 16384;
	var kCloseEmitted = 32768;
	var kMultiAwaitDrain = 65536;
	var kReadingMore = 1 << 17;
	var kDataEmitted = 1 << 18;
	function makeBitMapDescriptor(bit) {
		return {
			enumerable: false,
			get() {
				return (this.state & bit) !== 0;
			},
			set(value$1) {
				if (value$1) this.state |= bit;
				else this.state &= ~bit;
			}
		};
	}
	ObjectDefineProperties(ReadableState.prototype, {
		objectMode: makeBitMapDescriptor(kObjectMode),
		ended: makeBitMapDescriptor(kEnded),
		endEmitted: makeBitMapDescriptor(kEndEmitted),
		reading: makeBitMapDescriptor(kReading),
		constructed: makeBitMapDescriptor(kConstructed),
		sync: makeBitMapDescriptor(kSync),
		needReadable: makeBitMapDescriptor(kNeedReadable),
		emittedReadable: makeBitMapDescriptor(kEmittedReadable),
		readableListening: makeBitMapDescriptor(kReadableListening),
		resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
		errorEmitted: makeBitMapDescriptor(kErrorEmitted),
		emitClose: makeBitMapDescriptor(kEmitClose),
		autoDestroy: makeBitMapDescriptor(kAutoDestroy),
		destroyed: makeBitMapDescriptor(kDestroyed),
		closed: makeBitMapDescriptor(kClosed),
		closeEmitted: makeBitMapDescriptor(kCloseEmitted),
		multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
		readingMore: makeBitMapDescriptor(kReadingMore),
		dataEmitted: makeBitMapDescriptor(kDataEmitted)
	});
	function ReadableState(options, stream$5, isDuplex) {
		if (typeof isDuplex !== "boolean") isDuplex = stream$5 instanceof require_duplex();
		this.state = 6192;
		if (options && options.objectMode) this.state |= kObjectMode;
		if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
		this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
		this.buffer = new BufferList();
		this.length = 0;
		this.pipes = [];
		this.flowing = null;
		this[kPaused] = null;
		if (options && options.emitClose === false) this.state &= ~kEmitClose;
		if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
		this.errored = null;
		this.defaultEncoding = options && options.defaultEncoding || "utf8";
		this.awaitDrainWriters = null;
		this.decoder = null;
		this.encoding = null;
		if (options && options.encoding) {
			this.decoder = new StringDecoder(options.encoding);
			this.encoding = options.encoding;
		}
	}
	function Readable(options) {
		if (!(this instanceof Readable)) return new Readable(options);
		const isDuplex = this instanceof require_duplex();
		this._readableState = new ReadableState(options, this, isDuplex);
		if (options) {
			if (typeof options.read === "function") this._read = options.read;
			if (typeof options.destroy === "function") this._destroy = options.destroy;
			if (typeof options.construct === "function") this._construct = options.construct;
			if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
		}
		Stream.call(this, options);
		destroyImpl.construct(this, () => {
			if (this._readableState.needReadable) maybeReadMore(this, this._readableState);
		});
	}
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function(err, cb) {
		cb(err);
	};
	Readable.prototype[EE$1.captureRejectionSymbol] = function(err) {
		this.destroy(err);
	};
	Readable.prototype[SymbolAsyncDispose] = function() {
		let error;
		if (!this.destroyed) {
			error = this.readableEnded ? null : new AbortError();
			this.destroy(error);
		}
		return new Promise((resolve$1, reject$3) => eos(this, (err) => err && err !== error ? reject$3(err) : resolve$1(null)));
	};
	Readable.prototype.push = function(chunk, encoding) {
		return readableAddChunk(this, chunk, encoding, false);
	};
	Readable.prototype.unshift = function(chunk, encoding) {
		return readableAddChunk(this, chunk, encoding, true);
	};
	function readableAddChunk(stream$5, chunk, encoding, addToFront) {
		debug("readableAddChunk", chunk);
		const state = stream$5._readableState;
		let err;
		if ((state.state & kObjectMode) === 0) {
			if (typeof chunk === "string") {
				encoding = encoding || state.defaultEncoding;
				if (state.encoding !== encoding) if (addToFront && state.encoding) chunk = Buffer$3.from(chunk, encoding).toString(state.encoding);
				else {
					chunk = Buffer$3.from(chunk, encoding);
					encoding = "";
				}
			} else if (chunk instanceof Buffer$3) encoding = "";
			else if (Stream._isUint8Array(chunk)) {
				chunk = Stream._uint8ArrayToBuffer(chunk);
				encoding = "";
			} else if (chunk != null) err = new ERR_INVALID_ARG_TYPE("chunk", [
				"string",
				"Buffer",
				"Uint8Array"
			], chunk);
		}
		if (err) errorOrDestroy(stream$5, err);
		else if (chunk === null) {
			state.state &= ~kReading;
			onEofChunk(stream$5, state);
		} else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) if (addToFront) if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream$5, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
		else if (state.destroyed || state.errored) return false;
		else addChunk(stream$5, state, chunk, true);
		else if (state.ended) errorOrDestroy(stream$5, new ERR_STREAM_PUSH_AFTER_EOF());
		else if (state.destroyed || state.errored) return false;
		else {
			state.state &= ~kReading;
			if (state.decoder && !encoding) {
				chunk = state.decoder.write(chunk);
				if (state.objectMode || chunk.length !== 0) addChunk(stream$5, state, chunk, false);
				else maybeReadMore(stream$5, state);
			} else addChunk(stream$5, state, chunk, false);
		}
		else if (!addToFront) {
			state.state &= ~kReading;
			maybeReadMore(stream$5, state);
		}
		return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream$5, state, chunk, addToFront) {
		if (state.flowing && state.length === 0 && !state.sync && stream$5.listenerCount("data") > 0) {
			if ((state.state & kMultiAwaitDrain) !== 0) state.awaitDrainWriters.clear();
			else state.awaitDrainWriters = null;
			state.dataEmitted = true;
			stream$5.emit("data", chunk);
		} else {
			state.length += state.objectMode ? 1 : chunk.length;
			if (addToFront) state.buffer.unshift(chunk);
			else state.buffer.push(chunk);
			if ((state.state & kNeedReadable) !== 0) emitReadable(stream$5);
		}
		maybeReadMore(stream$5, state);
	}
	Readable.prototype.isPaused = function() {
		const state = this._readableState;
		return state[kPaused] === true || state.flowing === false;
	};
	Readable.prototype.setEncoding = function(enc) {
		const decoder = new StringDecoder(enc);
		this._readableState.decoder = decoder;
		this._readableState.encoding = this._readableState.decoder.encoding;
		const buffer$2 = this._readableState.buffer;
		let content = "";
		for (const data of buffer$2) content += decoder.write(data);
		buffer$2.clear();
		if (content !== "") buffer$2.push(content);
		this._readableState.length = content.length;
		return this;
	};
	var MAX_HWM = 1073741824;
	function computeNewHighWaterMark(n$1) {
		if (n$1 > MAX_HWM) throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n$1);
		else {
			n$1--;
			n$1 |= n$1 >>> 1;
			n$1 |= n$1 >>> 2;
			n$1 |= n$1 >>> 4;
			n$1 |= n$1 >>> 8;
			n$1 |= n$1 >>> 16;
			n$1++;
		}
		return n$1;
	}
	function howMuchToRead(n$1, state) {
		if (n$1 <= 0 || state.length === 0 && state.ended) return 0;
		if ((state.state & kObjectMode) !== 0) return 1;
		if (NumberIsNaN(n$1)) {
			if (state.flowing && state.length) return state.buffer.first().length;
			return state.length;
		}
		if (n$1 <= state.length) return n$1;
		return state.ended ? state.length : 0;
	}
	Readable.prototype.read = function(n$1) {
		debug("read", n$1);
		if (n$1 === void 0) n$1 = NaN;
		else if (!NumberIsInteger(n$1)) n$1 = NumberParseInt(n$1, 10);
		const state = this._readableState;
		const nOrig = n$1;
		if (n$1 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n$1);
		if (n$1 !== 0) state.state &= ~kEmittedReadable;
		if (n$1 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
			debug("read: emitReadable", state.length, state.ended);
			if (state.length === 0 && state.ended) endReadable(this);
			else emitReadable(this);
			return null;
		}
		n$1 = howMuchToRead(n$1, state);
		if (n$1 === 0 && state.ended) {
			if (state.length === 0) endReadable(this);
			return null;
		}
		let doRead = (state.state & kNeedReadable) !== 0;
		debug("need readable", doRead);
		if (state.length === 0 || state.length - n$1 < state.highWaterMark) {
			doRead = true;
			debug("length less than watermark", doRead);
		}
		if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
			doRead = false;
			debug("reading, ended or constructing", doRead);
		} else if (doRead) {
			debug("do read");
			state.state |= kReading | kSync;
			if (state.length === 0) state.state |= kNeedReadable;
			try {
				this._read(state.highWaterMark);
			} catch (err) {
				errorOrDestroy(this, err);
			}
			state.state &= ~kSync;
			if (!state.reading) n$1 = howMuchToRead(nOrig, state);
		}
		let ret;
		if (n$1 > 0) ret = fromList(n$1, state);
		else ret = null;
		if (ret === null) {
			state.needReadable = state.length <= state.highWaterMark;
			n$1 = 0;
		} else {
			state.length -= n$1;
			if (state.multiAwaitDrain) state.awaitDrainWriters.clear();
			else state.awaitDrainWriters = null;
		}
		if (state.length === 0) {
			if (!state.ended) state.needReadable = true;
			if (nOrig !== n$1 && state.ended) endReadable(this);
		}
		if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
			state.dataEmitted = true;
			this.emit("data", ret);
		}
		return ret;
	};
	function onEofChunk(stream$5, state) {
		debug("onEofChunk");
		if (state.ended) return;
		if (state.decoder) {
			const chunk = state.decoder.end();
			if (chunk && chunk.length) {
				state.buffer.push(chunk);
				state.length += state.objectMode ? 1 : chunk.length;
			}
		}
		state.ended = true;
		if (state.sync) emitReadable(stream$5);
		else {
			state.needReadable = false;
			state.emittedReadable = true;
			emitReadable_(stream$5);
		}
	}
	function emitReadable(stream$5) {
		const state = stream$5._readableState;
		debug("emitReadable", state.needReadable, state.emittedReadable);
		state.needReadable = false;
		if (!state.emittedReadable) {
			debug("emitReadable", state.flowing);
			state.emittedReadable = true;
			process.nextTick(emitReadable_, stream$5);
		}
	}
	function emitReadable_(stream$5) {
		const state = stream$5._readableState;
		debug("emitReadable_", state.destroyed, state.length, state.ended);
		if (!state.destroyed && !state.errored && (state.length || state.ended)) {
			stream$5.emit("readable");
			state.emittedReadable = false;
		}
		state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
		flow(stream$5);
	}
	function maybeReadMore(stream$5, state) {
		if (!state.readingMore && state.constructed) {
			state.readingMore = true;
			process.nextTick(maybeReadMore_, stream$5, state);
		}
	}
	function maybeReadMore_(stream$5, state) {
		while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
			const len = state.length;
			debug("maybeReadMore read 0");
			stream$5.read(0);
			if (len === state.length) break;
		}
		state.readingMore = false;
	}
	Readable.prototype._read = function(n$1) {
		throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
	};
	Readable.prototype.pipe = function(dest, pipeOpts) {
		const src = this;
		const state = this._readableState;
		if (state.pipes.length === 1) {
			if (!state.multiAwaitDrain) {
				state.multiAwaitDrain = true;
				state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
			}
		}
		state.pipes.push(dest);
		debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
		const endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr ? onend : unpipe;
		if (state.endEmitted) process.nextTick(endFn);
		else src.once("end", endFn);
		dest.on("unpipe", onunpipe);
		function onunpipe(readable, unpipeInfo) {
			debug("onunpipe");
			if (readable === src) {
				if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
					unpipeInfo.hasUnpiped = true;
					cleanup();
				}
			}
		}
		function onend() {
			debug("onend");
			dest.end();
		}
		let ondrain;
		let cleanedUp = false;
		function cleanup() {
			debug("cleanup");
			dest.removeListener("close", onclose);
			dest.removeListener("finish", onfinish);
			if (ondrain) dest.removeListener("drain", ondrain);
			dest.removeListener("error", onerror);
			dest.removeListener("unpipe", onunpipe);
			src.removeListener("end", onend);
			src.removeListener("end", unpipe);
			src.removeListener("data", ondata);
			cleanedUp = true;
			if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
		}
		function pause() {
			if (!cleanedUp) {
				if (state.pipes.length === 1 && state.pipes[0] === dest) {
					debug("false write response, pause", 0);
					state.awaitDrainWriters = dest;
					state.multiAwaitDrain = false;
				} else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
					debug("false write response, pause", state.awaitDrainWriters.size);
					state.awaitDrainWriters.add(dest);
				}
				src.pause();
			}
			if (!ondrain) {
				ondrain = pipeOnDrain(src, dest);
				dest.on("drain", ondrain);
			}
		}
		src.on("data", ondata);
		function ondata(chunk) {
			debug("ondata");
			const ret = dest.write(chunk);
			debug("dest.write", ret);
			if (ret === false) pause();
		}
		function onerror(er) {
			debug("onerror", er);
			unpipe();
			dest.removeListener("error", onerror);
			if (dest.listenerCount("error") === 0) {
				const s = dest._writableState || dest._readableState;
				if (s && !s.errorEmitted) errorOrDestroy(dest, er);
				else dest.emit("error", er);
			}
		}
		prependListener(dest, "error", onerror);
		function onclose() {
			dest.removeListener("finish", onfinish);
			unpipe();
		}
		dest.once("close", onclose);
		function onfinish() {
			debug("onfinish");
			dest.removeListener("close", onclose);
			unpipe();
		}
		dest.once("finish", onfinish);
		function unpipe() {
			debug("unpipe");
			src.unpipe(dest);
		}
		dest.emit("pipe", src);
		if (dest.writableNeedDrain === true) pause();
		else if (!state.flowing) {
			debug("pipe resume");
			src.resume();
		}
		return dest;
	};
	function pipeOnDrain(src, dest) {
		return function pipeOnDrainFunctionResult() {
			const state = src._readableState;
			if (state.awaitDrainWriters === dest) {
				debug("pipeOnDrain", 1);
				state.awaitDrainWriters = null;
			} else if (state.multiAwaitDrain) {
				debug("pipeOnDrain", state.awaitDrainWriters.size);
				state.awaitDrainWriters.delete(dest);
			}
			if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) src.resume();
		};
	}
	Readable.prototype.unpipe = function(dest) {
		const state = this._readableState;
		const unpipeInfo = { hasUnpiped: false };
		if (state.pipes.length === 0) return this;
		if (!dest) {
			const dests = state.pipes;
			state.pipes = [];
			this.pause();
			for (let i = 0; i < dests.length; i++) dests[i].emit("unpipe", this, { hasUnpiped: false });
			return this;
		}
		const index$1 = ArrayPrototypeIndexOf(state.pipes, dest);
		if (index$1 === -1) return this;
		state.pipes.splice(index$1, 1);
		if (state.pipes.length === 0) this.pause();
		dest.emit("unpipe", this, unpipeInfo);
		return this;
	};
	Readable.prototype.on = function(ev, fn) {
		const res = Stream.prototype.on.call(this, ev, fn);
		const state = this._readableState;
		if (ev === "data") {
			state.readableListening = this.listenerCount("readable") > 0;
			if (state.flowing !== false) this.resume();
		} else if (ev === "readable") {
			if (!state.endEmitted && !state.readableListening) {
				state.readableListening = state.needReadable = true;
				state.flowing = false;
				state.emittedReadable = false;
				debug("on readable", state.length, state.reading);
				if (state.length) emitReadable(this);
				else if (!state.reading) process.nextTick(nReadingNextTick, this);
			}
		}
		return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function(ev, fn) {
		const res = Stream.prototype.removeListener.call(this, ev, fn);
		if (ev === "readable") process.nextTick(updateReadableListening, this);
		return res;
	};
	Readable.prototype.off = Readable.prototype.removeListener;
	Readable.prototype.removeAllListeners = function(ev) {
		const res = Stream.prototype.removeAllListeners.apply(this, arguments);
		if (ev === "readable" || ev === void 0) process.nextTick(updateReadableListening, this);
		return res;
	};
	function updateReadableListening(self$1) {
		const state = self$1._readableState;
		state.readableListening = self$1.listenerCount("readable") > 0;
		if (state.resumeScheduled && state[kPaused] === false) state.flowing = true;
		else if (self$1.listenerCount("data") > 0) self$1.resume();
		else if (!state.readableListening) state.flowing = null;
	}
	function nReadingNextTick(self$1) {
		debug("readable nexttick read 0");
		self$1.read(0);
	}
	Readable.prototype.resume = function() {
		const state = this._readableState;
		if (!state.flowing) {
			debug("resume");
			state.flowing = !state.readableListening;
			resume(this, state);
		}
		state[kPaused] = false;
		return this;
	};
	function resume(stream$5, state) {
		if (!state.resumeScheduled) {
			state.resumeScheduled = true;
			process.nextTick(resume_, stream$5, state);
		}
	}
	function resume_(stream$5, state) {
		debug("resume", state.reading);
		if (!state.reading) stream$5.read(0);
		state.resumeScheduled = false;
		stream$5.emit("resume");
		flow(stream$5);
		if (state.flowing && !state.reading) stream$5.read(0);
	}
	Readable.prototype.pause = function() {
		debug("call pause flowing=%j", this._readableState.flowing);
		if (this._readableState.flowing !== false) {
			debug("pause");
			this._readableState.flowing = false;
			this.emit("pause");
		}
		this._readableState[kPaused] = true;
		return this;
	};
	function flow(stream$5) {
		const state = stream$5._readableState;
		debug("flow", state.flowing);
		while (state.flowing && stream$5.read() !== null);
	}
	Readable.prototype.wrap = function(stream$5) {
		let paused = false;
		stream$5.on("data", (chunk) => {
			if (!this.push(chunk) && stream$5.pause) {
				paused = true;
				stream$5.pause();
			}
		});
		stream$5.on("end", () => {
			this.push(null);
		});
		stream$5.on("error", (err) => {
			errorOrDestroy(this, err);
		});
		stream$5.on("close", () => {
			this.destroy();
		});
		stream$5.on("destroy", () => {
			this.destroy();
		});
		this._read = () => {
			if (paused && stream$5.resume) {
				paused = false;
				stream$5.resume();
			}
		};
		const streamKeys = ObjectKeys(stream$5);
		for (let j = 1; j < streamKeys.length; j++) {
			const i = streamKeys[j];
			if (this[i] === void 0 && typeof stream$5[i] === "function") this[i] = stream$5[i].bind(stream$5);
		}
		return this;
	};
	Readable.prototype[SymbolAsyncIterator] = function() {
		return streamToAsyncIterator(this);
	};
	Readable.prototype.iterator = function(options) {
		if (options !== void 0) validateObject(options, "options");
		return streamToAsyncIterator(this, options);
	};
	function streamToAsyncIterator(stream$5, options) {
		if (typeof stream$5.read !== "function") stream$5 = Readable.wrap(stream$5, { objectMode: true });
		const iter = createAsyncIterator(stream$5, options);
		iter.stream = stream$5;
		return iter;
	}
	async function* createAsyncIterator(stream$5, options) {
		let callback = nop;
		function next(resolve$1) {
			if (this === stream$5) {
				callback();
				callback = nop;
			} else callback = resolve$1;
		}
		stream$5.on("readable", next);
		let error;
		const cleanup = eos(stream$5, { writable: false }, (err) => {
			error = err ? aggregateTwoErrors(error, err) : null;
			callback();
			callback = nop;
		});
		try {
			while (true) {
				const chunk = stream$5.destroyed ? null : stream$5.read();
				if (chunk !== null) yield chunk;
				else if (error) throw error;
				else if (error === null) return;
				else await new Promise(next);
			}
		} catch (err) {
			error = aggregateTwoErrors(error, err);
			throw error;
		} finally {
			if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream$5._readableState.autoDestroy)) destroyImpl.destroyer(stream$5, null);
			else {
				stream$5.off("readable", next);
				cleanup();
			}
		}
	}
	ObjectDefineProperties(Readable.prototype, {
		readable: {
			__proto__: null,
			get() {
				const r$1 = this._readableState;
				return !!r$1 && r$1.readable !== false && !r$1.destroyed && !r$1.errorEmitted && !r$1.endEmitted;
			},
			set(val) {
				if (this._readableState) this._readableState.readable = !!val;
			}
		},
		readableDidRead: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return this._readableState.dataEmitted;
			}
		},
		readableAborted: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
			}
		},
		readableHighWaterMark: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return this._readableState.highWaterMark;
			}
		},
		readableBuffer: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return this._readableState && this._readableState.buffer;
			}
		},
		readableFlowing: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return this._readableState.flowing;
			},
			set: function(state) {
				if (this._readableState) this._readableState.flowing = state;
			}
		},
		readableLength: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState.length;
			}
		},
		readableObjectMode: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.objectMode : false;
			}
		},
		readableEncoding: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.encoding : null;
			}
		},
		errored: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.errored : null;
			}
		},
		closed: {
			__proto__: null,
			get() {
				return this._readableState ? this._readableState.closed : false;
			}
		},
		destroyed: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.destroyed : false;
			},
			set(value$1) {
				if (!this._readableState) return;
				this._readableState.destroyed = value$1;
			}
		},
		readableEnded: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._readableState ? this._readableState.endEmitted : false;
			}
		}
	});
	ObjectDefineProperties(ReadableState.prototype, {
		pipesCount: {
			__proto__: null,
			get() {
				return this.pipes.length;
			}
		},
		paused: {
			__proto__: null,
			get() {
				return this[kPaused] !== false;
			},
			set(value$1) {
				this[kPaused] = !!value$1;
			}
		}
	});
	Readable._fromList = fromList;
	function fromList(n$1, state) {
		if (state.length === 0) return null;
		let ret;
		if (state.objectMode) ret = state.buffer.shift();
		else if (!n$1 || n$1 >= state.length) {
			if (state.decoder) ret = state.buffer.join("");
			else if (state.buffer.length === 1) ret = state.buffer.first();
			else ret = state.buffer.concat(state.length);
			state.buffer.clear();
		} else ret = state.buffer.consume(n$1, state.decoder);
		return ret;
	}
	function endReadable(stream$5) {
		const state = stream$5._readableState;
		debug("endReadable", state.endEmitted);
		if (!state.endEmitted) {
			state.ended = true;
			process.nextTick(endReadableNT, state, stream$5);
		}
	}
	function endReadableNT(state, stream$5) {
		debug("endReadableNT", state.endEmitted, state.length);
		if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
			state.endEmitted = true;
			stream$5.emit("end");
			if (stream$5.writable && stream$5.allowHalfOpen === false) process.nextTick(endWritableNT, stream$5);
			else if (state.autoDestroy) {
				const wState = stream$5._writableState;
				if (!wState || wState.autoDestroy && (wState.finished || wState.writable === false)) stream$5.destroy();
			}
		}
	}
	function endWritableNT(stream$5) {
		if (stream$5.writable && !stream$5.writableEnded && !stream$5.destroyed) stream$5.end();
	}
	Readable.from = function(iterable, opts) {
		return from(Readable, iterable, opts);
	};
	var webStreamsAdapters;
	function lazyWebStreams() {
		if (webStreamsAdapters === void 0) webStreamsAdapters = {};
		return webStreamsAdapters;
	}
	Readable.fromWeb = function(readableStream, options) {
		return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
	};
	Readable.toWeb = function(streamReadable, options) {
		return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
	};
	Readable.wrap = function(src, options) {
		var _ref, _src$readableObjectMo;
		return new Readable({
			objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
			...options,
			destroy(err, callback) {
				destroyImpl.destroyer(src, err);
				callback(err);
			}
		}).wrap(src);
	};
}));
var require_writable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var process = require_process();
	var { ArrayPrototypeSlice, Error, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty, ObjectDefineProperties, ObjectSetPrototypeOf, StringPrototypeToLowerCase, Symbol, SymbolHasInstance } = require_primordials();
	module.exports = Writable;
	Writable.WritableState = WritableState;
	var { EventEmitter: EE } = __require("events");
	var Stream = require_legacy().Stream;
	var { Buffer: Buffer$2 } = __require("buffer");
	var destroyImpl = require_destroy();
	var { addAbortSignal } = require_add_abort_signal();
	var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
	var { ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = require_errors$1().codes;
	var { errorOrDestroy } = destroyImpl;
	ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
	ObjectSetPrototypeOf(Writable, Stream);
	function nop() {}
	var kOnFinished = Symbol("kOnFinished");
	function WritableState(options, stream$5, isDuplex) {
		if (typeof isDuplex !== "boolean") isDuplex = stream$5 instanceof require_duplex();
		this.objectMode = !!(options && options.objectMode);
		if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
		this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
		this.finalCalled = false;
		this.needDrain = false;
		this.ending = false;
		this.ended = false;
		this.finished = false;
		this.destroyed = false;
		this.decodeStrings = !!!(options && options.decodeStrings === false);
		this.defaultEncoding = options && options.defaultEncoding || "utf8";
		this.length = 0;
		this.writing = false;
		this.corked = 0;
		this.sync = true;
		this.bufferProcessing = false;
		this.onwrite = onwrite.bind(void 0, stream$5);
		this.writecb = null;
		this.writelen = 0;
		this.afterWriteTickInfo = null;
		resetBuffer(this);
		this.pendingcb = 0;
		this.constructed = true;
		this.prefinished = false;
		this.errorEmitted = false;
		this.emitClose = !options || options.emitClose !== false;
		this.autoDestroy = !options || options.autoDestroy !== false;
		this.errored = null;
		this.closed = false;
		this.closeEmitted = false;
		this[kOnFinished] = [];
	}
	function resetBuffer(state) {
		state.buffered = [];
		state.bufferedIndex = 0;
		state.allBuffers = true;
		state.allNoop = true;
	}
	WritableState.prototype.getBuffer = function getBuffer() {
		return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
	};
	ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
		__proto__: null,
		get() {
			return this.buffered.length - this.bufferedIndex;
		}
	});
	function Writable(options) {
		const isDuplex = this instanceof require_duplex();
		if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);
		this._writableState = new WritableState(options, this, isDuplex);
		if (options) {
			if (typeof options.write === "function") this._write = options.write;
			if (typeof options.writev === "function") this._writev = options.writev;
			if (typeof options.destroy === "function") this._destroy = options.destroy;
			if (typeof options.final === "function") this._final = options.final;
			if (typeof options.construct === "function") this._construct = options.construct;
			if (options.signal) addAbortSignal(options.signal, this);
		}
		Stream.call(this, options);
		destroyImpl.construct(this, () => {
			const state = this._writableState;
			if (!state.writing) clearBuffer(this, state);
			finishMaybe(this, state);
		});
	}
	ObjectDefineProperty(Writable, SymbolHasInstance, {
		__proto__: null,
		value: function(object) {
			if (FunctionPrototypeSymbolHasInstance(this, object)) return true;
			if (this !== Writable) return false;
			return object && object._writableState instanceof WritableState;
		}
	});
	Writable.prototype.pipe = function() {
		errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function _write(stream$5, chunk, encoding, cb) {
		const state = stream$5._writableState;
		if (typeof encoding === "function") {
			cb = encoding;
			encoding = state.defaultEncoding;
		} else {
			if (!encoding) encoding = state.defaultEncoding;
			else if (encoding !== "buffer" && !Buffer$2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
			if (typeof cb !== "function") cb = nop;
		}
		if (chunk === null) throw new ERR_STREAM_NULL_VALUES();
		else if (!state.objectMode) if (typeof chunk === "string") {
			if (state.decodeStrings !== false) {
				chunk = Buffer$2.from(chunk, encoding);
				encoding = "buffer";
			}
		} else if (chunk instanceof Buffer$2) encoding = "buffer";
		else if (Stream._isUint8Array(chunk)) {
			chunk = Stream._uint8ArrayToBuffer(chunk);
			encoding = "buffer";
		} else throw new ERR_INVALID_ARG_TYPE("chunk", [
			"string",
			"Buffer",
			"Uint8Array"
		], chunk);
		let err;
		if (state.ending) err = new ERR_STREAM_WRITE_AFTER_END();
		else if (state.destroyed) err = new ERR_STREAM_DESTROYED("write");
		if (err) {
			process.nextTick(cb, err);
			errorOrDestroy(stream$5, err, true);
			return err;
		}
		state.pendingcb++;
		return writeOrBuffer(stream$5, state, chunk, encoding, cb);
	}
	Writable.prototype.write = function(chunk, encoding, cb) {
		return _write(this, chunk, encoding, cb) === true;
	};
	Writable.prototype.cork = function() {
		this._writableState.corked++;
	};
	Writable.prototype.uncork = function() {
		const state = this._writableState;
		if (state.corked) {
			state.corked--;
			if (!state.writing) clearBuffer(this, state);
		}
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
		if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
		if (!Buffer$2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
		this._writableState.defaultEncoding = encoding;
		return this;
	};
	function writeOrBuffer(stream$5, state, chunk, encoding, callback) {
		const len = state.objectMode ? 1 : chunk.length;
		state.length += len;
		const ret = state.length < state.highWaterMark;
		if (!ret) state.needDrain = true;
		if (state.writing || state.corked || state.errored || !state.constructed) {
			state.buffered.push({
				chunk,
				encoding,
				callback
			});
			if (state.allBuffers && encoding !== "buffer") state.allBuffers = false;
			if (state.allNoop && callback !== nop) state.allNoop = false;
		} else {
			state.writelen = len;
			state.writecb = callback;
			state.writing = true;
			state.sync = true;
			stream$5._write(chunk, encoding, state.onwrite);
			state.sync = false;
		}
		return ret && !state.errored && !state.destroyed;
	}
	function doWrite(stream$5, state, writev, len, chunk, encoding, cb) {
		state.writelen = len;
		state.writecb = cb;
		state.writing = true;
		state.sync = true;
		if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
		else if (writev) stream$5._writev(chunk, state.onwrite);
		else stream$5._write(chunk, encoding, state.onwrite);
		state.sync = false;
	}
	function onwriteError(stream$5, state, er, cb) {
		--state.pendingcb;
		cb(er);
		errorBuffer(state);
		errorOrDestroy(stream$5, er);
	}
	function onwrite(stream$5, er) {
		const state = stream$5._writableState;
		const sync$3 = state.sync;
		const cb = state.writecb;
		if (typeof cb !== "function") {
			errorOrDestroy(stream$5, new ERR_MULTIPLE_CALLBACK());
			return;
		}
		state.writing = false;
		state.writecb = null;
		state.length -= state.writelen;
		state.writelen = 0;
		if (er) {
			er.stack;
			if (!state.errored) state.errored = er;
			if (stream$5._readableState && !stream$5._readableState.errored) stream$5._readableState.errored = er;
			if (sync$3) process.nextTick(onwriteError, stream$5, state, er, cb);
			else onwriteError(stream$5, state, er, cb);
		} else {
			if (state.buffered.length > state.bufferedIndex) clearBuffer(stream$5, state);
			if (sync$3) if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) state.afterWriteTickInfo.count++;
			else {
				state.afterWriteTickInfo = {
					count: 1,
					cb,
					stream: stream$5,
					state
				};
				process.nextTick(afterWriteTick, state.afterWriteTickInfo);
			}
			else afterWrite(stream$5, state, 1, cb);
		}
	}
	function afterWriteTick({ stream: stream$5, state, count, cb }) {
		state.afterWriteTickInfo = null;
		return afterWrite(stream$5, state, count, cb);
	}
	function afterWrite(stream$5, state, count, cb) {
		if (!state.ending && !stream$5.destroyed && state.length === 0 && state.needDrain) {
			state.needDrain = false;
			stream$5.emit("drain");
		}
		while (count-- > 0) {
			state.pendingcb--;
			cb();
		}
		if (state.destroyed) errorBuffer(state);
		finishMaybe(stream$5, state);
	}
	function errorBuffer(state) {
		if (state.writing) return;
		for (let n$1 = state.bufferedIndex; n$1 < state.buffered.length; ++n$1) {
			var _state$errored;
			const { chunk, callback } = state.buffered[n$1];
			const len = state.objectMode ? 1 : chunk.length;
			state.length -= len;
			callback((_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write"));
		}
		const onfinishCallbacks = state[kOnFinished].splice(0);
		for (let i = 0; i < onfinishCallbacks.length; i++) {
			var _state$errored2;
			onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
		}
		resetBuffer(state);
	}
	function clearBuffer(stream$5, state) {
		if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) return;
		const { buffered, bufferedIndex, objectMode } = state;
		const bufferedLength = buffered.length - bufferedIndex;
		if (!bufferedLength) return;
		let i = bufferedIndex;
		state.bufferProcessing = true;
		if (bufferedLength > 1 && stream$5._writev) {
			state.pendingcb -= bufferedLength - 1;
			const callback = state.allNoop ? nop : (err) => {
				for (let n$1 = i; n$1 < buffered.length; ++n$1) buffered[n$1].callback(err);
			};
			const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
			chunks.allBuffers = state.allBuffers;
			doWrite(stream$5, state, true, state.length, chunks, "", callback);
			resetBuffer(state);
		} else {
			do {
				const { chunk, encoding, callback } = buffered[i];
				buffered[i++] = null;
				doWrite(stream$5, state, false, objectMode ? 1 : chunk.length, chunk, encoding, callback);
			} while (i < buffered.length && !state.writing);
			if (i === buffered.length) resetBuffer(state);
			else if (i > 256) {
				buffered.splice(0, i);
				state.bufferedIndex = 0;
			} else state.bufferedIndex = i;
		}
		state.bufferProcessing = false;
	}
	Writable.prototype._write = function(chunk, encoding, cb) {
		if (this._writev) this._writev([{
			chunk,
			encoding
		}], cb);
		else throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function(chunk, encoding, cb) {
		const state = this._writableState;
		if (typeof chunk === "function") {
			cb = chunk;
			chunk = null;
			encoding = null;
		} else if (typeof encoding === "function") {
			cb = encoding;
			encoding = null;
		}
		let err;
		if (chunk !== null && chunk !== void 0) {
			const ret = _write(this, chunk, encoding);
			if (ret instanceof Error) err = ret;
		}
		if (state.corked) {
			state.corked = 1;
			this.uncork();
		}
		if (err) {} else if (!state.errored && !state.ending) {
			state.ending = true;
			finishMaybe(this, state, true);
			state.ended = true;
		} else if (state.finished) err = new ERR_STREAM_ALREADY_FINISHED("end");
		else if (state.destroyed) err = new ERR_STREAM_DESTROYED("end");
		if (typeof cb === "function") if (err || state.finished) process.nextTick(cb, err);
		else state[kOnFinished].push(cb);
		return this;
	};
	function needFinish(state) {
		return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
	}
	function callFinal(stream$5, state) {
		let called = false;
		function onFinish(err) {
			if (called) {
				errorOrDestroy(stream$5, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
				return;
			}
			called = true;
			state.pendingcb--;
			if (err) {
				const onfinishCallbacks = state[kOnFinished].splice(0);
				for (let i = 0; i < onfinishCallbacks.length; i++) onfinishCallbacks[i](err);
				errorOrDestroy(stream$5, err, state.sync);
			} else if (needFinish(state)) {
				state.prefinished = true;
				stream$5.emit("prefinish");
				state.pendingcb++;
				process.nextTick(finish, stream$5, state);
			}
		}
		state.sync = true;
		state.pendingcb++;
		try {
			stream$5._final(onFinish);
		} catch (err) {
			onFinish(err);
		}
		state.sync = false;
	}
	function prefinish(stream$5, state) {
		if (!state.prefinished && !state.finalCalled) if (typeof stream$5._final === "function" && !state.destroyed) {
			state.finalCalled = true;
			callFinal(stream$5, state);
		} else {
			state.prefinished = true;
			stream$5.emit("prefinish");
		}
	}
	function finishMaybe(stream$5, state, sync$3) {
		if (needFinish(state)) {
			prefinish(stream$5, state);
			if (state.pendingcb === 0) {
				if (sync$3) {
					state.pendingcb++;
					process.nextTick((stream$6, state$1) => {
						if (needFinish(state$1)) finish(stream$6, state$1);
						else state$1.pendingcb--;
					}, stream$5, state);
				} else if (needFinish(state)) {
					state.pendingcb++;
					finish(stream$5, state);
				}
			}
		}
	}
	function finish(stream$5, state) {
		state.pendingcb--;
		state.finished = true;
		const onfinishCallbacks = state[kOnFinished].splice(0);
		for (let i = 0; i < onfinishCallbacks.length; i++) onfinishCallbacks[i]();
		stream$5.emit("finish");
		if (state.autoDestroy) {
			const rState = stream$5._readableState;
			if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false)) stream$5.destroy();
		}
	}
	ObjectDefineProperties(Writable.prototype, {
		closed: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.closed : false;
			}
		},
		destroyed: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.destroyed : false;
			},
			set(value$1) {
				if (this._writableState) this._writableState.destroyed = value$1;
			}
		},
		writable: {
			__proto__: null,
			get() {
				const w = this._writableState;
				return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
			},
			set(val) {
				if (this._writableState) this._writableState.writable = !!val;
			}
		},
		writableFinished: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.finished : false;
			}
		},
		writableObjectMode: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.objectMode : false;
			}
		},
		writableBuffer: {
			__proto__: null,
			get() {
				return this._writableState && this._writableState.getBuffer();
			}
		},
		writableEnded: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.ending : false;
			}
		},
		writableNeedDrain: {
			__proto__: null,
			get() {
				const wState = this._writableState;
				if (!wState) return false;
				return !wState.destroyed && !wState.ending && wState.needDrain;
			}
		},
		writableHighWaterMark: {
			__proto__: null,
			get() {
				return this._writableState && this._writableState.highWaterMark;
			}
		},
		writableCorked: {
			__proto__: null,
			get() {
				return this._writableState ? this._writableState.corked : 0;
			}
		},
		writableLength: {
			__proto__: null,
			get() {
				return this._writableState && this._writableState.length;
			}
		},
		errored: {
			__proto__: null,
			enumerable: false,
			get() {
				return this._writableState ? this._writableState.errored : null;
			}
		},
		writableAborted: {
			__proto__: null,
			enumerable: false,
			get: function() {
				return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
			}
		}
	});
	var destroy = destroyImpl.destroy;
	Writable.prototype.destroy = function(err, cb) {
		const state = this._writableState;
		if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) process.nextTick(errorBuffer, state);
		destroy.call(this, err, cb);
		return this;
	};
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function(err, cb) {
		cb(err);
	};
	Writable.prototype[EE.captureRejectionSymbol] = function(err) {
		this.destroy(err);
	};
	var webStreamsAdapters;
	function lazyWebStreams() {
		if (webStreamsAdapters === void 0) webStreamsAdapters = {};
		return webStreamsAdapters;
	}
	Writable.fromWeb = function(writableStream, options) {
		return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
	};
	Writable.toWeb = function(streamWritable) {
		return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
	};
}));
var require_duplexify = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var process = require_process();
	var bufferModule = __require("buffer");
	var { isReadable, isWritable, isIterable, isNodeStream, isReadableNodeStream, isWritableNodeStream, isDuplexNodeStream, isReadableStream, isWritableStream } = require_utils();
	var eos = require_end_of_stream();
	var { AbortError, codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE } } = require_errors$1();
	var { destroyer } = require_destroy();
	var Duplex = require_duplex();
	var Readable = require_readable();
	var Writable = require_writable();
	var { createDeferredPromise } = require_util$2();
	var from = require_from();
	var Blob = globalThis.Blob || bufferModule.Blob;
	var isBlob = typeof Blob !== "undefined" ? function isBlob(b) {
		return b instanceof Blob;
	} : function isBlob(b) {
		return false;
	};
	var AbortController = globalThis.AbortController || (init_abort_controller(), __toCommonJS(abort_controller_exports)).AbortController;
	var { FunctionPrototypeCall } = require_primordials();
	var Duplexify = class extends Duplex {
		constructor(options) {
			super(options);
			if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
				this._readableState.readable = false;
				this._readableState.ended = true;
				this._readableState.endEmitted = true;
			}
			if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
				this._writableState.writable = false;
				this._writableState.ending = true;
				this._writableState.ended = true;
				this._writableState.finished = true;
			}
		}
	};
	module.exports = function duplexify(body, name$1) {
		if (isDuplexNodeStream(body)) return body;
		if (isReadableNodeStream(body)) return _duplexify({ readable: body });
		if (isWritableNodeStream(body)) return _duplexify({ writable: body });
		if (isNodeStream(body)) return _duplexify({
			writable: false,
			readable: false
		});
		if (isReadableStream(body)) return _duplexify({ readable: Readable.fromWeb(body) });
		if (isWritableStream(body)) return _duplexify({ writable: Writable.fromWeb(body) });
		if (typeof body === "function") {
			const { value: value$1, write, final, destroy } = fromAsyncGen(body);
			if (isIterable(value$1)) return from(Duplexify, value$1, {
				objectMode: true,
				write,
				final,
				destroy
			});
			const then$1 = value$1 === null || value$1 === void 0 ? void 0 : value$1.then;
			if (typeof then$1 === "function") {
				let d;
				const promise = FunctionPrototypeCall(then$1, value$1, (val) => {
					if (val != null) throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
				}, (err) => {
					destroyer(d, err);
				});
				return d = new Duplexify({
					objectMode: true,
					readable: false,
					write,
					final(cb) {
						final(async () => {
							try {
								await promise;
								process.nextTick(cb, null);
							} catch (err) {
								process.nextTick(cb, err);
							}
						});
					},
					destroy
				});
			}
			throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name$1, value$1);
		}
		if (isBlob(body)) return duplexify(body.arrayBuffer());
		if (isIterable(body)) return from(Duplexify, body, {
			objectMode: true,
			writable: false
		});
		if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) return Duplexify.fromWeb(body);
		if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") return _duplexify({
			readable: body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0,
			writable: body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0
		});
		const then = body === null || body === void 0 ? void 0 : body.then;
		if (typeof then === "function") {
			let d;
			FunctionPrototypeCall(then, body, (val) => {
				if (val != null) d.push(val);
				d.push(null);
			}, (err) => {
				destroyer(d, err);
			});
			return d = new Duplexify({
				objectMode: true,
				writable: false,
				read() {}
			});
		}
		throw new ERR_INVALID_ARG_TYPE(name$1, [
			"Blob",
			"ReadableStream",
			"WritableStream",
			"Stream",
			"Iterable",
			"AsyncIterable",
			"Function",
			"{ readable, writable } pair",
			"Promise"
		], body);
	};
	function fromAsyncGen(fn) {
		let { promise, resolve: resolve$1 } = createDeferredPromise();
		const ac = new AbortController();
		const signal = ac.signal;
		return {
			value: fn((async function* () {
				while (true) {
					const _promise = promise;
					promise = null;
					const { chunk, done, cb } = await _promise;
					process.nextTick(cb);
					if (done) return;
					if (signal.aborted) throw new AbortError(void 0, { cause: signal.reason });
					({promise, resolve: resolve$1} = createDeferredPromise());
					yield chunk;
				}
			})(), { signal }),
			write(chunk, encoding, cb) {
				const _resolve = resolve$1;
				resolve$1 = null;
				_resolve({
					chunk,
					done: false,
					cb
				});
			},
			final(cb) {
				const _resolve = resolve$1;
				resolve$1 = null;
				_resolve({
					done: true,
					cb
				});
			},
			destroy(err, cb) {
				ac.abort();
				cb(err);
			}
		};
	}
	function _duplexify(pair) {
		const r$1 = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
		const w = pair.writable;
		let readable = !!isReadable(r$1);
		let writable = !!isWritable(w);
		let ondrain;
		let onfinish;
		let onreadable;
		let onclose;
		let d;
		function onfinished(err) {
			const cb = onclose;
			onclose = null;
			if (cb) cb(err);
			else if (err) d.destroy(err);
		}
		d = new Duplexify({
			readableObjectMode: !!(r$1 !== null && r$1 !== void 0 && r$1.readableObjectMode),
			writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
			readable,
			writable
		});
		if (writable) {
			eos(w, (err) => {
				writable = false;
				if (err) destroyer(r$1, err);
				onfinished(err);
			});
			d._write = function(chunk, encoding, callback) {
				if (w.write(chunk, encoding)) callback();
				else ondrain = callback;
			};
			d._final = function(callback) {
				w.end();
				onfinish = callback;
			};
			w.on("drain", function() {
				if (ondrain) {
					const cb = ondrain;
					ondrain = null;
					cb();
				}
			});
			w.on("finish", function() {
				if (onfinish) {
					const cb = onfinish;
					onfinish = null;
					cb();
				}
			});
		}
		if (readable) {
			eos(r$1, (err) => {
				readable = false;
				if (err) destroyer(r$1, err);
				onfinished(err);
			});
			r$1.on("readable", function() {
				if (onreadable) {
					const cb = onreadable;
					onreadable = null;
					cb();
				}
			});
			r$1.on("end", function() {
				d.push(null);
			});
			d._read = function() {
				while (true) {
					const buf = r$1.read();
					if (buf === null) {
						onreadable = d._read;
						return;
					}
					if (!d.push(buf)) return;
				}
			};
		}
		d._destroy = function(err, callback) {
			if (!err && onclose !== null) err = new AbortError();
			onreadable = null;
			ondrain = null;
			onfinish = null;
			if (onclose === null) callback(err);
			else {
				onclose = callback;
				destroyer(w, err);
				destroyer(r$1, err);
			}
		};
		return d;
	}
}));
var require_duplex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials();
	module.exports = Duplex;
	var Readable = require_readable();
	var Writable = require_writable();
	ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
	ObjectSetPrototypeOf(Duplex, Readable);
	{
		const keys = ObjectKeys(Writable.prototype);
		for (let i = 0; i < keys.length; i++) {
			const method = keys[i];
			if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
		}
	}
	function Duplex(options) {
		if (!(this instanceof Duplex)) return new Duplex(options);
		Readable.call(this, options);
		Writable.call(this, options);
		if (options) {
			this.allowHalfOpen = options.allowHalfOpen !== false;
			if (options.readable === false) {
				this._readableState.readable = false;
				this._readableState.ended = true;
				this._readableState.endEmitted = true;
			}
			if (options.writable === false) {
				this._writableState.writable = false;
				this._writableState.ending = true;
				this._writableState.ended = true;
				this._writableState.finished = true;
			}
		} else this.allowHalfOpen = true;
	}
	ObjectDefineProperties(Duplex.prototype, {
		writable: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
		},
		writableHighWaterMark: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
		},
		writableObjectMode: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
		},
		writableBuffer: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
		},
		writableLength: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
		},
		writableFinished: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
		},
		writableCorked: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
		},
		writableEnded: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
		},
		writableNeedDrain: {
			__proto__: null,
			...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
		},
		destroyed: {
			__proto__: null,
			get() {
				if (this._readableState === void 0 || this._writableState === void 0) return false;
				return this._readableState.destroyed && this._writableState.destroyed;
			},
			set(value$1) {
				if (this._readableState && this._writableState) {
					this._readableState.destroyed = value$1;
					this._writableState.destroyed = value$1;
				}
			}
		}
	});
	var webStreamsAdapters;
	function lazyWebStreams() {
		if (webStreamsAdapters === void 0) webStreamsAdapters = {};
		return webStreamsAdapters;
	}
	Duplex.fromWeb = function(pair, options) {
		return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
	};
	Duplex.toWeb = function(duplex) {
		return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
	};
	var duplexify;
	Duplex.from = function(body) {
		if (!duplexify) duplexify = require_duplexify();
		return duplexify(body, "body");
	};
}));
var require_transform = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { ObjectSetPrototypeOf, Symbol } = require_primordials();
	module.exports = Transform;
	var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors$1().codes;
	var Duplex = require_duplex();
	var { getHighWaterMark } = require_state();
	ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
	ObjectSetPrototypeOf(Transform, Duplex);
	var kCallback = Symbol("kCallback");
	function Transform(options) {
		if (!(this instanceof Transform)) return new Transform(options);
		const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
		if (readableHighWaterMark === 0) options = {
			...options,
			highWaterMark: null,
			readableHighWaterMark,
			writableHighWaterMark: options.writableHighWaterMark || 0
		};
		Duplex.call(this, options);
		this._readableState.sync = false;
		this[kCallback] = null;
		if (options) {
			if (typeof options.transform === "function") this._transform = options.transform;
			if (typeof options.flush === "function") this._flush = options.flush;
		}
		this.on("prefinish", prefinish);
	}
	function final(cb) {
		if (typeof this._flush === "function" && !this.destroyed) this._flush((er, data) => {
			if (er) {
				if (cb) cb(er);
				else this.destroy(er);
				return;
			}
			if (data != null) this.push(data);
			this.push(null);
			if (cb) cb();
		});
		else {
			this.push(null);
			if (cb) cb();
		}
	}
	function prefinish() {
		if (this._final !== final) final.call(this);
	}
	Transform.prototype._final = final;
	Transform.prototype._transform = function(chunk, encoding, callback) {
		throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
	};
	Transform.prototype._write = function(chunk, encoding, callback) {
		const rState = this._readableState;
		const wState = this._writableState;
		const length = rState.length;
		this._transform(chunk, encoding, (err, val) => {
			if (err) {
				callback(err);
				return;
			}
			if (val != null) this.push(val);
			if (wState.ended || length === rState.length || rState.length < rState.highWaterMark) callback();
			else this[kCallback] = callback;
		});
	};
	Transform.prototype._read = function() {
		if (this[kCallback]) {
			const callback = this[kCallback];
			this[kCallback] = null;
			callback();
		}
	};
}));
var require_passthrough = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { ObjectSetPrototypeOf } = require_primordials();
	module.exports = PassThrough;
	var Transform = require_transform();
	ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
	ObjectSetPrototypeOf(PassThrough, Transform);
	function PassThrough(options) {
		if (!(this instanceof PassThrough)) return new PassThrough(options);
		Transform.call(this, options);
	}
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
		cb(null, chunk);
	};
}));
var require_pipeline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var process = require_process();
	var { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = require_primordials();
	var eos = require_end_of_stream();
	var { once } = require_util$2();
	var destroyImpl = require_destroy();
	var Duplex = require_duplex();
	var { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError } = require_errors$1();
	var { validateFunction, validateAbortSignal } = require_validators();
	var { isIterable, isReadable, isReadableNodeStream, isNodeStream, isTransformStream, isWebStream, isReadableStream, isReadableFinished } = require_utils();
	var AbortController = globalThis.AbortController || (init_abort_controller(), __toCommonJS(abort_controller_exports)).AbortController;
	var PassThrough;
	var Readable;
	var addAbortListener;
	function destroyer(stream$5, reading, writing) {
		let finished = false;
		stream$5.on("close", () => {
			finished = true;
		});
		return {
			destroy: (err) => {
				if (finished) return;
				finished = true;
				destroyImpl.destroyer(stream$5, err || new ERR_STREAM_DESTROYED("pipe"));
			},
			cleanup: eos(stream$5, {
				readable: reading,
				writable: writing
			}, (err) => {
				finished = !err;
			})
		};
	}
	function popCallback(streams) {
		validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
		return streams.pop();
	}
	function makeAsyncIterable(val) {
		if (isIterable(val)) return val;
		else if (isReadableNodeStream(val)) return fromReadable(val);
		throw new ERR_INVALID_ARG_TYPE("val", [
			"Readable",
			"Iterable",
			"AsyncIterable"
		], val);
	}
	async function* fromReadable(val) {
		if (!Readable) Readable = require_readable();
		yield* Readable.prototype[SymbolAsyncIterator].call(val);
	}
	async function pumpToNode(iterable, writable, finish, { end }) {
		let error;
		let onresolve = null;
		const resume = (err) => {
			if (err) error = err;
			if (onresolve) {
				const callback = onresolve;
				onresolve = null;
				callback();
			}
		};
		const wait = () => new Promise((resolve$1, reject$3) => {
			if (error) reject$3(error);
			else onresolve = () => {
				if (error) reject$3(error);
				else resolve$1();
			};
		});
		writable.on("drain", resume);
		const cleanup = eos(writable, { readable: false }, resume);
		try {
			if (writable.writableNeedDrain) await wait();
			for await (const chunk of iterable) if (!writable.write(chunk)) await wait();
			if (end) {
				writable.end();
				await wait();
			}
			finish();
		} catch (err) {
			finish(error !== err ? aggregateTwoErrors(error, err) : err);
		} finally {
			cleanup();
			writable.off("drain", resume);
		}
	}
	async function pumpToWeb(readable, writable, finish, { end }) {
		if (isTransformStream(writable)) writable = writable.writable;
		const writer = writable.getWriter();
		try {
			for await (const chunk of readable) {
				await writer.ready;
				writer.write(chunk).catch(() => {});
			}
			await writer.ready;
			if (end) await writer.close();
			finish();
		} catch (err) {
			try {
				await writer.abort(err);
				finish(err);
			} catch (err$1) {
				finish(err$1);
			}
		}
	}
	function pipeline(...streams) {
		return pipelineImpl(streams, once(popCallback(streams)));
	}
	function pipelineImpl(streams, callback, opts) {
		if (streams.length === 1 && ArrayIsArray(streams[0])) streams = streams[0];
		if (streams.length < 2) throw new ERR_MISSING_ARGS("streams");
		const ac = new AbortController();
		const signal = ac.signal;
		const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
		const lastStreamCleanup = [];
		validateAbortSignal(outerSignal, "options.signal");
		function abort() {
			finishImpl(new AbortError());
		}
		addAbortListener = addAbortListener || require_util$2().addAbortListener;
		let disposable;
		if (outerSignal) disposable = addAbortListener(outerSignal, abort);
		let error;
		let value$1;
		const destroys = [];
		let finishCount = 0;
		function finish(err) {
			finishImpl(err, --finishCount === 0);
		}
		function finishImpl(err, final) {
			var _disposable;
			if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) error = err;
			if (!error && !final) return;
			while (destroys.length) destroys.shift()(error);
			(_disposable = disposable) === null || _disposable === void 0 || _disposable[SymbolDispose]();
			ac.abort();
			if (final) {
				if (!error) lastStreamCleanup.forEach((fn) => fn());
				process.nextTick(callback, error, value$1);
			}
		}
		let ret;
		for (let i = 0; i < streams.length; i++) {
			const stream$5 = streams[i];
			const reading = i < streams.length - 1;
			const writing = i > 0;
			const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
			const isLastStream = i === streams.length - 1;
			if (isNodeStream(stream$5)) {
				if (end) {
					const { destroy, cleanup } = destroyer(stream$5, reading, writing);
					destroys.push(destroy);
					if (isReadable(stream$5) && isLastStream) lastStreamCleanup.push(cleanup);
				}
				function onError(err) {
					if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") finish(err);
				}
				stream$5.on("error", onError);
				if (isReadable(stream$5) && isLastStream) lastStreamCleanup.push(() => {
					stream$5.removeListener("error", onError);
				});
			}
			if (i === 0) if (typeof stream$5 === "function") {
				ret = stream$5({ signal });
				if (!isIterable(ret)) throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
			} else if (isIterable(stream$5) || isReadableNodeStream(stream$5) || isTransformStream(stream$5)) ret = stream$5;
			else ret = Duplex.from(stream$5);
			else if (typeof stream$5 === "function") {
				if (isTransformStream(ret)) {
					var _ret;
					ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
				} else ret = makeAsyncIterable(ret);
				ret = stream$5(ret, { signal });
				if (reading) {
					if (!isIterable(ret, true)) throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
				} else {
					var _ret2;
					if (!PassThrough) PassThrough = require_passthrough();
					const pt = new PassThrough({ objectMode: true });
					const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
					if (typeof then === "function") {
						finishCount++;
						then.call(ret, (val) => {
							value$1 = val;
							if (val != null) pt.write(val);
							if (end) pt.end();
							process.nextTick(finish);
						}, (err) => {
							pt.destroy(err);
							process.nextTick(finish, err);
						});
					} else if (isIterable(ret, true)) {
						finishCount++;
						pumpToNode(ret, pt, finish, { end });
					} else if (isReadableStream(ret) || isTransformStream(ret)) {
						const toRead = ret.readable || ret;
						finishCount++;
						pumpToNode(toRead, pt, finish, { end });
					} else throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
					ret = pt;
					const { destroy, cleanup } = destroyer(ret, false, true);
					destroys.push(destroy);
					if (isLastStream) lastStreamCleanup.push(cleanup);
				}
			} else if (isNodeStream(stream$5)) {
				if (isReadableNodeStream(ret)) {
					finishCount += 2;
					const cleanup = pipe(ret, stream$5, finish, { end });
					if (isReadable(stream$5) && isLastStream) lastStreamCleanup.push(cleanup);
				} else if (isTransformStream(ret) || isReadableStream(ret)) {
					const toRead = ret.readable || ret;
					finishCount++;
					pumpToNode(toRead, stream$5, finish, { end });
				} else if (isIterable(ret)) {
					finishCount++;
					pumpToNode(ret, stream$5, finish, { end });
				} else throw new ERR_INVALID_ARG_TYPE("val", [
					"Readable",
					"Iterable",
					"AsyncIterable",
					"ReadableStream",
					"TransformStream"
				], ret);
				ret = stream$5;
			} else if (isWebStream(stream$5)) {
				if (isReadableNodeStream(ret)) {
					finishCount++;
					pumpToWeb(makeAsyncIterable(ret), stream$5, finish, { end });
				} else if (isReadableStream(ret) || isIterable(ret)) {
					finishCount++;
					pumpToWeb(ret, stream$5, finish, { end });
				} else if (isTransformStream(ret)) {
					finishCount++;
					pumpToWeb(ret.readable, stream$5, finish, { end });
				} else throw new ERR_INVALID_ARG_TYPE("val", [
					"Readable",
					"Iterable",
					"AsyncIterable",
					"ReadableStream",
					"TransformStream"
				], ret);
				ret = stream$5;
			} else ret = Duplex.from(stream$5);
		}
		if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) process.nextTick(abort);
		return ret;
	}
	function pipe(src, dst, finish, { end }) {
		let ended = false;
		dst.on("close", () => {
			if (!ended) finish(new ERR_STREAM_PREMATURE_CLOSE());
		});
		src.pipe(dst, { end: false });
		if (end) {
			function endFn() {
				ended = true;
				dst.end();
			}
			if (isReadableFinished(src)) process.nextTick(endFn);
			else src.once("end", endFn);
		} else finish();
		eos(src, {
			readable: true,
			writable: false
		}, (err) => {
			const rState = src._readableState;
			if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) src.once("end", finish).once("error", finish);
			else finish(err);
		});
		return eos(dst, {
			readable: false,
			writable: true
		}, finish);
	}
	module.exports = {
		pipelineImpl,
		pipeline
	};
}));
var require_compose = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { pipeline } = require_pipeline();
	var Duplex = require_duplex();
	var { destroyer } = require_destroy();
	var { isNodeStream, isReadable, isWritable, isWebStream, isTransformStream, isWritableStream, isReadableStream } = require_utils();
	var { AbortError, codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS } } = require_errors$1();
	var eos = require_end_of_stream();
	module.exports = function compose$1(...streams) {
		if (streams.length === 0) throw new ERR_MISSING_ARGS("streams");
		if (streams.length === 1) return Duplex.from(streams[0]);
		const orgStreams = [...streams];
		if (typeof streams[0] === "function") streams[0] = Duplex.from(streams[0]);
		if (typeof streams[streams.length - 1] === "function") {
			const idx = streams.length - 1;
			streams[idx] = Duplex.from(streams[idx]);
		}
		for (let n$1 = 0; n$1 < streams.length; ++n$1) {
			if (!isNodeStream(streams[n$1]) && !isWebStream(streams[n$1])) continue;
			if (n$1 < streams.length - 1 && !(isReadable(streams[n$1]) || isReadableStream(streams[n$1]) || isTransformStream(streams[n$1]))) throw new ERR_INVALID_ARG_VALUE(`streams[${n$1}]`, orgStreams[n$1], "must be readable");
			if (n$1 > 0 && !(isWritable(streams[n$1]) || isWritableStream(streams[n$1]) || isTransformStream(streams[n$1]))) throw new ERR_INVALID_ARG_VALUE(`streams[${n$1}]`, orgStreams[n$1], "must be writable");
		}
		let ondrain;
		let onfinish;
		let onreadable;
		let onclose;
		let d;
		function onfinished(err) {
			const cb = onclose;
			onclose = null;
			if (cb) cb(err);
			else if (err) d.destroy(err);
			else if (!readable && !writable) d.destroy();
		}
		const head = streams[0];
		const tail = pipeline(streams, onfinished);
		const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
		const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
		d = new Duplex({
			writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
			readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
			writable,
			readable
		});
		if (writable) {
			if (isNodeStream(head)) {
				d._write = function(chunk, encoding, callback) {
					if (head.write(chunk, encoding)) callback();
					else ondrain = callback;
				};
				d._final = function(callback) {
					head.end();
					onfinish = callback;
				};
				head.on("drain", function() {
					if (ondrain) {
						const cb = ondrain;
						ondrain = null;
						cb();
					}
				});
			} else if (isWebStream(head)) {
				const writer = (isTransformStream(head) ? head.writable : head).getWriter();
				d._write = async function(chunk, encoding, callback) {
					try {
						await writer.ready;
						writer.write(chunk).catch(() => {});
						callback();
					} catch (err) {
						callback(err);
					}
				};
				d._final = async function(callback) {
					try {
						await writer.ready;
						writer.close().catch(() => {});
						onfinish = callback;
					} catch (err) {
						callback(err);
					}
				};
			}
			eos(isTransformStream(tail) ? tail.readable : tail, () => {
				if (onfinish) {
					const cb = onfinish;
					onfinish = null;
					cb();
				}
			});
		}
		if (readable) {
			if (isNodeStream(tail)) {
				tail.on("readable", function() {
					if (onreadable) {
						const cb = onreadable;
						onreadable = null;
						cb();
					}
				});
				tail.on("end", function() {
					d.push(null);
				});
				d._read = function() {
					while (true) {
						const buf = tail.read();
						if (buf === null) {
							onreadable = d._read;
							return;
						}
						if (!d.push(buf)) return;
					}
				};
			} else if (isWebStream(tail)) {
				const reader = (isTransformStream(tail) ? tail.readable : tail).getReader();
				d._read = async function() {
					while (true) try {
						const { value: value$1, done } = await reader.read();
						if (!d.push(value$1)) return;
						if (done) {
							d.push(null);
							return;
						}
					} catch {
						return;
					}
				};
			}
		}
		d._destroy = function(err, callback) {
			if (!err && onclose !== null) err = new AbortError();
			onreadable = null;
			ondrain = null;
			onfinish = null;
			if (onclose === null) callback(err);
			else {
				onclose = callback;
				if (isNodeStream(tail)) destroyer(tail, err);
			}
		};
		return d;
	};
}));
var require_operators = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var AbortController = globalThis.AbortController || (init_abort_controller(), __toCommonJS(abort_controller_exports)).AbortController;
	var { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE }, AbortError } = require_errors$1();
	var { validateAbortSignal, validateInteger, validateObject } = require_validators();
	var kWeakHandler = require_primordials().Symbol("kWeak");
	var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
	var { finished } = require_end_of_stream();
	var staticCompose = require_compose();
	var { addAbortSignalNoValidate } = require_add_abort_signal();
	var { isWritable, isNodeStream } = require_utils();
	var { deprecate } = require_util$2();
	var { ArrayPrototypePush, Boolean, MathFloor, Number, NumberIsNaN, Promise, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol } = require_primordials();
	var kEmpty = Symbol("kEmpty");
	var kEof = Symbol("kEof");
	function compose(stream$5, options) {
		if (options != null) validateObject(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		if (isNodeStream(stream$5) && !isWritable(stream$5)) throw new ERR_INVALID_ARG_VALUE("stream", stream$5, "must be writable");
		const composedStream = staticCompose(this, stream$5);
		if (options !== null && options !== void 0 && options.signal) addAbortSignalNoValidate(options.signal, composedStream);
		return composedStream;
	}
	function map(fn, options) {
		if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
		if (options != null) validateObject(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		let concurrency = 1;
		if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) concurrency = MathFloor(options.concurrency);
		let highWaterMark = concurrency - 1;
		if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) highWaterMark = MathFloor(options.highWaterMark);
		validateInteger(concurrency, "options.concurrency", 1);
		validateInteger(highWaterMark, "options.highWaterMark", 0);
		highWaterMark += concurrency;
		return async function* map$6() {
			const signal = require_util$2().AbortSignalAny([options === null || options === void 0 ? void 0 : options.signal].filter(Boolean));
			const stream$5 = this;
			const queue$2 = [];
			const signalOpt = { signal };
			let next;
			let resume;
			let done = false;
			let cnt = 0;
			function onCatch() {
				done = true;
				afterItemProcessed();
			}
			function afterItemProcessed() {
				cnt -= 1;
				maybeResume();
			}
			function maybeResume() {
				if (resume && !done && cnt < concurrency && queue$2.length < highWaterMark) {
					resume();
					resume = null;
				}
			}
			async function pump() {
				try {
					for await (let val of stream$5) {
						if (done) return;
						if (signal.aborted) throw new AbortError();
						try {
							val = fn(val, signalOpt);
							if (val === kEmpty) continue;
							val = PromiseResolve(val);
						} catch (err) {
							val = PromiseReject(err);
						}
						cnt += 1;
						PromisePrototypeThen(val, afterItemProcessed, onCatch);
						queue$2.push(val);
						if (next) {
							next();
							next = null;
						}
						if (!done && (queue$2.length >= highWaterMark || cnt >= concurrency)) await new Promise((resolve$1) => {
							resume = resolve$1;
						});
					}
					queue$2.push(kEof);
				} catch (err) {
					const val = PromiseReject(err);
					PromisePrototypeThen(val, afterItemProcessed, onCatch);
					queue$2.push(val);
				} finally {
					done = true;
					if (next) {
						next();
						next = null;
					}
				}
			}
			pump();
			try {
				while (true) {
					while (queue$2.length > 0) {
						const val = await queue$2[0];
						if (val === kEof) return;
						if (signal.aborted) throw new AbortError();
						if (val !== kEmpty) yield val;
						queue$2.shift();
						maybeResume();
					}
					await new Promise((resolve$1) => {
						next = resolve$1;
					});
				}
			} finally {
				done = true;
				if (resume) {
					resume();
					resume = null;
				}
			}
		}.call(this);
	}
	function asIndexedPairs(options = void 0) {
		if (options != null) validateObject(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		return async function* asIndexedPairs() {
			let index$1 = 0;
			for await (const val of this) {
				var _options$signal;
				if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) throw new AbortError({ cause: options.signal.reason });
				yield [index$1++, val];
			}
		}.call(this);
	}
	async function some(fn, options = void 0) {
		for await (const unused of filter.call(this, fn, options)) return true;
		return false;
	}
	async function every(fn, options = void 0) {
		if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
		return !await some.call(this, async (...args) => {
			return !await fn(...args);
		}, options);
	}
	async function find(fn, options) {
		for await (const result of filter.call(this, fn, options)) return result;
	}
	async function forEach(fn, options) {
		if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
		async function forEachFn(value$1, options$1) {
			await fn(value$1, options$1);
			return kEmpty;
		}
		for await (const unused of map.call(this, forEachFn, options));
	}
	function filter(fn, options) {
		if (typeof fn !== "function") throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
		async function filterFn(value$1, options$1) {
			if (await fn(value$1, options$1)) return value$1;
			return kEmpty;
		}
		return map.call(this, filterFn, options);
	}
	var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
		constructor() {
			super("reduce");
			this.message = "Reduce of an empty stream requires an initial value";
		}
	};
	async function reduce(reducer, initialValue, options) {
		var _options$signal2;
		if (typeof reducer !== "function") throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
		if (options != null) validateObject(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		let hasInitialValue = arguments.length > 1;
		if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
			const err = new AbortError(void 0, { cause: options.signal.reason });
			this.once("error", () => {});
			await finished(this.destroy(err));
			throw err;
		}
		const ac = new AbortController();
		const signal = ac.signal;
		if (options !== null && options !== void 0 && options.signal) {
			const opts = {
				once: true,
				[kWeakHandler]: this,
				[kResistStopPropagation]: true
			};
			options.signal.addEventListener("abort", () => ac.abort(), opts);
		}
		let gotAnyItemFromStream = false;
		try {
			for await (const value$1 of this) {
				var _options$signal3;
				gotAnyItemFromStream = true;
				if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) throw new AbortError();
				if (!hasInitialValue) {
					initialValue = value$1;
					hasInitialValue = true;
				} else initialValue = await reducer(initialValue, value$1, { signal });
			}
			if (!gotAnyItemFromStream && !hasInitialValue) throw new ReduceAwareErrMissingArgs();
		} finally {
			ac.abort();
		}
		return initialValue;
	}
	async function toArray(options) {
		if (options != null) validateObject(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		const result = [];
		for await (const val of this) {
			var _options$signal4;
			if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) throw new AbortError(void 0, { cause: options.signal.reason });
			ArrayPrototypePush(result, val);
		}
		return result;
	}
	function flatMap(fn, options) {
		const values = map.call(this, fn, options);
		return async function* flatMap$4() {
			for await (const val of values) yield* val;
		}.call(this);
	}
	function toIntegerOrInfinity(number) {
		number = Number(number);
		if (NumberIsNaN(number)) return 0;
		if (number < 0) throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
		return number;
	}
	function drop(number, options = void 0) {
		if (options != null) validateObject(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		number = toIntegerOrInfinity(number);
		return async function* drop() {
			var _options$signal5;
			if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) throw new AbortError();
			for await (const val of this) {
				var _options$signal6;
				if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) throw new AbortError();
				if (number-- <= 0) yield val;
			}
		}.call(this);
	}
	function take(number, options = void 0) {
		if (options != null) validateObject(options, "options");
		if ((options === null || options === void 0 ? void 0 : options.signal) != null) validateAbortSignal(options.signal, "options.signal");
		number = toIntegerOrInfinity(number);
		return async function* take() {
			var _options$signal7;
			if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) throw new AbortError();
			for await (const val of this) {
				var _options$signal8;
				if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) throw new AbortError();
				if (number-- > 0) yield val;
				if (number <= 0) return;
			}
		}.call(this);
	}
	module.exports.streamReturningOperators = {
		asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
		drop,
		filter,
		flatMap,
		map,
		take,
		compose
	};
	module.exports.promiseReturningOperators = {
		every,
		forEach,
		reduce,
		toArray,
		some,
		find
	};
}));
var require_promises = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { ArrayPrototypePop, Promise } = require_primordials();
	var { isIterable, isNodeStream, isWebStream } = require_utils();
	var { pipelineImpl: pl } = require_pipeline();
	var { finished } = require_end_of_stream();
	require_stream();
	function pipeline(...streams) {
		return new Promise((resolve$1, reject$3) => {
			let signal;
			let end;
			const lastArg = streams[streams.length - 1];
			if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
				const options = ArrayPrototypePop(streams);
				signal = options.signal;
				end = options.end;
			}
			pl(streams, (err, value$1) => {
				if (err) reject$3(err);
				else resolve$1(value$1);
			}, {
				signal,
				end
			});
		});
	}
	module.exports = {
		finished,
		pipeline
	};
}));
var require_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Buffer: Buffer$1 } = __require("buffer");
	var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
	var { promisify: { custom: customPromisify } } = require_util$2();
	var { streamReturningOperators, promiseReturningOperators } = require_operators();
	var { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = require_errors$1();
	var compose = require_compose();
	var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
	var { pipeline } = require_pipeline();
	var { destroyer } = require_destroy();
	var eos = require_end_of_stream();
	var promises = require_promises();
	var utils = require_utils();
	var Stream = module.exports = require_legacy().Stream;
	Stream.isDestroyed = utils.isDestroyed;
	Stream.isDisturbed = utils.isDisturbed;
	Stream.isErrored = utils.isErrored;
	Stream.isReadable = utils.isReadable;
	Stream.isWritable = utils.isWritable;
	Stream.Readable = require_readable();
	for (const key of ObjectKeys(streamReturningOperators)) {
		const op = streamReturningOperators[key];
		function fn(...args) {
			if (new.target) throw ERR_ILLEGAL_CONSTRUCTOR();
			return Stream.Readable.from(ReflectApply(op, this, args));
		}
		ObjectDefineProperty(fn, "name", {
			__proto__: null,
			value: op.name
		});
		ObjectDefineProperty(fn, "length", {
			__proto__: null,
			value: op.length
		});
		ObjectDefineProperty(Stream.Readable.prototype, key, {
			__proto__: null,
			value: fn,
			enumerable: false,
			configurable: true,
			writable: true
		});
	}
	for (const key of ObjectKeys(promiseReturningOperators)) {
		const op = promiseReturningOperators[key];
		function fn(...args) {
			if (new.target) throw ERR_ILLEGAL_CONSTRUCTOR();
			return ReflectApply(op, this, args);
		}
		ObjectDefineProperty(fn, "name", {
			__proto__: null,
			value: op.name
		});
		ObjectDefineProperty(fn, "length", {
			__proto__: null,
			value: op.length
		});
		ObjectDefineProperty(Stream.Readable.prototype, key, {
			__proto__: null,
			value: fn,
			enumerable: false,
			configurable: true,
			writable: true
		});
	}
	Stream.Writable = require_writable();
	Stream.Duplex = require_duplex();
	Stream.Transform = require_transform();
	Stream.PassThrough = require_passthrough();
	Stream.pipeline = pipeline;
	var { addAbortSignal } = require_add_abort_signal();
	Stream.addAbortSignal = addAbortSignal;
	Stream.finished = eos;
	Stream.destroy = destroyer;
	Stream.compose = compose;
	Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
	Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
	ObjectDefineProperty(Stream, "promises", {
		__proto__: null,
		configurable: true,
		enumerable: true,
		get() {
			return promises;
		}
	});
	ObjectDefineProperty(pipeline, customPromisify, {
		__proto__: null,
		enumerable: true,
		get() {
			return promises.pipeline;
		}
	});
	ObjectDefineProperty(eos, customPromisify, {
		__proto__: null,
		enumerable: true,
		get() {
			return promises.finished;
		}
	});
	Stream.Stream = Stream;
	Stream._isUint8Array = function isUint8Array(value$1) {
		return value$1 instanceof Uint8Array;
	};
	Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
		return Buffer$1.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
	};
}));
var require_ours = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stream$1 = __require("stream");
	if (Stream$1 && process.env.READABLE_STREAM === "disable") {
		const promises = Stream$1.promises;
		module.exports._uint8ArrayToBuffer = Stream$1._uint8ArrayToBuffer;
		module.exports._isUint8Array = Stream$1._isUint8Array;
		module.exports.isDisturbed = Stream$1.isDisturbed;
		module.exports.isErrored = Stream$1.isErrored;
		module.exports.isReadable = Stream$1.isReadable;
		module.exports.Readable = Stream$1.Readable;
		module.exports.Writable = Stream$1.Writable;
		module.exports.Duplex = Stream$1.Duplex;
		module.exports.Transform = Stream$1.Transform;
		module.exports.PassThrough = Stream$1.PassThrough;
		module.exports.addAbortSignal = Stream$1.addAbortSignal;
		module.exports.finished = Stream$1.finished;
		module.exports.destroy = Stream$1.destroy;
		module.exports.pipeline = Stream$1.pipeline;
		module.exports.compose = Stream$1.compose;
		Object.defineProperty(Stream$1, "promises", {
			configurable: true,
			enumerable: true,
			get() {
				return promises;
			}
		});
		module.exports.Stream = Stream$1.Stream;
	} else {
		const CustomStream = require_stream();
		const promises = require_promises();
		const originalDestroy = CustomStream.Readable.destroy;
		module.exports = CustomStream.Readable;
		module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
		module.exports._isUint8Array = CustomStream._isUint8Array;
		module.exports.isDisturbed = CustomStream.isDisturbed;
		module.exports.isErrored = CustomStream.isErrored;
		module.exports.isReadable = CustomStream.isReadable;
		module.exports.Readable = CustomStream.Readable;
		module.exports.Writable = CustomStream.Writable;
		module.exports.Duplex = CustomStream.Duplex;
		module.exports.Transform = CustomStream.Transform;
		module.exports.PassThrough = CustomStream.PassThrough;
		module.exports.addAbortSignal = CustomStream.addAbortSignal;
		module.exports.finished = CustomStream.finished;
		module.exports.destroy = CustomStream.destroy;
		module.exports.destroy = originalDestroy;
		module.exports.pipeline = CustomStream.pipeline;
		module.exports.compose = CustomStream.compose;
		Object.defineProperty(CustomStream, "promises", {
			configurable: true,
			enumerable: true,
			get() {
				return promises;
			}
		});
		module.exports.Stream = CustomStream.Stream;
	}
	module.exports.default = module.exports;
}));
var require__arrayPush = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayPush(array, values) {
		var index$1 = -1, length = values.length, offset = array.length;
		while (++index$1 < length) array[offset + index$1] = values[index$1];
		return array;
	}
	module.exports = arrayPush;
}));
var require__isFlattenable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol = require__Symbol(), isArguments = require_isArguments(), isArray = require_isArray();
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : void 0;
	function isFlattenable(value$1) {
		return isArray(value$1) || isArguments(value$1) || !!(spreadableSymbol && value$1 && value$1[spreadableSymbol]);
	}
	module.exports = isFlattenable;
}));
var require__baseFlatten = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayPush = require__arrayPush(), isFlattenable = require__isFlattenable();
	function baseFlatten(array, depth, predicate, isStrict, result) {
		var index$1 = -1, length = array.length;
		predicate || (predicate = isFlattenable);
		result || (result = []);
		while (++index$1 < length) {
			var value$1 = array[index$1];
			if (depth > 0 && predicate(value$1)) if (depth > 1) baseFlatten(value$1, depth - 1, predicate, isStrict, result);
			else arrayPush(result, value$1);
			else if (!isStrict) result[result.length] = value$1;
		}
		return result;
	}
	module.exports = baseFlatten;
}));
var require_flatten = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFlatten = require__baseFlatten();
	function flatten(array) {
		return (array == null ? 0 : array.length) ? baseFlatten(array, 1) : [];
	}
	module.exports = flatten;
}));
var require__nativeCreate = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(Object, "create");
}));
var require__hashClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate = require__nativeCreate();
	function hashClear() {
		this.__data__ = nativeCreate ? nativeCreate(null) : {};
		this.size = 0;
	}
	module.exports = hashClear;
}));
var require__hashDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function hashDelete(key) {
		var result = this.has(key) && delete this.__data__[key];
		this.size -= result ? 1 : 0;
		return result;
	}
	module.exports = hashDelete;
}));
var require__hashGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate = require__nativeCreate();
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hashGet(key) {
		var data = this.__data__;
		if (nativeCreate) {
			var result = data[key];
			return result === HASH_UNDEFINED ? void 0 : result;
		}
		return hasOwnProperty.call(data, key) ? data[key] : void 0;
	}
	module.exports = hashGet;
}));
var require__hashHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate = require__nativeCreate();
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hashHas(key) {
		var data = this.__data__;
		return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
	}
	module.exports = hashHas;
}));
var require__hashSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate = require__nativeCreate();
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	function hashSet(key, value$1) {
		var data = this.__data__;
		this.size += this.has(key) ? 0 : 1;
		data[key] = nativeCreate && value$1 === void 0 ? HASH_UNDEFINED : value$1;
		return this;
	}
	module.exports = hashSet;
}));
var require__Hash = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hashClear = require__hashClear(), hashDelete = require__hashDelete(), hashGet = require__hashGet(), hashHas = require__hashHas(), hashSet = require__hashSet();
	function Hash(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	Hash.prototype.clear = hashClear;
	Hash.prototype["delete"] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	module.exports = Hash;
}));
var require__listCacheClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function listCacheClear() {
		this.__data__ = [];
		this.size = 0;
	}
	module.exports = listCacheClear;
}));
var require__assocIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var eq = require_eq();
	function assocIndexOf(array, key) {
		var length = array.length;
		while (length--) if (eq(array[length][0], key)) return length;
		return -1;
	}
	module.exports = assocIndexOf;
}));
var require__listCacheDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf = require__assocIndexOf();
	var splice = Array.prototype.splice;
	function listCacheDelete(key) {
		var data = this.__data__, index$1 = assocIndexOf(data, key);
		if (index$1 < 0) return false;
		if (index$1 == data.length - 1) data.pop();
		else splice.call(data, index$1, 1);
		--this.size;
		return true;
	}
	module.exports = listCacheDelete;
}));
var require__listCacheGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf = require__assocIndexOf();
	function listCacheGet(key) {
		var data = this.__data__, index$1 = assocIndexOf(data, key);
		return index$1 < 0 ? void 0 : data[index$1][1];
	}
	module.exports = listCacheGet;
}));
var require__listCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf = require__assocIndexOf();
	function listCacheHas(key) {
		return assocIndexOf(this.__data__, key) > -1;
	}
	module.exports = listCacheHas;
}));
var require__listCacheSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf = require__assocIndexOf();
	function listCacheSet(key, value$1) {
		var data = this.__data__, index$1 = assocIndexOf(data, key);
		if (index$1 < 0) {
			++this.size;
			data.push([key, value$1]);
		} else data[index$1][1] = value$1;
		return this;
	}
	module.exports = listCacheSet;
}));
var require__ListCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var listCacheClear = require__listCacheClear(), listCacheDelete = require__listCacheDelete(), listCacheGet = require__listCacheGet(), listCacheHas = require__listCacheHas(), listCacheSet = require__listCacheSet();
	function ListCache(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype["delete"] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	module.exports = ListCache;
}));
var require__Map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Map");
}));
var require__mapCacheClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Hash = require__Hash(), ListCache = require__ListCache(), Map = require__Map();
	function mapCacheClear() {
		this.size = 0;
		this.__data__ = {
			"hash": new Hash(),
			"map": new (Map || ListCache)(),
			"string": new Hash()
		};
	}
	module.exports = mapCacheClear;
}));
var require__isKeyable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isKeyable(value$1) {
		var type = typeof value$1;
		return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value$1 !== "__proto__" : value$1 === null;
	}
	module.exports = isKeyable;
}));
var require__getMapData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isKeyable = require__isKeyable();
	function getMapData(map$6, key) {
		var data = map$6.__data__;
		return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
	}
	module.exports = getMapData;
}));
var require__mapCacheDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData = require__getMapData();
	function mapCacheDelete(key) {
		var result = getMapData(this, key)["delete"](key);
		this.size -= result ? 1 : 0;
		return result;
	}
	module.exports = mapCacheDelete;
}));
var require__mapCacheGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData = require__getMapData();
	function mapCacheGet(key) {
		return getMapData(this, key).get(key);
	}
	module.exports = mapCacheGet;
}));
var require__mapCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData = require__getMapData();
	function mapCacheHas(key) {
		return getMapData(this, key).has(key);
	}
	module.exports = mapCacheHas;
}));
var require__mapCacheSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData = require__getMapData();
	function mapCacheSet(key, value$1) {
		var data = getMapData(this, key), size = data.size;
		data.set(key, value$1);
		this.size += data.size == size ? 0 : 1;
		return this;
	}
	module.exports = mapCacheSet;
}));
var require__MapCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var mapCacheClear = require__mapCacheClear(), mapCacheDelete = require__mapCacheDelete(), mapCacheGet = require__mapCacheGet(), mapCacheHas = require__mapCacheHas(), mapCacheSet = require__mapCacheSet();
	function MapCache(entries) {
		var index$1 = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index$1 < length) {
			var entry = entries[index$1];
			this.set(entry[0], entry[1]);
		}
	}
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype["delete"] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	module.exports = MapCache;
}));
var require__setCacheAdd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	function setCacheAdd(value$1) {
		this.__data__.set(value$1, HASH_UNDEFINED);
		return this;
	}
	module.exports = setCacheAdd;
}));
var require__setCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setCacheHas(value$1) {
		return this.__data__.has(value$1);
	}
	module.exports = setCacheHas;
}));
var require__SetCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MapCache = require__MapCache(), setCacheAdd = require__setCacheAdd(), setCacheHas = require__setCacheHas();
	function SetCache(values) {
		var index$1 = -1, length = values == null ? 0 : values.length;
		this.__data__ = new MapCache();
		while (++index$1 < length) this.add(values[index$1]);
	}
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	module.exports = SetCache;
}));
var require__baseFindIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
		var length = array.length, index$1 = fromIndex + (fromRight ? 1 : -1);
		while (fromRight ? index$1-- : ++index$1 < length) if (predicate(array[index$1], index$1, array)) return index$1;
		return -1;
	}
	module.exports = baseFindIndex;
}));
var require__baseIsNaN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseIsNaN(value$1) {
		return value$1 !== value$1;
	}
	module.exports = baseIsNaN;
}));
var require__strictIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function strictIndexOf(array, value$1, fromIndex) {
		var index$1 = fromIndex - 1, length = array.length;
		while (++index$1 < length) if (array[index$1] === value$1) return index$1;
		return -1;
	}
	module.exports = strictIndexOf;
}));
var require__baseIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFindIndex = require__baseFindIndex(), baseIsNaN = require__baseIsNaN(), strictIndexOf = require__strictIndexOf();
	function baseIndexOf(array, value$1, fromIndex) {
		return value$1 === value$1 ? strictIndexOf(array, value$1, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
	}
	module.exports = baseIndexOf;
}));
var require__arrayIncludes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIndexOf = require__baseIndexOf();
	function arrayIncludes(array, value$1) {
		return !!(array == null ? 0 : array.length) && baseIndexOf(array, value$1, 0) > -1;
	}
	module.exports = arrayIncludes;
}));
var require__arrayIncludesWith = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayIncludesWith(array, value$1, comparator) {
		var index$1 = -1, length = array == null ? 0 : array.length;
		while (++index$1 < length) if (comparator(value$1, array[index$1])) return true;
		return false;
	}
	module.exports = arrayIncludesWith;
}));
var require__arrayMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayMap(array, iteratee) {
		var index$1 = -1, length = array == null ? 0 : array.length, result = Array(length);
		while (++index$1 < length) result[index$1] = iteratee(array[index$1], index$1, array);
		return result;
	}
	module.exports = arrayMap;
}));
var require__cacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function cacheHas(cache, key) {
		return cache.has(key);
	}
	module.exports = cacheHas;
}));
var require__baseDifference = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SetCache = require__SetCache(), arrayIncludes = require__arrayIncludes(), arrayIncludesWith = require__arrayIncludesWith(), arrayMap = require__arrayMap(), baseUnary = require__baseUnary(), cacheHas = require__cacheHas();
	var LARGE_ARRAY_SIZE = 200;
	function baseDifference(array, values, iteratee, comparator) {
		var index$1 = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
		if (!length) return result;
		if (iteratee) values = arrayMap(values, baseUnary(iteratee));
		if (comparator) {
			includes = arrayIncludesWith;
			isCommon = false;
		} else if (values.length >= LARGE_ARRAY_SIZE) {
			includes = cacheHas;
			isCommon = false;
			values = new SetCache(values);
		}
		outer: while (++index$1 < length) {
			var value$1 = array[index$1], computed = iteratee == null ? value$1 : iteratee(value$1);
			value$1 = comparator || value$1 !== 0 ? value$1 : 0;
			if (isCommon && computed === computed) {
				var valuesIndex = valuesLength;
				while (valuesIndex--) if (values[valuesIndex] === computed) continue outer;
				result.push(value$1);
			} else if (!includes(values, computed, comparator)) result.push(value$1);
		}
		return result;
	}
	module.exports = baseDifference;
}));
var require_isArrayLikeObject = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isArrayLike = require_isArrayLike(), isObjectLike = require_isObjectLike();
	function isArrayLikeObject(value$1) {
		return isObjectLike(value$1) && isArrayLike(value$1);
	}
	module.exports = isArrayLikeObject;
}));
var require_difference = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseDifference = require__baseDifference(), baseFlatten = require__baseFlatten(), baseRest = require__baseRest(), isArrayLikeObject = require_isArrayLikeObject();
	module.exports = baseRest(function(array, values) {
		return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
	});
}));
var require__Set = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Set");
}));
var require_noop = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function noop() {}
	module.exports = noop;
}));
var require__setToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setToArray(set$1) {
		var index$1 = -1, result = Array(set$1.size);
		set$1.forEach(function(value$1) {
			result[++index$1] = value$1;
		});
		return result;
	}
	module.exports = setToArray;
}));
var require__createSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Set = require__Set(), noop = require_noop(), setToArray = require__setToArray();
	module.exports = !(Set && 1 / setToArray(new Set([, -0]))[1] == Infinity) ? noop : function(values) {
		return new Set(values);
	};
}));
var require__baseUniq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SetCache = require__SetCache(), arrayIncludes = require__arrayIncludes(), arrayIncludesWith = require__arrayIncludesWith(), cacheHas = require__cacheHas(), createSet = require__createSet(), setToArray = require__setToArray();
	var LARGE_ARRAY_SIZE = 200;
	function baseUniq(array, iteratee, comparator) {
		var index$1 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
		if (comparator) {
			isCommon = false;
			includes = arrayIncludesWith;
		} else if (length >= LARGE_ARRAY_SIZE) {
			var set$1 = iteratee ? null : createSet(array);
			if (set$1) return setToArray(set$1);
			isCommon = false;
			includes = cacheHas;
			seen = new SetCache();
		} else seen = iteratee ? [] : result;
		outer: while (++index$1 < length) {
			var value$1 = array[index$1], computed = iteratee ? iteratee(value$1) : value$1;
			value$1 = comparator || value$1 !== 0 ? value$1 : 0;
			if (isCommon && computed === computed) {
				var seenIndex = seen.length;
				while (seenIndex--) if (seen[seenIndex] === computed) continue outer;
				if (iteratee) seen.push(computed);
				result.push(value$1);
			} else if (!includes(seen, computed, comparator)) {
				if (seen !== result) seen.push(computed);
				result.push(value$1);
			}
		}
		return result;
	}
	module.exports = baseUniq;
}));
var require_union = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFlatten = require__baseFlatten(), baseRest = require__baseRest(), baseUniq = require__baseUniq(), isArrayLikeObject = require_isArrayLikeObject();
	module.exports = baseRest(function(arrays) {
		return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	});
}));
var require__overArg = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function overArg(func, transform$1) {
		return function(arg) {
			return func(transform$1(arg));
		};
	}
	module.exports = overArg;
}));
var require__getPrototype = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__overArg()(Object.getPrototypeOf, Object);
}));
var require_isPlainObject = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag = require__baseGetTag(), getPrototype = require__getPrototype(), isObjectLike = require_isObjectLike();
	var objectTag = "[object Object]";
	var funcProto = Function.prototype, objectProto = Object.prototype;
	var funcToString = funcProto.toString;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var objectCtorString = funcToString.call(Object);
	function isPlainObject(value$1) {
		if (!isObjectLike(value$1) || baseGetTag(value$1) != objectTag) return false;
		var proto = getPrototype(value$1);
		if (proto === null) return true;
		var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	module.exports = isPlainObject;
}));
var require_brace_expansion = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var balanced = require_balanced_match();
	module.exports = expandTop;
	var escSlash = "\0SLASH" + Math.random() + "\0";
	var escOpen = "\0OPEN" + Math.random() + "\0";
	var escClose = "\0CLOSE" + Math.random() + "\0";
	var escComma = "\0COMMA" + Math.random() + "\0";
	var escPeriod = "\0PERIOD" + Math.random() + "\0";
	function numeric(str) {
		return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
	}
	function escapeBraces(str) {
		return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
	}
	function unescapeBraces(str) {
		return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
	}
	function parseCommaParts(str) {
		if (!str) return [""];
		var parts = [];
		var m = balanced("{", "}", str);
		if (!m) return str.split(",");
		var pre = m.pre;
		var body = m.body;
		var post = m.post;
		var p = pre.split(",");
		p[p.length - 1] += "{" + body + "}";
		var postParts = parseCommaParts(post);
		if (post.length) {
			p[p.length - 1] += postParts.shift();
			p.push.apply(p, postParts);
		}
		parts.push.apply(parts, p);
		return parts;
	}
	function expandTop(str) {
		if (!str) return [];
		if (str.substr(0, 2) === "{}") str = "\\{\\}" + str.substr(2);
		return expand(escapeBraces(str), true).map(unescapeBraces);
	}
	function embrace(str) {
		return "{" + str + "}";
	}
	function isPadded(el) {
		return /^-?0\d/.test(el);
	}
	function lte(i, y) {
		return i <= y;
	}
	function gte(i, y) {
		return i >= y;
	}
	function expand(str, isTop) {
		var expansions = [];
		var m = balanced("{", "}", str);
		if (!m) return [str];
		var pre = m.pre;
		var post = m.post.length ? expand(m.post, false) : [""];
		if (/\$$/.test(m.pre)) for (var k = 0; k < post.length; k++) {
			var expansion = pre + "{" + m.body + "}" + post[k];
			expansions.push(expansion);
		}
		else {
			var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
			var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
			var isSequence = isNumericSequence || isAlphaSequence;
			var isOptions = m.body.indexOf(",") >= 0;
			if (!isSequence && !isOptions) {
				if (m.post.match(/,(?!,).*\}/)) {
					str = m.pre + "{" + m.body + escClose + m.post;
					return expand(str);
				}
				return [str];
			}
			var n$1;
			if (isSequence) n$1 = m.body.split(/\.\./);
			else {
				n$1 = parseCommaParts(m.body);
				if (n$1.length === 1) {
					n$1 = expand(n$1[0], false).map(embrace);
					if (n$1.length === 1) return post.map(function(p) {
						return m.pre + n$1[0] + p;
					});
				}
			}
			var N;
			if (isSequence) {
				var x = numeric(n$1[0]);
				var y = numeric(n$1[1]);
				var width = Math.max(n$1[0].length, n$1[1].length);
				var incr = n$1.length == 3 ? Math.abs(numeric(n$1[2])) : 1;
				var test = lte;
				if (y < x) {
					incr *= -1;
					test = gte;
				}
				var pad = n$1.some(isPadded);
				N = [];
				for (var i = x; test(i, y); i += incr) {
					var c;
					if (isAlphaSequence) {
						c = String.fromCharCode(i);
						if (c === "\\") c = "";
					} else {
						c = String(i);
						if (pad) {
							var need = width - c.length;
							if (need > 0) {
								var z = new Array(need + 1).join("0");
								if (i < 0) c = "-" + z + c.slice(1);
								else c = z + c;
							}
						}
					}
					N.push(c);
				}
			} else {
				N = [];
				for (var j = 0; j < n$1.length; j++) N.push.apply(N, expand(n$1[j], false));
			}
			for (var j = 0; j < N.length; j++) for (var k = 0; k < post.length; k++) {
				var expansion = pre + N[j] + post[k];
				if (!isTop || isSequence || expansion) expansions.push(expansion);
			}
		}
		return expansions;
	}
}));
var require_assert_valid_pattern = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.assertValidPattern = void 0;
	var MAX_PATTERN_LENGTH = 1024 * 64;
	var assertValidPattern = (pattern$1) => {
		if (typeof pattern$1 !== "string") throw new TypeError("invalid pattern");
		if (pattern$1.length > MAX_PATTERN_LENGTH) throw new TypeError("pattern is too long");
	};
	exports.assertValidPattern = assertValidPattern;
}));
var require_brace_expressions = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseClass = void 0;
	var posixClasses = {
		"[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
		"[:alpha:]": ["\\p{L}\\p{Nl}", true],
		"[:ascii:]": ["\\x00-\\x7f", false],
		"[:blank:]": ["\\p{Zs}\\t", true],
		"[:cntrl:]": ["\\p{Cc}", true],
		"[:digit:]": ["\\p{Nd}", true],
		"[:graph:]": [
			"\\p{Z}\\p{C}",
			true,
			true
		],
		"[:lower:]": ["\\p{Ll}", true],
		"[:print:]": ["\\p{C}", true],
		"[:punct:]": ["\\p{P}", true],
		"[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
		"[:upper:]": ["\\p{Lu}", true],
		"[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
		"[:xdigit:]": ["A-Fa-f0-9", false]
	};
	var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
	var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	var rangesToString = (ranges) => ranges.join("");
	var parseClass = (glob, position) => {
		const pos = position;
		/* c8 ignore start */
		if (glob.charAt(pos) !== "[") throw new Error("not in a brace expression");
		/* c8 ignore stop */
		const ranges = [];
		const negs = [];
		let i = pos + 1;
		let sawStart = false;
		let uflag = false;
		let escaping = false;
		let negate = false;
		let endPos = pos;
		let rangeStart = "";
		WHILE: while (i < glob.length) {
			const c = glob.charAt(i);
			if ((c === "!" || c === "^") && i === pos + 1) {
				negate = true;
				i++;
				continue;
			}
			if (c === "]" && sawStart && !escaping) {
				endPos = i + 1;
				break;
			}
			sawStart = true;
			if (c === "\\") {
				if (!escaping) {
					escaping = true;
					i++;
					continue;
				}
			}
			if (c === "[" && !escaping) {
				for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) if (glob.startsWith(cls, i)) {
					if (rangeStart) return [
						"$.",
						false,
						glob.length - pos,
						true
					];
					i += cls.length;
					if (neg) negs.push(unip);
					else ranges.push(unip);
					uflag = uflag || u;
					continue WHILE;
				}
			}
			escaping = false;
			if (rangeStart) {
				if (c > rangeStart) ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
				else if (c === rangeStart) ranges.push(braceEscape(c));
				rangeStart = "";
				i++;
				continue;
			}
			if (glob.startsWith("-]", i + 1)) {
				ranges.push(braceEscape(c + "-"));
				i += 2;
				continue;
			}
			if (glob.startsWith("-", i + 1)) {
				rangeStart = c;
				i += 2;
				continue;
			}
			ranges.push(braceEscape(c));
			i++;
		}
		if (endPos < i) return [
			"",
			false,
			0,
			false
		];
		if (!ranges.length && !negs.length) return [
			"$.",
			false,
			glob.length - pos,
			true
		];
		if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) return [
			regexpEscape(ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]),
			false,
			endPos - pos,
			false
		];
		const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
		const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
		return [
			ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs,
			uflag,
			endPos - pos,
			true
		];
	};
	exports.parseClass = parseClass;
}));
var require_unescape = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.unescape = void 0;
	var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
		return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
	};
	exports.unescape = unescape;
}));
var require_ast = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AST = void 0;
	var brace_expressions_js_1 = require_brace_expressions();
	var unescape_js_1 = require_unescape();
	var types = new Set([
		"!",
		"?",
		"+",
		"*",
		"@"
	]);
	var isExtglobType = (c) => types.has(c);
	var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
	var startNoDot = "(?!\\.)";
	var addPatternStart = new Set(["[", "."]);
	var justDots = new Set(["..", "."]);
	var reSpecials = /* @__PURE__ */ new Set("().*{}+?[]^$\\!");
	var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	var qmark = "[^/]";
	var star = qmark + "*?";
	var starNoEmpty = qmark + "+?";
	exports.AST = class AST {
		type;
		#root;
		#hasMagic;
		#uflag = false;
		#parts = [];
		#parent;
		#parentIndex;
		#negs;
		#filledNegs = false;
		#options;
		#toString;
		#emptyExt = false;
		constructor(type, parent$1, options = {}) {
			this.type = type;
			if (type) this.#hasMagic = true;
			this.#parent = parent$1;
			this.#root = this.#parent ? this.#parent.#root : this;
			this.#options = this.#root === this ? options : this.#root.#options;
			this.#negs = this.#root === this ? [] : this.#root.#negs;
			if (type === "!" && !this.#root.#filledNegs) this.#negs.push(this);
			this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
		}
		get hasMagic() {
			/* c8 ignore start */
			if (this.#hasMagic !== void 0) return this.#hasMagic;
			/* c8 ignore stop */
			for (const p of this.#parts) {
				if (typeof p === "string") continue;
				if (p.type || p.hasMagic) return this.#hasMagic = true;
			}
			return this.#hasMagic;
		}
		toString() {
			if (this.#toString !== void 0) return this.#toString;
			if (!this.type) return this.#toString = this.#parts.map((p) => String(p)).join("");
			else return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
		}
		#fillNegs() {
			/* c8 ignore start */
			if (this !== this.#root) throw new Error("should only call on root");
			if (this.#filledNegs) return this;
			/* c8 ignore stop */
			this.toString();
			this.#filledNegs = true;
			let n$1;
			while (n$1 = this.#negs.pop()) {
				if (n$1.type !== "!") continue;
				let p = n$1;
				let pp = p.#parent;
				while (pp) {
					for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) for (const part of n$1.#parts) {
						/* c8 ignore start */
						if (typeof part === "string") throw new Error("string part in extglob AST??");
						/* c8 ignore stop */
						part.copyIn(pp.#parts[i]);
					}
					p = pp;
					pp = p.#parent;
				}
			}
			return this;
		}
		push(...parts) {
			for (const p of parts) {
				if (p === "") continue;
				/* c8 ignore start */
				if (typeof p !== "string" && !(p instanceof AST && p.#parent === this)) throw new Error("invalid part: " + p);
				/* c8 ignore stop */
				this.#parts.push(p);
			}
		}
		toJSON() {
			const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
			if (this.isStart() && !this.type) ret.unshift([]);
			if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) ret.push({});
			return ret;
		}
		isStart() {
			if (this.#root === this) return true;
			if (!this.#parent?.isStart()) return false;
			if (this.#parentIndex === 0) return true;
			const p = this.#parent;
			for (let i = 0; i < this.#parentIndex; i++) {
				const pp = p.#parts[i];
				if (!(pp instanceof AST && pp.type === "!")) return false;
			}
			return true;
		}
		isEnd() {
			if (this.#root === this) return true;
			if (this.#parent?.type === "!") return true;
			if (!this.#parent?.isEnd()) return false;
			if (!this.type) return this.#parent?.isEnd();
			/* c8 ignore start */
			const pl = this.#parent ? this.#parent.#parts.length : 0;
			/* c8 ignore stop */
			return this.#parentIndex === pl - 1;
		}
		copyIn(part) {
			if (typeof part === "string") this.push(part);
			else this.push(part.clone(this));
		}
		clone(parent$1) {
			const c = new AST(this.type, parent$1);
			for (const p of this.#parts) c.copyIn(p);
			return c;
		}
		static #parseAST(str, ast, pos, opt) {
			let escaping = false;
			let inBrace = false;
			let braceStart = -1;
			let braceNeg = false;
			if (ast.type === null) {
				let i$1 = pos;
				let acc$1 = "";
				while (i$1 < str.length) {
					const c = str.charAt(i$1++);
					if (escaping || c === "\\") {
						escaping = !escaping;
						acc$1 += c;
						continue;
					}
					if (inBrace) {
						if (i$1 === braceStart + 1) {
							if (c === "^" || c === "!") braceNeg = true;
						} else if (c === "]" && !(i$1 === braceStart + 2 && braceNeg)) inBrace = false;
						acc$1 += c;
						continue;
					} else if (c === "[") {
						inBrace = true;
						braceStart = i$1;
						braceNeg = false;
						acc$1 += c;
						continue;
					}
					if (!opt.noext && isExtglobType(c) && str.charAt(i$1) === "(") {
						ast.push(acc$1);
						acc$1 = "";
						const ext = new AST(c, ast);
						i$1 = AST.#parseAST(str, ext, i$1, opt);
						ast.push(ext);
						continue;
					}
					acc$1 += c;
				}
				ast.push(acc$1);
				return i$1;
			}
			let i = pos + 1;
			let part = new AST(null, ast);
			const parts = [];
			let acc = "";
			while (i < str.length) {
				const c = str.charAt(i++);
				if (escaping || c === "\\") {
					escaping = !escaping;
					acc += c;
					continue;
				}
				if (inBrace) {
					if (i === braceStart + 1) {
						if (c === "^" || c === "!") braceNeg = true;
					} else if (c === "]" && !(i === braceStart + 2 && braceNeg)) inBrace = false;
					acc += c;
					continue;
				} else if (c === "[") {
					inBrace = true;
					braceStart = i;
					braceNeg = false;
					acc += c;
					continue;
				}
				if (isExtglobType(c) && str.charAt(i) === "(") {
					part.push(acc);
					acc = "";
					const ext = new AST(c, part);
					part.push(ext);
					i = AST.#parseAST(str, ext, i, opt);
					continue;
				}
				if (c === "|") {
					part.push(acc);
					acc = "";
					parts.push(part);
					part = new AST(null, ast);
					continue;
				}
				if (c === ")") {
					if (acc === "" && ast.#parts.length === 0) ast.#emptyExt = true;
					part.push(acc);
					acc = "";
					ast.push(...parts, part);
					return i;
				}
				acc += c;
			}
			ast.type = null;
			ast.#hasMagic = void 0;
			ast.#parts = [str.substring(pos - 1)];
			return i;
		}
		static fromGlob(pattern$1, options = {}) {
			const ast = new AST(null, void 0, options);
			AST.#parseAST(pattern$1, ast, 0, options);
			return ast;
		}
		toMMPattern() {
			/* c8 ignore start */
			if (this !== this.#root) return this.#root.toMMPattern();
			/* c8 ignore stop */
			const glob = this.toString();
			const [re, body, hasMagic, uflag] = this.toRegExpSource();
			if (!(hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase())) return body;
			const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
			return Object.assign(new RegExp(`^${re}$`, flags), {
				_src: re,
				_glob: glob
			});
		}
		get options() {
			return this.#options;
		}
		toRegExpSource(allowDot) {
			const dot = allowDot ?? !!this.#options.dot;
			if (this.#root === this) this.#fillNegs();
			if (!this.type) {
				const noEmpty = this.isStart() && this.isEnd();
				const src = this.#parts.map((p) => {
					const [re, _$1, hasMagic, uflag] = typeof p === "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
					this.#hasMagic = this.#hasMagic || hasMagic;
					this.#uflag = this.#uflag || uflag;
					return re;
				}).join("");
				let start$1 = "";
				if (this.isStart()) {
					if (typeof this.#parts[0] === "string") {
						if (!(this.#parts.length === 1 && justDots.has(this.#parts[0]))) {
							const aps = addPatternStart;
							const needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4));
							const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
							start$1 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
						}
					}
				}
				let end = "";
				if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") end = "(?:$|\\/)";
				return [
					start$1 + src + end,
					(0, unescape_js_1.unescape)(src),
					this.#hasMagic = !!this.#hasMagic,
					this.#uflag
				];
			}
			const repeated = this.type === "*" || this.type === "+";
			const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
			let body = this.#partsToRegExp(dot);
			if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
				const s = this.toString();
				this.#parts = [s];
				this.type = null;
				this.#hasMagic = void 0;
				return [
					s,
					(0, unescape_js_1.unescape)(this.toString()),
					false,
					false
				];
			}
			let bodyDotAllowed = !repeated || allowDot || dot || false ? "" : this.#partsToRegExp(true);
			if (bodyDotAllowed === body) bodyDotAllowed = "";
			if (bodyDotAllowed) body = `(?:${body})(?:${bodyDotAllowed})*?`;
			let final = "";
			if (this.type === "!" && this.#emptyExt) final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
			else {
				const close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
				final = start + body + close;
			}
			return [
				final,
				(0, unescape_js_1.unescape)(body),
				this.#hasMagic = !!this.#hasMagic,
				this.#uflag
			];
		}
		#partsToRegExp(dot) {
			return this.#parts.map((p) => {
				/* c8 ignore start */
				if (typeof p === "string") throw new Error("string type in extglob ast??");
				/* c8 ignore stop */
				const [re, _$1, _hasMagic, uflag] = p.toRegExpSource(dot);
				this.#uflag = this.#uflag || uflag;
				return re;
			}).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
		}
		static #parseGlob(glob, hasMagic, noEmpty = false) {
			let escaping = false;
			let re = "";
			let uflag = false;
			for (let i = 0; i < glob.length; i++) {
				const c = glob.charAt(i);
				if (escaping) {
					escaping = false;
					re += (reSpecials.has(c) ? "\\" : "") + c;
					continue;
				}
				if (c === "\\") {
					if (i === glob.length - 1) re += "\\\\";
					else escaping = true;
					continue;
				}
				if (c === "[") {
					const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
					if (consumed) {
						re += src;
						uflag = uflag || needUflag;
						i += consumed - 1;
						hasMagic = hasMagic || magic;
						continue;
					}
				}
				if (c === "*") {
					if (noEmpty && glob === "*") re += starNoEmpty;
					else re += star;
					hasMagic = true;
					continue;
				}
				if (c === "?") {
					re += qmark;
					hasMagic = true;
					continue;
				}
				re += regExpEscape(c);
			}
			return [
				re,
				(0, unescape_js_1.unescape)(glob),
				!!hasMagic,
				uflag
			];
		}
	};
}));
var require_escape = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.escape = void 0;
	var escape = (s, { windowsPathsNoEscape = false } = {}) => {
		return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
	};
	exports.escape = escape;
}));
var require_commonjs$4 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
	var brace_expansion_1 = __importDefault(require_brace_expansion());
	var assert_valid_pattern_js_1 = require_assert_valid_pattern();
	var ast_js_1 = require_ast();
	var escape_js_1 = require_escape();
	var unescape_js_1 = require_unescape();
	var minimatch = (p, pattern$1, options = {}) => {
		(0, assert_valid_pattern_js_1.assertValidPattern)(pattern$1);
		if (!options.nocomment && pattern$1.charAt(0) === "#") return false;
		return new Minimatch(pattern$1, options).match(p);
	};
	exports.minimatch = minimatch;
	var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
	var starDotExtTest = (ext) => (f) => !f.startsWith(".") && f.endsWith(ext);
	var starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
	var starDotExtTestNocase = (ext) => {
		ext = ext.toLowerCase();
		return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext);
	};
	var starDotExtTestNocaseDot = (ext) => {
		ext = ext.toLowerCase();
		return (f) => f.toLowerCase().endsWith(ext);
	};
	var starDotStarRE = /^\*+\.\*+$/;
	var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
	var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
	var dotStarRE = /^\.\*+$/;
	var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
	var starRE = /^\*+$/;
	var starTest = (f) => f.length !== 0 && !f.startsWith(".");
	var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
	var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
	var qmarksTestNocase = ([$0, ext = ""]) => {
		const noext = qmarksTestNoExt([$0]);
		if (!ext) return noext;
		ext = ext.toLowerCase();
		return (f) => noext(f) && f.toLowerCase().endsWith(ext);
	};
	var qmarksTestNocaseDot = ([$0, ext = ""]) => {
		const noext = qmarksTestNoExtDot([$0]);
		if (!ext) return noext;
		ext = ext.toLowerCase();
		return (f) => noext(f) && f.toLowerCase().endsWith(ext);
	};
	var qmarksTestDot = ([$0, ext = ""]) => {
		const noext = qmarksTestNoExtDot([$0]);
		return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
	};
	var qmarksTest = ([$0, ext = ""]) => {
		const noext = qmarksTestNoExt([$0]);
		return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
	};
	var qmarksTestNoExt = ([$0]) => {
		const len = $0.length;
		return (f) => f.length === len && !f.startsWith(".");
	};
	var qmarksTestNoExtDot = ([$0]) => {
		const len = $0.length;
		return (f) => f.length === len && f !== "." && f !== "..";
	};
	/* c8 ignore start */
	var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
	var path = {
		win32: { sep: "\\" },
		posix: { sep: "/" }
	};
	/* c8 ignore stop */
	exports.sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
	exports.minimatch.sep = exports.sep;
	exports.GLOBSTAR = Symbol("globstar **");
	exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
	var star = "[^/]*?";
	var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
	var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
	var filter = (pattern$1, options = {}) => (p) => (0, exports.minimatch)(p, pattern$1, options);
	exports.filter = filter;
	exports.minimatch.filter = exports.filter;
	var ext = (a, b = {}) => Object.assign({}, a, b);
	var defaults = (def) => {
		if (!def || typeof def !== "object" || !Object.keys(def).length) return exports.minimatch;
		const orig = exports.minimatch;
		const m = (p, pattern$1, options = {}) => orig(p, pattern$1, ext(def, options));
		return Object.assign(m, {
			Minimatch: class Minimatch extends orig.Minimatch {
				constructor(pattern$1, options = {}) {
					super(pattern$1, ext(def, options));
				}
				static defaults(options) {
					return orig.defaults(ext(def, options)).Minimatch;
				}
			},
			AST: class AST extends orig.AST {
				/* c8 ignore start */
				constructor(type, parent$1, options = {}) {
					super(type, parent$1, ext(def, options));
				}
				/* c8 ignore stop */
				static fromGlob(pattern$1, options = {}) {
					return orig.AST.fromGlob(pattern$1, ext(def, options));
				}
			},
			unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
			escape: (s, options = {}) => orig.escape(s, ext(def, options)),
			filter: (pattern$1, options = {}) => orig.filter(pattern$1, ext(def, options)),
			defaults: (options) => orig.defaults(ext(def, options)),
			makeRe: (pattern$1, options = {}) => orig.makeRe(pattern$1, ext(def, options)),
			braceExpand: (pattern$1, options = {}) => orig.braceExpand(pattern$1, ext(def, options)),
			match: (list, pattern$1, options = {}) => orig.match(list, pattern$1, ext(def, options)),
			sep: orig.sep,
			GLOBSTAR: exports.GLOBSTAR
		});
	};
	exports.defaults = defaults;
	exports.minimatch.defaults = exports.defaults;
	var braceExpand = (pattern$1, options = {}) => {
		(0, assert_valid_pattern_js_1.assertValidPattern)(pattern$1);
		if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern$1)) return [pattern$1];
		return (0, brace_expansion_1.default)(pattern$1);
	};
	exports.braceExpand = braceExpand;
	exports.minimatch.braceExpand = exports.braceExpand;
	var makeRe = (pattern$1, options = {}) => new Minimatch(pattern$1, options).makeRe();
	exports.makeRe = makeRe;
	exports.minimatch.makeRe = exports.makeRe;
	var match = (list, pattern$1, options = {}) => {
		const mm = new Minimatch(pattern$1, options);
		list = list.filter((f) => mm.match(f));
		if (mm.options.nonull && !list.length) list.push(pattern$1);
		return list;
	};
	exports.match = match;
	exports.minimatch.match = exports.match;
	var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
	var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	var Minimatch = class {
		options;
		set;
		pattern;
		windowsPathsNoEscape;
		nonegate;
		negate;
		comment;
		empty;
		preserveMultipleSlashes;
		partial;
		globSet;
		globParts;
		nocase;
		isWindows;
		platform;
		windowsNoMagicRoot;
		regexp;
		constructor(pattern$1, options = {}) {
			(0, assert_valid_pattern_js_1.assertValidPattern)(pattern$1);
			options = options || {};
			this.options = options;
			this.pattern = pattern$1;
			this.platform = options.platform || defaultPlatform;
			this.isWindows = this.platform === "win32";
			this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
			if (this.windowsPathsNoEscape) this.pattern = this.pattern.replace(/\\/g, "/");
			this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
			this.regexp = null;
			this.negate = false;
			this.nonegate = !!options.nonegate;
			this.comment = false;
			this.empty = false;
			this.partial = !!options.partial;
			this.nocase = !!this.options.nocase;
			this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
			this.globSet = [];
			this.globParts = [];
			this.set = [];
			this.make();
		}
		hasMagic() {
			if (this.options.magicalBraces && this.set.length > 1) return true;
			for (const pattern$1 of this.set) for (const part of pattern$1) if (typeof part !== "string") return true;
			return false;
		}
		debug(..._$1) {}
		make() {
			const pattern$1 = this.pattern;
			const options = this.options;
			if (!options.nocomment && pattern$1.charAt(0) === "#") {
				this.comment = true;
				return;
			}
			if (!pattern$1) {
				this.empty = true;
				return;
			}
			this.parseNegate();
			this.globSet = [...new Set(this.braceExpand())];
			if (options.debug) this.debug = (...args) => console.error(...args);
			this.debug(this.pattern, this.globSet);
			const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
			this.globParts = this.preprocess(rawGlobParts);
			this.debug(this.pattern, this.globParts);
			let set$1 = this.globParts.map((s, _$1, __) => {
				if (this.isWindows && this.windowsNoMagicRoot) {
					const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
					const isDrive = /^[a-z]:/i.test(s[0]);
					if (isUNC) return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
					else if (isDrive) return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
				}
				return s.map((ss) => this.parse(ss));
			});
			this.debug(this.pattern, set$1);
			this.set = set$1.filter((s) => s.indexOf(false) === -1);
			if (this.isWindows) for (let i = 0; i < this.set.length; i++) {
				const p = this.set[i];
				if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) p[2] = "?";
			}
			this.debug(this.pattern, this.set);
		}
		preprocess(globParts) {
			if (this.options.noglobstar) {
				for (let i = 0; i < globParts.length; i++) for (let j = 0; j < globParts[i].length; j++) if (globParts[i][j] === "**") globParts[i][j] = "*";
			}
			const { optimizationLevel = 1 } = this.options;
			if (optimizationLevel >= 2) {
				globParts = this.firstPhasePreProcess(globParts);
				globParts = this.secondPhasePreProcess(globParts);
			} else if (optimizationLevel >= 1) globParts = this.levelOneOptimize(globParts);
			else globParts = this.adjascentGlobstarOptimize(globParts);
			return globParts;
		}
		adjascentGlobstarOptimize(globParts) {
			return globParts.map((parts) => {
				let gs = -1;
				while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
					let i = gs;
					while (parts[i + 1] === "**") i++;
					if (i !== gs) parts.splice(gs, i - gs);
				}
				return parts;
			});
		}
		levelOneOptimize(globParts) {
			return globParts.map((parts) => {
				parts = parts.reduce((set$1, part) => {
					const prev = set$1[set$1.length - 1];
					if (part === "**" && prev === "**") return set$1;
					if (part === "..") {
						if (prev && prev !== ".." && prev !== "." && prev !== "**") {
							set$1.pop();
							return set$1;
						}
					}
					set$1.push(part);
					return set$1;
				}, []);
				return parts.length === 0 ? [""] : parts;
			});
		}
		levelTwoFileOptimize(parts) {
			if (!Array.isArray(parts)) parts = this.slashSplit(parts);
			let didSomething = false;
			do {
				didSomething = false;
				if (!this.preserveMultipleSlashes) {
					for (let i = 1; i < parts.length - 1; i++) {
						const p = parts[i];
						if (i === 1 && p === "" && parts[0] === "") continue;
						if (p === "." || p === "") {
							didSomething = true;
							parts.splice(i, 1);
							i--;
						}
					}
					if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
						didSomething = true;
						parts.pop();
					}
				}
				let dd = 0;
				while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
					const p = parts[dd - 1];
					if (p && p !== "." && p !== ".." && p !== "**") {
						didSomething = true;
						parts.splice(dd - 1, 2);
						dd -= 2;
					}
				}
			} while (didSomething);
			return parts.length === 0 ? [""] : parts;
		}
		firstPhasePreProcess(globParts) {
			let didSomething = false;
			do {
				didSomething = false;
				for (let parts of globParts) {
					let gs = -1;
					while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
						let gss = gs;
						while (parts[gss + 1] === "**") gss++;
						if (gss > gs) parts.splice(gs + 1, gss - gs);
						let next = parts[gs + 1];
						const p = parts[gs + 2];
						const p2 = parts[gs + 3];
						if (next !== "..") continue;
						if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") continue;
						didSomething = true;
						parts.splice(gs, 1);
						const other = parts.slice(0);
						other[gs] = "**";
						globParts.push(other);
						gs--;
					}
					if (!this.preserveMultipleSlashes) {
						for (let i = 1; i < parts.length - 1; i++) {
							const p = parts[i];
							if (i === 1 && p === "" && parts[0] === "") continue;
							if (p === "." || p === "") {
								didSomething = true;
								parts.splice(i, 1);
								i--;
							}
						}
						if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
							didSomething = true;
							parts.pop();
						}
					}
					let dd = 0;
					while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
						const p = parts[dd - 1];
						if (p && p !== "." && p !== ".." && p !== "**") {
							didSomething = true;
							const splin = dd === 1 && parts[dd + 1] === "**" ? ["."] : [];
							parts.splice(dd - 1, 2, ...splin);
							if (parts.length === 0) parts.push("");
							dd -= 2;
						}
					}
				}
			} while (didSomething);
			return globParts;
		}
		secondPhasePreProcess(globParts) {
			for (let i = 0; i < globParts.length - 1; i++) for (let j = i + 1; j < globParts.length; j++) {
				const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
				if (matched) {
					globParts[i] = [];
					globParts[j] = matched;
					break;
				}
			}
			return globParts.filter((gs) => gs.length);
		}
		partsMatch(a, b, emptyGSMatch = false) {
			let ai = 0;
			let bi = 0;
			let result = [];
			let which = "";
			while (ai < a.length && bi < b.length) if (a[ai] === b[bi]) {
				result.push(which === "b" ? b[bi] : a[ai]);
				ai++;
				bi++;
			} else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
				result.push(a[ai]);
				ai++;
			} else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
				result.push(b[bi]);
				bi++;
			} else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
				if (which === "b") return false;
				which = "a";
				result.push(a[ai]);
				ai++;
				bi++;
			} else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
				if (which === "a") return false;
				which = "b";
				result.push(b[bi]);
				ai++;
				bi++;
			} else return false;
			return a.length === b.length && result;
		}
		parseNegate() {
			if (this.nonegate) return;
			const pattern$1 = this.pattern;
			let negate = false;
			let negateOffset = 0;
			for (let i = 0; i < pattern$1.length && pattern$1.charAt(i) === "!"; i++) {
				negate = !negate;
				negateOffset++;
			}
			if (negateOffset) this.pattern = pattern$1.slice(negateOffset);
			this.negate = negate;
		}
		matchOne(file, pattern$1, partial = false) {
			const options = this.options;
			if (this.isWindows) {
				const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
				const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
				const patternDrive = typeof pattern$1[0] === "string" && /^[a-z]:$/i.test(pattern$1[0]);
				const patternUNC = !patternDrive && pattern$1[0] === "" && pattern$1[1] === "" && pattern$1[2] === "?" && typeof pattern$1[3] === "string" && /^[a-z]:$/i.test(pattern$1[3]);
				const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
				const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
				if (typeof fdi === "number" && typeof pdi === "number") {
					const [fd, pd$1] = [file[fdi], pattern$1[pdi]];
					if (fd.toLowerCase() === pd$1.toLowerCase()) {
						pattern$1[pdi] = fd;
						if (pdi > fdi) pattern$1 = pattern$1.slice(pdi);
						else if (fdi > pdi) file = file.slice(fdi);
					}
				}
			}
			const { optimizationLevel = 1 } = this.options;
			if (optimizationLevel >= 2) file = this.levelTwoFileOptimize(file);
			this.debug("matchOne", this, {
				file,
				pattern: pattern$1
			});
			this.debug("matchOne", file.length, pattern$1.length);
			for (var fi = 0, pi = 0, fl = file.length, pl = pattern$1.length; fi < fl && pi < pl; fi++, pi++) {
				this.debug("matchOne loop");
				var p = pattern$1[pi];
				var f = file[fi];
				this.debug(pattern$1, p, f);
				/* c8 ignore start */
				if (p === false) return false;
				/* c8 ignore stop */
				if (p === exports.GLOBSTAR) {
					this.debug("GLOBSTAR", [
						pattern$1,
						p,
						f
					]);
					var fr = fi;
					var pr = pi + 1;
					if (pr === pl) {
						this.debug("** at the end");
						for (; fi < fl; fi++) if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
						return true;
					}
					while (fr < fl) {
						var swallowee = file[fr];
						this.debug("\nglobstar while", file, fr, pattern$1, pr, swallowee);
						if (this.matchOne(file.slice(fr), pattern$1.slice(pr), partial)) {
							this.debug("globstar found match!", fr, fl, swallowee);
							return true;
						} else {
							if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
								this.debug("dot detected!", file, fr, pattern$1, pr);
								break;
							}
							this.debug("globstar swallow a segment, and continue");
							fr++;
						}
					}
					/* c8 ignore start */
					if (partial) {
						this.debug("\n>>> no match, partial?", file, fr, pattern$1, pr);
						if (fr === fl) return true;
					}
					/* c8 ignore stop */
					return false;
				}
				let hit;
				if (typeof p === "string") {
					hit = f === p;
					this.debug("string match", p, f, hit);
				} else {
					hit = p.test(f);
					this.debug("pattern match", p, f, hit);
				}
				if (!hit) return false;
			}
			if (fi === fl && pi === pl) return true;
			else if (fi === fl) return partial;
			else if (pi === pl) return fi === fl - 1 && file[fi] === "";
			else throw new Error("wtf?");
			/* c8 ignore stop */
		}
		braceExpand() {
			return (0, exports.braceExpand)(this.pattern, this.options);
		}
		parse(pattern$1) {
			(0, assert_valid_pattern_js_1.assertValidPattern)(pattern$1);
			const options = this.options;
			if (pattern$1 === "**") return exports.GLOBSTAR;
			if (pattern$1 === "") return "";
			let m;
			let fastTest = null;
			if (m = pattern$1.match(starRE)) fastTest = options.dot ? starTestDot : starTest;
			else if (m = pattern$1.match(starDotExtRE)) fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
			else if (m = pattern$1.match(qmarksRE)) fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
			else if (m = pattern$1.match(starDotStarRE)) fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
			else if (m = pattern$1.match(dotStarRE)) fastTest = dotStarTest;
			const re = ast_js_1.AST.fromGlob(pattern$1, this.options).toMMPattern();
			if (fastTest && typeof re === "object") Reflect.defineProperty(re, "test", { value: fastTest });
			return re;
		}
		makeRe() {
			if (this.regexp || this.regexp === false) return this.regexp;
			const set$1 = this.set;
			if (!set$1.length) {
				this.regexp = false;
				return this.regexp;
			}
			const options = this.options;
			const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
			const flags = new Set(options.nocase ? ["i"] : []);
			let re = set$1.map((pattern$1) => {
				const pp = pattern$1.map((p) => {
					if (p instanceof RegExp) for (const f of p.flags.split("")) flags.add(f);
					return typeof p === "string" ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;
				});
				pp.forEach((p, i) => {
					const next = pp[i + 1];
					const prev = pp[i - 1];
					if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) return;
					if (prev === void 0) if (next !== void 0 && next !== exports.GLOBSTAR) pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
					else pp[i] = twoStar;
					else if (next === void 0) pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
					else if (next !== exports.GLOBSTAR) {
						pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
						pp[i + 1] = exports.GLOBSTAR;
					}
				});
				return pp.filter((p) => p !== exports.GLOBSTAR).join("/");
			}).join("|");
			const [open, close] = set$1.length > 1 ? ["(?:", ")"] : ["", ""];
			re = "^" + open + re + close + "$";
			if (this.negate) re = "^(?!" + re + ").+$";
			try {
				this.regexp = new RegExp(re, [...flags].join(""));
			} catch (ex) {
				this.regexp = false;
			}
			/* c8 ignore stop */
			return this.regexp;
		}
		slashSplit(p) {
			if (this.preserveMultipleSlashes) return p.split("/");
			else if (this.isWindows && /^\/\/[^\/]+/.test(p)) return ["", ...p.split(/\/+/)];
			else return p.split(/\/+/);
		}
		match(f, partial = this.partial) {
			this.debug("match", f, this.pattern);
			if (this.comment) return false;
			if (this.empty) return f === "";
			if (f === "/" && partial) return true;
			const options = this.options;
			if (this.isWindows) f = f.split("\\").join("/");
			const ff = this.slashSplit(f);
			this.debug(this.pattern, "split", ff);
			const set$1 = this.set;
			this.debug(this.pattern, "set", set$1);
			let filename = ff[ff.length - 1];
			if (!filename) for (let i = ff.length - 2; !filename && i >= 0; i--) filename = ff[i];
			for (let i = 0; i < set$1.length; i++) {
				const pattern$1 = set$1[i];
				let file = ff;
				if (options.matchBase && pattern$1.length === 1) file = [filename];
				if (this.matchOne(file, pattern$1, partial)) {
					if (options.flipNegate) return true;
					return !this.negate;
				}
			}
			if (options.flipNegate) return false;
			return this.negate;
		}
		static defaults(def) {
			return exports.minimatch.defaults(def).Minimatch;
		}
	};
	exports.Minimatch = Minimatch;
	/* c8 ignore start */
	var ast_js_2 = require_ast();
	Object.defineProperty(exports, "AST", {
		enumerable: true,
		get: function() {
			return ast_js_2.AST;
		}
	});
	var escape_js_2 = require_escape();
	Object.defineProperty(exports, "escape", {
		enumerable: true,
		get: function() {
			return escape_js_2.escape;
		}
	});
	var unescape_js_2 = require_unescape();
	Object.defineProperty(exports, "unescape", {
		enumerable: true,
		get: function() {
			return unescape_js_2.unescape;
		}
	});
	/* c8 ignore stop */
	exports.minimatch.AST = ast_js_1.AST;
	exports.minimatch.Minimatch = Minimatch;
	exports.minimatch.escape = escape_js_1.escape;
	exports.minimatch.unescape = unescape_js_1.unescape;
}));
var require_commonjs$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LRUCache = void 0;
	var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
	var warned = /* @__PURE__ */ new Set();
	/* c8 ignore start */
	var PROCESS = typeof process === "object" && !!process ? process : {};
	/* c8 ignore start */
	var emitWarning = (msg, type, code, fn) => {
		typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
	};
	var AC = globalThis.AbortController;
	var AS = globalThis.AbortSignal;
	/* c8 ignore start */
	if (typeof AC === "undefined") {
		AS = class AbortSignal$2 {
			onabort;
			_onabort = [];
			reason;
			aborted = false;
			addEventListener(_$1, fn) {
				this._onabort.push(fn);
			}
		};
		AC = class AbortController$2 {
			constructor() {
				warnACPolyfill();
			}
			signal = new AS();
			abort(reason) {
				if (this.signal.aborted) return;
				this.signal.reason = reason;
				this.signal.aborted = true;
				for (const fn of this.signal._onabort) fn(reason);
				this.signal.onabort?.(reason);
			}
		};
		let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
		const warnACPolyfill = () => {
			if (!printACPolyfillWarning) return;
			printACPolyfillWarning = false;
			emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
		};
	}
	/* c8 ignore stop */
	var shouldWarn = (code) => !warned.has(code);
	var isPosInt = (n$1) => n$1 && n$1 === Math.floor(n$1) && n$1 > 0 && isFinite(n$1);
	/* c8 ignore start */
	var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
	/* c8 ignore stop */
	var ZeroArray = class extends Array {
		constructor(size) {
			super(size);
			this.fill(0);
		}
	};
	var Stack = class Stack {
		heap;
		length;
		static #constructing = false;
		static create(max) {
			const HeapCls = getUintArray(max);
			if (!HeapCls) return [];
			Stack.#constructing = true;
			const s = new Stack(max, HeapCls);
			Stack.#constructing = false;
			return s;
		}
		constructor(max, HeapCls) {
			/* c8 ignore start */
			if (!Stack.#constructing) throw new TypeError("instantiate Stack using Stack.create(n)");
			/* c8 ignore stop */
			this.heap = new HeapCls(max);
			this.length = 0;
		}
		push(n$1) {
			this.heap[this.length++] = n$1;
		}
		pop() {
			return this.heap[--this.length];
		}
	};
	exports.LRUCache = class LRUCache {
		#max;
		#maxSize;
		#dispose;
		#disposeAfter;
		#fetchMethod;
		#memoMethod;
		ttl;
		ttlResolution;
		ttlAutopurge;
		updateAgeOnGet;
		updateAgeOnHas;
		allowStale;
		noDisposeOnSet;
		noUpdateTTL;
		maxEntrySize;
		sizeCalculation;
		noDeleteOnFetchRejection;
		noDeleteOnStaleGet;
		allowStaleOnFetchAbort;
		allowStaleOnFetchRejection;
		ignoreFetchAbort;
		#size;
		#calculatedSize;
		#keyMap;
		#keyList;
		#valList;
		#next;
		#prev;
		#head;
		#tail;
		#free;
		#disposed;
		#sizes;
		#starts;
		#ttls;
		#hasDispose;
		#hasFetchMethod;
		#hasDisposeAfter;
		static unsafeExposeInternals(c) {
			return {
				starts: c.#starts,
				ttls: c.#ttls,
				sizes: c.#sizes,
				keyMap: c.#keyMap,
				keyList: c.#keyList,
				valList: c.#valList,
				next: c.#next,
				prev: c.#prev,
				get head() {
					return c.#head;
				},
				get tail() {
					return c.#tail;
				},
				free: c.#free,
				isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
				backgroundFetch: (k, index$1, options, context$2) => c.#backgroundFetch(k, index$1, options, context$2),
				moveToTail: (index$1) => c.#moveToTail(index$1),
				indexes: (options) => c.#indexes(options),
				rindexes: (options) => c.#rindexes(options),
				isStale: (index$1) => c.#isStale(index$1)
			};
		}
		get max() {
			return this.#max;
		}
		get maxSize() {
			return this.#maxSize;
		}
		get calculatedSize() {
			return this.#calculatedSize;
		}
		get size() {
			return this.#size;
		}
		get fetchMethod() {
			return this.#fetchMethod;
		}
		get memoMethod() {
			return this.#memoMethod;
		}
		get dispose() {
			return this.#dispose;
		}
		get disposeAfter() {
			return this.#disposeAfter;
		}
		constructor(options) {
			const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
			if (max !== 0 && !isPosInt(max)) throw new TypeError("max option must be a nonnegative integer");
			const UintArray = max ? getUintArray(max) : Array;
			if (!UintArray) throw new Error("invalid max value: " + max);
			this.#max = max;
			this.#maxSize = maxSize;
			this.maxEntrySize = maxEntrySize || this.#maxSize;
			this.sizeCalculation = sizeCalculation;
			if (this.sizeCalculation) {
				if (!this.#maxSize && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
				if (typeof this.sizeCalculation !== "function") throw new TypeError("sizeCalculation set to non-function");
			}
			if (memoMethod !== void 0 && typeof memoMethod !== "function") throw new TypeError("memoMethod must be a function if defined");
			this.#memoMethod = memoMethod;
			if (fetchMethod !== void 0 && typeof fetchMethod !== "function") throw new TypeError("fetchMethod must be a function if specified");
			this.#fetchMethod = fetchMethod;
			this.#hasFetchMethod = !!fetchMethod;
			this.#keyMap = /* @__PURE__ */ new Map();
			this.#keyList = new Array(max).fill(void 0);
			this.#valList = new Array(max).fill(void 0);
			this.#next = new UintArray(max);
			this.#prev = new UintArray(max);
			this.#head = 0;
			this.#tail = 0;
			this.#free = Stack.create(max);
			this.#size = 0;
			this.#calculatedSize = 0;
			if (typeof dispose === "function") this.#dispose = dispose;
			if (typeof disposeAfter === "function") {
				this.#disposeAfter = disposeAfter;
				this.#disposed = [];
			} else {
				this.#disposeAfter = void 0;
				this.#disposed = void 0;
			}
			this.#hasDispose = !!this.#dispose;
			this.#hasDisposeAfter = !!this.#disposeAfter;
			this.noDisposeOnSet = !!noDisposeOnSet;
			this.noUpdateTTL = !!noUpdateTTL;
			this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
			this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
			this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
			this.ignoreFetchAbort = !!ignoreFetchAbort;
			if (this.maxEntrySize !== 0) {
				if (this.#maxSize !== 0) {
					if (!isPosInt(this.#maxSize)) throw new TypeError("maxSize must be a positive integer if specified");
				}
				if (!isPosInt(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
				this.#initializeSizeTracking();
			}
			this.allowStale = !!allowStale;
			this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
			this.updateAgeOnGet = !!updateAgeOnGet;
			this.updateAgeOnHas = !!updateAgeOnHas;
			this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
			this.ttlAutopurge = !!ttlAutopurge;
			this.ttl = ttl || 0;
			if (this.ttl) {
				if (!isPosInt(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
				this.#initializeTTLTracking();
			}
			if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
			if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
				const code = "LRU_CACHE_UNBOUNDED";
				if (shouldWarn(code)) {
					warned.add(code);
					emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, LRUCache);
				}
			}
		}
		getRemainingTTL(key) {
			return this.#keyMap.has(key) ? Infinity : 0;
		}
		#initializeTTLTracking() {
			const ttls = new ZeroArray(this.#max);
			const starts = new ZeroArray(this.#max);
			this.#ttls = ttls;
			this.#starts = starts;
			this.#setItemTTL = (index$1, ttl, start = perf.now()) => {
				starts[index$1] = ttl !== 0 ? start : 0;
				ttls[index$1] = ttl;
				if (ttl !== 0 && this.ttlAutopurge) {
					const t$1 = setTimeout(() => {
						if (this.#isStale(index$1)) this.#delete(this.#keyList[index$1], "expire");
					}, ttl + 1);
					/* c8 ignore start */
					if (t$1.unref) t$1.unref();
				}
			};
			this.#updateItemAge = (index$1) => {
				starts[index$1] = ttls[index$1] !== 0 ? perf.now() : 0;
			};
			this.#statusTTL = (status, index$1) => {
				if (ttls[index$1]) {
					const ttl = ttls[index$1];
					const start = starts[index$1];
					/* c8 ignore next */
					if (!ttl || !start) return;
					status.ttl = ttl;
					status.start = start;
					status.now = cachedNow || getNow();
					status.remainingTTL = ttl - (status.now - start);
				}
			};
			let cachedNow = 0;
			const getNow = () => {
				const n$1 = perf.now();
				if (this.ttlResolution > 0) {
					cachedNow = n$1;
					const t$1 = setTimeout(() => cachedNow = 0, this.ttlResolution);
					/* c8 ignore start */
					if (t$1.unref) t$1.unref();
				}
				return n$1;
			};
			this.getRemainingTTL = (key) => {
				const index$1 = this.#keyMap.get(key);
				if (index$1 === void 0) return 0;
				const ttl = ttls[index$1];
				const start = starts[index$1];
				if (!ttl || !start) return Infinity;
				return ttl - ((cachedNow || getNow()) - start);
			};
			this.#isStale = (index$1) => {
				const s = starts[index$1];
				const t$1 = ttls[index$1];
				return !!t$1 && !!s && (cachedNow || getNow()) - s > t$1;
			};
		}
		#updateItemAge = () => {};
		#statusTTL = () => {};
		#setItemTTL = () => {};
		/* c8 ignore stop */
		#isStale = () => false;
		#initializeSizeTracking() {
			const sizes = new ZeroArray(this.#max);
			this.#calculatedSize = 0;
			this.#sizes = sizes;
			this.#removeItemSize = (index$1) => {
				this.#calculatedSize -= sizes[index$1];
				sizes[index$1] = 0;
			};
			this.#requireSize = (k, v, size, sizeCalculation) => {
				if (this.#isBackgroundFetch(v)) return 0;
				if (!isPosInt(size)) if (sizeCalculation) {
					if (typeof sizeCalculation !== "function") throw new TypeError("sizeCalculation must be a function");
					size = sizeCalculation(v, k);
					if (!isPosInt(size)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
				} else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
				return size;
			};
			this.#addItemSize = (index$1, size, status) => {
				sizes[index$1] = size;
				if (this.#maxSize) {
					const maxSize = this.#maxSize - sizes[index$1];
					while (this.#calculatedSize > maxSize) this.#evict(true);
				}
				this.#calculatedSize += sizes[index$1];
				if (status) {
					status.entrySize = size;
					status.totalCalculatedSize = this.#calculatedSize;
				}
			};
		}
		#removeItemSize = (_i) => {};
		#addItemSize = (_i, _s, _st) => {};
		#requireSize = (_k, _v, size, sizeCalculation) => {
			if (size || sizeCalculation) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
			return 0;
		};
		*#indexes({ allowStale = this.allowStale } = {}) {
			if (this.#size) for (let i = this.#tail;;) {
				if (!this.#isValidIndex(i)) break;
				if (allowStale || !this.#isStale(i)) yield i;
				if (i === this.#head) break;
				else i = this.#prev[i];
			}
		}
		*#rindexes({ allowStale = this.allowStale } = {}) {
			if (this.#size) for (let i = this.#head;;) {
				if (!this.#isValidIndex(i)) break;
				if (allowStale || !this.#isStale(i)) yield i;
				if (i === this.#tail) break;
				else i = this.#next[i];
			}
		}
		#isValidIndex(index$1) {
			return index$1 !== void 0 && this.#keyMap.get(this.#keyList[index$1]) === index$1;
		}
		*entries() {
			for (const i of this.#indexes()) if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield [this.#keyList[i], this.#valList[i]];
		}
		*rentries() {
			for (const i of this.#rindexes()) if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield [this.#keyList[i], this.#valList[i]];
		}
		*keys() {
			for (const i of this.#indexes()) {
				const k = this.#keyList[i];
				if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield k;
			}
		}
		*rkeys() {
			for (const i of this.#rindexes()) {
				const k = this.#keyList[i];
				if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield k;
			}
		}
		*values() {
			for (const i of this.#indexes()) if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield this.#valList[i];
		}
		*rvalues() {
			for (const i of this.#rindexes()) if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) yield this.#valList[i];
		}
		[Symbol.iterator]() {
			return this.entries();
		}
		[Symbol.toStringTag] = "LRUCache";
		find(fn, getOptions = {}) {
			for (const i of this.#indexes()) {
				const v = this.#valList[i];
				const value$1 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value$1 === void 0) continue;
				if (fn(value$1, this.#keyList[i], this)) return this.get(this.#keyList[i], getOptions);
			}
		}
		forEach(fn, thisp = this) {
			for (const i of this.#indexes()) {
				const v = this.#valList[i];
				const value$1 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value$1 === void 0) continue;
				fn.call(thisp, value$1, this.#keyList[i], this);
			}
		}
		rforEach(fn, thisp = this) {
			for (const i of this.#rindexes()) {
				const v = this.#valList[i];
				const value$1 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value$1 === void 0) continue;
				fn.call(thisp, value$1, this.#keyList[i], this);
			}
		}
		purgeStale() {
			let deleted = false;
			for (const i of this.#rindexes({ allowStale: true })) if (this.#isStale(i)) {
				this.#delete(this.#keyList[i], "expire");
				deleted = true;
			}
			return deleted;
		}
		info(key) {
			const i = this.#keyMap.get(key);
			if (i === void 0) return void 0;
			const v = this.#valList[i];
			const value$1 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
			if (value$1 === void 0) return void 0;
			const entry = { value: value$1 };
			if (this.#ttls && this.#starts) {
				const ttl = this.#ttls[i];
				const start = this.#starts[i];
				if (ttl && start) {
					entry.ttl = ttl - (perf.now() - start);
					entry.start = Date.now();
				}
			}
			if (this.#sizes) entry.size = this.#sizes[i];
			return entry;
		}
		dump() {
			const arr = [];
			for (const i of this.#indexes({ allowStale: true })) {
				const key = this.#keyList[i];
				const v = this.#valList[i];
				const value$1 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
				if (value$1 === void 0 || key === void 0) continue;
				const entry = { value: value$1 };
				if (this.#ttls && this.#starts) {
					entry.ttl = this.#ttls[i];
					const age = perf.now() - this.#starts[i];
					entry.start = Math.floor(Date.now() - age);
				}
				if (this.#sizes) entry.size = this.#sizes[i];
				arr.unshift([key, entry]);
			}
			return arr;
		}
		load(arr) {
			this.clear();
			for (const [key, entry] of arr) {
				if (entry.start) {
					const age = Date.now() - entry.start;
					entry.start = perf.now() - age;
				}
				this.set(key, entry.value, entry);
			}
		}
		set(k, v, setOptions = {}) {
			if (v === void 0) {
				this.delete(k);
				return this;
			}
			const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
			let { noUpdateTTL = this.noUpdateTTL } = setOptions;
			const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
			if (this.maxEntrySize && size > this.maxEntrySize) {
				if (status) {
					status.set = "miss";
					status.maxEntrySizeExceeded = true;
				}
				this.#delete(k, "set");
				return this;
			}
			let index$1 = this.#size === 0 ? void 0 : this.#keyMap.get(k);
			if (index$1 === void 0) {
				index$1 = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
				this.#keyList[index$1] = k;
				this.#valList[index$1] = v;
				this.#keyMap.set(k, index$1);
				this.#next[this.#tail] = index$1;
				this.#prev[index$1] = this.#tail;
				this.#tail = index$1;
				this.#size++;
				this.#addItemSize(index$1, size, status);
				if (status) status.set = "add";
				noUpdateTTL = false;
			} else {
				this.#moveToTail(index$1);
				const oldVal = this.#valList[index$1];
				if (v !== oldVal) {
					if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
						oldVal.__abortController.abort(/* @__PURE__ */ new Error("replaced"));
						const { __staleWhileFetching: s } = oldVal;
						if (s !== void 0 && !noDisposeOnSet) {
							if (this.#hasDispose) this.#dispose?.(s, k, "set");
							if (this.#hasDisposeAfter) this.#disposed?.push([
								s,
								k,
								"set"
							]);
						}
					} else if (!noDisposeOnSet) {
						if (this.#hasDispose) this.#dispose?.(oldVal, k, "set");
						if (this.#hasDisposeAfter) this.#disposed?.push([
							oldVal,
							k,
							"set"
						]);
					}
					this.#removeItemSize(index$1);
					this.#addItemSize(index$1, size, status);
					this.#valList[index$1] = v;
					if (status) {
						status.set = "replace";
						const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
						if (oldValue !== void 0) status.oldValue = oldValue;
					}
				} else if (status) status.set = "update";
			}
			if (ttl !== 0 && !this.#ttls) this.#initializeTTLTracking();
			if (this.#ttls) {
				if (!noUpdateTTL) this.#setItemTTL(index$1, ttl, start);
				if (status) this.#statusTTL(status, index$1);
			}
			if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
			return this;
		}
		pop() {
			try {
				while (this.#size) {
					const val = this.#valList[this.#head];
					this.#evict(true);
					if (this.#isBackgroundFetch(val)) {
						if (val.__staleWhileFetching) return val.__staleWhileFetching;
					} else if (val !== void 0) return val;
				}
			} finally {
				if (this.#hasDisposeAfter && this.#disposed) {
					const dt = this.#disposed;
					let task;
					while (task = dt?.shift()) this.#disposeAfter?.(...task);
				}
			}
		}
		#evict(free) {
			const head = this.#head;
			const k = this.#keyList[head];
			const v = this.#valList[head];
			if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("evicted"));
			else if (this.#hasDispose || this.#hasDisposeAfter) {
				if (this.#hasDispose) this.#dispose?.(v, k, "evict");
				if (this.#hasDisposeAfter) this.#disposed?.push([
					v,
					k,
					"evict"
				]);
			}
			this.#removeItemSize(head);
			if (free) {
				this.#keyList[head] = void 0;
				this.#valList[head] = void 0;
				this.#free.push(head);
			}
			if (this.#size === 1) {
				this.#head = this.#tail = 0;
				this.#free.length = 0;
			} else this.#head = this.#next[head];
			this.#keyMap.delete(k);
			this.#size--;
			return head;
		}
		has(k, hasOptions = {}) {
			const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
			const index$1 = this.#keyMap.get(k);
			if (index$1 !== void 0) {
				const v = this.#valList[index$1];
				if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) return false;
				if (!this.#isStale(index$1)) {
					if (updateAgeOnHas) this.#updateItemAge(index$1);
					if (status) {
						status.has = "hit";
						this.#statusTTL(status, index$1);
					}
					return true;
				} else if (status) {
					status.has = "stale";
					this.#statusTTL(status, index$1);
				}
			} else if (status) status.has = "miss";
			return false;
		}
		peek(k, peekOptions = {}) {
			const { allowStale = this.allowStale } = peekOptions;
			const index$1 = this.#keyMap.get(k);
			if (index$1 === void 0 || !allowStale && this.#isStale(index$1)) return;
			const v = this.#valList[index$1];
			return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
		}
		#backgroundFetch(k, index$1, options, context$2) {
			const v = index$1 === void 0 ? void 0 : this.#valList[index$1];
			if (this.#isBackgroundFetch(v)) return v;
			const ac = new AC();
			const { signal } = options;
			signal?.addEventListener("abort", () => ac.abort(signal.reason), { signal: ac.signal });
			const fetchOpts = {
				signal: ac.signal,
				options,
				context: context$2
			};
			const cb = (v$1, updateCache = false) => {
				const { aborted } = ac.signal;
				const ignoreAbort = options.ignoreFetchAbort && v$1 !== void 0;
				if (options.status) if (aborted && !updateCache) {
					options.status.fetchAborted = true;
					options.status.fetchError = ac.signal.reason;
					if (ignoreAbort) options.status.fetchAbortIgnored = true;
				} else options.status.fetchResolved = true;
				if (aborted && !ignoreAbort && !updateCache) return fetchFail(ac.signal.reason);
				const bf$1 = p;
				if (this.#valList[index$1] === p) if (v$1 === void 0) if (bf$1.__staleWhileFetching) this.#valList[index$1] = bf$1.__staleWhileFetching;
				else this.#delete(k, "fetch");
				else {
					if (options.status) options.status.fetchUpdated = true;
					this.set(k, v$1, fetchOpts.options);
				}
				return v$1;
			};
			const eb = (er) => {
				if (options.status) {
					options.status.fetchRejected = true;
					options.status.fetchError = er;
				}
				return fetchFail(er);
			};
			const fetchFail = (er) => {
				const { aborted } = ac.signal;
				const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
				const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
				const noDelete = allowStale || options.noDeleteOnFetchRejection;
				const bf$1 = p;
				if (this.#valList[index$1] === p) {
					if (!noDelete || bf$1.__staleWhileFetching === void 0) this.#delete(k, "fetch");
					else if (!allowStaleAborted) this.#valList[index$1] = bf$1.__staleWhileFetching;
				}
				if (allowStale) {
					if (options.status && bf$1.__staleWhileFetching !== void 0) options.status.returnedStale = true;
					return bf$1.__staleWhileFetching;
				} else if (bf$1.__returned === bf$1) throw er;
			};
			const pcall = (res, rej) => {
				const fmp = this.#fetchMethod?.(k, v, fetchOpts);
				if (fmp && fmp instanceof Promise) fmp.then((v$1) => res(v$1 === void 0 ? void 0 : v$1), rej);
				ac.signal.addEventListener("abort", () => {
					if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
						res(void 0);
						if (options.allowStaleOnFetchAbort) res = (v$1) => cb(v$1, true);
					}
				});
			};
			if (options.status) options.status.fetchDispatched = true;
			const p = new Promise(pcall).then(cb, eb);
			const bf = Object.assign(p, {
				__abortController: ac,
				__staleWhileFetching: v,
				__returned: void 0
			});
			if (index$1 === void 0) {
				this.set(k, bf, {
					...fetchOpts.options,
					status: void 0
				});
				index$1 = this.#keyMap.get(k);
			} else this.#valList[index$1] = bf;
			return bf;
		}
		#isBackgroundFetch(p) {
			if (!this.#hasFetchMethod) return false;
			const b = p;
			return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
		}
		async fetch(k, fetchOptions = {}) {
			const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context: context$2, forceRefresh = false, status, signal } = fetchOptions;
			if (!this.#hasFetchMethod) {
				if (status) status.fetch = "get";
				return this.get(k, {
					allowStale,
					updateAgeOnGet,
					noDeleteOnStaleGet,
					status
				});
			}
			const options = {
				allowStale,
				updateAgeOnGet,
				noDeleteOnStaleGet,
				ttl,
				noDisposeOnSet,
				size,
				sizeCalculation,
				noUpdateTTL,
				noDeleteOnFetchRejection,
				allowStaleOnFetchRejection,
				allowStaleOnFetchAbort,
				ignoreFetchAbort,
				status,
				signal
			};
			let index$1 = this.#keyMap.get(k);
			if (index$1 === void 0) {
				if (status) status.fetch = "miss";
				const p = this.#backgroundFetch(k, index$1, options, context$2);
				return p.__returned = p;
			} else {
				const v = this.#valList[index$1];
				if (this.#isBackgroundFetch(v)) {
					const stale = allowStale && v.__staleWhileFetching !== void 0;
					if (status) {
						status.fetch = "inflight";
						if (stale) status.returnedStale = true;
					}
					return stale ? v.__staleWhileFetching : v.__returned = v;
				}
				const isStale = this.#isStale(index$1);
				if (!forceRefresh && !isStale) {
					if (status) status.fetch = "hit";
					this.#moveToTail(index$1);
					if (updateAgeOnGet) this.#updateItemAge(index$1);
					if (status) this.#statusTTL(status, index$1);
					return v;
				}
				const p = this.#backgroundFetch(k, index$1, options, context$2);
				const staleVal = p.__staleWhileFetching !== void 0 && allowStale;
				if (status) {
					status.fetch = isStale ? "stale" : "refresh";
					if (staleVal && isStale) status.returnedStale = true;
				}
				return staleVal ? p.__staleWhileFetching : p.__returned = p;
			}
		}
		async forceFetch(k, fetchOptions = {}) {
			const v = await this.fetch(k, fetchOptions);
			if (v === void 0) throw new Error("fetch() returned undefined");
			return v;
		}
		memo(k, memoOptions = {}) {
			const memoMethod = this.#memoMethod;
			if (!memoMethod) throw new Error("no memoMethod provided to constructor");
			const { context: context$2, forceRefresh, ...options } = memoOptions;
			const v = this.get(k, options);
			if (!forceRefresh && v !== void 0) return v;
			const vv = memoMethod(k, v, {
				options,
				context: context$2
			});
			this.set(k, vv, options);
			return vv;
		}
		get(k, getOptions = {}) {
			const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
			const index$1 = this.#keyMap.get(k);
			if (index$1 !== void 0) {
				const value$1 = this.#valList[index$1];
				const fetching = this.#isBackgroundFetch(value$1);
				if (status) this.#statusTTL(status, index$1);
				if (this.#isStale(index$1)) {
					if (status) status.get = "stale";
					if (!fetching) {
						if (!noDeleteOnStaleGet) this.#delete(k, "expire");
						if (status && allowStale) status.returnedStale = true;
						return allowStale ? value$1 : void 0;
					} else {
						if (status && allowStale && value$1.__staleWhileFetching !== void 0) status.returnedStale = true;
						return allowStale ? value$1.__staleWhileFetching : void 0;
					}
				} else {
					if (status) status.get = "hit";
					if (fetching) return value$1.__staleWhileFetching;
					this.#moveToTail(index$1);
					if (updateAgeOnGet) this.#updateItemAge(index$1);
					return value$1;
				}
			} else if (status) status.get = "miss";
		}
		#connect(p, n$1) {
			this.#prev[n$1] = p;
			this.#next[p] = n$1;
		}
		#moveToTail(index$1) {
			if (index$1 !== this.#tail) {
				if (index$1 === this.#head) this.#head = this.#next[index$1];
				else this.#connect(this.#prev[index$1], this.#next[index$1]);
				this.#connect(this.#tail, index$1);
				this.#tail = index$1;
			}
		}
		delete(k) {
			return this.#delete(k, "delete");
		}
		#delete(k, reason) {
			let deleted = false;
			if (this.#size !== 0) {
				const index$1 = this.#keyMap.get(k);
				if (index$1 !== void 0) {
					deleted = true;
					if (this.#size === 1) this.#clear(reason);
					else {
						this.#removeItemSize(index$1);
						const v = this.#valList[index$1];
						if (this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
						else if (this.#hasDispose || this.#hasDisposeAfter) {
							if (this.#hasDispose) this.#dispose?.(v, k, reason);
							if (this.#hasDisposeAfter) this.#disposed?.push([
								v,
								k,
								reason
							]);
						}
						this.#keyMap.delete(k);
						this.#keyList[index$1] = void 0;
						this.#valList[index$1] = void 0;
						if (index$1 === this.#tail) this.#tail = this.#prev[index$1];
						else if (index$1 === this.#head) this.#head = this.#next[index$1];
						else {
							const pi = this.#prev[index$1];
							this.#next[pi] = this.#next[index$1];
							const ni = this.#next[index$1];
							this.#prev[ni] = this.#prev[index$1];
						}
						this.#size--;
						this.#free.push(index$1);
					}
				}
			}
			if (this.#hasDisposeAfter && this.#disposed?.length) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
			return deleted;
		}
		clear() {
			return this.#clear("delete");
		}
		#clear(reason) {
			for (const index$1 of this.#rindexes({ allowStale: true })) {
				const v = this.#valList[index$1];
				if (this.#isBackgroundFetch(v)) v.__abortController.abort(/* @__PURE__ */ new Error("deleted"));
				else {
					const k = this.#keyList[index$1];
					if (this.#hasDispose) this.#dispose?.(v, k, reason);
					if (this.#hasDisposeAfter) this.#disposed?.push([
						v,
						k,
						reason
					]);
				}
			}
			this.#keyMap.clear();
			this.#valList.fill(void 0);
			this.#keyList.fill(void 0);
			if (this.#ttls && this.#starts) {
				this.#ttls.fill(0);
				this.#starts.fill(0);
			}
			if (this.#sizes) this.#sizes.fill(0);
			this.#head = 0;
			this.#tail = 0;
			this.#free.length = 0;
			this.#calculatedSize = 0;
			this.#size = 0;
			if (this.#hasDisposeAfter && this.#disposed) {
				const dt = this.#disposed;
				let task;
				while (task = dt?.shift()) this.#disposeAfter?.(...task);
			}
		}
	};
}));
var require_commonjs$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;
	var proc = typeof process === "object" && process ? process : {
		stdout: null,
		stderr: null
	};
	var node_events_1 = __require("node:events");
	var node_stream_1 = __importDefault(__require("node:stream"));
	var node_string_decoder_1 = __require("node:string_decoder");
	var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));
	exports.isStream = isStream;
	var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && s.pipe !== node_stream_1.default.Writable.prototype.pipe;
	exports.isReadable = isReadable;
	var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
	exports.isWritable = isWritable;
	var EOF = Symbol("EOF");
	var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
	var EMITTED_END = Symbol("emittedEnd");
	var EMITTING_END = Symbol("emittingEnd");
	var EMITTED_ERROR = Symbol("emittedError");
	var CLOSED = Symbol("closed");
	var READ = Symbol("read");
	var FLUSH = Symbol("flush");
	var FLUSHCHUNK = Symbol("flushChunk");
	var ENCODING = Symbol("encoding");
	var DECODER = Symbol("decoder");
	var FLOWING = Symbol("flowing");
	var PAUSED = Symbol("paused");
	var RESUME = Symbol("resume");
	var BUFFER = Symbol("buffer");
	var PIPES = Symbol("pipes");
	var BUFFERLENGTH = Symbol("bufferLength");
	var BUFFERPUSH = Symbol("bufferPush");
	var BUFFERSHIFT = Symbol("bufferShift");
	var OBJECTMODE = Symbol("objectMode");
	var DESTROYED = Symbol("destroyed");
	var ERROR = Symbol("error");
	var EMITDATA = Symbol("emitData");
	var EMITEND = Symbol("emitEnd");
	var EMITEND2 = Symbol("emitEnd2");
	var ASYNC = Symbol("async");
	var ABORT = Symbol("abort");
	var ABORTED = Symbol("aborted");
	var SIGNAL = Symbol("signal");
	var DATALISTENERS = Symbol("dataListeners");
	var DISCARDED = Symbol("discarded");
	var defer = (fn) => Promise.resolve().then(fn);
	var nodefer = (fn) => fn();
	var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
	var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
	var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
	var Pipe = class {
		src;
		dest;
		opts;
		ondrain;
		constructor(src, dest, opts) {
			this.src = src;
			this.dest = dest;
			this.opts = opts;
			this.ondrain = () => src[RESUME]();
			this.dest.on("drain", this.ondrain);
		}
		unpipe() {
			this.dest.removeListener("drain", this.ondrain);
		}
		/* c8 ignore start */
		proxyErrors(_er) {}
		/* c8 ignore stop */
		end() {
			this.unpipe();
			if (this.opts.end) this.dest.end();
		}
	};
	var PipeProxyErrors = class extends Pipe {
		unpipe() {
			this.src.removeListener("error", this.proxyErrors);
			super.unpipe();
		}
		constructor(src, dest, opts) {
			super(src, dest, opts);
			this.proxyErrors = (er) => dest.emit("error", er);
			src.on("error", this.proxyErrors);
		}
	};
	var isObjectModeOptions = (o$1) => !!o$1.objectMode;
	var isEncodingOptions = (o$1) => !o$1.objectMode && !!o$1.encoding && o$1.encoding !== "buffer";
	var Minipass = class extends node_events_1.EventEmitter {
		[FLOWING] = false;
		[PAUSED] = false;
		[PIPES] = [];
		[BUFFER] = [];
		[OBJECTMODE];
		[ENCODING];
		[ASYNC];
		[DECODER];
		[EOF] = false;
		[EMITTED_END] = false;
		[EMITTING_END] = false;
		[CLOSED] = false;
		[EMITTED_ERROR] = null;
		[BUFFERLENGTH] = 0;
		[DESTROYED] = false;
		[SIGNAL];
		[ABORTED] = false;
		[DATALISTENERS] = 0;
		[DISCARDED] = false;
		writable = true;
		readable = true;
		constructor(...args) {
			const options = args[0] || {};
			super();
			if (options.objectMode && typeof options.encoding === "string") throw new TypeError("Encoding and objectMode may not be used together");
			if (isObjectModeOptions(options)) {
				this[OBJECTMODE] = true;
				this[ENCODING] = null;
			} else if (isEncodingOptions(options)) {
				this[ENCODING] = options.encoding;
				this[OBJECTMODE] = false;
			} else {
				this[OBJECTMODE] = false;
				this[ENCODING] = null;
			}
			this[ASYNC] = !!options.async;
			this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
			if (options && options.debugExposeBuffer === true) Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
			if (options && options.debugExposePipes === true) Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
			const { signal } = options;
			if (signal) {
				this[SIGNAL] = signal;
				if (signal.aborted) this[ABORT]();
				else signal.addEventListener("abort", () => this[ABORT]());
			}
		}
		get bufferLength() {
			return this[BUFFERLENGTH];
		}
		get encoding() {
			return this[ENCODING];
		}
		set encoding(_enc) {
			throw new Error("Encoding must be set at instantiation time");
		}
		setEncoding(_enc) {
			throw new Error("Encoding must be set at instantiation time");
		}
		get objectMode() {
			return this[OBJECTMODE];
		}
		set objectMode(_om) {
			throw new Error("objectMode must be set at instantiation time");
		}
		get ["async"]() {
			return this[ASYNC];
		}
		set ["async"](a) {
			this[ASYNC] = this[ASYNC] || !!a;
		}
		[ABORT]() {
			this[ABORTED] = true;
			this.emit("abort", this[SIGNAL]?.reason);
			this.destroy(this[SIGNAL]?.reason);
		}
		get aborted() {
			return this[ABORTED];
		}
		set aborted(_$1) {}
		write(chunk, encoding, cb) {
			if (this[ABORTED]) return false;
			if (this[EOF]) throw new Error("write after end");
			if (this[DESTROYED]) {
				this.emit("error", Object.assign(/* @__PURE__ */ new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
				return true;
			}
			if (typeof encoding === "function") {
				cb = encoding;
				encoding = "utf8";
			}
			if (!encoding) encoding = "utf8";
			const fn = this[ASYNC] ? defer : nodefer;
			if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
				if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
				else if (isArrayBufferLike(chunk)) chunk = Buffer.from(chunk);
				else if (typeof chunk !== "string") throw new Error("Non-contiguous data written to non-objectMode stream");
			}
			if (this[OBJECTMODE]) {
				/* c8 ignore start */
				if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
				/* c8 ignore stop */
				if (this[FLOWING]) this.emit("data", chunk);
				else this[BUFFERPUSH](chunk);
				if (this[BUFFERLENGTH] !== 0) this.emit("readable");
				if (cb) fn(cb);
				return this[FLOWING];
			}
			if (!chunk.length) {
				if (this[BUFFERLENGTH] !== 0) this.emit("readable");
				if (cb) fn(cb);
				return this[FLOWING];
			}
			if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) chunk = Buffer.from(chunk, encoding);
			if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);
			if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
			if (this[FLOWING]) this.emit("data", chunk);
			else this[BUFFERPUSH](chunk);
			if (this[BUFFERLENGTH] !== 0) this.emit("readable");
			if (cb) fn(cb);
			return this[FLOWING];
		}
		read(n$1) {
			if (this[DESTROYED]) return null;
			this[DISCARDED] = false;
			if (this[BUFFERLENGTH] === 0 || n$1 === 0 || n$1 && n$1 > this[BUFFERLENGTH]) {
				this[MAYBE_EMIT_END]();
				return null;
			}
			if (this[OBJECTMODE]) n$1 = null;
			if (this[BUFFER].length > 1 && !this[OBJECTMODE]) this[BUFFER] = [this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
			const ret = this[READ](n$1 || null, this[BUFFER][0]);
			this[MAYBE_EMIT_END]();
			return ret;
		}
		[READ](n$1, chunk) {
			if (this[OBJECTMODE]) this[BUFFERSHIFT]();
			else {
				const c = chunk;
				if (n$1 === c.length || n$1 === null) this[BUFFERSHIFT]();
				else if (typeof c === "string") {
					this[BUFFER][0] = c.slice(n$1);
					chunk = c.slice(0, n$1);
					this[BUFFERLENGTH] -= n$1;
				} else {
					this[BUFFER][0] = c.subarray(n$1);
					chunk = c.subarray(0, n$1);
					this[BUFFERLENGTH] -= n$1;
				}
			}
			this.emit("data", chunk);
			if (!this[BUFFER].length && !this[EOF]) this.emit("drain");
			return chunk;
		}
		end(chunk, encoding, cb) {
			if (typeof chunk === "function") {
				cb = chunk;
				chunk = void 0;
			}
			if (typeof encoding === "function") {
				cb = encoding;
				encoding = "utf8";
			}
			if (chunk !== void 0) this.write(chunk, encoding);
			if (cb) this.once("end", cb);
			this[EOF] = true;
			this.writable = false;
			if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]();
			return this;
		}
		[RESUME]() {
			if (this[DESTROYED]) return;
			if (!this[DATALISTENERS] && !this[PIPES].length) this[DISCARDED] = true;
			this[PAUSED] = false;
			this[FLOWING] = true;
			this.emit("resume");
			if (this[BUFFER].length) this[FLUSH]();
			else if (this[EOF]) this[MAYBE_EMIT_END]();
			else this.emit("drain");
		}
		resume() {
			return this[RESUME]();
		}
		pause() {
			this[FLOWING] = false;
			this[PAUSED] = true;
			this[DISCARDED] = false;
		}
		get destroyed() {
			return this[DESTROYED];
		}
		get flowing() {
			return this[FLOWING];
		}
		get paused() {
			return this[PAUSED];
		}
		[BUFFERPUSH](chunk) {
			if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
			else this[BUFFERLENGTH] += chunk.length;
			this[BUFFER].push(chunk);
		}
		[BUFFERSHIFT]() {
			if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
			else this[BUFFERLENGTH] -= this[BUFFER][0].length;
			return this[BUFFER].shift();
		}
		[FLUSH](noDrain = false) {
			do			;
while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
			if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit("drain");
		}
		[FLUSHCHUNK](chunk) {
			this.emit("data", chunk);
			return this[FLOWING];
		}
		pipe(dest, opts) {
			if (this[DESTROYED]) return dest;
			this[DISCARDED] = false;
			const ended = this[EMITTED_END];
			opts = opts || {};
			if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
			else opts.end = opts.end !== false;
			opts.proxyErrors = !!opts.proxyErrors;
			if (ended) {
				if (opts.end) dest.end();
			} else {
				this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
				if (this[ASYNC]) defer(() => this[RESUME]());
				else this[RESUME]();
			}
			return dest;
		}
		unpipe(dest) {
			const p = this[PIPES].find((p$1) => p$1.dest === dest);
			if (p) {
				if (this[PIPES].length === 1) {
					if (this[FLOWING] && this[DATALISTENERS] === 0) this[FLOWING] = false;
					this[PIPES] = [];
				} else this[PIPES].splice(this[PIPES].indexOf(p), 1);
				p.unpipe();
			}
		}
		addListener(ev, handler$1) {
			return this.on(ev, handler$1);
		}
		on(ev, handler$1) {
			const ret = super.on(ev, handler$1);
			if (ev === "data") {
				this[DISCARDED] = false;
				this[DATALISTENERS]++;
				if (!this[PIPES].length && !this[FLOWING]) this[RESUME]();
			} else if (ev === "readable" && this[BUFFERLENGTH] !== 0) super.emit("readable");
			else if (isEndish(ev) && this[EMITTED_END]) {
				super.emit(ev);
				this.removeAllListeners(ev);
			} else if (ev === "error" && this[EMITTED_ERROR]) {
				const h = handler$1;
				if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]));
				else h.call(this, this[EMITTED_ERROR]);
			}
			return ret;
		}
		removeListener(ev, handler$1) {
			return this.off(ev, handler$1);
		}
		off(ev, handler$1) {
			const ret = super.off(ev, handler$1);
			if (ev === "data") {
				this[DATALISTENERS] = this.listeners("data").length;
				if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) this[FLOWING] = false;
			}
			return ret;
		}
		removeAllListeners(ev) {
			const ret = super.removeAllListeners(ev);
			if (ev === "data" || ev === void 0) {
				this[DATALISTENERS] = 0;
				if (!this[DISCARDED] && !this[PIPES].length) this[FLOWING] = false;
			}
			return ret;
		}
		get emittedEnd() {
			return this[EMITTED_END];
		}
		[MAYBE_EMIT_END]() {
			if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
				this[EMITTING_END] = true;
				this.emit("end");
				this.emit("prefinish");
				this.emit("finish");
				if (this[CLOSED]) this.emit("close");
				this[EMITTING_END] = false;
			}
		}
		emit(ev, ...args) {
			const data = args[0];
			if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) return false;
			else if (ev === "data") return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
			else if (ev === "end") return this[EMITEND]();
			else if (ev === "close") {
				this[CLOSED] = true;
				if (!this[EMITTED_END] && !this[DESTROYED]) return false;
				const ret$1 = super.emit("close");
				this.removeAllListeners("close");
				return ret$1;
			} else if (ev === "error") {
				this[EMITTED_ERROR] = data;
				super.emit(ERROR, data);
				const ret$1 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
				this[MAYBE_EMIT_END]();
				return ret$1;
			} else if (ev === "resume") {
				const ret$1 = super.emit("resume");
				this[MAYBE_EMIT_END]();
				return ret$1;
			} else if (ev === "finish" || ev === "prefinish") {
				const ret$1 = super.emit(ev);
				this.removeAllListeners(ev);
				return ret$1;
			}
			const ret = super.emit(ev, ...args);
			this[MAYBE_EMIT_END]();
			return ret;
		}
		[EMITDATA](data) {
			for (const p of this[PIPES]) if (p.dest.write(data) === false) this.pause();
			const ret = this[DISCARDED] ? false : super.emit("data", data);
			this[MAYBE_EMIT_END]();
			return ret;
		}
		[EMITEND]() {
			if (this[EMITTED_END]) return false;
			this[EMITTED_END] = true;
			this.readable = false;
			return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
		}
		[EMITEND2]() {
			if (this[DECODER]) {
				const data = this[DECODER].end();
				if (data) {
					for (const p of this[PIPES]) p.dest.write(data);
					if (!this[DISCARDED]) super.emit("data", data);
				}
			}
			for (const p of this[PIPES]) p.end();
			const ret = super.emit("end");
			this.removeAllListeners("end");
			return ret;
		}
		async collect() {
			const buf = Object.assign([], { dataLength: 0 });
			if (!this[OBJECTMODE]) buf.dataLength = 0;
			const p = this.promise();
			this.on("data", (c) => {
				buf.push(c);
				if (!this[OBJECTMODE]) buf.dataLength += c.length;
			});
			await p;
			return buf;
		}
		async concat() {
			if (this[OBJECTMODE]) throw new Error("cannot concat in objectMode");
			const buf = await this.collect();
			return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
		}
		async promise() {
			return new Promise((resolve$1, reject$3) => {
				this.on(DESTROYED, () => reject$3(/* @__PURE__ */ new Error("stream destroyed")));
				this.on("error", (er) => reject$3(er));
				this.on("end", () => resolve$1());
			});
		}
		[Symbol.asyncIterator]() {
			this[DISCARDED] = false;
			let stopped = false;
			const stop = async () => {
				this.pause();
				stopped = true;
				return {
					value: void 0,
					done: true
				};
			};
			const next = () => {
				if (stopped) return stop();
				const res = this.read();
				if (res !== null) return Promise.resolve({
					done: false,
					value: res
				});
				if (this[EOF]) return stop();
				let resolve$1;
				let reject$3;
				const onerr = (er) => {
					this.off("data", ondata);
					this.off("end", onend);
					this.off(DESTROYED, ondestroy);
					stop();
					reject$3(er);
				};
				const ondata = (value$1) => {
					this.off("error", onerr);
					this.off("end", onend);
					this.off(DESTROYED, ondestroy);
					this.pause();
					resolve$1({
						value: value$1,
						done: !!this[EOF]
					});
				};
				const onend = () => {
					this.off("error", onerr);
					this.off("data", ondata);
					this.off(DESTROYED, ondestroy);
					stop();
					resolve$1({
						done: true,
						value: void 0
					});
				};
				const ondestroy = () => onerr(/* @__PURE__ */ new Error("stream destroyed"));
				return new Promise((res$1, rej) => {
					reject$3 = rej;
					resolve$1 = res$1;
					this.once(DESTROYED, ondestroy);
					this.once("error", onerr);
					this.once("end", onend);
					this.once("data", ondata);
				});
			};
			return {
				next,
				throw: stop,
				return: stop,
				[Symbol.asyncIterator]() {
					return this;
				}
			};
		}
		[Symbol.iterator]() {
			this[DISCARDED] = false;
			let stopped = false;
			const stop = () => {
				this.pause();
				this.off(ERROR, stop);
				this.off(DESTROYED, stop);
				this.off("end", stop);
				stopped = true;
				return {
					done: true,
					value: void 0
				};
			};
			const next = () => {
				if (stopped) return stop();
				const value$1 = this.read();
				return value$1 === null ? stop() : {
					done: false,
					value: value$1
				};
			};
			this.once("end", stop);
			this.once(ERROR, stop);
			this.once(DESTROYED, stop);
			return {
				next,
				throw: stop,
				return: stop,
				[Symbol.iterator]() {
					return this;
				}
			};
		}
		destroy(er) {
			if (this[DESTROYED]) {
				if (er) this.emit("error", er);
				else this.emit(DESTROYED);
				return this;
			}
			this[DESTROYED] = true;
			this[DISCARDED] = true;
			this[BUFFER].length = 0;
			this[BUFFERLENGTH] = 0;
			const wc = this;
			if (typeof wc.close === "function" && !this[CLOSED]) wc.close();
			if (er) this.emit("error", er);
			else this.emit(DESTROYED);
			return this;
		}
		static get isStream() {
			return exports.isStream;
		}
	};
	exports.Minipass = Minipass;
}));
var require_commonjs$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;
	var lru_cache_1 = require_commonjs$3();
	var node_path_1 = __require("node:path");
	var node_url_1$1 = __require("node:url");
	var fs_1 = __require("fs");
	var actualFS = __importStar(__require("node:fs"));
	var realpathSync = fs_1.realpathSync.native;
	var promises_1$2 = __require("node:fs/promises");
	var minipass_1 = require_commonjs$2();
	var defaultFS = {
		lstatSync: fs_1.lstatSync,
		readdir: fs_1.readdir,
		readdirSync: fs_1.readdirSync,
		readlinkSync: fs_1.readlinkSync,
		realpathSync,
		promises: {
			lstat: promises_1$2.lstat,
			readdir: promises_1$2.readdir,
			readlink: promises_1$2.readlink,
			realpath: promises_1$2.realpath
		}
	};
	var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
		...defaultFS,
		...fsOption,
		promises: {
			...defaultFS.promises,
			...fsOption.promises || {}
		}
	};
	var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
	var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
	var eitherSep = /[\\\/]/;
	var UNKNOWN = 0;
	var IFIFO = 1;
	var IFCHR = 2;
	var IFDIR = 4;
	var IFBLK = 6;
	var IFREG = 8;
	var IFLNK = 10;
	var IFSOCK = 12;
	var IFMT = 15;
	var IFMT_UNKNOWN = ~IFMT;
	var READDIR_CALLED = 16;
	var LSTAT_CALLED = 32;
	var ENOTDIR = 64;
	var ENOENT = 128;
	var ENOREADLINK = 256;
	var ENOREALPATH = 512;
	var ENOCHILD = ENOENT | 576;
	var TYPEMASK = 1023;
	var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
	var normalizeCache = /* @__PURE__ */ new Map();
	var normalize = (s) => {
		const c = normalizeCache.get(s);
		if (c) return c;
		const n$1 = s.normalize("NFKD");
		normalizeCache.set(s, n$1);
		return n$1;
	};
	var normalizeNocaseCache = /* @__PURE__ */ new Map();
	var normalizeNocase = (s) => {
		const c = normalizeNocaseCache.get(s);
		if (c) return c;
		const n$1 = normalize(s.toLowerCase());
		normalizeNocaseCache.set(s, n$1);
		return n$1;
	};
	var ResolveCache = class extends lru_cache_1.LRUCache {
		constructor() {
			super({ max: 256 });
		}
	};
	exports.ResolveCache = ResolveCache;
	var ChildrenCache = class extends lru_cache_1.LRUCache {
		constructor(maxSize = 16 * 1024) {
			super({
				maxSize,
				sizeCalculation: (a) => a.length + 1
			});
		}
	};
	exports.ChildrenCache = ChildrenCache;
	var setAsCwd = Symbol("PathScurry setAsCwd");
	var PathBase = class {
		name;
		root;
		roots;
		parent;
		nocase;
		isCWD = false;
		#fs;
		#dev;
		get dev() {
			return this.#dev;
		}
		#mode;
		get mode() {
			return this.#mode;
		}
		#nlink;
		get nlink() {
			return this.#nlink;
		}
		#uid;
		get uid() {
			return this.#uid;
		}
		#gid;
		get gid() {
			return this.#gid;
		}
		#rdev;
		get rdev() {
			return this.#rdev;
		}
		#blksize;
		get blksize() {
			return this.#blksize;
		}
		#ino;
		get ino() {
			return this.#ino;
		}
		#size;
		get size() {
			return this.#size;
		}
		#blocks;
		get blocks() {
			return this.#blocks;
		}
		#atimeMs;
		get atimeMs() {
			return this.#atimeMs;
		}
		#mtimeMs;
		get mtimeMs() {
			return this.#mtimeMs;
		}
		#ctimeMs;
		get ctimeMs() {
			return this.#ctimeMs;
		}
		#birthtimeMs;
		get birthtimeMs() {
			return this.#birthtimeMs;
		}
		#atime;
		get atime() {
			return this.#atime;
		}
		#mtime;
		get mtime() {
			return this.#mtime;
		}
		#ctime;
		get ctime() {
			return this.#ctime;
		}
		#birthtime;
		get birthtime() {
			return this.#birthtime;
		}
		#matchName;
		#depth;
		#fullpath;
		#fullpathPosix;
		#relative;
		#relativePosix;
		#type;
		#children;
		#linkTarget;
		#realpath;
		get parentPath() {
			return (this.parent || this).fullpath();
		}
		get path() {
			return this.parentPath;
		}
		constructor(name$1, type = UNKNOWN, root, roots, nocase, children, opts) {
			this.name = name$1;
			this.#matchName = nocase ? normalizeNocase(name$1) : normalize(name$1);
			this.#type = type & TYPEMASK;
			this.nocase = nocase;
			this.roots = roots;
			this.root = root || this;
			this.#children = children;
			this.#fullpath = opts.fullpath;
			this.#relative = opts.relative;
			this.#relativePosix = opts.relativePosix;
			this.parent = opts.parent;
			if (this.parent) this.#fs = this.parent.#fs;
			else this.#fs = fsFromOption(opts.fs);
		}
		depth() {
			if (this.#depth !== void 0) return this.#depth;
			if (!this.parent) return this.#depth = 0;
			return this.#depth = this.parent.depth() + 1;
		}
		childrenCache() {
			return this.#children;
		}
		resolve(path$5) {
			if (!path$5) return this;
			const rootPath = this.getRootString(path$5);
			const dirParts = path$5.substring(rootPath.length).split(this.splitSep);
			return rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
		}
		#resolveParts(dirParts) {
			let p = this;
			for (const part of dirParts) p = p.child(part);
			return p;
		}
		children() {
			const cached = this.#children.get(this);
			if (cached) return cached;
			const children = Object.assign([], { provisional: 0 });
			this.#children.set(this, children);
			this.#type &= ~READDIR_CALLED;
			return children;
		}
		child(pathPart, opts) {
			if (pathPart === "" || pathPart === ".") return this;
			if (pathPart === "..") return this.parent || this;
			const children = this.children();
			const name$1 = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
			for (const p of children) if (p.#matchName === name$1) return p;
			const s = this.parent ? this.sep : "";
			const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
			const pchild = this.newChild(pathPart, UNKNOWN, {
				...opts,
				parent: this,
				fullpath
			});
			if (!this.canReaddir()) pchild.#type |= ENOENT;
			children.push(pchild);
			return pchild;
		}
		relative() {
			if (this.isCWD) return "";
			if (this.#relative !== void 0) return this.#relative;
			const name$1 = this.name;
			const p = this.parent;
			if (!p) return this.#relative = this.name;
			const pv = p.relative();
			return pv + (!pv || !p.parent ? "" : this.sep) + name$1;
		}
		relativePosix() {
			if (this.sep === "/") return this.relative();
			if (this.isCWD) return "";
			if (this.#relativePosix !== void 0) return this.#relativePosix;
			const name$1 = this.name;
			const p = this.parent;
			if (!p) return this.#relativePosix = this.fullpathPosix();
			const pv = p.relativePosix();
			return pv + (!pv || !p.parent ? "" : "/") + name$1;
		}
		fullpath() {
			if (this.#fullpath !== void 0) return this.#fullpath;
			const name$1 = this.name;
			const p = this.parent;
			if (!p) return this.#fullpath = this.name;
			return this.#fullpath = p.fullpath() + (!p.parent ? "" : this.sep) + name$1;
		}
		fullpathPosix() {
			if (this.#fullpathPosix !== void 0) return this.#fullpathPosix;
			if (this.sep === "/") return this.#fullpathPosix = this.fullpath();
			if (!this.parent) {
				const p$1 = this.fullpath().replace(/\\/g, "/");
				if (/^[a-z]:\//i.test(p$1)) return this.#fullpathPosix = `//?/${p$1}`;
				else return this.#fullpathPosix = p$1;
			}
			const p = this.parent;
			const pfpp = p.fullpathPosix();
			return this.#fullpathPosix = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
		}
		isUnknown() {
			return (this.#type & IFMT) === UNKNOWN;
		}
		isType(type) {
			return this[`is${type}`]();
		}
		getType() {
			return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : this.isSocket() ? "Socket" : "Unknown";
			/* c8 ignore stop */
		}
		isFile() {
			return (this.#type & IFMT) === IFREG;
		}
		isDirectory() {
			return (this.#type & IFMT) === IFDIR;
		}
		isCharacterDevice() {
			return (this.#type & IFMT) === IFCHR;
		}
		isBlockDevice() {
			return (this.#type & IFMT) === IFBLK;
		}
		isFIFO() {
			return (this.#type & IFMT) === IFIFO;
		}
		isSocket() {
			return (this.#type & IFMT) === IFSOCK;
		}
		isSymbolicLink() {
			return (this.#type & IFLNK) === IFLNK;
		}
		lstatCached() {
			return this.#type & LSTAT_CALLED ? this : void 0;
		}
		readlinkCached() {
			return this.#linkTarget;
		}
		realpathCached() {
			return this.#realpath;
		}
		readdirCached() {
			const children = this.children();
			return children.slice(0, children.provisional);
		}
		canReadlink() {
			if (this.#linkTarget) return true;
			if (!this.parent) return false;
			const ifmt = this.#type & IFMT;
			return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
		}
		calledReaddir() {
			return !!(this.#type & READDIR_CALLED);
		}
		isENOENT() {
			return !!(this.#type & ENOENT);
		}
		isNamed(n$1) {
			return !this.nocase ? this.#matchName === normalize(n$1) : this.#matchName === normalizeNocase(n$1);
		}
		async readlink() {
			const target = this.#linkTarget;
			if (target) return target;
			if (!this.canReadlink()) return;
			/* c8 ignore start */
			if (!this.parent) return;
			/* c8 ignore stop */
			try {
				const read = await this.#fs.promises.readlink(this.fullpath());
				const linkTarget = (await this.parent.realpath())?.resolve(read);
				if (linkTarget) return this.#linkTarget = linkTarget;
			} catch (er) {
				this.#readlinkFail(er.code);
				return;
			}
		}
		readlinkSync() {
			const target = this.#linkTarget;
			if (target) return target;
			if (!this.canReadlink()) return;
			/* c8 ignore start */
			if (!this.parent) return;
			/* c8 ignore stop */
			try {
				const read = this.#fs.readlinkSync(this.fullpath());
				const linkTarget = this.parent.realpathSync()?.resolve(read);
				if (linkTarget) return this.#linkTarget = linkTarget;
			} catch (er) {
				this.#readlinkFail(er.code);
				return;
			}
		}
		#readdirSuccess(children) {
			this.#type |= READDIR_CALLED;
			for (let p = children.provisional; p < children.length; p++) {
				const c = children[p];
				if (c) c.#markENOENT();
			}
		}
		#markENOENT() {
			if (this.#type & ENOENT) return;
			this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
			this.#markChildrenENOENT();
		}
		#markChildrenENOENT() {
			const children = this.children();
			children.provisional = 0;
			for (const p of children) p.#markENOENT();
		}
		#markENOREALPATH() {
			this.#type |= ENOREALPATH;
			this.#markENOTDIR();
		}
		#markENOTDIR() {
			/* c8 ignore start */
			if (this.#type & ENOTDIR) return;
			/* c8 ignore stop */
			let t$1 = this.#type;
			if ((t$1 & IFMT) === IFDIR) t$1 &= IFMT_UNKNOWN;
			this.#type = t$1 | ENOTDIR;
			this.#markChildrenENOENT();
		}
		#readdirFail(code = "") {
			if (code === "ENOTDIR" || code === "EPERM") this.#markENOTDIR();
			else if (code === "ENOENT") this.#markENOENT();
			else this.children().provisional = 0;
		}
		#lstatFail(code = "") {
			/* c8 ignore start */
			if (code === "ENOTDIR") this.parent.#markENOTDIR();
			else if (code === "ENOENT")
 /* c8 ignore stop */
			this.#markENOENT();
		}
		#readlinkFail(code = "") {
			let ter = this.#type;
			ter |= ENOREADLINK;
			if (code === "ENOENT") ter |= ENOENT;
			if (code === "EINVAL" || code === "UNKNOWN") ter &= IFMT_UNKNOWN;
			this.#type = ter;
			/* c8 ignore start */
			if (code === "ENOTDIR" && this.parent) this.parent.#markENOTDIR();
			/* c8 ignore stop */
		}
		#readdirAddChild(e$1, c) {
			return this.#readdirMaybePromoteChild(e$1, c) || this.#readdirAddNewChild(e$1, c);
		}
		#readdirAddNewChild(e$1, c) {
			const type = entToType(e$1);
			const child = this.newChild(e$1.name, type, { parent: this });
			const ifmt = child.#type & IFMT;
			if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) child.#type |= ENOTDIR;
			c.unshift(child);
			c.provisional++;
			return child;
		}
		#readdirMaybePromoteChild(e$1, c) {
			for (let p = c.provisional; p < c.length; p++) {
				const pchild = c[p];
				if ((this.nocase ? normalizeNocase(e$1.name) : normalize(e$1.name)) !== pchild.#matchName) continue;
				return this.#readdirPromoteChild(e$1, pchild, p, c);
			}
		}
		#readdirPromoteChild(e$1, p, index$1, c) {
			const v = p.name;
			p.#type = p.#type & IFMT_UNKNOWN | entToType(e$1);
			if (v !== e$1.name) p.name = e$1.name;
			if (index$1 !== c.provisional) {
				if (index$1 === c.length - 1) c.pop();
				else c.splice(index$1, 1);
				c.unshift(p);
			}
			c.provisional++;
			return p;
		}
		async lstat() {
			if ((this.#type & ENOENT) === 0) try {
				this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
				return this;
			} catch (er) {
				this.#lstatFail(er.code);
			}
		}
		lstatSync() {
			if ((this.#type & ENOENT) === 0) try {
				this.#applyStat(this.#fs.lstatSync(this.fullpath()));
				return this;
			} catch (er) {
				this.#lstatFail(er.code);
			}
		}
		#applyStat(st) {
			const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
			this.#atime = atime;
			this.#atimeMs = atimeMs;
			this.#birthtime = birthtime;
			this.#birthtimeMs = birthtimeMs;
			this.#blksize = blksize;
			this.#blocks = blocks;
			this.#ctime = ctime;
			this.#ctimeMs = ctimeMs;
			this.#dev = dev;
			this.#gid = gid;
			this.#ino = ino;
			this.#mode = mode;
			this.#mtime = mtime;
			this.#mtimeMs = mtimeMs;
			this.#nlink = nlink;
			this.#rdev = rdev;
			this.#size = size;
			this.#uid = uid;
			const ifmt = entToType(st);
			this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
			if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) this.#type |= ENOTDIR;
		}
		#onReaddirCB = [];
		#readdirCBInFlight = false;
		#callOnReaddirCB(children) {
			this.#readdirCBInFlight = false;
			const cbs = this.#onReaddirCB.slice();
			this.#onReaddirCB.length = 0;
			cbs.forEach((cb) => cb(null, children));
		}
		readdirCB(cb, allowZalgo = false) {
			if (!this.canReaddir()) {
				if (allowZalgo) cb(null, []);
				else queueMicrotask(() => cb(null, []));
				return;
			}
			const children = this.children();
			if (this.calledReaddir()) {
				const c = children.slice(0, children.provisional);
				if (allowZalgo) cb(null, c);
				else queueMicrotask(() => cb(null, c));
				return;
			}
			this.#onReaddirCB.push(cb);
			if (this.#readdirCBInFlight) return;
			this.#readdirCBInFlight = true;
			const fullpath = this.fullpath();
			this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
				if (er) {
					this.#readdirFail(er.code);
					children.provisional = 0;
				} else {
					for (const e$1 of entries) this.#readdirAddChild(e$1, children);
					this.#readdirSuccess(children);
				}
				this.#callOnReaddirCB(children.slice(0, children.provisional));
			});
		}
		#asyncReaddirInFlight;
		async readdir() {
			if (!this.canReaddir()) return [];
			const children = this.children();
			if (this.calledReaddir()) return children.slice(0, children.provisional);
			const fullpath = this.fullpath();
			if (this.#asyncReaddirInFlight) await this.#asyncReaddirInFlight;
			else {
				/* c8 ignore start */
				let resolve$1 = () => {};
				/* c8 ignore stop */
				this.#asyncReaddirInFlight = new Promise((res) => resolve$1 = res);
				try {
					for (const e$1 of await this.#fs.promises.readdir(fullpath, { withFileTypes: true })) this.#readdirAddChild(e$1, children);
					this.#readdirSuccess(children);
				} catch (er) {
					this.#readdirFail(er.code);
					children.provisional = 0;
				}
				this.#asyncReaddirInFlight = void 0;
				resolve$1();
			}
			return children.slice(0, children.provisional);
		}
		readdirSync() {
			if (!this.canReaddir()) return [];
			const children = this.children();
			if (this.calledReaddir()) return children.slice(0, children.provisional);
			const fullpath = this.fullpath();
			try {
				for (const e$1 of this.#fs.readdirSync(fullpath, { withFileTypes: true })) this.#readdirAddChild(e$1, children);
				this.#readdirSuccess(children);
			} catch (er) {
				this.#readdirFail(er.code);
				children.provisional = 0;
			}
			return children.slice(0, children.provisional);
		}
		canReaddir() {
			if (this.#type & ENOCHILD) return false;
			const ifmt = IFMT & this.#type;
			/* c8 ignore start */
			if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) return false;
			/* c8 ignore stop */
			return true;
		}
		shouldWalk(dirs, walkFilter) {
			return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
		}
		async realpath() {
			if (this.#realpath) return this.#realpath;
			if ((ENOREADLINK | 640) & this.#type) return void 0;
			try {
				const rp = await this.#fs.promises.realpath(this.fullpath());
				return this.#realpath = this.resolve(rp);
			} catch (_$1) {
				this.#markENOREALPATH();
			}
		}
		realpathSync() {
			if (this.#realpath) return this.#realpath;
			if ((ENOREADLINK | 640) & this.#type) return void 0;
			try {
				const rp = this.#fs.realpathSync(this.fullpath());
				return this.#realpath = this.resolve(rp);
			} catch (_$1) {
				this.#markENOREALPATH();
			}
		}
		[setAsCwd](oldCwd) {
			if (oldCwd === this) return;
			oldCwd.isCWD = false;
			this.isCWD = true;
			const changed = /* @__PURE__ */ new Set([]);
			let rp = [];
			let p = this;
			while (p && p.parent) {
				changed.add(p);
				p.#relative = rp.join(this.sep);
				p.#relativePosix = rp.join("/");
				p = p.parent;
				rp.push("..");
			}
			p = oldCwd;
			while (p && p.parent && !changed.has(p)) {
				p.#relative = void 0;
				p.#relativePosix = void 0;
				p = p.parent;
			}
		}
	};
	exports.PathBase = PathBase;
	var PathWin32 = class PathWin32 extends PathBase {
		sep = "\\";
		splitSep = eitherSep;
		constructor(name$1, type = UNKNOWN, root, roots, nocase, children, opts) {
			super(name$1, type, root, roots, nocase, children, opts);
		}
		newChild(name$1, type = UNKNOWN, opts = {}) {
			return new PathWin32(name$1, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
		}
		getRootString(path$5) {
			return node_path_1.win32.parse(path$5).root;
		}
		getRoot(rootPath) {
			rootPath = uncToDrive(rootPath.toUpperCase());
			if (rootPath === this.root.name) return this.root;
			for (const [compare, root] of Object.entries(this.roots)) if (this.sameRoot(rootPath, compare)) return this.roots[rootPath] = root;
			return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
		}
		sameRoot(rootPath, compare = this.root.name) {
			rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
			return rootPath === compare;
		}
	};
	exports.PathWin32 = PathWin32;
	var PathPosix = class PathPosix extends PathBase {
		splitSep = "/";
		sep = "/";
		constructor(name$1, type = UNKNOWN, root, roots, nocase, children, opts) {
			super(name$1, type, root, roots, nocase, children, opts);
		}
		getRootString(path$5) {
			return path$5.startsWith("/") ? "/" : "";
		}
		getRoot(_rootPath) {
			return this.root;
		}
		newChild(name$1, type = UNKNOWN, opts = {}) {
			return new PathPosix(name$1, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
		}
	};
	exports.PathPosix = PathPosix;
	var PathScurryBase = class {
		root;
		rootPath;
		roots;
		cwd;
		#resolveCache;
		#resolvePosixCache;
		#children;
		nocase;
		#fs;
		constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs: fs$7 = defaultFS } = {}) {
			this.#fs = fsFromOption(fs$7);
			if (cwd instanceof URL || cwd.startsWith("file://")) cwd = (0, node_url_1$1.fileURLToPath)(cwd);
			const cwdPath = pathImpl.resolve(cwd);
			this.roots = Object.create(null);
			this.rootPath = this.parseRootPath(cwdPath);
			this.#resolveCache = new ResolveCache();
			this.#resolvePosixCache = new ResolveCache();
			this.#children = new ChildrenCache(childrenCacheSize);
			const split = cwdPath.substring(this.rootPath.length).split(sep);
			if (split.length === 1 && !split[0]) split.pop();
			/* c8 ignore start */
			if (nocase === void 0) throw new TypeError("must provide nocase setting to PathScurryBase ctor");
			/* c8 ignore stop */
			this.nocase = nocase;
			this.root = this.newRoot(this.#fs);
			this.roots[this.rootPath] = this.root;
			let prev = this.root;
			let len = split.length - 1;
			const joinSep = pathImpl.sep;
			let abs = this.rootPath;
			let sawFirst = false;
			for (const part of split) {
				const l = len--;
				prev = prev.child(part, {
					relative: new Array(l).fill("..").join(joinSep),
					relativePosix: new Array(l).fill("..").join("/"),
					fullpath: abs += (sawFirst ? "" : joinSep) + part
				});
				sawFirst = true;
			}
			this.cwd = prev;
		}
		depth(path$5 = this.cwd) {
			if (typeof path$5 === "string") path$5 = this.cwd.resolve(path$5);
			return path$5.depth();
		}
		childrenCache() {
			return this.#children;
		}
		resolve(...paths) {
			let r$1 = "";
			for (let i = paths.length - 1; i >= 0; i--) {
				const p = paths[i];
				if (!p || p === ".") continue;
				r$1 = r$1 ? `${p}/${r$1}` : p;
				if (this.isAbsolute(p)) break;
			}
			const cached = this.#resolveCache.get(r$1);
			if (cached !== void 0) return cached;
			const result = this.cwd.resolve(r$1).fullpath();
			this.#resolveCache.set(r$1, result);
			return result;
		}
		resolvePosix(...paths) {
			let r$1 = "";
			for (let i = paths.length - 1; i >= 0; i--) {
				const p = paths[i];
				if (!p || p === ".") continue;
				r$1 = r$1 ? `${p}/${r$1}` : p;
				if (this.isAbsolute(p)) break;
			}
			const cached = this.#resolvePosixCache.get(r$1);
			if (cached !== void 0) return cached;
			const result = this.cwd.resolve(r$1).fullpathPosix();
			this.#resolvePosixCache.set(r$1, result);
			return result;
		}
		relative(entry = this.cwd) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			return entry.relative();
		}
		relativePosix(entry = this.cwd) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			return entry.relativePosix();
		}
		basename(entry = this.cwd) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			return entry.name;
		}
		dirname(entry = this.cwd) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			return (entry.parent || entry).fullpath();
		}
		async readdir(entry = this.cwd, opts = { withFileTypes: true }) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				opts = entry;
				entry = this.cwd;
			}
			const { withFileTypes } = opts;
			if (!entry.canReaddir()) return [];
			else {
				const p = await entry.readdir();
				return withFileTypes ? p : p.map((e$1) => e$1.name);
			}
		}
		readdirSync(entry = this.cwd, opts = { withFileTypes: true }) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				opts = entry;
				entry = this.cwd;
			}
			const { withFileTypes = true } = opts;
			if (!entry.canReaddir()) return [];
			else if (withFileTypes) return entry.readdirSync();
			else return entry.readdirSync().map((e$1) => e$1.name);
		}
		async lstat(entry = this.cwd) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			return entry.lstat();
		}
		lstatSync(entry = this.cwd) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			return entry.lstatSync();
		}
		async readlink(entry = this.cwd, { withFileTypes } = { withFileTypes: false }) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				withFileTypes = entry.withFileTypes;
				entry = this.cwd;
			}
			const e$1 = await entry.readlink();
			return withFileTypes ? e$1 : e$1?.fullpath();
		}
		readlinkSync(entry = this.cwd, { withFileTypes } = { withFileTypes: false }) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				withFileTypes = entry.withFileTypes;
				entry = this.cwd;
			}
			const e$1 = entry.readlinkSync();
			return withFileTypes ? e$1 : e$1?.fullpath();
		}
		async realpath(entry = this.cwd, { withFileTypes } = { withFileTypes: false }) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				withFileTypes = entry.withFileTypes;
				entry = this.cwd;
			}
			const e$1 = await entry.realpath();
			return withFileTypes ? e$1 : e$1?.fullpath();
		}
		realpathSync(entry = this.cwd, { withFileTypes } = { withFileTypes: false }) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				withFileTypes = entry.withFileTypes;
				entry = this.cwd;
			}
			const e$1 = entry.realpathSync();
			return withFileTypes ? e$1 : e$1?.fullpath();
		}
		async walk(entry = this.cwd, opts = {}) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				opts = entry;
				entry = this.cwd;
			}
			const { withFileTypes = true, follow = false, filter: filter$3, walkFilter } = opts;
			const results = [];
			if (!filter$3 || filter$3(entry)) results.push(withFileTypes ? entry : entry.fullpath());
			const dirs = /* @__PURE__ */ new Set();
			const walk = (dir$1, cb) => {
				dirs.add(dir$1);
				dir$1.readdirCB((er, entries) => {
					/* c8 ignore start */
					if (er) return cb(er);
					/* c8 ignore stop */
					let len = entries.length;
					if (!len) return cb();
					const next = () => {
						if (--len === 0) cb();
					};
					for (const e$1 of entries) {
						if (!filter$3 || filter$3(e$1)) results.push(withFileTypes ? e$1 : e$1.fullpath());
						if (follow && e$1.isSymbolicLink()) e$1.realpath().then((r$1) => r$1?.isUnknown() ? r$1.lstat() : r$1).then((r$1) => r$1?.shouldWalk(dirs, walkFilter) ? walk(r$1, next) : next());
						else if (e$1.shouldWalk(dirs, walkFilter)) walk(e$1, next);
						else next();
					}
				}, true);
			};
			const start = entry;
			return new Promise((res, rej) => {
				walk(start, (er) => {
					/* c8 ignore start */
					if (er) return rej(er);
					/* c8 ignore stop */
					res(results);
				});
			});
		}
		walkSync(entry = this.cwd, opts = {}) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				opts = entry;
				entry = this.cwd;
			}
			const { withFileTypes = true, follow = false, filter: filter$3, walkFilter } = opts;
			const results = [];
			if (!filter$3 || filter$3(entry)) results.push(withFileTypes ? entry : entry.fullpath());
			const dirs = new Set([entry]);
			for (const dir$1 of dirs) {
				const entries = dir$1.readdirSync();
				for (const e$1 of entries) {
					if (!filter$3 || filter$3(e$1)) results.push(withFileTypes ? e$1 : e$1.fullpath());
					let r$1 = e$1;
					if (e$1.isSymbolicLink()) {
						if (!(follow && (r$1 = e$1.realpathSync()))) continue;
						if (r$1.isUnknown()) r$1.lstatSync();
					}
					if (r$1.shouldWalk(dirs, walkFilter)) dirs.add(r$1);
				}
			}
			return results;
		}
		[Symbol.asyncIterator]() {
			return this.iterate();
		}
		iterate(entry = this.cwd, options = {}) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				options = entry;
				entry = this.cwd;
			}
			return this.stream(entry, options)[Symbol.asyncIterator]();
		}
		[Symbol.iterator]() {
			return this.iterateSync();
		}
		*iterateSync(entry = this.cwd, opts = {}) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				opts = entry;
				entry = this.cwd;
			}
			const { withFileTypes = true, follow = false, filter: filter$3, walkFilter } = opts;
			if (!filter$3 || filter$3(entry)) yield withFileTypes ? entry : entry.fullpath();
			const dirs = new Set([entry]);
			for (const dir$1 of dirs) {
				const entries = dir$1.readdirSync();
				for (const e$1 of entries) {
					if (!filter$3 || filter$3(e$1)) yield withFileTypes ? e$1 : e$1.fullpath();
					let r$1 = e$1;
					if (e$1.isSymbolicLink()) {
						if (!(follow && (r$1 = e$1.realpathSync()))) continue;
						if (r$1.isUnknown()) r$1.lstatSync();
					}
					if (r$1.shouldWalk(dirs, walkFilter)) dirs.add(r$1);
				}
			}
		}
		stream(entry = this.cwd, opts = {}) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				opts = entry;
				entry = this.cwd;
			}
			const { withFileTypes = true, follow = false, filter: filter$3, walkFilter } = opts;
			const results = new minipass_1.Minipass({ objectMode: true });
			if (!filter$3 || filter$3(entry)) results.write(withFileTypes ? entry : entry.fullpath());
			const dirs = /* @__PURE__ */ new Set();
			const queue$2 = [entry];
			let processing = 0;
			const process$1 = () => {
				let paused = false;
				while (!paused) {
					const dir$1 = queue$2.shift();
					if (!dir$1) {
						if (processing === 0) results.end();
						return;
					}
					processing++;
					dirs.add(dir$1);
					const onReaddir = (er, entries, didRealpaths = false) => {
						/* c8 ignore start */
						if (er) return results.emit("error", er);
						/* c8 ignore stop */
						if (follow && !didRealpaths) {
							const promises = [];
							for (const e$1 of entries) if (e$1.isSymbolicLink()) promises.push(e$1.realpath().then((r$1) => r$1?.isUnknown() ? r$1.lstat() : r$1));
							if (promises.length) {
								Promise.all(promises).then(() => onReaddir(null, entries, true));
								return;
							}
						}
						for (const e$1 of entries) if (e$1 && (!filter$3 || filter$3(e$1))) {
							if (!results.write(withFileTypes ? e$1 : e$1.fullpath())) paused = true;
						}
						processing--;
						for (const e$1 of entries) {
							const r$1 = e$1.realpathCached() || e$1;
							if (r$1.shouldWalk(dirs, walkFilter)) queue$2.push(r$1);
						}
						if (paused && !results.flowing) results.once("drain", process$1);
						else if (!sync$3) process$1();
					};
					let sync$3 = true;
					dir$1.readdirCB(onReaddir, true);
					sync$3 = false;
				}
			};
			process$1();
			return results;
		}
		streamSync(entry = this.cwd, opts = {}) {
			if (typeof entry === "string") entry = this.cwd.resolve(entry);
			else if (!(entry instanceof PathBase)) {
				opts = entry;
				entry = this.cwd;
			}
			const { withFileTypes = true, follow = false, filter: filter$3, walkFilter } = opts;
			const results = new minipass_1.Minipass({ objectMode: true });
			const dirs = /* @__PURE__ */ new Set();
			if (!filter$3 || filter$3(entry)) results.write(withFileTypes ? entry : entry.fullpath());
			const queue$2 = [entry];
			let processing = 0;
			const process$1 = () => {
				let paused = false;
				while (!paused) {
					const dir$1 = queue$2.shift();
					if (!dir$1) {
						if (processing === 0) results.end();
						return;
					}
					processing++;
					dirs.add(dir$1);
					const entries = dir$1.readdirSync();
					for (const e$1 of entries) if (!filter$3 || filter$3(e$1)) {
						if (!results.write(withFileTypes ? e$1 : e$1.fullpath())) paused = true;
					}
					processing--;
					for (const e$1 of entries) {
						let r$1 = e$1;
						if (e$1.isSymbolicLink()) {
							if (!(follow && (r$1 = e$1.realpathSync()))) continue;
							if (r$1.isUnknown()) r$1.lstatSync();
						}
						if (r$1.shouldWalk(dirs, walkFilter)) queue$2.push(r$1);
					}
				}
				if (paused && !results.flowing) results.once("drain", process$1);
			};
			process$1();
			return results;
		}
		chdir(path$5 = this.cwd) {
			const oldCwd = this.cwd;
			this.cwd = typeof path$5 === "string" ? this.cwd.resolve(path$5) : path$5;
			this.cwd[setAsCwd](oldCwd);
		}
	};
	exports.PathScurryBase = PathScurryBase;
	var PathScurryWin32 = class extends PathScurryBase {
		sep = "\\";
		constructor(cwd = process.cwd(), opts = {}) {
			const { nocase = true } = opts;
			super(cwd, node_path_1.win32, "\\", {
				...opts,
				nocase
			});
			this.nocase = nocase;
			for (let p = this.cwd; p; p = p.parent) p.nocase = this.nocase;
		}
		parseRootPath(dir$1) {
			return node_path_1.win32.parse(dir$1).root.toUpperCase();
		}
		newRoot(fs$7) {
			return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs$7 });
		}
		isAbsolute(p) {
			return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
		}
	};
	exports.PathScurryWin32 = PathScurryWin32;
	var PathScurryPosix = class extends PathScurryBase {
		sep = "/";
		constructor(cwd = process.cwd(), opts = {}) {
			const { nocase = false } = opts;
			super(cwd, node_path_1.posix, "/", {
				...opts,
				nocase
			});
			this.nocase = nocase;
		}
		parseRootPath(_dir) {
			return "/";
		}
		newRoot(fs$7) {
			return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs$7 });
		}
		isAbsolute(p) {
			return p.startsWith("/");
		}
	};
	exports.PathScurryPosix = PathScurryPosix;
	var PathScurryDarwin = class extends PathScurryPosix {
		constructor(cwd = process.cwd(), opts = {}) {
			const { nocase = true } = opts;
			super(cwd, {
				...opts,
				nocase
			});
		}
	};
	exports.PathScurryDarwin = PathScurryDarwin;
	exports.Path = process.platform === "win32" ? PathWin32 : PathPosix;
	exports.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
}));
var require_pattern = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Pattern = void 0;
	var minimatch_1 = require_commonjs$4();
	var isPatternList = (pl) => pl.length >= 1;
	var isGlobList = (gl) => gl.length >= 1;
	exports.Pattern = class Pattern {
		#patternList;
		#globList;
		#index;
		length;
		#platform;
		#rest;
		#globString;
		#isDrive;
		#isUNC;
		#isAbsolute;
		#followGlobstar = true;
		constructor(patternList, globList, index$1, platform) {
			if (!isPatternList(patternList)) throw new TypeError("empty pattern list");
			if (!isGlobList(globList)) throw new TypeError("empty glob list");
			if (globList.length !== patternList.length) throw new TypeError("mismatched pattern list and glob list lengths");
			this.length = patternList.length;
			if (index$1 < 0 || index$1 >= this.length) throw new TypeError("index out of range");
			this.#patternList = patternList;
			this.#globList = globList;
			this.#index = index$1;
			this.#platform = platform;
			if (this.#index === 0) {
				if (this.isUNC()) {
					const [p0, p1, p2, p3, ...prest] = this.#patternList;
					const [g0, g1, g2, g3, ...grest] = this.#globList;
					if (prest[0] === "") {
						prest.shift();
						grest.shift();
					}
					const p = [
						p0,
						p1,
						p2,
						p3,
						""
					].join("/");
					const g = [
						g0,
						g1,
						g2,
						g3,
						""
					].join("/");
					this.#patternList = [p, ...prest];
					this.#globList = [g, ...grest];
					this.length = this.#patternList.length;
				} else if (this.isDrive() || this.isAbsolute()) {
					const [p1, ...prest] = this.#patternList;
					const [g1, ...grest] = this.#globList;
					if (prest[0] === "") {
						prest.shift();
						grest.shift();
					}
					const p = p1 + "/";
					const g = g1 + "/";
					this.#patternList = [p, ...prest];
					this.#globList = [g, ...grest];
					this.length = this.#patternList.length;
				}
			}
		}
		pattern() {
			return this.#patternList[this.#index];
		}
		isString() {
			return typeof this.#patternList[this.#index] === "string";
		}
		isGlobstar() {
			return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
		}
		isRegExp() {
			return this.#patternList[this.#index] instanceof RegExp;
		}
		globString() {
			return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
		}
		hasMore() {
			return this.length > this.#index + 1;
		}
		rest() {
			if (this.#rest !== void 0) return this.#rest;
			if (!this.hasMore()) return this.#rest = null;
			this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
			this.#rest.#isAbsolute = this.#isAbsolute;
			this.#rest.#isUNC = this.#isUNC;
			this.#rest.#isDrive = this.#isDrive;
			return this.#rest;
		}
		isUNC() {
			const pl = this.#patternList;
			return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
		}
		isDrive() {
			const pl = this.#patternList;
			return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
		}
		isAbsolute() {
			const pl = this.#patternList;
			return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
		}
		root() {
			const p = this.#patternList[0];
			return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
		}
		checkFollowGlobstar() {
			return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
		}
		markFollowGlobstar() {
			if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar) return false;
			this.#followGlobstar = false;
			return true;
		}
	};
}));
var require_ignore = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Ignore = void 0;
	var minimatch_1 = require_commonjs$4();
	var pattern_js_1 = require_pattern();
	var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
	var Ignore = class {
		relative;
		relativeChildren;
		absolute;
		absoluteChildren;
		platform;
		mmopts;
		constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
			this.relative = [];
			this.absolute = [];
			this.relativeChildren = [];
			this.absoluteChildren = [];
			this.platform = platform;
			this.mmopts = {
				dot: true,
				nobrace,
				nocase,
				noext,
				noglobstar,
				optimizationLevel: 2,
				platform,
				nocomment: true,
				nonegate: true
			};
			for (const ign of ignored) this.add(ign);
		}
		add(ign) {
			const mm = new minimatch_1.Minimatch(ign, this.mmopts);
			for (let i = 0; i < mm.set.length; i++) {
				const parsed = mm.set[i];
				const globParts = mm.globParts[i];
				/* c8 ignore start */
				if (!parsed || !globParts) throw new Error("invalid pattern object");
				while (parsed[0] === "." && globParts[0] === ".") {
					parsed.shift();
					globParts.shift();
				}
				/* c8 ignore stop */
				const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
				const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
				const children = globParts[globParts.length - 1] === "**";
				const absolute = p.isAbsolute();
				if (absolute) this.absolute.push(m);
				else this.relative.push(m);
				if (children) if (absolute) this.absoluteChildren.push(m);
				else this.relativeChildren.push(m);
			}
		}
		ignored(p) {
			const fullpath = p.fullpath();
			const fullpaths = `${fullpath}/`;
			const relative = p.relative() || ".";
			const relatives = `${relative}/`;
			for (const m of this.relative) if (m.match(relative) || m.match(relatives)) return true;
			for (const m of this.absolute) if (m.match(fullpath) || m.match(fullpaths)) return true;
			return false;
		}
		childrenIgnored(p) {
			const fullpath = p.fullpath() + "/";
			const relative = (p.relative() || ".") + "/";
			for (const m of this.relativeChildren) if (m.match(relative)) return true;
			for (const m of this.absoluteChildren) if (m.match(fullpath)) return true;
			return false;
		}
	};
	exports.Ignore = Ignore;
}));
var require_processor = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;
	var minimatch_1 = require_commonjs$4();
	var HasWalkedCache = class HasWalkedCache {
		store;
		constructor(store = /* @__PURE__ */ new Map()) {
			this.store = store;
		}
		copy() {
			return new HasWalkedCache(new Map(this.store));
		}
		hasWalked(target, pattern$1) {
			return this.store.get(target.fullpath())?.has(pattern$1.globString());
		}
		storeWalked(target, pattern$1) {
			const fullpath = target.fullpath();
			const cached = this.store.get(fullpath);
			if (cached) cached.add(pattern$1.globString());
			else this.store.set(fullpath, new Set([pattern$1.globString()]));
		}
	};
	exports.HasWalkedCache = HasWalkedCache;
	var MatchRecord = class {
		store = /* @__PURE__ */ new Map();
		add(target, absolute, ifDir) {
			const n$1 = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
			const current = this.store.get(target);
			this.store.set(target, current === void 0 ? n$1 : n$1 & current);
		}
		entries() {
			return [...this.store.entries()].map(([path$5, n$1]) => [
				path$5,
				!!(n$1 & 2),
				!!(n$1 & 1)
			]);
		}
	};
	exports.MatchRecord = MatchRecord;
	var SubWalks = class {
		store = /* @__PURE__ */ new Map();
		add(target, pattern$1) {
			if (!target.canReaddir()) return;
			const subs = this.store.get(target);
			if (subs) {
				if (!subs.find((p) => p.globString() === pattern$1.globString())) subs.push(pattern$1);
			} else this.store.set(target, [pattern$1]);
		}
		get(target) {
			const subs = this.store.get(target);
			/* c8 ignore start */
			if (!subs) throw new Error("attempting to walk unknown path");
			/* c8 ignore stop */
			return subs;
		}
		entries() {
			return this.keys().map((k) => [k, this.store.get(k)]);
		}
		keys() {
			return [...this.store.keys()].filter((t$1) => t$1.canReaddir());
		}
	};
	exports.SubWalks = SubWalks;
	exports.Processor = class Processor {
		hasWalkedCache;
		matches = new MatchRecord();
		subwalks = new SubWalks();
		patterns;
		follow;
		dot;
		opts;
		constructor(opts, hasWalkedCache) {
			this.opts = opts;
			this.follow = !!opts.follow;
			this.dot = !!opts.dot;
			this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
		}
		processPatterns(target, patterns) {
			this.patterns = patterns;
			const processingSet = patterns.map((p) => [target, p]);
			for (let [t$1, pattern$1] of processingSet) {
				this.hasWalkedCache.storeWalked(t$1, pattern$1);
				const root = pattern$1.root();
				const absolute = pattern$1.isAbsolute() && this.opts.absolute !== false;
				if (root) {
					t$1 = t$1.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
					const rest$1 = pattern$1.rest();
					if (!rest$1) {
						this.matches.add(t$1, true, false);
						continue;
					} else pattern$1 = rest$1;
				}
				if (t$1.isENOENT()) continue;
				let p;
				let rest;
				let changed = false;
				while (typeof (p = pattern$1.pattern()) === "string" && (rest = pattern$1.rest())) {
					t$1 = t$1.resolve(p);
					pattern$1 = rest;
					changed = true;
				}
				p = pattern$1.pattern();
				rest = pattern$1.rest();
				if (changed) {
					if (this.hasWalkedCache.hasWalked(t$1, pattern$1)) continue;
					this.hasWalkedCache.storeWalked(t$1, pattern$1);
				}
				if (typeof p === "string") {
					const ifDir = p === ".." || p === "" || p === ".";
					this.matches.add(t$1.resolve(p), absolute, ifDir);
					continue;
				} else if (p === minimatch_1.GLOBSTAR) {
					if (!t$1.isSymbolicLink() || this.follow || pattern$1.checkFollowGlobstar()) this.subwalks.add(t$1, pattern$1);
					const rp = rest?.pattern();
					const rrest = rest?.rest();
					if (!rest || (rp === "" || rp === ".") && !rrest) this.matches.add(t$1, absolute, rp === "" || rp === ".");
					else if (rp === "..") {
						/* c8 ignore start */
						const tp = t$1.parent || t$1;
						/* c8 ignore stop */
						if (!rrest) this.matches.add(tp, absolute, true);
						else if (!this.hasWalkedCache.hasWalked(tp, rrest)) this.subwalks.add(tp, rrest);
					}
				} else if (p instanceof RegExp) this.subwalks.add(t$1, pattern$1);
			}
			return this;
		}
		subwalkTargets() {
			return this.subwalks.keys();
		}
		child() {
			return new Processor(this.opts, this.hasWalkedCache);
		}
		filterEntries(parent$1, entries) {
			const patterns = this.subwalks.get(parent$1);
			const results = this.child();
			for (const e$1 of entries) for (const pattern$1 of patterns) {
				const absolute = pattern$1.isAbsolute();
				const p = pattern$1.pattern();
				const rest = pattern$1.rest();
				if (p === minimatch_1.GLOBSTAR) results.testGlobstar(e$1, pattern$1, rest, absolute);
				else if (p instanceof RegExp) results.testRegExp(e$1, p, rest, absolute);
				else results.testString(e$1, p, rest, absolute);
			}
			return results;
		}
		testGlobstar(e$1, pattern$1, rest, absolute) {
			if (this.dot || !e$1.name.startsWith(".")) {
				if (!pattern$1.hasMore()) this.matches.add(e$1, absolute, false);
				if (e$1.canReaddir()) {
					if (this.follow || !e$1.isSymbolicLink()) this.subwalks.add(e$1, pattern$1);
					else if (e$1.isSymbolicLink()) {
						if (rest && pattern$1.checkFollowGlobstar()) this.subwalks.add(e$1, rest);
						else if (pattern$1.markFollowGlobstar()) this.subwalks.add(e$1, pattern$1);
					}
				}
			}
			if (rest) {
				const rp = rest.pattern();
				if (typeof rp === "string" && rp !== ".." && rp !== "" && rp !== ".") this.testString(e$1, rp, rest.rest(), absolute);
				else if (rp === "..") {
					/* c8 ignore start */
					const ep = e$1.parent || e$1;
					/* c8 ignore stop */
					this.subwalks.add(ep, rest);
				} else if (rp instanceof RegExp) this.testRegExp(e$1, rp, rest.rest(), absolute);
			}
		}
		testRegExp(e$1, p, rest, absolute) {
			if (!p.test(e$1.name)) return;
			if (!rest) this.matches.add(e$1, absolute, false);
			else this.subwalks.add(e$1, rest);
		}
		testString(e$1, p, rest, absolute) {
			if (!e$1.isNamed(p)) return;
			if (!rest) this.matches.add(e$1, absolute, false);
			else this.subwalks.add(e$1, rest);
		}
	};
}));
var require_walker = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;
	var minipass_1 = require_commonjs$2();
	var ignore_js_1 = require_ignore();
	var processor_js_1 = require_processor();
	var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;
	var GlobUtil = class {
		path;
		patterns;
		opts;
		seen = /* @__PURE__ */ new Set();
		paused = false;
		aborted = false;
		#onResume = [];
		#ignore;
		#sep;
		signal;
		maxDepth;
		includeChildMatches;
		constructor(patterns, path$5, opts) {
			this.patterns = patterns;
			this.path = path$5;
			this.opts = opts;
			this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
			this.includeChildMatches = opts.includeChildMatches !== false;
			if (opts.ignore || !this.includeChildMatches) {
				this.#ignore = makeIgnore(opts.ignore ?? [], opts);
				if (!this.includeChildMatches && typeof this.#ignore.add !== "function") throw new Error("cannot ignore child matches, ignore lacks add() method.");
			}
			/* c8 ignore start */
			this.maxDepth = opts.maxDepth || Infinity;
			/* c8 ignore stop */
			if (opts.signal) {
				this.signal = opts.signal;
				this.signal.addEventListener("abort", () => {
					this.#onResume.length = 0;
				});
			}
		}
		#ignored(path$5) {
			return this.seen.has(path$5) || !!this.#ignore?.ignored?.(path$5);
		}
		#childrenIgnored(path$5) {
			return !!this.#ignore?.childrenIgnored?.(path$5);
		}
		pause() {
			this.paused = true;
		}
		resume() {
			/* c8 ignore start */
			if (this.signal?.aborted) return;
			/* c8 ignore stop */
			this.paused = false;
			let fn = void 0;
			while (!this.paused && (fn = this.#onResume.shift())) fn();
		}
		onResume(fn) {
			if (this.signal?.aborted) return;
			/* c8 ignore start */
			if (!this.paused) fn();
			else
 /* c8 ignore stop */
			this.#onResume.push(fn);
		}
		async matchCheck(e$1, ifDir) {
			if (ifDir && this.opts.nodir) return void 0;
			let rpc;
			if (this.opts.realpath) {
				rpc = e$1.realpathCached() || await e$1.realpath();
				if (!rpc) return void 0;
				e$1 = rpc;
			}
			const s = e$1.isUnknown() || this.opts.stat ? await e$1.lstat() : e$1;
			if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
				const target = await s.realpath();
				/* c8 ignore start */
				if (target && (target.isUnknown() || this.opts.stat)) await target.lstat();
			}
			return this.matchCheckTest(s, ifDir);
		}
		matchCheckTest(e$1, ifDir) {
			return e$1 && (this.maxDepth === Infinity || e$1.depth() <= this.maxDepth) && (!ifDir || e$1.canReaddir()) && (!this.opts.nodir || !e$1.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e$1.isSymbolicLink() || !e$1.realpathCached()?.isDirectory()) && !this.#ignored(e$1) ? e$1 : void 0;
		}
		matchCheckSync(e$1, ifDir) {
			if (ifDir && this.opts.nodir) return void 0;
			let rpc;
			if (this.opts.realpath) {
				rpc = e$1.realpathCached() || e$1.realpathSync();
				if (!rpc) return void 0;
				e$1 = rpc;
			}
			const s = e$1.isUnknown() || this.opts.stat ? e$1.lstatSync() : e$1;
			if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
				const target = s.realpathSync();
				if (target && (target?.isUnknown() || this.opts.stat)) target.lstatSync();
			}
			return this.matchCheckTest(s, ifDir);
		}
		matchFinish(e$1, absolute) {
			if (this.#ignored(e$1)) return;
			if (!this.includeChildMatches && this.#ignore?.add) {
				const ign = `${e$1.relativePosix()}/**`;
				this.#ignore.add(ign);
			}
			const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
			this.seen.add(e$1);
			const mark = this.opts.mark && e$1.isDirectory() ? this.#sep : "";
			if (this.opts.withFileTypes) this.matchEmit(e$1);
			else if (abs) {
				const abs$1 = this.opts.posix ? e$1.fullpathPosix() : e$1.fullpath();
				this.matchEmit(abs$1 + mark);
			} else {
				const rel = this.opts.posix ? e$1.relativePosix() : e$1.relative();
				const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
				this.matchEmit(!rel ? "." + mark : pre + rel + mark);
			}
		}
		async match(e$1, absolute, ifDir) {
			const p = await this.matchCheck(e$1, ifDir);
			if (p) this.matchFinish(p, absolute);
		}
		matchSync(e$1, absolute, ifDir) {
			const p = this.matchCheckSync(e$1, ifDir);
			if (p) this.matchFinish(p, absolute);
		}
		walkCB(target, patterns, cb) {
			/* c8 ignore start */
			if (this.signal?.aborted) cb();
			/* c8 ignore stop */
			this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
		}
		walkCB2(target, patterns, processor, cb) {
			if (this.#childrenIgnored(target)) return cb();
			if (this.signal?.aborted) cb();
			if (this.paused) {
				this.onResume(() => this.walkCB2(target, patterns, processor, cb));
				return;
			}
			processor.processPatterns(target, patterns);
			let tasks = 1;
			const next = () => {
				if (--tasks === 0) cb();
			};
			for (const [m, absolute, ifDir] of processor.matches.entries()) {
				if (this.#ignored(m)) continue;
				tasks++;
				this.match(m, absolute, ifDir).then(() => next());
			}
			for (const t$1 of processor.subwalkTargets()) {
				if (this.maxDepth !== Infinity && t$1.depth() >= this.maxDepth) continue;
				tasks++;
				const childrenCached = t$1.readdirCached();
				if (t$1.calledReaddir()) this.walkCB3(t$1, childrenCached, processor, next);
				else t$1.readdirCB((_$1, entries) => this.walkCB3(t$1, entries, processor, next), true);
			}
			next();
		}
		walkCB3(target, entries, processor, cb) {
			processor = processor.filterEntries(target, entries);
			let tasks = 1;
			const next = () => {
				if (--tasks === 0) cb();
			};
			for (const [m, absolute, ifDir] of processor.matches.entries()) {
				if (this.#ignored(m)) continue;
				tasks++;
				this.match(m, absolute, ifDir).then(() => next());
			}
			for (const [target$1, patterns] of processor.subwalks.entries()) {
				tasks++;
				this.walkCB2(target$1, patterns, processor.child(), next);
			}
			next();
		}
		walkCBSync(target, patterns, cb) {
			/* c8 ignore start */
			if (this.signal?.aborted) cb();
			/* c8 ignore stop */
			this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
		}
		walkCB2Sync(target, patterns, processor, cb) {
			if (this.#childrenIgnored(target)) return cb();
			if (this.signal?.aborted) cb();
			if (this.paused) {
				this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
				return;
			}
			processor.processPatterns(target, patterns);
			let tasks = 1;
			const next = () => {
				if (--tasks === 0) cb();
			};
			for (const [m, absolute, ifDir] of processor.matches.entries()) {
				if (this.#ignored(m)) continue;
				this.matchSync(m, absolute, ifDir);
			}
			for (const t$1 of processor.subwalkTargets()) {
				if (this.maxDepth !== Infinity && t$1.depth() >= this.maxDepth) continue;
				tasks++;
				const children = t$1.readdirSync();
				this.walkCB3Sync(t$1, children, processor, next);
			}
			next();
		}
		walkCB3Sync(target, entries, processor, cb) {
			processor = processor.filterEntries(target, entries);
			let tasks = 1;
			const next = () => {
				if (--tasks === 0) cb();
			};
			for (const [m, absolute, ifDir] of processor.matches.entries()) {
				if (this.#ignored(m)) continue;
				this.matchSync(m, absolute, ifDir);
			}
			for (const [target$1, patterns] of processor.subwalks.entries()) {
				tasks++;
				this.walkCB2Sync(target$1, patterns, processor.child(), next);
			}
			next();
		}
	};
	exports.GlobUtil = GlobUtil;
	var GlobWalker = class extends GlobUtil {
		matches = /* @__PURE__ */ new Set();
		constructor(patterns, path$5, opts) {
			super(patterns, path$5, opts);
		}
		matchEmit(e$1) {
			this.matches.add(e$1);
		}
		async walk() {
			if (this.signal?.aborted) throw this.signal.reason;
			if (this.path.isUnknown()) await this.path.lstat();
			await new Promise((res, rej) => {
				this.walkCB(this.path, this.patterns, () => {
					if (this.signal?.aborted) rej(this.signal.reason);
					else res(this.matches);
				});
			});
			return this.matches;
		}
		walkSync() {
			if (this.signal?.aborted) throw this.signal.reason;
			if (this.path.isUnknown()) this.path.lstatSync();
			this.walkCBSync(this.path, this.patterns, () => {
				if (this.signal?.aborted) throw this.signal.reason;
			});
			return this.matches;
		}
	};
	exports.GlobWalker = GlobWalker;
	var GlobStream = class extends GlobUtil {
		results;
		constructor(patterns, path$5, opts) {
			super(patterns, path$5, opts);
			this.results = new minipass_1.Minipass({
				signal: this.signal,
				objectMode: true
			});
			this.results.on("drain", () => this.resume());
			this.results.on("resume", () => this.resume());
		}
		matchEmit(e$1) {
			this.results.write(e$1);
			if (!this.results.flowing) this.pause();
		}
		stream() {
			const target = this.path;
			if (target.isUnknown()) target.lstat().then(() => {
				this.walkCB(target, this.patterns, () => this.results.end());
			});
			else this.walkCB(target, this.patterns, () => this.results.end());
			return this.results;
		}
		streamSync() {
			if (this.path.isUnknown()) this.path.lstatSync();
			this.walkCBSync(this.path, this.patterns, () => this.results.end());
			return this.results;
		}
	};
	exports.GlobStream = GlobStream;
}));
var require_glob = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Glob = void 0;
	var minimatch_1 = require_commonjs$4();
	var node_url_1 = __require("node:url");
	var path_scurry_1 = require_commonjs$1();
	var pattern_js_1 = require_pattern();
	var walker_js_1 = require_walker();
	var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
	var Glob = class {
		absolute;
		cwd;
		root;
		dot;
		dotRelative;
		follow;
		ignore;
		magicalBraces;
		mark;
		matchBase;
		maxDepth;
		nobrace;
		nocase;
		nodir;
		noext;
		noglobstar;
		pattern;
		platform;
		realpath;
		scurry;
		stat;
		signal;
		windowsPathsNoEscape;
		withFileTypes;
		includeChildMatches;
		opts;
		patterns;
		constructor(pattern$1, opts) {
			/* c8 ignore start */
			if (!opts) throw new TypeError("glob options required");
			/* c8 ignore stop */
			this.withFileTypes = !!opts.withFileTypes;
			this.signal = opts.signal;
			this.follow = !!opts.follow;
			this.dot = !!opts.dot;
			this.dotRelative = !!opts.dotRelative;
			this.nodir = !!opts.nodir;
			this.mark = !!opts.mark;
			if (!opts.cwd) this.cwd = "";
			else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
			this.cwd = opts.cwd || "";
			this.root = opts.root;
			this.magicalBraces = !!opts.magicalBraces;
			this.nobrace = !!opts.nobrace;
			this.noext = !!opts.noext;
			this.realpath = !!opts.realpath;
			this.absolute = opts.absolute;
			this.includeChildMatches = opts.includeChildMatches !== false;
			this.noglobstar = !!opts.noglobstar;
			this.matchBase = !!opts.matchBase;
			this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
			this.stat = !!opts.stat;
			this.ignore = opts.ignore;
			if (this.withFileTypes && this.absolute !== void 0) throw new Error("cannot set absolute and withFileTypes:true");
			if (typeof pattern$1 === "string") pattern$1 = [pattern$1];
			this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
			if (this.windowsPathsNoEscape) pattern$1 = pattern$1.map((p) => p.replace(/\\/g, "/"));
			if (this.matchBase) {
				if (opts.noglobstar) throw new TypeError("base matching requires globstar");
				pattern$1 = pattern$1.map((p) => p.includes("/") ? p : `./**/${p}`);
			}
			this.pattern = pattern$1;
			this.platform = opts.platform || defaultPlatform;
			this.opts = {
				...opts,
				platform: this.platform
			};
			if (opts.scurry) {
				this.scurry = opts.scurry;
				if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) throw new Error("nocase option contradicts provided scurry option");
			} else this.scurry = new (opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry)(this.cwd, {
				nocase: opts.nocase,
				fs: opts.fs
			});
			this.nocase = this.scurry.nocase;
			const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
			const mmo = {
				...opts,
				dot: this.dot,
				matchBase: this.matchBase,
				nobrace: this.nobrace,
				nocase: this.nocase,
				nocaseMagicOnly,
				nocomment: true,
				noext: this.noext,
				nonegate: true,
				optimizationLevel: 2,
				platform: this.platform,
				windowsPathsNoEscape: this.windowsPathsNoEscape,
				debug: !!this.opts.debug
			};
			const [matchSet, globParts] = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo)).reduce((set$1, m) => {
				set$1[0].push(...m.set);
				set$1[1].push(...m.globParts);
				return set$1;
			}, [[], []]);
			this.patterns = matchSet.map((set$1, i) => {
				const g = globParts[i];
				/* c8 ignore start */
				if (!g) throw new Error("invalid pattern object");
				/* c8 ignore stop */
				return new pattern_js_1.Pattern(set$1, g, 0, this.platform);
			});
		}
		async walk() {
			return [...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
				...this.opts,
				maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
				platform: this.platform,
				nocase: this.nocase,
				includeChildMatches: this.includeChildMatches
			}).walk()];
		}
		walkSync() {
			return [...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
				...this.opts,
				maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
				platform: this.platform,
				nocase: this.nocase,
				includeChildMatches: this.includeChildMatches
			}).walkSync()];
		}
		stream() {
			return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
				...this.opts,
				maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
				platform: this.platform,
				nocase: this.nocase,
				includeChildMatches: this.includeChildMatches
			}).stream();
		}
		streamSync() {
			return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
				...this.opts,
				maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
				platform: this.platform,
				nocase: this.nocase,
				includeChildMatches: this.includeChildMatches
			}).streamSync();
		}
		iterateSync() {
			return this.streamSync()[Symbol.iterator]();
		}
		[Symbol.iterator]() {
			return this.iterateSync();
		}
		iterate() {
			return this.stream()[Symbol.asyncIterator]();
		}
		[Symbol.asyncIterator]() {
			return this.iterate();
		}
	};
	exports.Glob = Glob;
}));
var require_has_magic = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hasMagic = void 0;
	var minimatch_1 = require_commonjs$4();
	var hasMagic = (pattern$1, options = {}) => {
		if (!Array.isArray(pattern$1)) pattern$1 = [pattern$1];
		for (const p of pattern$1) if (new minimatch_1.Minimatch(p, options).hasMagic()) return true;
		return false;
	};
	exports.hasMagic = hasMagic;
}));
var require_commonjs = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = void 0;
	exports.globStreamSync = globStreamSync;
	exports.globStream = globStream;
	exports.globSync = globSync;
	exports.globIterateSync = globIterateSync;
	exports.globIterate = globIterate;
	var minimatch_1 = require_commonjs$4();
	var glob_js_1 = require_glob();
	var has_magic_js_1 = require_has_magic();
	var minimatch_2 = require_commonjs$4();
	Object.defineProperty(exports, "escape", {
		enumerable: true,
		get: function() {
			return minimatch_2.escape;
		}
	});
	Object.defineProperty(exports, "unescape", {
		enumerable: true,
		get: function() {
			return minimatch_2.unescape;
		}
	});
	var glob_js_2 = require_glob();
	Object.defineProperty(exports, "Glob", {
		enumerable: true,
		get: function() {
			return glob_js_2.Glob;
		}
	});
	var has_magic_js_2 = require_has_magic();
	Object.defineProperty(exports, "hasMagic", {
		enumerable: true,
		get: function() {
			return has_magic_js_2.hasMagic;
		}
	});
	var ignore_js_1 = require_ignore();
	Object.defineProperty(exports, "Ignore", {
		enumerable: true,
		get: function() {
			return ignore_js_1.Ignore;
		}
	});
	function globStreamSync(pattern$1, options = {}) {
		return new glob_js_1.Glob(pattern$1, options).streamSync();
	}
	function globStream(pattern$1, options = {}) {
		return new glob_js_1.Glob(pattern$1, options).stream();
	}
	function globSync(pattern$1, options = {}) {
		return new glob_js_1.Glob(pattern$1, options).walkSync();
	}
	async function glob_(pattern$1, options = {}) {
		return new glob_js_1.Glob(pattern$1, options).walk();
	}
	function globIterateSync(pattern$1, options = {}) {
		return new glob_js_1.Glob(pattern$1, options).iterateSync();
	}
	function globIterate(pattern$1, options = {}) {
		return new glob_js_1.Glob(pattern$1, options).iterate();
	}
	exports.streamSync = globStreamSync;
	exports.stream = Object.assign(globStream, { sync: globStreamSync });
	exports.iterateSync = globIterateSync;
	exports.iterate = Object.assign(globIterate, { sync: globIterateSync });
	exports.sync = Object.assign(globSync, {
		stream: globStreamSync,
		iterate: globIterateSync
	});
	exports.glob = Object.assign(glob_, {
		glob: glob_,
		globSync,
		sync: exports.sync,
		globStream,
		stream: exports.stream,
		globStreamSync,
		streamSync: exports.streamSync,
		globIterate,
		iterate: exports.iterate,
		globIterateSync,
		iterateSync: exports.iterateSync,
		Glob: glob_js_1.Glob,
		hasMagic: has_magic_js_1.hasMagic,
		escape: minimatch_1.escape,
		unescape: minimatch_1.unescape
	});
	exports.glob.glob = exports.glob;
}));
var require_file = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var fs = require_graceful_fs();
	var path$4 = __require("path");
	var flatten = require_flatten();
	var difference = require_difference();
	var union = require_union();
	var isPlainObject = require_isPlainObject();
	var glob = require_commonjs();
	var file = module.exports = {};
	var pathSeparatorRe = /[\/\\]/g;
	var processPatterns = function(patterns, fn) {
		var result = [];
		flatten(patterns).forEach(function(pattern$1) {
			var exclusion = pattern$1.indexOf("!") === 0;
			if (exclusion) pattern$1 = pattern$1.slice(1);
			var matches = fn(pattern$1);
			if (exclusion) result = difference(result, matches);
			else result = union(result, matches);
		});
		return result;
	};
	file.exists = function() {
		var filepath = path$4.join.apply(path$4, arguments);
		return fs.existsSync(filepath);
	};
	file.expand = function(...args) {
		var options = isPlainObject(args[0]) ? args.shift() : {};
		var patterns = Array.isArray(args[0]) ? args[0] : args;
		if (patterns.length === 0) return [];
		var matches = processPatterns(patterns, function(pattern$1) {
			return glob.sync(pattern$1, options);
		});
		if (options.filter) matches = matches.filter(function(filepath) {
			filepath = path$4.join(options.cwd || "", filepath);
			try {
				if (typeof options.filter === "function") return options.filter(filepath);
				else return fs.statSync(filepath)[options.filter]();
			} catch (e$1) {
				return false;
			}
		});
		return matches;
	};
	file.expandMapping = function(patterns, destBase, options) {
		options = Object.assign({ rename: function(destBase$1, destPath) {
			return path$4.join(destBase$1 || "", destPath);
		} }, options);
		var files$1 = [];
		var fileByDest = {};
		file.expand(options, patterns).forEach(function(src) {
			var destPath = src;
			if (options.flatten) destPath = path$4.basename(destPath);
			if (options.ext) destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
			var dest = options.rename(destBase, destPath, options);
			if (options.cwd) src = path$4.join(options.cwd, src);
			dest = dest.replace(pathSeparatorRe, "/");
			src = src.replace(pathSeparatorRe, "/");
			if (fileByDest[dest]) fileByDest[dest].src.push(src);
			else {
				files$1.push({
					src: [src],
					dest
				});
				fileByDest[dest] = files$1[files$1.length - 1];
			}
		});
		return files$1;
	};
	file.normalizeFilesArray = function(data) {
		var files$1 = [];
		data.forEach(function(obj) {
			if ("src" in obj || "dest" in obj) files$1.push(obj);
		});
		if (files$1.length === 0) return [];
		files$1 = _(files$1).chain().forEach(function(obj) {
			if (!("src" in obj) || !obj.src) return;
			if (Array.isArray(obj.src)) obj.src = flatten(obj.src);
			else obj.src = [obj.src];
		}).map(function(obj) {
			var expandOptions = Object.assign({}, obj);
			delete expandOptions.src;
			delete expandOptions.dest;
			if (obj.expand) return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
				var result$1 = Object.assign({}, obj);
				result$1.orig = Object.assign({}, obj);
				result$1.src = mapObj.src;
				result$1.dest = mapObj.dest;
				[
					"expand",
					"cwd",
					"flatten",
					"rename",
					"ext"
				].forEach(function(prop) {
					delete result$1[prop];
				});
				return result$1;
			});
			var result = Object.assign({}, obj);
			result.orig = Object.assign({}, obj);
			if ("src" in result) Object.defineProperty(result, "src", {
				enumerable: true,
				get: function fn() {
					var src;
					if (!("result" in fn)) {
						src = obj.src;
						src = Array.isArray(src) ? flatten(src) : [src];
						fn.result = file.expand(expandOptions, src);
					}
					return fn.result;
				}
			});
			if ("dest" in result) result.dest = obj.dest;
			return result;
		}).flatten().value();
		return files$1;
	};
}));
var require_archiver_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var fs = require_graceful_fs();
	var path$3 = __require("path");
	var isStream = require_is_stream();
	var lazystream = require_lazystream();
	var normalizePath = require_normalize_path();
	var defaults = require_defaults();
	__require("stream").Stream;
	var PassThrough = require_ours().PassThrough;
	var utils = module.exports = {};
	utils.file = require_file();
	utils.collectStream = function(source, callback) {
		var collection = [];
		var size = 0;
		source.on("error", callback);
		source.on("data", function(chunk) {
			collection.push(chunk);
			size += chunk.length;
		});
		source.on("end", function() {
			var buf = Buffer.alloc(size);
			var offset = 0;
			collection.forEach(function(data) {
				data.copy(buf, offset);
				offset += data.length;
			});
			callback(null, buf);
		});
	};
	utils.dateify = function(dateish) {
		dateish = dateish || /* @__PURE__ */ new Date();
		if (dateish instanceof Date) dateish = dateish;
		else if (typeof dateish === "string") dateish = new Date(dateish);
		else dateish = /* @__PURE__ */ new Date();
		return dateish;
	};
	utils.defaults = function(object, source, guard) {
		var args = arguments;
		args[0] = args[0] || {};
		return defaults(...args);
	};
	utils.isStream = function(source) {
		return isStream(source);
	};
	utils.lazyReadStream = function(filepath) {
		return new lazystream.Readable(function() {
			return fs.createReadStream(filepath);
		});
	};
	utils.normalizeInputSource = function(source) {
		if (source === null) return Buffer.alloc(0);
		else if (typeof source === "string") return Buffer.from(source);
		else if (utils.isStream(source)) return source.pipe(new PassThrough());
		return source;
	};
	utils.sanitizePath = function(filepath) {
		return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
	};
	utils.trailingSlashIt = function(str) {
		return str.slice(-1) !== "/" ? str + "/" : str;
	};
	utils.unixifyPath = function(filepath) {
		return normalizePath(filepath, false).replace(/^\w+:/, "");
	};
	utils.walkdir = function(dirpath, base, callback) {
		var results = [];
		if (typeof base === "function") {
			callback = base;
			base = dirpath;
		}
		fs.readdir(dirpath, function(err, list) {
			var i = 0;
			var file;
			var filepath;
			if (err) return callback(err);
			(function next() {
				file = list[i++];
				if (!file) return callback(null, results);
				filepath = path$3.join(dirpath, file);
				fs.stat(filepath, function(err$1, stats) {
					results.push({
						path: filepath,
						relative: path$3.relative(base, filepath).replace(/\\/g, "/"),
						stats
					});
					if (stats && stats.isDirectory()) utils.walkdir(filepath, base, function(err$2, res) {
						if (err$2) return callback(err$2);
						res.forEach(function(dirEntry) {
							results.push(dirEntry);
						});
						next();
					});
					else next();
				});
			})();
		});
	};
}));
var require_error = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Archiver Core
	*
	* @ignore
	* @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
	* @copyright (c) 2012-2014 Chris Talkington, contributors.
	*/
	var util$4 = __require("util");
	var ERROR_CODES = {
		"ABORTED": "archive was aborted",
		"DIRECTORYDIRPATHREQUIRED": "diretory dirpath argument must be a non-empty string value",
		"DIRECTORYFUNCTIONINVALIDDATA": "invalid data returned by directory custom data function",
		"ENTRYNAMEREQUIRED": "entry name must be a non-empty string value",
		"FILEFILEPATHREQUIRED": "file filepath argument must be a non-empty string value",
		"FINALIZING": "archive already finalizing",
		"QUEUECLOSED": "queue closed",
		"NOENDMETHOD": "no suitable finalize/end method defined by module",
		"DIRECTORYNOTSUPPORTED": "support for directory entries not defined by module",
		"FORMATSET": "archive format already set",
		"INPUTSTEAMBUFFERREQUIRED": "input source must be valid Stream or Buffer instance",
		"MODULESET": "module already set",
		"SYMLINKNOTSUPPORTED": "support for symlink entries not defined by module",
		"SYMLINKFILEPATHREQUIRED": "symlink filepath argument must be a non-empty string value",
		"SYMLINKTARGETREQUIRED": "symlink target argument must be a non-empty string value",
		"ENTRYNOTSUPPORTED": "entry not supported"
	};
	function ArchiverError(code, data) {
		Error.captureStackTrace(this, this.constructor);
		this.message = ERROR_CODES[code] || code;
		this.code = code;
		this.data = data;
	}
	util$4.inherits(ArchiverError, Error);
	exports = module.exports = ArchiverError;
}));
var require_core = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Archiver Core
	*
	* @ignore
	* @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
	* @copyright (c) 2012-2014 Chris Talkington, contributors.
	*/
	var fs$3 = __require("fs");
	var glob = require_readdir_glob();
	var async = (init_async(), __toCommonJS(async_exports));
	var path$2 = __require("path");
	var util = require_archiver_utils();
	var inherits$6 = __require("util").inherits;
	var ArchiverError = require_error();
	var Transform = require_ours().Transform;
	var win32 = process.platform === "win32";
	var Archiver = function(format, options) {
		if (!(this instanceof Archiver)) return new Archiver(format, options);
		if (typeof format !== "string") {
			options = format;
			format = "zip";
		}
		options = this.options = util.defaults(options, {
			highWaterMark: 1024 * 1024,
			statConcurrency: 4
		});
		Transform.call(this, options);
		this._format = false;
		this._module = false;
		this._pending = 0;
		this._pointer = 0;
		this._entriesCount = 0;
		this._entriesProcessedCount = 0;
		this._fsEntriesTotalBytes = 0;
		this._fsEntriesProcessedBytes = 0;
		this._queue = async.queue(this._onQueueTask.bind(this), 1);
		this._queue.drain(this._onQueueDrain.bind(this));
		this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
		this._statQueue.drain(this._onQueueDrain.bind(this));
		this._state = {
			aborted: false,
			finalize: false,
			finalizing: false,
			finalized: false,
			modulePiped: false
		};
		this._streams = [];
	};
	inherits$6(Archiver, Transform);
	Archiver.prototype._abort = function() {
		this._state.aborted = true;
		this._queue.kill();
		this._statQueue.kill();
		if (this._queue.idle()) this._shutdown();
	};
	Archiver.prototype._append = function(filepath, data) {
		data = data || {};
		var task = {
			source: null,
			filepath
		};
		if (!data.name) data.name = filepath;
		data.sourcePath = filepath;
		task.data = data;
		this._entriesCount++;
		if (data.stats && data.stats instanceof fs$3.Stats) {
			task = this._updateQueueTaskWithStats(task, data.stats);
			if (task) {
				if (data.stats.size) this._fsEntriesTotalBytes += data.stats.size;
				this._queue.push(task);
			}
		} else this._statQueue.push(task);
	};
	Archiver.prototype._finalize = function() {
		if (this._state.finalizing || this._state.finalized || this._state.aborted) return;
		this._state.finalizing = true;
		this._moduleFinalize();
		this._state.finalizing = false;
		this._state.finalized = true;
	};
	Archiver.prototype._maybeFinalize = function() {
		if (this._state.finalizing || this._state.finalized || this._state.aborted) return false;
		if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
			this._finalize();
			return true;
		}
		return false;
	};
	Archiver.prototype._moduleAppend = function(source, data, callback) {
		if (this._state.aborted) {
			callback();
			return;
		}
		this._module.append(source, data, function(err) {
			this._task = null;
			if (this._state.aborted) {
				this._shutdown();
				return;
			}
			if (err) {
				this.emit("error", err);
				setImmediate(callback);
				return;
			}
			this.emit("entry", data);
			this._entriesProcessedCount++;
			if (data.stats && data.stats.size) this._fsEntriesProcessedBytes += data.stats.size;
			this.emit("progress", {
				entries: {
					total: this._entriesCount,
					processed: this._entriesProcessedCount
				},
				fs: {
					totalBytes: this._fsEntriesTotalBytes,
					processedBytes: this._fsEntriesProcessedBytes
				}
			});
			setImmediate(callback);
		}.bind(this));
	};
	Archiver.prototype._moduleFinalize = function() {
		if (typeof this._module.finalize === "function") this._module.finalize();
		else if (typeof this._module.end === "function") this._module.end();
		else this.emit("error", new ArchiverError("NOENDMETHOD"));
	};
	Archiver.prototype._modulePipe = function() {
		this._module.on("error", this._onModuleError.bind(this));
		this._module.pipe(this);
		this._state.modulePiped = true;
	};
	Archiver.prototype._moduleSupports = function(key) {
		if (!this._module.supports || !this._module.supports[key]) return false;
		return this._module.supports[key];
	};
	Archiver.prototype._moduleUnpipe = function() {
		this._module.unpipe(this);
		this._state.modulePiped = false;
	};
	Archiver.prototype._normalizeEntryData = function(data, stats) {
		data = util.defaults(data, {
			type: "file",
			name: null,
			date: null,
			mode: null,
			prefix: null,
			sourcePath: null,
			stats: false
		});
		if (stats && data.stats === false) data.stats = stats;
		var isDir = data.type === "directory";
		if (data.name) {
			if (typeof data.prefix === "string" && "" !== data.prefix) {
				data.name = data.prefix + "/" + data.name;
				data.prefix = null;
			}
			data.name = util.sanitizePath(data.name);
			if (data.type !== "symlink" && data.name.slice(-1) === "/") {
				isDir = true;
				data.type = "directory";
			} else if (isDir) data.name += "/";
		}
		if (typeof data.mode === "number") if (win32) data.mode &= 511;
		else data.mode &= 4095;
		else if (data.stats && data.mode === null) {
			if (win32) data.mode = data.stats.mode & 511;
			else data.mode = data.stats.mode & 4095;
			if (win32 && isDir) data.mode = 493;
		} else if (data.mode === null) data.mode = isDir ? 493 : 420;
		if (data.stats && data.date === null) data.date = data.stats.mtime;
		else data.date = util.dateify(data.date);
		return data;
	};
	Archiver.prototype._onModuleError = function(err) {
		this.emit("error", err);
	};
	Archiver.prototype._onQueueDrain = function() {
		if (this._state.finalizing || this._state.finalized || this._state.aborted) return;
		if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) this._finalize();
	};
	Archiver.prototype._onQueueTask = function(task, callback) {
		var fullCallback = () => {
			if (task.data.callback) task.data.callback();
			callback();
		};
		if (this._state.finalizing || this._state.finalized || this._state.aborted) {
			fullCallback();
			return;
		}
		this._task = task;
		this._moduleAppend(task.source, task.data, fullCallback);
	};
	Archiver.prototype._onStatQueueTask = function(task, callback) {
		if (this._state.finalizing || this._state.finalized || this._state.aborted) {
			callback();
			return;
		}
		fs$3.lstat(task.filepath, function(err, stats) {
			if (this._state.aborted) {
				setImmediate(callback);
				return;
			}
			if (err) {
				this._entriesCount--;
				this.emit("warning", err);
				setImmediate(callback);
				return;
			}
			task = this._updateQueueTaskWithStats(task, stats);
			if (task) {
				if (stats.size) this._fsEntriesTotalBytes += stats.size;
				this._queue.push(task);
			}
			setImmediate(callback);
		}.bind(this));
	};
	Archiver.prototype._shutdown = function() {
		this._moduleUnpipe();
		this.end();
	};
	Archiver.prototype._transform = function(chunk, encoding, callback) {
		if (chunk) this._pointer += chunk.length;
		callback(null, chunk);
	};
	Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
		if (stats.isFile()) {
			task.data.type = "file";
			task.data.sourceType = "stream";
			task.source = util.lazyReadStream(task.filepath);
		} else if (stats.isDirectory() && this._moduleSupports("directory")) {
			task.data.name = util.trailingSlashIt(task.data.name);
			task.data.type = "directory";
			task.data.sourcePath = util.trailingSlashIt(task.filepath);
			task.data.sourceType = "buffer";
			task.source = Buffer.concat([]);
		} else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
			var linkPath = fs$3.readlinkSync(task.filepath);
			var dirName = path$2.dirname(task.filepath);
			task.data.type = "symlink";
			task.data.linkname = path$2.relative(dirName, path$2.resolve(dirName, linkPath));
			task.data.sourceType = "buffer";
			task.source = Buffer.concat([]);
		} else {
			if (stats.isDirectory()) this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
			else if (stats.isSymbolicLink()) this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
			else this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
			return null;
		}
		task.data = this._normalizeEntryData(task.data, stats);
		return task;
	};
	Archiver.prototype.abort = function() {
		if (this._state.aborted || this._state.finalized) return this;
		this._abort();
		return this;
	};
	Archiver.prototype.append = function(source, data) {
		if (this._state.finalize || this._state.aborted) {
			this.emit("error", new ArchiverError("QUEUECLOSED"));
			return this;
		}
		data = this._normalizeEntryData(data);
		if (typeof data.name !== "string" || data.name.length === 0) {
			this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
			return this;
		}
		if (data.type === "directory" && !this._moduleSupports("directory")) {
			this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name }));
			return this;
		}
		source = util.normalizeInputSource(source);
		if (Buffer.isBuffer(source)) data.sourceType = "buffer";
		else if (util.isStream(source)) data.sourceType = "stream";
		else {
			this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name }));
			return this;
		}
		this._entriesCount++;
		this._queue.push({
			data,
			source
		});
		return this;
	};
	Archiver.prototype.directory = function(dirpath, destpath, data) {
		if (this._state.finalize || this._state.aborted) {
			this.emit("error", new ArchiverError("QUEUECLOSED"));
			return this;
		}
		if (typeof dirpath !== "string" || dirpath.length === 0) {
			this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
			return this;
		}
		this._pending++;
		if (destpath === false) destpath = "";
		else if (typeof destpath !== "string") destpath = dirpath;
		var dataFunction = false;
		if (typeof data === "function") {
			dataFunction = data;
			data = {};
		} else if (typeof data !== "object") data = {};
		var globOptions = {
			stat: true,
			dot: true
		};
		function onGlobEnd() {
			this._pending--;
			this._maybeFinalize();
		}
		function onGlobError(err) {
			this.emit("error", err);
		}
		function onGlobMatch(match$3) {
			globber.pause();
			var ignoreMatch = false;
			var entryData = Object.assign({}, data);
			entryData.name = match$3.relative;
			entryData.prefix = destpath;
			entryData.stats = match$3.stat;
			entryData.callback = globber.resume.bind(globber);
			try {
				if (dataFunction) {
					entryData = dataFunction(entryData);
					if (entryData === false) ignoreMatch = true;
					else if (typeof entryData !== "object") throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
				}
			} catch (e$1) {
				this.emit("error", e$1);
				return;
			}
			if (ignoreMatch) {
				globber.resume();
				return;
			}
			this._append(match$3.absolute, entryData);
		}
		var globber = glob(dirpath, globOptions);
		globber.on("error", onGlobError.bind(this));
		globber.on("match", onGlobMatch.bind(this));
		globber.on("end", onGlobEnd.bind(this));
		return this;
	};
	Archiver.prototype.file = function(filepath, data) {
		if (this._state.finalize || this._state.aborted) {
			this.emit("error", new ArchiverError("QUEUECLOSED"));
			return this;
		}
		if (typeof filepath !== "string" || filepath.length === 0) {
			this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
			return this;
		}
		this._append(filepath, data);
		return this;
	};
	Archiver.prototype.glob = function(pattern$1, options, data) {
		this._pending++;
		options = util.defaults(options, {
			stat: true,
			pattern: pattern$1
		});
		function onGlobEnd() {
			this._pending--;
			this._maybeFinalize();
		}
		function onGlobError(err) {
			this.emit("error", err);
		}
		function onGlobMatch(match$3) {
			globber.pause();
			var entryData = Object.assign({}, data);
			entryData.callback = globber.resume.bind(globber);
			entryData.stats = match$3.stat;
			entryData.name = match$3.relative;
			this._append(match$3.absolute, entryData);
		}
		var globber = glob(options.cwd || ".", options);
		globber.on("error", onGlobError.bind(this));
		globber.on("match", onGlobMatch.bind(this));
		globber.on("end", onGlobEnd.bind(this));
		return this;
	};
	Archiver.prototype.finalize = function() {
		if (this._state.aborted) {
			var abortedError = new ArchiverError("ABORTED");
			this.emit("error", abortedError);
			return Promise.reject(abortedError);
		}
		if (this._state.finalize) {
			var finalizingError = new ArchiverError("FINALIZING");
			this.emit("error", finalizingError);
			return Promise.reject(finalizingError);
		}
		this._state.finalize = true;
		if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) this._finalize();
		var self$1 = this;
		return new Promise(function(resolve$1, reject$3) {
			var errored;
			self$1._module.on("end", function() {
				if (!errored) resolve$1();
			});
			self$1._module.on("error", function(err) {
				errored = true;
				reject$3(err);
			});
		});
	};
	Archiver.prototype.setFormat = function(format) {
		if (this._format) {
			this.emit("error", new ArchiverError("FORMATSET"));
			return this;
		}
		this._format = format;
		return this;
	};
	Archiver.prototype.setModule = function(module$1) {
		if (this._state.aborted) {
			this.emit("error", new ArchiverError("ABORTED"));
			return this;
		}
		if (this._state.module) {
			this.emit("error", new ArchiverError("MODULESET"));
			return this;
		}
		this._module = module$1;
		this._modulePipe();
		return this;
	};
	Archiver.prototype.symlink = function(filepath, target, mode) {
		if (this._state.finalize || this._state.aborted) {
			this.emit("error", new ArchiverError("QUEUECLOSED"));
			return this;
		}
		if (typeof filepath !== "string" || filepath.length === 0) {
			this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
			return this;
		}
		if (typeof target !== "string" || target.length === 0) {
			this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
			return this;
		}
		if (!this._moduleSupports("symlink")) {
			this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
			return this;
		}
		var data = {};
		data.type = "symlink";
		data.name = filepath.replace(/\\/g, "/");
		data.linkname = target.replace(/\\/g, "/");
		data.sourceType = "buffer";
		if (typeof mode === "number") data.mode = mode;
		this._entriesCount++;
		this._queue.push({
			data,
			source: Buffer.concat([])
		});
		return this;
	};
	Archiver.prototype.pointer = function() {
		return this._pointer;
	};
	Archiver.prototype.use = function(plugin) {
		this._streams.push(plugin);
		return this;
	};
	module.exports = Archiver;
}));
var require_archive_entry = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ArchiveEntry = module.exports = function() {};
	ArchiveEntry.prototype.getName = function() {};
	ArchiveEntry.prototype.getSize = function() {};
	ArchiveEntry.prototype.getLastModifiedDate = function() {};
	ArchiveEntry.prototype.isDirectory = function() {};
}));
var require_util$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var util = module.exports = {};
	util.dateToDos = function(d, forceLocalTime) {
		forceLocalTime = forceLocalTime || false;
		var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
		if (year < 1980) return 2162688;
		else if (year >= 2044) return 2141175677;
		var val = {
			year,
			month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
			date: forceLocalTime ? d.getDate() : d.getUTCDate(),
			hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
			minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
			seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
		};
		return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
	};
	util.dosToDate = function(dos) {
		return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
	};
	util.fromDosTime = function(buf) {
		return util.dosToDate(buf.readUInt32LE(0));
	};
	util.getEightBytes = function(v) {
		var buf = Buffer.alloc(8);
		buf.writeUInt32LE(v % 4294967296, 0);
		buf.writeUInt32LE(v / 4294967296 | 0, 4);
		return buf;
	};
	util.getShortBytes = function(v) {
		var buf = Buffer.alloc(2);
		buf.writeUInt16LE((v & 65535) >>> 0, 0);
		return buf;
	};
	util.getShortBytesValue = function(buf, offset) {
		return buf.readUInt16LE(offset);
	};
	util.getLongBytes = function(v) {
		var buf = Buffer.alloc(4);
		buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
		return buf;
	};
	util.getLongBytesValue = function(buf, offset) {
		return buf.readUInt32LE(offset);
	};
	util.toDosTime = function(d) {
		return util.getLongBytes(util.dateToDos(d));
	};
}));
var require_general_purpose_bit = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var zipUtil = require_util$1();
	var DATA_DESCRIPTOR_FLAG = 8;
	var ENCRYPTION_FLAG = 1;
	var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 4;
	var SLIDING_DICTIONARY_SIZE_FLAG = 2;
	var STRONG_ENCRYPTION_FLAG = 64;
	var UFT8_NAMES_FLAG = 2048;
	var GeneralPurposeBit = module.exports = function() {
		if (!(this instanceof GeneralPurposeBit)) return new GeneralPurposeBit();
		this.descriptor = false;
		this.encryption = false;
		this.utf8 = false;
		this.numberOfShannonFanoTrees = 0;
		this.strongEncryption = false;
		this.slidingDictionarySize = 0;
		return this;
	};
	GeneralPurposeBit.prototype.encode = function() {
		return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
	};
	GeneralPurposeBit.prototype.parse = function(buf, offset) {
		var flag = zipUtil.getShortBytesValue(buf, offset);
		var gbp = new GeneralPurposeBit();
		gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
		gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
		gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
		gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
		gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
		gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
		return gbp;
	};
	GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n$1) {
		this.numberOfShannonFanoTrees = n$1;
	};
	GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
		return this.numberOfShannonFanoTrees;
	};
	GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n$1) {
		this.slidingDictionarySize = n$1;
	};
	GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
		return this.slidingDictionarySize;
	};
	GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
		this.descriptor = b;
	};
	GeneralPurposeBit.prototype.usesDataDescriptor = function() {
		return this.descriptor;
	};
	GeneralPurposeBit.prototype.useEncryption = function(b) {
		this.encryption = b;
	};
	GeneralPurposeBit.prototype.usesEncryption = function() {
		return this.encryption;
	};
	GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
		this.strongEncryption = b;
	};
	GeneralPurposeBit.prototype.usesStrongEncryption = function() {
		return this.strongEncryption;
	};
	GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
		this.utf8 = b;
	};
	GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
		return this.utf8;
	};
}));
var require_unix_stat = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		PERM_MASK: 4095,
		FILE_TYPE_FLAG: 61440,
		LINK_FLAG: 40960,
		FILE_FLAG: 32768,
		DIR_FLAG: 16384,
		DEFAULT_LINK_PERM: 511,
		DEFAULT_DIR_PERM: 493,
		DEFAULT_FILE_PERM: 420
	};
}));
var require_constants$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		WORD: 4,
		DWORD: 8,
		EMPTY: Buffer.alloc(0),
		SHORT: 2,
		SHORT_MASK: 65535,
		SHORT_SHIFT: 16,
		SHORT_ZERO: Buffer.from(Array(2)),
		LONG: 4,
		LONG_ZERO: Buffer.from(Array(4)),
		MIN_VERSION_INITIAL: 10,
		MIN_VERSION_DATA_DESCRIPTOR: 20,
		MIN_VERSION_ZIP64: 45,
		VERSION_MADEBY: 45,
		METHOD_STORED: 0,
		METHOD_DEFLATED: 8,
		PLATFORM_UNIX: 3,
		PLATFORM_FAT: 0,
		SIG_LFH: 67324752,
		SIG_DD: 134695760,
		SIG_CFH: 33639248,
		SIG_EOCD: 101010256,
		SIG_ZIP64_EOCD: 101075792,
		SIG_ZIP64_EOCD_LOC: 117853008,
		ZIP64_MAGIC_SHORT: 65535,
		ZIP64_MAGIC: 4294967295,
		ZIP64_EXTRA_ID: 1,
		ZLIB_NO_COMPRESSION: 0,
		ZLIB_BEST_SPEED: 1,
		ZLIB_BEST_COMPRESSION: 9,
		ZLIB_DEFAULT_COMPRESSION: -1,
		MODE_MASK: 4095,
		DEFAULT_FILE_MODE: 33188,
		DEFAULT_DIR_MODE: 16877,
		EXT_FILE_ATTR_DIR: 1106051088,
		EXT_FILE_ATTR_FILE: 2175008800,
		S_IFMT: 61440,
		S_IFIFO: 4096,
		S_IFCHR: 8192,
		S_IFDIR: 16384,
		S_IFBLK: 24576,
		S_IFREG: 32768,
		S_IFLNK: 40960,
		S_IFSOCK: 49152,
		S_DOS_A: 32,
		S_DOS_D: 16,
		S_DOS_V: 8,
		S_DOS_S: 4,
		S_DOS_H: 2,
		S_DOS_R: 1
	};
}));
var require_zip_archive_entry = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var inherits$5 = __require("util").inherits;
	var normalizePath = require_normalize_path();
	var ArchiveEntry = require_archive_entry();
	var GeneralPurposeBit = require_general_purpose_bit();
	var UnixStat = require_unix_stat();
	var constants = require_constants$1();
	var zipUtil = require_util$1();
	var ZipArchiveEntry = module.exports = function(name$1) {
		if (!(this instanceof ZipArchiveEntry)) return new ZipArchiveEntry(name$1);
		ArchiveEntry.call(this);
		this.platform = constants.PLATFORM_FAT;
		this.method = -1;
		this.name = null;
		this.size = 0;
		this.csize = 0;
		this.gpb = new GeneralPurposeBit();
		this.crc = 0;
		this.time = -1;
		this.minver = constants.MIN_VERSION_INITIAL;
		this.mode = -1;
		this.extra = null;
		this.exattr = 0;
		this.inattr = 0;
		this.comment = null;
		if (name$1) this.setName(name$1);
	};
	inherits$5(ZipArchiveEntry, ArchiveEntry);
	ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
		return this.getExtra();
	};
	ZipArchiveEntry.prototype.getComment = function() {
		return this.comment !== null ? this.comment : "";
	};
	ZipArchiveEntry.prototype.getCompressedSize = function() {
		return this.csize;
	};
	ZipArchiveEntry.prototype.getCrc = function() {
		return this.crc;
	};
	ZipArchiveEntry.prototype.getExternalAttributes = function() {
		return this.exattr;
	};
	ZipArchiveEntry.prototype.getExtra = function() {
		return this.extra !== null ? this.extra : constants.EMPTY;
	};
	ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
		return this.gpb;
	};
	ZipArchiveEntry.prototype.getInternalAttributes = function() {
		return this.inattr;
	};
	ZipArchiveEntry.prototype.getLastModifiedDate = function() {
		return this.getTime();
	};
	ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
		return this.getExtra();
	};
	ZipArchiveEntry.prototype.getMethod = function() {
		return this.method;
	};
	ZipArchiveEntry.prototype.getName = function() {
		return this.name;
	};
	ZipArchiveEntry.prototype.getPlatform = function() {
		return this.platform;
	};
	ZipArchiveEntry.prototype.getSize = function() {
		return this.size;
	};
	ZipArchiveEntry.prototype.getTime = function() {
		return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
	};
	ZipArchiveEntry.prototype.getTimeDos = function() {
		return this.time !== -1 ? this.time : 0;
	};
	ZipArchiveEntry.prototype.getUnixMode = function() {
		return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
	};
	ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
		return this.minver;
	};
	ZipArchiveEntry.prototype.setComment = function(comment) {
		if (Buffer.byteLength(comment) !== comment.length) this.getGeneralPurposeBit().useUTF8ForNames(true);
		this.comment = comment;
	};
	ZipArchiveEntry.prototype.setCompressedSize = function(size) {
		if (size < 0) throw new Error("invalid entry compressed size");
		this.csize = size;
	};
	ZipArchiveEntry.prototype.setCrc = function(crc) {
		if (crc < 0) throw new Error("invalid entry crc32");
		this.crc = crc;
	};
	ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
		this.exattr = attr >>> 0;
	};
	ZipArchiveEntry.prototype.setExtra = function(extra) {
		this.extra = extra;
	};
	ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
		if (!(gpb instanceof GeneralPurposeBit)) throw new Error("invalid entry GeneralPurposeBit");
		this.gpb = gpb;
	};
	ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
		this.inattr = attr;
	};
	ZipArchiveEntry.prototype.setMethod = function(method) {
		if (method < 0) throw new Error("invalid entry compression method");
		this.method = method;
	};
	ZipArchiveEntry.prototype.setName = function(name$1, prependSlash = false) {
		name$1 = normalizePath(name$1, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
		if (prependSlash) name$1 = `/${name$1}`;
		if (Buffer.byteLength(name$1) !== name$1.length) this.getGeneralPurposeBit().useUTF8ForNames(true);
		this.name = name$1;
	};
	ZipArchiveEntry.prototype.setPlatform = function(platform) {
		this.platform = platform;
	};
	ZipArchiveEntry.prototype.setSize = function(size) {
		if (size < 0) throw new Error("invalid entry size");
		this.size = size;
	};
	ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
		if (!(time instanceof Date)) throw new Error("invalid entry time");
		this.time = zipUtil.dateToDos(time, forceLocalTime);
	};
	ZipArchiveEntry.prototype.setUnixMode = function(mode) {
		mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
		var extattr = 0;
		extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
		this.setExternalAttributes(extattr);
		this.mode = mode & constants.MODE_MASK;
		this.platform = constants.PLATFORM_UNIX;
	};
	ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
		this.minver = minver;
	};
	ZipArchiveEntry.prototype.isDirectory = function() {
		return this.getName().slice(-1) === "/";
	};
	ZipArchiveEntry.prototype.isUnixSymlink = function() {
		return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
	};
	ZipArchiveEntry.prototype.isZip64 = function() {
		return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
	};
}));
var require_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	__require("stream").Stream;
	var PassThrough = require_ours().PassThrough;
	var isStream = require_is_stream();
	var util = module.exports = {};
	util.normalizeInputSource = function(source) {
		if (source === null) return Buffer.alloc(0);
		else if (typeof source === "string") return Buffer.from(source);
		else if (isStream(source) && !source._readableState) {
			var normalized = new PassThrough();
			source.pipe(normalized);
			return normalized;
		}
		return source;
	};
}));
var require_archive_output_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var inherits$4 = __require("util").inherits;
	var isStream = require_is_stream();
	var Transform = require_ours().Transform;
	var ArchiveEntry = require_archive_entry();
	var util = require_util();
	var ArchiveOutputStream = module.exports = function(options) {
		if (!(this instanceof ArchiveOutputStream)) return new ArchiveOutputStream(options);
		Transform.call(this, options);
		this.offset = 0;
		this._archive = {
			finish: false,
			finished: false,
			processing: false
		};
	};
	inherits$4(ArchiveOutputStream, Transform);
	ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {};
	ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {};
	ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
		if (err) this.emit("error", err);
	};
	ArchiveOutputStream.prototype._finish = function(ae) {};
	ArchiveOutputStream.prototype._normalizeEntry = function(ae) {};
	ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
		callback(null, chunk);
	};
	ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
		source = source || null;
		if (typeof callback !== "function") callback = this._emitErrorCallback.bind(this);
		if (!(ae instanceof ArchiveEntry)) {
			callback(/* @__PURE__ */ new Error("not a valid instance of ArchiveEntry"));
			return;
		}
		if (this._archive.finish || this._archive.finished) {
			callback(/* @__PURE__ */ new Error("unacceptable entry after finish"));
			return;
		}
		if (this._archive.processing) {
			callback(/* @__PURE__ */ new Error("already processing an entry"));
			return;
		}
		this._archive.processing = true;
		this._normalizeEntry(ae);
		this._entry = ae;
		source = util.normalizeInputSource(source);
		if (Buffer.isBuffer(source)) this._appendBuffer(ae, source, callback);
		else if (isStream(source)) this._appendStream(ae, source, callback);
		else {
			this._archive.processing = false;
			callback(/* @__PURE__ */ new Error("input source must be valid Stream or Buffer instance"));
			return;
		}
		return this;
	};
	ArchiveOutputStream.prototype.finish = function() {
		if (this._archive.processing) {
			this._archive.finish = true;
			return;
		}
		this._finish();
	};
	ArchiveOutputStream.prototype.getBytesWritten = function() {
		return this.offset;
	};
	ArchiveOutputStream.prototype.write = function(chunk, cb) {
		if (chunk) this.offset += chunk.length;
		return Transform.prototype.write.call(this, chunk, cb);
	};
}));
var require_crc32 = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function(factory) {
		if (typeof DO_NOT_EXPORT_CRC === "undefined") if ("object" === typeof exports) factory(exports);
		else if ("function" === typeof define && define.amd) define(function() {
			var module$1 = {};
			factory(module$1);
			return module$1;
		});
		else factory({});
		else factory({});
	})(function(CRC32) {
		CRC32.version = "1.2.2";
		function signed_crc_table() {
			var c = 0, table = new Array(256);
			for (var n$1 = 0; n$1 != 256; ++n$1) {
				c = n$1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
				table[n$1] = c;
			}
			return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
		}
		var T0 = signed_crc_table();
		function slice_by_16_tables(T) {
			var c = 0, v = 0, n$1 = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
			for (n$1 = 0; n$1 != 256; ++n$1) table[n$1] = T[n$1];
			for (n$1 = 0; n$1 != 256; ++n$1) {
				v = T[n$1];
				for (c = 256 + n$1; c < 4096; c += 256) v = table[c] = v >>> 8 ^ T[v & 255];
			}
			var out = [];
			for (n$1 = 1; n$1 != 16; ++n$1) out[n$1 - 1] = typeof Int32Array !== "undefined" ? table.subarray(n$1 * 256, n$1 * 256 + 256) : table.slice(n$1 * 256, n$1 * 256 + 256);
			return out;
		}
		var TT = slice_by_16_tables(T0);
		var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
		var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
		var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
		function crc32_bstr(bstr, seed) {
			var C = seed ^ -1;
			for (var i = 0, L = bstr.length; i < L;) C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
			return ~C;
		}
		function crc32_buf(B, seed) {
			var C = seed ^ -1, L = B.length - 15, i = 0;
			for (; i < L;) C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
			L += 15;
			while (i < L) C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
			return ~C;
		}
		function crc32_str(str, seed) {
			var C = seed ^ -1;
			for (var i = 0, L = str.length, c = 0, d = 0; i < L;) {
				c = str.charCodeAt(i++);
				if (c < 128) C = C >>> 8 ^ T0[(C ^ c) & 255];
				else if (c < 2048) {
					C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
					C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
				} else if (c >= 55296 && c < 57344) {
					c = (c & 1023) + 64;
					d = str.charCodeAt(i++) & 1023;
					C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
					C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
					C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
					C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
				} else {
					C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
					C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
					C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
				}
			}
			return ~C;
		}
		CRC32.table = T0;
		CRC32.bstr = crc32_bstr;
		CRC32.buf = crc32_buf;
		CRC32.str = crc32_str;
	});
}));
var require_crc32_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Transform } = require_ours();
	var crc32 = require_crc32();
	var CRC32Stream = class extends Transform {
		constructor(options) {
			super(options);
			this.checksum = Buffer.allocUnsafe(4);
			this.checksum.writeInt32BE(0, 0);
			this.rawSize = 0;
		}
		_transform(chunk, encoding, callback) {
			if (chunk) {
				this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
				this.rawSize += chunk.length;
			}
			callback(null, chunk);
		}
		digest(encoding) {
			const checksum = Buffer.allocUnsafe(4);
			checksum.writeUInt32BE(this.checksum >>> 0, 0);
			return encoding ? checksum.toString(encoding) : checksum;
		}
		hex() {
			return this.digest("hex").toUpperCase();
		}
		size() {
			return this.rawSize;
		}
	};
	module.exports = CRC32Stream;
}));
var require_deflate_crc32_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { DeflateRaw } = __require("zlib");
	var crc32 = require_crc32();
	var DeflateCRC32Stream = class extends DeflateRaw {
		constructor(options) {
			super(options);
			this.checksum = Buffer.allocUnsafe(4);
			this.checksum.writeInt32BE(0, 0);
			this.rawSize = 0;
			this.compressedSize = 0;
		}
		push(chunk, encoding) {
			if (chunk) this.compressedSize += chunk.length;
			return super.push(chunk, encoding);
		}
		_transform(chunk, encoding, callback) {
			if (chunk) {
				this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
				this.rawSize += chunk.length;
			}
			super._transform(chunk, encoding, callback);
		}
		digest(encoding) {
			const checksum = Buffer.allocUnsafe(4);
			checksum.writeUInt32BE(this.checksum >>> 0, 0);
			return encoding ? checksum.toString(encoding) : checksum;
		}
		hex() {
			return this.digest("hex").toUpperCase();
		}
		size(compressed = false) {
			if (compressed) return this.compressedSize;
			else return this.rawSize;
		}
	};
	module.exports = DeflateCRC32Stream;
}));
var require_lib = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		CRC32Stream: require_crc32_stream(),
		DeflateCRC32Stream: require_deflate_crc32_stream()
	};
}));
var require_zip_archive_output_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var inherits$3 = __require("util").inherits;
	var crc32 = require_crc32();
	var { CRC32Stream } = require_lib();
	var { DeflateCRC32Stream } = require_lib();
	var ArchiveOutputStream = require_archive_output_stream();
	require_zip_archive_entry();
	require_general_purpose_bit();
	var constants = require_constants$1();
	require_util();
	var zipUtil = require_util$1();
	var ZipArchiveOutputStream = module.exports = function(options) {
		if (!(this instanceof ZipArchiveOutputStream)) return new ZipArchiveOutputStream(options);
		options = this.options = this._defaults(options);
		ArchiveOutputStream.call(this, options);
		this._entry = null;
		this._entries = [];
		this._archive = {
			centralLength: 0,
			centralOffset: 0,
			comment: "",
			finish: false,
			finished: false,
			processing: false,
			forceZip64: options.forceZip64,
			forceLocalTime: options.forceLocalTime
		};
	};
	inherits$3(ZipArchiveOutputStream, ArchiveOutputStream);
	ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
		this._entries.push(ae);
		if (ae.getGeneralPurposeBit().usesDataDescriptor()) this._writeDataDescriptor(ae);
		this._archive.processing = false;
		this._entry = null;
		if (this._archive.finish && !this._archive.finished) this._finish();
	};
	ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
		if (source.length === 0) ae.setMethod(constants.METHOD_STORED);
		var method = ae.getMethod();
		if (method === constants.METHOD_STORED) {
			ae.setSize(source.length);
			ae.setCompressedSize(source.length);
			ae.setCrc(crc32.buf(source) >>> 0);
		}
		this._writeLocalFileHeader(ae);
		if (method === constants.METHOD_STORED) {
			this.write(source);
			this._afterAppend(ae);
			callback(null, ae);
			return;
		} else if (method === constants.METHOD_DEFLATED) {
			this._smartStream(ae, callback).end(source);
			return;
		} else {
			callback(/* @__PURE__ */ new Error("compression method " + method + " not implemented"));
			return;
		}
	};
	ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
		ae.getGeneralPurposeBit().useDataDescriptor(true);
		ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
		this._writeLocalFileHeader(ae);
		var smart = this._smartStream(ae, callback);
		source.once("error", function(err) {
			smart.emit("error", err);
			smart.end();
		});
		source.pipe(smart);
	};
	ZipArchiveOutputStream.prototype._defaults = function(o$1) {
		if (typeof o$1 !== "object") o$1 = {};
		if (typeof o$1.zlib !== "object") o$1.zlib = {};
		if (typeof o$1.zlib.level !== "number") o$1.zlib.level = constants.ZLIB_BEST_SPEED;
		o$1.forceZip64 = !!o$1.forceZip64;
		o$1.forceLocalTime = !!o$1.forceLocalTime;
		return o$1;
	};
	ZipArchiveOutputStream.prototype._finish = function() {
		this._archive.centralOffset = this.offset;
		this._entries.forEach(function(ae) {
			this._writeCentralFileHeader(ae);
		}.bind(this));
		this._archive.centralLength = this.offset - this._archive.centralOffset;
		if (this.isZip64()) this._writeCentralDirectoryZip64();
		this._writeCentralDirectoryEnd();
		this._archive.processing = false;
		this._archive.finish = true;
		this._archive.finished = true;
		this.end();
	};
	ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
		if (ae.getMethod() === -1) ae.setMethod(constants.METHOD_DEFLATED);
		if (ae.getMethod() === constants.METHOD_DEFLATED) {
			ae.getGeneralPurposeBit().useDataDescriptor(true);
			ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
		}
		if (ae.getTime() === -1) ae.setTime(/* @__PURE__ */ new Date(), this._archive.forceLocalTime);
		ae._offsets = {
			file: 0,
			data: 0,
			contents: 0
		};
	};
	ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
		var process$1 = ae.getMethod() === constants.METHOD_DEFLATED ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();
		var error = null;
		function handleStuff() {
			var digest = process$1.digest().readUInt32BE(0);
			ae.setCrc(digest);
			ae.setSize(process$1.size());
			ae.setCompressedSize(process$1.size(true));
			this._afterAppend(ae);
			callback(error, ae);
		}
		process$1.once("end", handleStuff.bind(this));
		process$1.once("error", function(err) {
			error = err;
		});
		process$1.pipe(this, { end: false });
		return process$1;
	};
	ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
		var records = this._entries.length;
		var size = this._archive.centralLength;
		var offset = this._archive.centralOffset;
		if (this.isZip64()) {
			records = constants.ZIP64_MAGIC_SHORT;
			size = constants.ZIP64_MAGIC;
			offset = constants.ZIP64_MAGIC;
		}
		this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
		this.write(constants.SHORT_ZERO);
		this.write(constants.SHORT_ZERO);
		this.write(zipUtil.getShortBytes(records));
		this.write(zipUtil.getShortBytes(records));
		this.write(zipUtil.getLongBytes(size));
		this.write(zipUtil.getLongBytes(offset));
		var comment = this.getComment();
		var commentLength = Buffer.byteLength(comment);
		this.write(zipUtil.getShortBytes(commentLength));
		this.write(comment);
	};
	ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
		this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
		this.write(zipUtil.getEightBytes(44));
		this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
		this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
		this.write(constants.LONG_ZERO);
		this.write(constants.LONG_ZERO);
		this.write(zipUtil.getEightBytes(this._entries.length));
		this.write(zipUtil.getEightBytes(this._entries.length));
		this.write(zipUtil.getEightBytes(this._archive.centralLength));
		this.write(zipUtil.getEightBytes(this._archive.centralOffset));
		this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
		this.write(constants.LONG_ZERO);
		this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
		this.write(zipUtil.getLongBytes(1));
	};
	ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
		var gpb = ae.getGeneralPurposeBit();
		var method = ae.getMethod();
		var fileOffset = ae._offsets.file;
		var size = ae.getSize();
		var compressedSize = ae.getCompressedSize();
		if (ae.isZip64() || fileOffset > constants.ZIP64_MAGIC) {
			size = constants.ZIP64_MAGIC;
			compressedSize = constants.ZIP64_MAGIC;
			fileOffset = constants.ZIP64_MAGIC;
			ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
			var extraBuf = Buffer.concat([
				zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
				zipUtil.getShortBytes(24),
				zipUtil.getEightBytes(ae.getSize()),
				zipUtil.getEightBytes(ae.getCompressedSize()),
				zipUtil.getEightBytes(ae._offsets.file)
			], 28);
			ae.setExtra(extraBuf);
		}
		this.write(zipUtil.getLongBytes(constants.SIG_CFH));
		this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
		this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
		this.write(gpb.encode());
		this.write(zipUtil.getShortBytes(method));
		this.write(zipUtil.getLongBytes(ae.getTimeDos()));
		this.write(zipUtil.getLongBytes(ae.getCrc()));
		this.write(zipUtil.getLongBytes(compressedSize));
		this.write(zipUtil.getLongBytes(size));
		var name$1 = ae.getName();
		var comment = ae.getComment();
		var extra = ae.getCentralDirectoryExtra();
		if (gpb.usesUTF8ForNames()) {
			name$1 = Buffer.from(name$1);
			comment = Buffer.from(comment);
		}
		this.write(zipUtil.getShortBytes(name$1.length));
		this.write(zipUtil.getShortBytes(extra.length));
		this.write(zipUtil.getShortBytes(comment.length));
		this.write(constants.SHORT_ZERO);
		this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
		this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
		this.write(zipUtil.getLongBytes(fileOffset));
		this.write(name$1);
		this.write(extra);
		this.write(comment);
	};
	ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
		this.write(zipUtil.getLongBytes(constants.SIG_DD));
		this.write(zipUtil.getLongBytes(ae.getCrc()));
		if (ae.isZip64()) {
			this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
			this.write(zipUtil.getEightBytes(ae.getSize()));
		} else {
			this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
			this.write(zipUtil.getLongBytes(ae.getSize()));
		}
	};
	ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
		var gpb = ae.getGeneralPurposeBit();
		var method = ae.getMethod();
		var name$1 = ae.getName();
		var extra = ae.getLocalFileDataExtra();
		if (ae.isZip64()) {
			gpb.useDataDescriptor(true);
			ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
		}
		if (gpb.usesUTF8ForNames()) name$1 = Buffer.from(name$1);
		ae._offsets.file = this.offset;
		this.write(zipUtil.getLongBytes(constants.SIG_LFH));
		this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
		this.write(gpb.encode());
		this.write(zipUtil.getShortBytes(method));
		this.write(zipUtil.getLongBytes(ae.getTimeDos()));
		ae._offsets.data = this.offset;
		if (gpb.usesDataDescriptor()) {
			this.write(constants.LONG_ZERO);
			this.write(constants.LONG_ZERO);
			this.write(constants.LONG_ZERO);
		} else {
			this.write(zipUtil.getLongBytes(ae.getCrc()));
			this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
			this.write(zipUtil.getLongBytes(ae.getSize()));
		}
		this.write(zipUtil.getShortBytes(name$1.length));
		this.write(zipUtil.getShortBytes(extra.length));
		this.write(name$1);
		this.write(extra);
		ae._offsets.contents = this.offset;
	};
	ZipArchiveOutputStream.prototype.getComment = function(comment) {
		return this._archive.comment !== null ? this._archive.comment : "";
	};
	ZipArchiveOutputStream.prototype.isZip64 = function() {
		return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
	};
	ZipArchiveOutputStream.prototype.setComment = function(comment) {
		this._archive.comment = comment;
	};
}));
var require_compress_commons = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		ArchiveEntry: require_archive_entry(),
		ZipArchiveEntry: require_zip_archive_entry(),
		ArchiveOutputStream: require_archive_output_stream(),
		ZipArchiveOutputStream: require_zip_archive_output_stream()
	};
}));
var require_zip_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* ZipStream
	*
	* @ignore
	* @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
	* @copyright (c) 2014 Chris Talkington, contributors.
	*/
	var inherits$2 = __require("util").inherits;
	var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
	var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
	var util = require_archiver_utils();
	var ZipStream = module.exports = function(options) {
		if (!(this instanceof ZipStream)) return new ZipStream(options);
		options = this.options = options || {};
		options.zlib = options.zlib || {};
		ZipArchiveOutputStream.call(this, options);
		if (typeof options.level === "number" && options.level >= 0) {
			options.zlib.level = options.level;
			delete options.level;
		}
		if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) options.store = true;
		options.namePrependSlash = options.namePrependSlash || false;
		if (options.comment && options.comment.length > 0) this.setComment(options.comment);
	};
	inherits$2(ZipStream, ZipArchiveOutputStream);
	ZipStream.prototype._normalizeFileData = function(data) {
		data = util.defaults(data, {
			type: "file",
			name: null,
			namePrependSlash: this.options.namePrependSlash,
			linkname: null,
			date: null,
			mode: null,
			store: this.options.store,
			comment: ""
		});
		var isDir = data.type === "directory";
		var isSymlink = data.type === "symlink";
		if (data.name) {
			data.name = util.sanitizePath(data.name);
			if (!isSymlink && data.name.slice(-1) === "/") {
				isDir = true;
				data.type = "directory";
			} else if (isDir) data.name += "/";
		}
		if (isDir || isSymlink) data.store = true;
		data.date = util.dateify(data.date);
		return data;
	};
	ZipStream.prototype.entry = function(source, data, callback) {
		if (typeof callback !== "function") callback = this._emitErrorCallback.bind(this);
		data = this._normalizeFileData(data);
		if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
			callback(/* @__PURE__ */ new Error(data.type + " entries not currently supported"));
			return;
		}
		if (typeof data.name !== "string" || data.name.length === 0) {
			callback(/* @__PURE__ */ new Error("entry name must be a non-empty string value"));
			return;
		}
		if (data.type === "symlink" && typeof data.linkname !== "string") {
			callback(/* @__PURE__ */ new Error("entry linkname must be a non-empty string value when type equals symlink"));
			return;
		}
		var entry = new ZipArchiveEntry(data.name);
		entry.setTime(data.date, this.options.forceLocalTime);
		if (data.namePrependSlash) entry.setName(data.name, true);
		if (data.store) entry.setMethod(0);
		if (data.comment.length > 0) entry.setComment(data.comment);
		if (data.type === "symlink" && typeof data.mode !== "number") data.mode = 40960;
		if (typeof data.mode === "number") {
			if (data.type === "symlink") data.mode |= 40960;
			entry.setUnixMode(data.mode);
		}
		if (data.type === "symlink" && typeof data.linkname === "string") source = Buffer.from(data.linkname);
		return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
	};
	ZipStream.prototype.finalize = function() {
		this.finish();
	};
}));
var require_zip$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* ZIP Format Plugin
	*
	* @module plugins/zip
	* @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
	* @copyright (c) 2012-2014 Chris Talkington, contributors.
	*/
	var engine = require_zip_stream();
	var util = require_archiver_utils();
	var Zip = function(options) {
		if (!(this instanceof Zip)) return new Zip(options);
		options = this.options = util.defaults(options, {
			comment: "",
			forceUTC: false,
			namePrependSlash: false,
			store: false
		});
		this.supports = {
			directory: true,
			symlink: true
		};
		this.engine = new engine(options);
	};
	Zip.prototype.append = function(source, data, callback) {
		this.engine.entry(source, data, callback);
	};
	Zip.prototype.finalize = function() {
		this.engine.finalize();
	};
	Zip.prototype.on = function() {
		return this.engine.on.apply(this.engine, arguments);
	};
	Zip.prototype.pipe = function() {
		return this.engine.pipe.apply(this.engine, arguments);
	};
	Zip.prototype.unpipe = function() {
		return this.engine.unpipe.apply(this.engine, arguments);
	};
	module.exports = Zip;
}));
var require_default = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = __require("events");
}));
var require_fixed_size = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = class FixedFIFO {
		constructor(hwm) {
			if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error("Max size for a FixedFIFO should be a power of two");
			this.buffer = new Array(hwm);
			this.mask = hwm - 1;
			this.top = 0;
			this.btm = 0;
			this.next = null;
		}
		clear() {
			this.top = this.btm = 0;
			this.next = null;
			this.buffer.fill(void 0);
		}
		push(data) {
			if (this.buffer[this.top] !== void 0) return false;
			this.buffer[this.top] = data;
			this.top = this.top + 1 & this.mask;
			return true;
		}
		shift() {
			const last = this.buffer[this.btm];
			if (last === void 0) return void 0;
			this.buffer[this.btm] = void 0;
			this.btm = this.btm + 1 & this.mask;
			return last;
		}
		peek() {
			return this.buffer[this.btm];
		}
		isEmpty() {
			return this.buffer[this.btm] === void 0;
		}
	};
}));
var require_fast_fifo = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var FixedFIFO = require_fixed_size();
	module.exports = class FastFIFO {
		constructor(hwm) {
			this.hwm = hwm || 16;
			this.head = new FixedFIFO(this.hwm);
			this.tail = this.head;
			this.length = 0;
		}
		clear() {
			this.head = this.tail;
			this.head.clear();
			this.length = 0;
		}
		push(val) {
			this.length++;
			if (!this.head.push(val)) {
				const prev = this.head;
				this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
				this.head.push(val);
			}
		}
		shift() {
			if (this.length !== 0) this.length--;
			const val = this.tail.shift();
			if (val === void 0 && this.tail.next) {
				const next = this.tail.next;
				this.tail.next = null;
				this.tail = next;
				return this.tail.shift();
			}
			return val;
		}
		peek() {
			const val = this.tail.peek();
			if (val === void 0 && this.tail.next) return this.tail.next.peek();
			return val;
		}
		isEmpty() {
			return this.length === 0;
		}
	};
}));
var require_b4a = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isBuffer(value$1) {
		return Buffer.isBuffer(value$1) || value$1 instanceof Uint8Array;
	}
	function isEncoding(encoding) {
		return Buffer.isEncoding(encoding);
	}
	function alloc(size, fill, encoding) {
		return Buffer.alloc(size, fill, encoding);
	}
	function allocUnsafe(size) {
		return Buffer.allocUnsafe(size);
	}
	function allocUnsafeSlow(size) {
		return Buffer.allocUnsafeSlow(size);
	}
	function byteLength(string$1, encoding) {
		return Buffer.byteLength(string$1, encoding);
	}
	function compare(a, b) {
		return Buffer.compare(a, b);
	}
	function concat(buffers, totalLength) {
		return Buffer.concat(buffers, totalLength);
	}
	function copy(source, target, targetStart, start, end) {
		return toBuffer(source).copy(target, targetStart, start, end);
	}
	function equals(a, b) {
		return toBuffer(a).equals(b);
	}
	function fill(buffer$2, value$1, offset, end, encoding) {
		return toBuffer(buffer$2).fill(value$1, offset, end, encoding);
	}
	function from(value$1, encodingOrOffset, length) {
		return Buffer.from(value$1, encodingOrOffset, length);
	}
	function includes(buffer$2, value$1, byteOffset, encoding) {
		return toBuffer(buffer$2).includes(value$1, byteOffset, encoding);
	}
	function indexOf(buffer$2, value$1, byfeOffset, encoding) {
		return toBuffer(buffer$2).indexOf(value$1, byfeOffset, encoding);
	}
	function lastIndexOf(buffer$2, value$1, byteOffset, encoding) {
		return toBuffer(buffer$2).lastIndexOf(value$1, byteOffset, encoding);
	}
	function swap16(buffer$2) {
		return toBuffer(buffer$2).swap16();
	}
	function swap32(buffer$2) {
		return toBuffer(buffer$2).swap32();
	}
	function swap64(buffer$2) {
		return toBuffer(buffer$2).swap64();
	}
	function toBuffer(buffer$2) {
		if (Buffer.isBuffer(buffer$2)) return buffer$2;
		return Buffer.from(buffer$2.buffer, buffer$2.byteOffset, buffer$2.byteLength);
	}
	function toString(buffer$2, encoding, start, end) {
		return toBuffer(buffer$2).toString(encoding, start, end);
	}
	function write(buffer$2, string$1, offset, length, encoding) {
		return toBuffer(buffer$2).write(string$1, offset, length, encoding);
	}
	function readDoubleBE(buffer$2, offset) {
		return toBuffer(buffer$2).readDoubleBE(offset);
	}
	function readDoubleLE(buffer$2, offset) {
		return toBuffer(buffer$2).readDoubleLE(offset);
	}
	function readFloatBE(buffer$2, offset) {
		return toBuffer(buffer$2).readFloatBE(offset);
	}
	function readFloatLE(buffer$2, offset) {
		return toBuffer(buffer$2).readFloatLE(offset);
	}
	function readInt32BE(buffer$2, offset) {
		return toBuffer(buffer$2).readInt32BE(offset);
	}
	function readInt32LE(buffer$2, offset) {
		return toBuffer(buffer$2).readInt32LE(offset);
	}
	function readUInt32BE(buffer$2, offset) {
		return toBuffer(buffer$2).readUInt32BE(offset);
	}
	function readUInt32LE(buffer$2, offset) {
		return toBuffer(buffer$2).readUInt32LE(offset);
	}
	function writeDoubleBE(buffer$2, value$1, offset) {
		return toBuffer(buffer$2).writeDoubleBE(value$1, offset);
	}
	function writeDoubleLE(buffer$2, value$1, offset) {
		return toBuffer(buffer$2).writeDoubleLE(value$1, offset);
	}
	function writeFloatBE(buffer$2, value$1, offset) {
		return toBuffer(buffer$2).writeFloatBE(value$1, offset);
	}
	function writeFloatLE(buffer$2, value$1, offset) {
		return toBuffer(buffer$2).writeFloatLE(value$1, offset);
	}
	function writeInt32BE(buffer$2, value$1, offset) {
		return toBuffer(buffer$2).writeInt32BE(value$1, offset);
	}
	function writeInt32LE(buffer$2, value$1, offset) {
		return toBuffer(buffer$2).writeInt32LE(value$1, offset);
	}
	function writeUInt32BE(buffer$2, value$1, offset) {
		return toBuffer(buffer$2).writeUInt32BE(value$1, offset);
	}
	function writeUInt32LE(buffer$2, value$1, offset) {
		return toBuffer(buffer$2).writeUInt32LE(value$1, offset);
	}
	module.exports = {
		isBuffer,
		isEncoding,
		alloc,
		allocUnsafe,
		allocUnsafeSlow,
		byteLength,
		compare,
		concat,
		copy,
		equals,
		fill,
		from,
		includes,
		indexOf,
		lastIndexOf,
		swap16,
		swap32,
		swap64,
		toBuffer,
		toString,
		write,
		readDoubleBE,
		readDoubleLE,
		readFloatBE,
		readFloatLE,
		readInt32BE,
		readInt32LE,
		readUInt32BE,
		readUInt32LE,
		writeDoubleBE,
		writeDoubleLE,
		writeFloatBE,
		writeFloatLE,
		writeInt32BE,
		writeInt32LE,
		writeUInt32BE,
		writeUInt32LE
	};
}));
var require_pass_through_decoder = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var b4a = require_b4a();
	module.exports = class PassThroughDecoder {
		constructor(encoding) {
			this.encoding = encoding;
		}
		get remaining() {
			return 0;
		}
		decode(tail) {
			return b4a.toString(tail, this.encoding);
		}
		flush() {
			return "";
		}
	};
}));
var require_utf8_decoder = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var b4a = require_b4a();
	module.exports = class UTF8Decoder {
		constructor() {
			this.codePoint = 0;
			this.bytesSeen = 0;
			this.bytesNeeded = 0;
			this.lowerBoundary = 128;
			this.upperBoundary = 191;
		}
		get remaining() {
			return this.bytesSeen;
		}
		decode(data) {
			if (this.bytesNeeded === 0) {
				let isBoundary = true;
				for (let i = Math.max(0, data.byteLength - 4), n$1 = data.byteLength; i < n$1 && isBoundary; i++) isBoundary = data[i] <= 127;
				if (isBoundary) return b4a.toString(data, "utf8");
			}
			let result = "";
			for (let i = 0, n$1 = data.byteLength; i < n$1; i++) {
				const byte = data[i];
				if (this.bytesNeeded === 0) {
					if (byte <= 127) result += String.fromCharCode(byte);
					else {
						this.bytesSeen = 1;
						if (byte >= 194 && byte <= 223) {
							this.bytesNeeded = 2;
							this.codePoint = byte & 31;
						} else if (byte >= 224 && byte <= 239) {
							if (byte === 224) this.lowerBoundary = 160;
							else if (byte === 237) this.upperBoundary = 159;
							this.bytesNeeded = 3;
							this.codePoint = byte & 15;
						} else if (byte >= 240 && byte <= 244) {
							if (byte === 240) this.lowerBoundary = 144;
							if (byte === 244) this.upperBoundary = 143;
							this.bytesNeeded = 4;
							this.codePoint = byte & 7;
						} else result += "";
					}
					continue;
				}
				if (byte < this.lowerBoundary || byte > this.upperBoundary) {
					this.codePoint = 0;
					this.bytesNeeded = 0;
					this.bytesSeen = 0;
					this.lowerBoundary = 128;
					this.upperBoundary = 191;
					result += "";
					continue;
				}
				this.lowerBoundary = 128;
				this.upperBoundary = 191;
				this.codePoint = this.codePoint << 6 | byte & 63;
				this.bytesSeen++;
				if (this.bytesSeen !== this.bytesNeeded) continue;
				result += String.fromCodePoint(this.codePoint);
				this.codePoint = 0;
				this.bytesNeeded = 0;
				this.bytesSeen = 0;
			}
			return result;
		}
		flush() {
			const result = this.bytesNeeded > 0 ? "" : "";
			this.codePoint = 0;
			this.bytesNeeded = 0;
			this.bytesSeen = 0;
			this.lowerBoundary = 128;
			this.upperBoundary = 191;
			return result;
		}
	};
}));
var require_text_decoder = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var PassThroughDecoder = require_pass_through_decoder();
	var UTF8Decoder = require_utf8_decoder();
	module.exports = class TextDecoder$1 {
		constructor(encoding = "utf8") {
			this.encoding = normalizeEncoding(encoding);
			switch (this.encoding) {
				case "utf8":
					this.decoder = new UTF8Decoder();
					break;
				case "utf16le":
				case "base64": throw new Error("Unsupported encoding: " + this.encoding);
				default: this.decoder = new PassThroughDecoder(this.encoding);
			}
		}
		get remaining() {
			return this.decoder.remaining;
		}
		push(data) {
			if (typeof data === "string") return data;
			return this.decoder.decode(data);
		}
		write(data) {
			return this.push(data);
		}
		end(data) {
			let result = "";
			if (data) result = this.push(data);
			result += this.decoder.flush();
			return result;
		}
	};
	function normalizeEncoding(encoding) {
		encoding = encoding.toLowerCase();
		switch (encoding) {
			case "utf8":
			case "utf-8": return "utf8";
			case "ucs2":
			case "ucs-2":
			case "utf16le":
			case "utf-16le": return "utf16le";
			case "latin1":
			case "binary": return "latin1";
			case "base64":
			case "ascii":
			case "hex": return encoding;
			default: throw new Error("Unknown encoding: " + encoding);
		}
	}
}));
var require_streamx = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { EventEmitter } = require_default();
	var STREAM_DESTROYED = /* @__PURE__ */ new Error("Stream was destroyed");
	var PREMATURE_CLOSE = /* @__PURE__ */ new Error("Premature close");
	var FIFO = require_fast_fifo();
	var TextDecoder = require_text_decoder();
	var qmt = typeof queueMicrotask === "undefined" ? (fn) => global.process.nextTick(fn) : queueMicrotask;
	var MAX = (1 << 29) - 1;
	var OPENING = 1;
	var PREDESTROYING = 2;
	var DESTROYING = 4;
	var DESTROYED = 8;
	var NOT_OPENING = MAX ^ OPENING;
	var NOT_PREDESTROYING = MAX ^ PREDESTROYING;
	var READ_ACTIVE = 16;
	var READ_UPDATING = 32;
	var READ_PRIMARY = 64;
	var READ_QUEUED = 128;
	var READ_RESUMED = 256;
	var READ_PIPE_DRAINED = 512;
	var READ_ENDING = 1024;
	var READ_EMIT_DATA = 2048;
	var READ_EMIT_READABLE = 4096;
	var READ_EMITTED_READABLE = 8192;
	var READ_DONE = 16384;
	var READ_NEXT_TICK = 32768;
	var READ_NEEDS_PUSH = 65536;
	var READ_READ_AHEAD = 131072;
	var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
	var READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
	var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
	var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
	var READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
	var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
	var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
	var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
	var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
	var READ_PAUSED = MAX ^ READ_RESUMED;
	var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
	var READ_NOT_ENDING = MAX ^ READ_ENDING;
	var READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
	var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
	var READ_NOT_UPDATING = MAX ^ READ_UPDATING;
	var READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
	var READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
	var WRITE_ACTIVE = 1 << 18;
	var WRITE_UPDATING = 2 << 18;
	var WRITE_PRIMARY = 4 << 18;
	var WRITE_QUEUED = 8 << 18;
	var WRITE_UNDRAINED = 16 << 18;
	var WRITE_DONE = 32 << 18;
	var WRITE_EMIT_DRAIN = 64 << 18;
	var WRITE_NEXT_TICK = 128 << 18;
	var WRITE_WRITING = 256 << 18;
	var WRITE_FINISHING = 512 << 18;
	var WRITE_CORKED = 1024 << 18;
	var WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
	var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
	var WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
	var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
	var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
	var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
	var WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
	var WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
	var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
	var NOT_ACTIVE = MAX ^ ACTIVE;
	var DONE = READ_DONE | WRITE_DONE;
	var DESTROY_STATUS = DESTROYED | 6;
	var OPEN_STATUS = DESTROY_STATUS | OPENING;
	var AUTO_DESTROY = DESTROY_STATUS | DONE;
	var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
	var ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
	var IS_OPENING = OPEN_STATUS | ACTIVE_OR_TICKING & NOT_ACTIVE;
	var READ_PRIMARY_STATUS = READ_ENDING | 16399;
	var READ_STATUS = READ_DONE | 143;
	var READ_ENDING_STATUS = READ_ENDING | 143;
	var READ_READABLE_STATUS = 12431;
	var SHOULD_NOT_READ = 214047;
	var READ_BACKPRESSURE_STATUS = READ_ENDING | 16398;
	var READ_UPDATE_SYNC_STATUS = 32879;
	var READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
	var WRITE_PRIMARY_STATUS = WRITE_FINISHING | 8388623;
	var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
	var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
	var WRITE_DRAIN_STATUS = 6553615;
	var WRITE_STATUS = 270794767;
	var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
	var WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
	var WRITE_FINISHING_STATUS = 144965647;
	var WRITE_BACKPRESSURE_STATUS = 146800654;
	var WRITE_UPDATE_SYNC_STATUS = 35127311;
	var WRITE_DROP_DATA = WRITE_DONE | 134217742;
	var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");
	var WritableState = class {
		constructor(stream$5, { highWaterMark = 16384, map: map$6 = null, mapWritable, byteLength, byteLengthWritable } = {}) {
			this.stream = stream$5;
			this.queue = new FIFO();
			this.highWaterMark = highWaterMark;
			this.buffered = 0;
			this.error = null;
			this.pipeline = null;
			this.drains = null;
			this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
			this.map = mapWritable || map$6;
			this.afterWrite = afterWrite.bind(this);
			this.afterUpdateNextTick = updateWriteNT.bind(this);
		}
		get ended() {
			return (this.stream._duplexState & WRITE_DONE) !== 0;
		}
		push(data) {
			if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false;
			if (this.map !== null) data = this.map(data);
			this.buffered += this.byteLength(data);
			this.queue.push(data);
			if (this.buffered < this.highWaterMark) {
				this.stream._duplexState |= WRITE_QUEUED;
				return true;
			}
			this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
			return false;
		}
		shift() {
			const data = this.queue.shift();
			this.buffered -= this.byteLength(data);
			if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;
			return data;
		}
		end(data) {
			if (typeof data === "function") this.stream.once("finish", data);
			else if (data !== void 0 && data !== null) this.push(data);
			this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
		}
		autoBatch(data, cb) {
			const buffer$2 = [];
			const stream$5 = this.stream;
			buffer$2.push(data);
			while ((stream$5._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) buffer$2.push(stream$5._writableState.shift());
			if ((stream$5._duplexState & OPEN_STATUS) !== 0) return cb(null);
			stream$5._writev(buffer$2, cb);
		}
		update() {
			const stream$5 = this.stream;
			stream$5._duplexState |= WRITE_UPDATING;
			do {
				while ((stream$5._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
					const data = this.shift();
					stream$5._duplexState |= WRITE_ACTIVE_AND_WRITING;
					stream$5._write(data, this.afterWrite);
				}
				if ((stream$5._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
			} while (this.continueUpdate() === true);
			stream$5._duplexState &= WRITE_NOT_UPDATING;
		}
		updateNonPrimary() {
			const stream$5 = this.stream;
			if ((stream$5._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
				stream$5._duplexState = stream$5._duplexState | WRITE_ACTIVE;
				stream$5._final(afterFinal.bind(this));
				return;
			}
			if ((stream$5._duplexState & DESTROY_STATUS) === DESTROYING) {
				if ((stream$5._duplexState & ACTIVE_OR_TICKING) === 0) {
					stream$5._duplexState |= ACTIVE;
					stream$5._destroy(afterDestroy.bind(this));
				}
				return;
			}
			if ((stream$5._duplexState & IS_OPENING) === OPENING) {
				stream$5._duplexState = (stream$5._duplexState | ACTIVE) & NOT_OPENING;
				stream$5._open(afterOpen.bind(this));
			}
		}
		continueUpdate() {
			if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;
			this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
			return true;
		}
		updateCallback() {
			if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();
			else this.updateNextTick();
		}
		updateNextTick() {
			if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;
			this.stream._duplexState |= WRITE_NEXT_TICK;
			if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick);
		}
	};
	var ReadableState = class {
		constructor(stream$5, { highWaterMark = 16384, map: map$6 = null, mapReadable, byteLength, byteLengthReadable } = {}) {
			this.stream = stream$5;
			this.queue = new FIFO();
			this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
			this.buffered = 0;
			this.readAhead = highWaterMark > 0;
			this.error = null;
			this.pipeline = null;
			this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
			this.map = mapReadable || map$6;
			this.pipeTo = null;
			this.afterRead = afterRead.bind(this);
			this.afterUpdateNextTick = updateReadNT.bind(this);
		}
		get ended() {
			return (this.stream._duplexState & READ_DONE) !== 0;
		}
		pipe(pipeTo, cb) {
			if (this.pipeTo !== null) throw new Error("Can only pipe to one destination");
			if (typeof cb !== "function") cb = null;
			this.stream._duplexState |= READ_PIPE_DRAINED;
			this.pipeTo = pipeTo;
			this.pipeline = new Pipeline(this.stream, pipeTo, cb);
			if (cb) this.stream.on("error", noop);
			if (isStreamx(pipeTo)) {
				pipeTo._writableState.pipeline = this.pipeline;
				if (cb) pipeTo.on("error", noop);
				pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
			} else {
				const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
				const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
				pipeTo.on("error", onerror);
				pipeTo.on("close", onclose);
				pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
			}
			pipeTo.on("drain", afterDrain.bind(this));
			this.stream.emit("piping", pipeTo);
			pipeTo.emit("pipe", this.stream);
		}
		push(data) {
			const stream$5 = this.stream;
			if (data === null) {
				this.highWaterMark = 0;
				stream$5._duplexState = (stream$5._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
				return false;
			}
			if (this.map !== null) {
				data = this.map(data);
				if (data === null) {
					stream$5._duplexState &= READ_PUSHED;
					return this.buffered < this.highWaterMark;
				}
			}
			this.buffered += this.byteLength(data);
			this.queue.push(data);
			stream$5._duplexState = (stream$5._duplexState | READ_QUEUED) & READ_PUSHED;
			return this.buffered < this.highWaterMark;
		}
		shift() {
			const data = this.queue.shift();
			this.buffered -= this.byteLength(data);
			if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
			return data;
		}
		unshift(data) {
			const pending = [this.map !== null ? this.map(data) : data];
			while (this.buffered > 0) pending.push(this.shift());
			for (let i = 0; i < pending.length - 1; i++) {
				const data$1 = pending[i];
				this.buffered += this.byteLength(data$1);
				this.queue.push(data$1);
			}
			this.push(pending[pending.length - 1]);
		}
		read() {
			const stream$5 = this.stream;
			if ((stream$5._duplexState & READ_STATUS) === READ_QUEUED) {
				const data = this.shift();
				if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream$5._duplexState &= READ_PIPE_NOT_DRAINED;
				if ((stream$5._duplexState & READ_EMIT_DATA) !== 0) stream$5.emit("data", data);
				return data;
			}
			if (this.readAhead === false) {
				stream$5._duplexState |= READ_READ_AHEAD;
				this.updateNextTick();
			}
			return null;
		}
		drain() {
			const stream$5 = this.stream;
			while ((stream$5._duplexState & READ_STATUS) === READ_QUEUED && (stream$5._duplexState & READ_FLOWING) !== 0) {
				const data = this.shift();
				if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream$5._duplexState &= READ_PIPE_NOT_DRAINED;
				if ((stream$5._duplexState & READ_EMIT_DATA) !== 0) stream$5.emit("data", data);
			}
		}
		update() {
			const stream$5 = this.stream;
			stream$5._duplexState |= READ_UPDATING;
			do {
				this.drain();
				while (this.buffered < this.highWaterMark && (stream$5._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
					stream$5._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
					stream$5._read(this.afterRead);
					this.drain();
				}
				if ((stream$5._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
					stream$5._duplexState |= READ_EMITTED_READABLE;
					stream$5.emit("readable");
				}
				if ((stream$5._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
			} while (this.continueUpdate() === true);
			stream$5._duplexState &= READ_NOT_UPDATING;
		}
		updateNonPrimary() {
			const stream$5 = this.stream;
			if ((stream$5._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
				stream$5._duplexState = (stream$5._duplexState | READ_DONE) & READ_NOT_ENDING;
				stream$5.emit("end");
				if ((stream$5._duplexState & AUTO_DESTROY) === DONE) stream$5._duplexState |= DESTROYING;
				if (this.pipeTo !== null) this.pipeTo.end();
			}
			if ((stream$5._duplexState & DESTROY_STATUS) === DESTROYING) {
				if ((stream$5._duplexState & ACTIVE_OR_TICKING) === 0) {
					stream$5._duplexState |= ACTIVE;
					stream$5._destroy(afterDestroy.bind(this));
				}
				return;
			}
			if ((stream$5._duplexState & IS_OPENING) === OPENING) {
				stream$5._duplexState = (stream$5._duplexState | ACTIVE) & NOT_OPENING;
				stream$5._open(afterOpen.bind(this));
			}
		}
		continueUpdate() {
			if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;
			this.stream._duplexState &= READ_NOT_NEXT_TICK;
			return true;
		}
		updateCallback() {
			if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();
			else this.updateNextTick();
		}
		updateNextTickIfOpen() {
			if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return;
			this.stream._duplexState |= READ_NEXT_TICK;
			if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);
		}
		updateNextTick() {
			if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;
			this.stream._duplexState |= READ_NEXT_TICK;
			if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);
		}
	};
	var TransformState = class {
		constructor(stream$5) {
			this.data = null;
			this.afterTransform = afterTransform.bind(stream$5);
			this.afterFinal = null;
		}
	};
	var Pipeline = class {
		constructor(src, dst, cb) {
			this.from = src;
			this.to = dst;
			this.afterPipe = cb;
			this.error = null;
			this.pipeToFinished = false;
		}
		finished() {
			this.pipeToFinished = true;
		}
		done(stream$5, err) {
			if (err) this.error = err;
			if (stream$5 === this.to) {
				this.to = null;
				if (this.from !== null) {
					if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) this.from.destroy(this.error || /* @__PURE__ */ new Error("Writable stream closed prematurely"));
					return;
				}
			}
			if (stream$5 === this.from) {
				this.from = null;
				if (this.to !== null) {
					if ((stream$5._duplexState & READ_DONE) === 0) this.to.destroy(this.error || /* @__PURE__ */ new Error("Readable stream closed before ending"));
					return;
				}
			}
			if (this.afterPipe !== null) this.afterPipe(this.error);
			this.to = this.from = this.afterPipe = null;
		}
	};
	function afterDrain() {
		this.stream._duplexState |= READ_PIPE_DRAINED;
		this.updateCallback();
	}
	function afterFinal(err) {
		const stream$5 = this.stream;
		if (err) stream$5.destroy(err);
		if ((stream$5._duplexState & DESTROY_STATUS) === 0) {
			stream$5._duplexState |= WRITE_DONE;
			stream$5.emit("finish");
		}
		if ((stream$5._duplexState & AUTO_DESTROY) === DONE) stream$5._duplexState |= DESTROYING;
		stream$5._duplexState &= WRITE_NOT_FINISHING;
		if ((stream$5._duplexState & WRITE_UPDATING) === 0) this.update();
		else this.updateNextTick();
	}
	function afterDestroy(err) {
		const stream$5 = this.stream;
		if (!err && this.error !== STREAM_DESTROYED) err = this.error;
		if (err) stream$5.emit("error", err);
		stream$5._duplexState |= DESTROYED;
		stream$5.emit("close");
		const rs = stream$5._readableState;
		const ws = stream$5._writableState;
		if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream$5, err);
		if (ws !== null) {
			while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false);
			if (ws.pipeline !== null) ws.pipeline.done(stream$5, err);
		}
	}
	function afterWrite(err) {
		const stream$5 = this.stream;
		if (err) stream$5.destroy(err);
		stream$5._duplexState &= WRITE_NOT_ACTIVE;
		if (this.drains !== null) tickDrains(this.drains);
		if ((stream$5._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
			stream$5._duplexState &= WRITE_DRAINED;
			if ((stream$5._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) stream$5.emit("drain");
		}
		this.updateCallback();
	}
	function afterRead(err) {
		if (err) this.stream.destroy(err);
		this.stream._duplexState &= READ_NOT_ACTIVE;
		if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;
		this.updateCallback();
	}
	function updateReadNT() {
		if ((this.stream._duplexState & READ_UPDATING) === 0) {
			this.stream._duplexState &= READ_NOT_NEXT_TICK;
			this.update();
		}
	}
	function updateWriteNT() {
		if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
			this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
			this.update();
		}
	}
	function tickDrains(drains) {
		for (let i = 0; i < drains.length; i++) if (--drains[i].writes === 0) {
			drains.shift().resolve(true);
			i--;
		}
	}
	function afterOpen(err) {
		const stream$5 = this.stream;
		if (err) stream$5.destroy(err);
		if ((stream$5._duplexState & DESTROYING) === 0) {
			if ((stream$5._duplexState & READ_PRIMARY_STATUS) === 0) stream$5._duplexState |= READ_PRIMARY;
			if ((stream$5._duplexState & WRITE_PRIMARY_STATUS) === 0) stream$5._duplexState |= WRITE_PRIMARY;
			stream$5.emit("open");
		}
		stream$5._duplexState &= NOT_ACTIVE;
		if (stream$5._writableState !== null) stream$5._writableState.updateCallback();
		if (stream$5._readableState !== null) stream$5._readableState.updateCallback();
	}
	function afterTransform(err, data) {
		if (data !== void 0 && data !== null) this.push(data);
		this._writableState.afterWrite(err);
	}
	function newListener(name$1) {
		if (this._readableState !== null) {
			if (name$1 === "data") {
				this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
				this._readableState.updateNextTick();
			}
			if (name$1 === "readable") {
				this._duplexState |= READ_EMIT_READABLE;
				this._readableState.updateNextTick();
			}
		}
		if (this._writableState !== null) {
			if (name$1 === "drain") {
				this._duplexState |= WRITE_EMIT_DRAIN;
				this._writableState.updateNextTick();
			}
		}
	}
	var Stream = class extends EventEmitter {
		constructor(opts) {
			super();
			this._duplexState = 0;
			this._readableState = null;
			this._writableState = null;
			if (opts) {
				if (opts.open) this._open = opts.open;
				if (opts.destroy) this._destroy = opts.destroy;
				if (opts.predestroy) this._predestroy = opts.predestroy;
				if (opts.signal) opts.signal.addEventListener("abort", abort.bind(this));
			}
			this.on("newListener", newListener);
		}
		_open(cb) {
			cb(null);
		}
		_destroy(cb) {
			cb(null);
		}
		_predestroy() {}
		get readable() {
			return this._readableState !== null ? true : void 0;
		}
		get writable() {
			return this._writableState !== null ? true : void 0;
		}
		get destroyed() {
			return (this._duplexState & DESTROYED) !== 0;
		}
		get destroying() {
			return (this._duplexState & DESTROY_STATUS) !== 0;
		}
		destroy(err) {
			if ((this._duplexState & DESTROY_STATUS) === 0) {
				if (!err) err = STREAM_DESTROYED;
				this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
				if (this._readableState !== null) {
					this._readableState.highWaterMark = 0;
					this._readableState.error = err;
				}
				if (this._writableState !== null) {
					this._writableState.highWaterMark = 0;
					this._writableState.error = err;
				}
				this._duplexState |= PREDESTROYING;
				this._predestroy();
				this._duplexState &= NOT_PREDESTROYING;
				if (this._readableState !== null) this._readableState.updateNextTick();
				if (this._writableState !== null) this._writableState.updateNextTick();
			}
		}
	};
	var Readable = class Readable extends Stream {
		constructor(opts) {
			super(opts);
			this._duplexState |= WRITE_DONE | 131073;
			this._readableState = new ReadableState(this, opts);
			if (opts) {
				if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;
				if (opts.read) this._read = opts.read;
				if (opts.eagerOpen) this._readableState.updateNextTick();
				if (opts.encoding) this.setEncoding(opts.encoding);
			}
		}
		setEncoding(encoding) {
			const dec = new TextDecoder(encoding);
			const map$6 = this._readableState.map || echo;
			this._readableState.map = mapOrSkip;
			return this;
			function mapOrSkip(data) {
				const next = dec.push(data);
				return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map$6(next);
			}
		}
		_read(cb) {
			cb(null);
		}
		pipe(dest, cb) {
			this._readableState.updateNextTick();
			this._readableState.pipe(dest, cb);
			return dest;
		}
		read() {
			this._readableState.updateNextTick();
			return this._readableState.read();
		}
		push(data) {
			this._readableState.updateNextTickIfOpen();
			return this._readableState.push(data);
		}
		unshift(data) {
			this._readableState.updateNextTickIfOpen();
			return this._readableState.unshift(data);
		}
		resume() {
			this._duplexState |= READ_RESUMED_READ_AHEAD;
			this._readableState.updateNextTick();
			return this;
		}
		pause() {
			this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
			return this;
		}
		static _fromAsyncIterator(ite, opts) {
			let destroy;
			const rs = new Readable({
				...opts,
				read(cb) {
					ite.next().then(push).then(cb.bind(null, null)).catch(cb);
				},
				predestroy() {
					destroy = ite.return();
				},
				destroy(cb) {
					if (!destroy) return cb(null);
					destroy.then(cb.bind(null, null)).catch(cb);
				}
			});
			return rs;
			function push(data) {
				if (data.done) rs.push(null);
				else rs.push(data.value);
			}
		}
		static from(data, opts) {
			if (isReadStreamx(data)) return data;
			if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);
			if (!Array.isArray(data)) data = data === void 0 ? [] : [data];
			let i = 0;
			return new Readable({
				...opts,
				read(cb) {
					this.push(i === data.length ? null : data[i++]);
					cb(null);
				}
			});
		}
		static isBackpressured(rs) {
			return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
		}
		static isPaused(rs) {
			return (rs._duplexState & READ_RESUMED) === 0;
		}
		[asyncIterator]() {
			const stream$5 = this;
			let error = null;
			let promiseResolve = null;
			let promiseReject = null;
			this.on("error", (err) => {
				error = err;
			});
			this.on("readable", onreadable);
			this.on("close", onclose);
			return {
				[asyncIterator]() {
					return this;
				},
				next() {
					return new Promise(function(resolve$1, reject$3) {
						promiseResolve = resolve$1;
						promiseReject = reject$3;
						const data = stream$5.read();
						if (data !== null) ondata(data);
						else if ((stream$5._duplexState & DESTROYED) !== 0) ondata(null);
					});
				},
				return() {
					return destroy(null);
				},
				throw(err) {
					return destroy(err);
				}
			};
			function onreadable() {
				if (promiseResolve !== null) ondata(stream$5.read());
			}
			function onclose() {
				if (promiseResolve !== null) ondata(null);
			}
			function ondata(data) {
				if (promiseReject === null) return;
				if (error) promiseReject(error);
				else if (data === null && (stream$5._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);
				else promiseResolve({
					value: data,
					done: data === null
				});
				promiseReject = promiseResolve = null;
			}
			function destroy(err) {
				stream$5.destroy(err);
				return new Promise((resolve$1, reject$3) => {
					if (stream$5._duplexState & DESTROYED) return resolve$1({
						value: void 0,
						done: true
					});
					stream$5.once("close", function() {
						if (err) reject$3(err);
						else resolve$1({
							value: void 0,
							done: true
						});
					});
				});
			}
		}
	};
	var Writable = class extends Stream {
		constructor(opts) {
			super(opts);
			this._duplexState |= OPENING | READ_DONE;
			this._writableState = new WritableState(this, opts);
			if (opts) {
				if (opts.writev) this._writev = opts.writev;
				if (opts.write) this._write = opts.write;
				if (opts.final) this._final = opts.final;
				if (opts.eagerOpen) this._writableState.updateNextTick();
			}
		}
		cork() {
			this._duplexState |= WRITE_CORKED;
		}
		uncork() {
			this._duplexState &= WRITE_NOT_CORKED;
			this._writableState.updateNextTick();
		}
		_writev(batch, cb) {
			cb(null);
		}
		_write(data, cb) {
			this._writableState.autoBatch(data, cb);
		}
		_final(cb) {
			cb(null);
		}
		static isBackpressured(ws) {
			return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
		}
		static drained(ws) {
			if (ws.destroyed) return Promise.resolve(false);
			const state = ws._writableState;
			const writes = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length) + (ws._duplexState & WRITE_WRITING ? 1 : 0);
			if (writes === 0) return Promise.resolve(true);
			if (state.drains === null) state.drains = [];
			return new Promise((resolve$1) => {
				state.drains.push({
					writes,
					resolve: resolve$1
				});
			});
		}
		write(data) {
			this._writableState.updateNextTick();
			return this._writableState.push(data);
		}
		end(data) {
			this._writableState.updateNextTick();
			this._writableState.end(data);
			return this;
		}
	};
	var Duplex = class extends Readable {
		constructor(opts) {
			super(opts);
			this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
			this._writableState = new WritableState(this, opts);
			if (opts) {
				if (opts.writev) this._writev = opts.writev;
				if (opts.write) this._write = opts.write;
				if (opts.final) this._final = opts.final;
			}
		}
		cork() {
			this._duplexState |= WRITE_CORKED;
		}
		uncork() {
			this._duplexState &= WRITE_NOT_CORKED;
			this._writableState.updateNextTick();
		}
		_writev(batch, cb) {
			cb(null);
		}
		_write(data, cb) {
			this._writableState.autoBatch(data, cb);
		}
		_final(cb) {
			cb(null);
		}
		write(data) {
			this._writableState.updateNextTick();
			return this._writableState.push(data);
		}
		end(data) {
			this._writableState.updateNextTick();
			this._writableState.end(data);
			return this;
		}
	};
	var Transform = class extends Duplex {
		constructor(opts) {
			super(opts);
			this._transformState = new TransformState(this);
			if (opts) {
				if (opts.transform) this._transform = opts.transform;
				if (opts.flush) this._flush = opts.flush;
			}
		}
		_write(data, cb) {
			if (this._readableState.buffered >= this._readableState.highWaterMark) this._transformState.data = data;
			else this._transform(data, this._transformState.afterTransform);
		}
		_read(cb) {
			if (this._transformState.data !== null) {
				const data = this._transformState.data;
				this._transformState.data = null;
				cb(null);
				this._transform(data, this._transformState.afterTransform);
			} else cb(null);
		}
		destroy(err) {
			super.destroy(err);
			if (this._transformState.data !== null) {
				this._transformState.data = null;
				this._transformState.afterTransform();
			}
		}
		_transform(data, cb) {
			cb(null, data);
		}
		_flush(cb) {
			cb(null);
		}
		_final(cb) {
			this._transformState.afterFinal = cb;
			this._flush(transformAfterFlush.bind(this));
		}
	};
	var PassThrough = class extends Transform {};
	function transformAfterFlush(err, data) {
		const cb = this._transformState.afterFinal;
		if (err) return cb(err);
		if (data !== null && data !== void 0) this.push(data);
		this.push(null);
		cb(null);
	}
	function pipelinePromise(...streams) {
		return new Promise((resolve$1, reject$3) => {
			return pipeline(...streams, (err) => {
				if (err) return reject$3(err);
				resolve$1();
			});
		});
	}
	function pipeline(stream$5, ...streams) {
		const all$1 = Array.isArray(stream$5) ? [...stream$5, ...streams] : [stream$5, ...streams];
		const done = all$1.length && typeof all$1[all$1.length - 1] === "function" ? all$1.pop() : null;
		if (all$1.length < 2) throw new Error("Pipeline requires at least 2 streams");
		let src = all$1[0];
		let dest = null;
		let error = null;
		for (let i = 1; i < all$1.length; i++) {
			dest = all$1[i];
			if (isStreamx(src)) src.pipe(dest, onerror);
			else {
				errorHandle(src, true, i > 1, onerror);
				src.pipe(dest);
			}
			src = dest;
		}
		if (done) {
			let fin = false;
			const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
			dest.on("error", (err) => {
				if (error === null) error = err;
			});
			dest.on("finish", () => {
				fin = true;
				if (!autoDestroy) done(error);
			});
			if (autoDestroy) dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
		}
		return dest;
		function errorHandle(s, rd, wr, onerror$1) {
			s.on("error", onerror$1);
			s.on("close", onclose);
			function onclose() {
				if (rd && s._readableState && !s._readableState.ended) return onerror$1(PREMATURE_CLOSE);
				if (wr && s._writableState && !s._writableState.ended) return onerror$1(PREMATURE_CLOSE);
			}
		}
		function onerror(err) {
			if (!err || error) return;
			error = err;
			for (const s of all$1) s.destroy(err);
		}
	}
	function echo(s) {
		return s;
	}
	function isStream(stream$5) {
		return !!stream$5._readableState || !!stream$5._writableState;
	}
	function isStreamx(stream$5) {
		return typeof stream$5._duplexState === "number" && isStream(stream$5);
	}
	function isEnded(stream$5) {
		return !!stream$5._readableState && stream$5._readableState.ended;
	}
	function isFinished(stream$5) {
		return !!stream$5._writableState && stream$5._writableState.ended;
	}
	function getStreamError(stream$5, opts = {}) {
		const err = stream$5._readableState && stream$5._readableState.error || stream$5._writableState && stream$5._writableState.error;
		return !opts.all && err === STREAM_DESTROYED ? null : err;
	}
	function isReadStreamx(stream$5) {
		return isStreamx(stream$5) && stream$5.readable;
	}
	function isDisturbed(stream$5) {
		return (stream$5._duplexState & OPENING) !== OPENING || (stream$5._duplexState & ACTIVE_OR_TICKING) !== 0;
	}
	function isTypedArray(data) {
		return typeof data === "object" && data !== null && typeof data.byteLength === "number";
	}
	function defaultByteLength(data) {
		return isTypedArray(data) ? data.byteLength : 1024;
	}
	function noop() {}
	function abort() {
		this.destroy(/* @__PURE__ */ new Error("Stream aborted."));
	}
	function isWritev(s) {
		return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
	}
	module.exports = {
		pipeline,
		pipelinePromise,
		isStream,
		isStreamx,
		isEnded,
		isFinished,
		isDisturbed,
		getStreamError,
		Stream,
		Writable,
		Readable,
		Duplex,
		Transform,
		PassThrough
	};
}));
var require_headers = /* @__PURE__ */ __commonJSMin(((exports) => {
	var b4a = require_b4a();
	var ZEROS = "0000000000000000000";
	var SEVENS = "7777777777777777777";
	var ZERO_OFFSET = "0".charCodeAt(0);
	var USTAR_MAGIC = b4a.from([
		117,
		115,
		116,
		97,
		114,
		0
	]);
	var USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET]);
	var GNU_MAGIC = b4a.from([
		117,
		115,
		116,
		97,
		114,
		32
	]);
	var GNU_VER = b4a.from([32, 0]);
	var MASK = 4095;
	var MAGIC_OFFSET = 257;
	var VERSION_OFFSET = 263;
	exports.decodeLongPath = function decodeLongPath(buf, encoding) {
		return decodeStr(buf, 0, buf.length, encoding);
	};
	exports.encodePax = function encodePax(opts) {
		let result = "";
		if (opts.name) result += addLength(" path=" + opts.name + "\n");
		if (opts.linkname) result += addLength(" linkpath=" + opts.linkname + "\n");
		const pax = opts.pax;
		if (pax) for (const key in pax) result += addLength(" " + key + "=" + pax[key] + "\n");
		return b4a.from(result);
	};
	exports.decodePax = function decodePax(buf) {
		const result = {};
		while (buf.length) {
			let i = 0;
			while (i < buf.length && buf[i] !== 32) i++;
			const len = parseInt(b4a.toString(buf.subarray(0, i)), 10);
			if (!len) return result;
			const b = b4a.toString(buf.subarray(i + 1, len - 1));
			const keyIndex = b.indexOf("=");
			if (keyIndex === -1) return result;
			result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
			buf = buf.subarray(len);
		}
		return result;
	};
	exports.encode = function encode(opts) {
		const buf = b4a.alloc(512);
		let name$1 = opts.name;
		let prefix = "";
		if (opts.typeflag === 5 && name$1[name$1.length - 1] !== "/") name$1 += "/";
		if (b4a.byteLength(name$1) !== name$1.length) return null;
		while (b4a.byteLength(name$1) > 100) {
			const i = name$1.indexOf("/");
			if (i === -1) return null;
			prefix += prefix ? "/" + name$1.slice(0, i) : name$1.slice(0, i);
			name$1 = name$1.slice(i + 1);
		}
		if (b4a.byteLength(name$1) > 100 || b4a.byteLength(prefix) > 155) return null;
		if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null;
		b4a.write(buf, name$1);
		b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100);
		b4a.write(buf, encodeOct(opts.uid, 6), 108);
		b4a.write(buf, encodeOct(opts.gid, 6), 116);
		encodeSize(opts.size, buf, 124);
		b4a.write(buf, encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
		buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
		if (opts.linkname) b4a.write(buf, opts.linkname, 157);
		b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
		b4a.copy(USTAR_VER, buf, VERSION_OFFSET);
		if (opts.uname) b4a.write(buf, opts.uname, 265);
		if (opts.gname) b4a.write(buf, opts.gname, 297);
		b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
		b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337);
		if (prefix) b4a.write(buf, prefix, 345);
		b4a.write(buf, encodeOct(cksum(buf), 6), 148);
		return buf;
	};
	exports.decode = function decode(buf, filenameEncoding, allowUnknownFormat) {
		let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
		let name$1 = decodeStr(buf, 0, 100, filenameEncoding);
		const mode = decodeOct(buf, 100, 8);
		const uid = decodeOct(buf, 108, 8);
		const gid = decodeOct(buf, 116, 8);
		const size = decodeOct(buf, 124, 12);
		const mtime = decodeOct(buf, 136, 12);
		const type = toType(typeflag);
		const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
		const uname = decodeStr(buf, 265, 32);
		const gname = decodeStr(buf, 297, 32);
		const devmajor = decodeOct(buf, 329, 8);
		const devminor = decodeOct(buf, 337, 8);
		const c = cksum(buf);
		if (c === 256) return null;
		if (c !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
		if (isUSTAR(buf)) {
			if (buf[345]) name$1 = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name$1;
		} else if (isGNU(buf)) {} else if (!allowUnknownFormat) throw new Error("Invalid tar header: unknown format.");
		if (typeflag === 0 && name$1 && name$1[name$1.length - 1] === "/") typeflag = 5;
		return {
			name: name$1,
			mode,
			uid,
			gid,
			size,
			mtime: /* @__PURE__ */ new Date(1e3 * mtime),
			type,
			linkname,
			uname,
			gname,
			devmajor,
			devminor,
			pax: null
		};
	};
	function isUSTAR(buf) {
		return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
	}
	function isGNU(buf) {
		return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
	}
	function clamp(index$1, len, defaultValue) {
		if (typeof index$1 !== "number") return defaultValue;
		index$1 = ~~index$1;
		if (index$1 >= len) return len;
		if (index$1 >= 0) return index$1;
		index$1 += len;
		if (index$1 >= 0) return index$1;
		return 0;
	}
	function toType(flag) {
		switch (flag) {
			case 0: return "file";
			case 1: return "link";
			case 2: return "symlink";
			case 3: return "character-device";
			case 4: return "block-device";
			case 5: return "directory";
			case 6: return "fifo";
			case 7: return "contiguous-file";
			case 72: return "pax-header";
			case 55: return "pax-global-header";
			case 27: return "gnu-long-link-path";
			case 28:
			case 30: return "gnu-long-path";
		}
		return null;
	}
	function toTypeflag(flag) {
		switch (flag) {
			case "file": return 0;
			case "link": return 1;
			case "symlink": return 2;
			case "character-device": return 3;
			case "block-device": return 4;
			case "directory": return 5;
			case "fifo": return 6;
			case "contiguous-file": return 7;
			case "pax-header": return 72;
		}
		return 0;
	}
	function indexOf(block, num, offset, end) {
		for (; offset < end; offset++) if (block[offset] === num) return offset;
		return end;
	}
	function cksum(block) {
		let sum = 256;
		for (let i = 0; i < 148; i++) sum += block[i];
		for (let j = 156; j < 512; j++) sum += block[j];
		return sum;
	}
	function encodeOct(val, n$1) {
		val = val.toString(8);
		if (val.length > n$1) return SEVENS.slice(0, n$1) + " ";
		return ZEROS.slice(0, n$1 - val.length) + val + " ";
	}
	function encodeSizeBin(num, buf, off) {
		buf[off] = 128;
		for (let i = 11; i > 0; i--) {
			buf[off + i] = num & 255;
			num = Math.floor(num / 256);
		}
	}
	function encodeSize(num, buf, off) {
		if (num.toString(8).length > 11) encodeSizeBin(num, buf, off);
		else b4a.write(buf, encodeOct(num, 11), off);
	}
	function parse256(buf) {
		let positive;
		if (buf[0] === 128) positive = true;
		else if (buf[0] === 255) positive = false;
		else return null;
		const tuple = [];
		let i;
		for (i = buf.length - 1; i > 0; i--) {
			const byte = buf[i];
			if (positive) tuple.push(byte);
			else tuple.push(255 - byte);
		}
		let sum = 0;
		const l = tuple.length;
		for (i = 0; i < l; i++) sum += tuple[i] * Math.pow(256, i);
		return positive ? sum : -1 * sum;
	}
	function decodeOct(val, offset, length) {
		val = val.subarray(offset, offset + length);
		offset = 0;
		if (val[offset] & 128) return parse256(val);
		else {
			while (offset < val.length && val[offset] === 32) offset++;
			const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
			while (offset < end && val[offset] === 0) offset++;
			if (end === offset) return 0;
			return parseInt(b4a.toString(val.subarray(offset, end)), 8);
		}
	}
	function decodeStr(val, offset, length, encoding) {
		return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
	}
	function addLength(str) {
		const len = b4a.byteLength(str);
		let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
		if (len + digits >= Math.pow(10, digits)) digits++;
		return len + digits + str;
	}
}));
var require_extract$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Writable, Readable, getStreamError } = require_streamx();
	var FIFO = require_fast_fifo();
	var b4a = require_b4a();
	var headers = require_headers();
	var EMPTY = b4a.alloc(0);
	var BufferList = class {
		constructor() {
			this.buffered = 0;
			this.shifted = 0;
			this.queue = new FIFO();
			this._offset = 0;
		}
		push(buffer$2) {
			this.buffered += buffer$2.byteLength;
			this.queue.push(buffer$2);
		}
		shiftFirst(size) {
			return this._buffered === 0 ? null : this._next(size);
		}
		shift(size) {
			if (size > this.buffered) return null;
			if (size === 0) return EMPTY;
			let chunk = this._next(size);
			if (size === chunk.byteLength) return chunk;
			const chunks = [chunk];
			while ((size -= chunk.byteLength) > 0) {
				chunk = this._next(size);
				chunks.push(chunk);
			}
			return b4a.concat(chunks);
		}
		_next(size) {
			const buf = this.queue.peek();
			const rem = buf.byteLength - this._offset;
			if (size >= rem) {
				const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
				this.queue.shift();
				this._offset = 0;
				this.buffered -= rem;
				this.shifted += rem;
				return sub;
			}
			this.buffered -= size;
			this.shifted += size;
			return buf.subarray(this._offset, this._offset += size);
		}
	};
	var Source = class extends Readable {
		constructor(self$1, header, offset) {
			super();
			this.header = header;
			this.offset = offset;
			this._parent = self$1;
		}
		_read(cb) {
			if (this.header.size === 0) this.push(null);
			if (this._parent._stream === this) this._parent._update();
			cb(null);
		}
		_predestroy() {
			this._parent.destroy(getStreamError(this));
		}
		_detach() {
			if (this._parent._stream === this) {
				this._parent._stream = null;
				this._parent._missing = overflow(this.header.size);
				this._parent._update();
			}
		}
		_destroy(cb) {
			this._detach();
			cb(null);
		}
	};
	var Extract = class extends Writable {
		constructor(opts) {
			super(opts);
			if (!opts) opts = {};
			this._buffer = new BufferList();
			this._offset = 0;
			this._header = null;
			this._stream = null;
			this._missing = 0;
			this._longHeader = false;
			this._callback = noop;
			this._locked = false;
			this._finished = false;
			this._pax = null;
			this._paxGlobal = null;
			this._gnuLongPath = null;
			this._gnuLongLinkPath = null;
			this._filenameEncoding = opts.filenameEncoding || "utf-8";
			this._allowUnknownFormat = !!opts.allowUnknownFormat;
			this._unlockBound = this._unlock.bind(this);
		}
		_unlock(err) {
			this._locked = false;
			if (err) {
				this.destroy(err);
				this._continueWrite(err);
				return;
			}
			this._update();
		}
		_consumeHeader() {
			if (this._locked) return false;
			this._offset = this._buffer.shifted;
			try {
				this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
			} catch (err) {
				this._continueWrite(err);
				return false;
			}
			if (!this._header) return true;
			switch (this._header.type) {
				case "gnu-long-path":
				case "gnu-long-link-path":
				case "pax-global-header":
				case "pax-header":
					this._longHeader = true;
					this._missing = this._header.size;
					return true;
			}
			this._locked = true;
			this._applyLongHeaders();
			if (this._header.size === 0 || this._header.type === "directory") {
				this.emit("entry", this._header, this._createStream(), this._unlockBound);
				return true;
			}
			this._stream = this._createStream();
			this._missing = this._header.size;
			this.emit("entry", this._header, this._stream, this._unlockBound);
			return true;
		}
		_applyLongHeaders() {
			if (this._gnuLongPath) {
				this._header.name = this._gnuLongPath;
				this._gnuLongPath = null;
			}
			if (this._gnuLongLinkPath) {
				this._header.linkname = this._gnuLongLinkPath;
				this._gnuLongLinkPath = null;
			}
			if (this._pax) {
				if (this._pax.path) this._header.name = this._pax.path;
				if (this._pax.linkpath) this._header.linkname = this._pax.linkpath;
				if (this._pax.size) this._header.size = parseInt(this._pax.size, 10);
				this._header.pax = this._pax;
				this._pax = null;
			}
		}
		_decodeLongHeader(buf) {
			switch (this._header.type) {
				case "gnu-long-path":
					this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding);
					break;
				case "gnu-long-link-path":
					this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding);
					break;
				case "pax-global-header":
					this._paxGlobal = headers.decodePax(buf);
					break;
				case "pax-header":
					this._pax = this._paxGlobal === null ? headers.decodePax(buf) : Object.assign({}, this._paxGlobal, headers.decodePax(buf));
					break;
			}
		}
		_consumeLongHeader() {
			this._longHeader = false;
			this._missing = overflow(this._header.size);
			const buf = this._buffer.shift(this._header.size);
			try {
				this._decodeLongHeader(buf);
			} catch (err) {
				this._continueWrite(err);
				return false;
			}
			return true;
		}
		_consumeStream() {
			const buf = this._buffer.shiftFirst(this._missing);
			if (buf === null) return false;
			this._missing -= buf.byteLength;
			const drained = this._stream.push(buf);
			if (this._missing === 0) {
				this._stream.push(null);
				if (drained) this._stream._detach();
				return drained && this._locked === false;
			}
			return drained;
		}
		_createStream() {
			return new Source(this, this._header, this._offset);
		}
		_update() {
			while (this._buffer.buffered > 0 && !this.destroying) {
				if (this._missing > 0) {
					if (this._stream !== null) {
						if (this._consumeStream() === false) return;
						continue;
					}
					if (this._longHeader === true) {
						if (this._missing > this._buffer.buffered) break;
						if (this._consumeLongHeader() === false) return false;
						continue;
					}
					const ignore = this._buffer.shiftFirst(this._missing);
					if (ignore !== null) this._missing -= ignore.byteLength;
					continue;
				}
				if (this._buffer.buffered < 512) break;
				if (this._stream !== null || this._consumeHeader() === false) return;
			}
			this._continueWrite(null);
		}
		_continueWrite(err) {
			const cb = this._callback;
			this._callback = noop;
			cb(err);
		}
		_write(data, cb) {
			this._callback = cb;
			this._buffer.push(data);
			this._update();
		}
		_final(cb) {
			this._finished = this._missing === 0 && this._buffer.buffered === 0;
			cb(this._finished ? null : /* @__PURE__ */ new Error("Unexpected end of data"));
		}
		_predestroy() {
			this._continueWrite(null);
		}
		_destroy(cb) {
			if (this._stream) this._stream.destroy(getStreamError(this));
			cb(null);
		}
		[Symbol.asyncIterator]() {
			let error = null;
			let promiseResolve = null;
			let promiseReject = null;
			let entryStream = null;
			let entryCallback = null;
			const extract = this;
			this.on("entry", onentry);
			this.on("error", (err) => {
				error = err;
			});
			this.on("close", onclose);
			return {
				[Symbol.asyncIterator]() {
					return this;
				},
				next() {
					return new Promise(onnext);
				},
				return() {
					return destroy(null);
				},
				throw(err) {
					return destroy(err);
				}
			};
			function consumeCallback(err) {
				if (!entryCallback) return;
				const cb = entryCallback;
				entryCallback = null;
				cb(err);
			}
			function onnext(resolve$1, reject$3) {
				if (error) return reject$3(error);
				if (entryStream) {
					resolve$1({
						value: entryStream,
						done: false
					});
					entryStream = null;
					return;
				}
				promiseResolve = resolve$1;
				promiseReject = reject$3;
				consumeCallback(null);
				if (extract._finished && promiseResolve) {
					promiseResolve({
						value: void 0,
						done: true
					});
					promiseResolve = promiseReject = null;
				}
			}
			function onentry(header, stream$5, callback) {
				entryCallback = callback;
				stream$5.on("error", noop);
				if (promiseResolve) {
					promiseResolve({
						value: stream$5,
						done: false
					});
					promiseResolve = promiseReject = null;
				} else entryStream = stream$5;
			}
			function onclose() {
				consumeCallback(error);
				if (!promiseResolve) return;
				if (error) promiseReject(error);
				else promiseResolve({
					value: void 0,
					done: true
				});
				promiseResolve = promiseReject = null;
			}
			function destroy(err) {
				extract.destroy(err);
				consumeCallback(err);
				return new Promise((resolve$1, reject$3) => {
					if (extract.destroyed) return resolve$1({
						value: void 0,
						done: true
					});
					extract.once("close", function() {
						if (err) reject$3(err);
						else resolve$1({
							value: void 0,
							done: true
						});
					});
				});
			}
		}
	};
	module.exports = function extract(opts) {
		return new Extract(opts);
	};
	function noop() {}
	function overflow(size) {
		size &= 511;
		return size && 512 - size;
	}
}));
var require_constants = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var constants = {
		S_IFMT: 61440,
		S_IFDIR: 16384,
		S_IFCHR: 8192,
		S_IFBLK: 24576,
		S_IFIFO: 4096,
		S_IFLNK: 40960
	};
	try {
		module.exports = __require("fs").constants || constants;
	} catch {
		module.exports = constants;
	}
}));
var require_pack = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var { Readable, Writable, getStreamError } = require_streamx();
	var b4a = require_b4a();
	var constants = require_constants();
	var headers = require_headers();
	var DMODE = 493;
	var FMODE = 420;
	var END_OF_TAR = b4a.alloc(1024);
	var Sink = class extends Writable {
		constructor(pack, header, callback) {
			super({
				mapWritable,
				eagerOpen: true
			});
			this.written = 0;
			this.header = header;
			this._callback = callback;
			this._linkname = null;
			this._isLinkname = header.type === "symlink" && !header.linkname;
			this._isVoid = header.type !== "file" && header.type !== "contiguous-file";
			this._finished = false;
			this._pack = pack;
			this._openCallback = null;
			if (this._pack._stream === null) this._pack._stream = this;
			else this._pack._pending.push(this);
		}
		_open(cb) {
			this._openCallback = cb;
			if (this._pack._stream === this) this._continueOpen();
		}
		_continuePack(err) {
			if (this._callback === null) return;
			const callback = this._callback;
			this._callback = null;
			callback(err);
		}
		_continueOpen() {
			if (this._pack._stream === null) this._pack._stream = this;
			const cb = this._openCallback;
			this._openCallback = null;
			if (cb === null) return;
			if (this._pack.destroying) return cb(/* @__PURE__ */ new Error("pack stream destroyed"));
			if (this._pack._finalized) return cb(/* @__PURE__ */ new Error("pack stream is already finalized"));
			this._pack._stream = this;
			if (!this._isLinkname) this._pack._encode(this.header);
			if (this._isVoid) {
				this._finish();
				this._continuePack(null);
			}
			cb(null);
		}
		_write(data, cb) {
			if (this._isLinkname) {
				this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data;
				return cb(null);
			}
			if (this._isVoid) {
				if (data.byteLength > 0) return cb(/* @__PURE__ */ new Error("No body allowed for this entry"));
				return cb();
			}
			this.written += data.byteLength;
			if (this._pack.push(data)) return cb();
			this._pack._drain = cb;
		}
		_finish() {
			if (this._finished) return;
			this._finished = true;
			if (this._isLinkname) {
				this.header.linkname = this._linkname ? b4a.toString(this._linkname, "utf-8") : "";
				this._pack._encode(this.header);
			}
			overflow(this._pack, this.header.size);
			this._pack._done(this);
		}
		_final(cb) {
			if (this.written !== this.header.size) return cb(/* @__PURE__ */ new Error("Size mismatch"));
			this._finish();
			cb(null);
		}
		_getError() {
			return getStreamError(this) || /* @__PURE__ */ new Error("tar entry destroyed");
		}
		_predestroy() {
			this._pack.destroy(this._getError());
		}
		_destroy(cb) {
			this._pack._done(this);
			this._continuePack(this._finished ? null : this._getError());
			cb();
		}
	};
	var Pack = class extends Readable {
		constructor(opts) {
			super(opts);
			this._drain = noop;
			this._finalized = false;
			this._finalizing = false;
			this._pending = [];
			this._stream = null;
		}
		entry(header, buffer$2, callback) {
			if (this._finalized || this.destroying) throw new Error("already finalized or destroyed");
			if (typeof buffer$2 === "function") {
				callback = buffer$2;
				buffer$2 = null;
			}
			if (!callback) callback = noop;
			if (!header.size || header.type === "symlink") header.size = 0;
			if (!header.type) header.type = modeToType(header.mode);
			if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
			if (!header.uid) header.uid = 0;
			if (!header.gid) header.gid = 0;
			if (!header.mtime) header.mtime = /* @__PURE__ */ new Date();
			if (typeof buffer$2 === "string") buffer$2 = b4a.from(buffer$2);
			const sink = new Sink(this, header, callback);
			if (b4a.isBuffer(buffer$2)) {
				header.size = buffer$2.byteLength;
				sink.write(buffer$2);
				sink.end();
				return sink;
			}
			if (sink._isVoid) return sink;
			return sink;
		}
		finalize() {
			if (this._stream || this._pending.length > 0) {
				this._finalizing = true;
				return;
			}
			if (this._finalized) return;
			this._finalized = true;
			this.push(END_OF_TAR);
			this.push(null);
		}
		_done(stream$5) {
			if (stream$5 !== this._stream) return;
			this._stream = null;
			if (this._finalizing) this.finalize();
			if (this._pending.length) this._pending.shift()._continueOpen();
		}
		_encode(header) {
			if (!header.pax) {
				const buf = headers.encode(header);
				if (buf) {
					this.push(buf);
					return;
				}
			}
			this._encodePax(header);
		}
		_encodePax(header) {
			const paxHeader = headers.encodePax({
				name: header.name,
				linkname: header.linkname,
				pax: header.pax
			});
			const newHeader = {
				name: "PaxHeader",
				mode: header.mode,
				uid: header.uid,
				gid: header.gid,
				size: paxHeader.byteLength,
				mtime: header.mtime,
				type: "pax-header",
				linkname: header.linkname && "PaxHeader",
				uname: header.uname,
				gname: header.gname,
				devmajor: header.devmajor,
				devminor: header.devminor
			};
			this.push(headers.encode(newHeader));
			this.push(paxHeader);
			overflow(this, paxHeader.byteLength);
			newHeader.size = header.size;
			newHeader.type = header.type;
			this.push(headers.encode(newHeader));
		}
		_doDrain() {
			const drain = this._drain;
			this._drain = noop;
			drain();
		}
		_predestroy() {
			const err = getStreamError(this);
			if (this._stream) this._stream.destroy(err);
			while (this._pending.length) {
				const stream$5 = this._pending.shift();
				stream$5.destroy(err);
				stream$5._continueOpen();
			}
			this._doDrain();
		}
		_read(cb) {
			this._doDrain();
			cb();
		}
	};
	module.exports = function pack(opts) {
		return new Pack(opts);
	};
	function modeToType(mode) {
		switch (mode & constants.S_IFMT) {
			case constants.S_IFBLK: return "block-device";
			case constants.S_IFCHR: return "character-device";
			case constants.S_IFDIR: return "directory";
			case constants.S_IFIFO: return "fifo";
			case constants.S_IFLNK: return "symlink";
		}
		return "file";
	}
	function noop() {}
	function overflow(self$1, size) {
		size &= 511;
		if (size) self$1.push(END_OF_TAR.subarray(0, 512 - size));
	}
	function mapWritable(buf) {
		return b4a.isBuffer(buf) ? buf : b4a.from(buf);
	}
}));
var require_tar_stream = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.extract = require_extract$1();
	exports.pack = require_pack();
}));
var require_tar = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* TAR Format Plugin
	*
	* @module plugins/tar
	* @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
	* @copyright (c) 2012-2014 Chris Talkington, contributors.
	*/
	var zlib$1 = __require("zlib");
	var engine = require_tar_stream();
	var util = require_archiver_utils();
	var Tar = function(options) {
		if (!(this instanceof Tar)) return new Tar(options);
		options = this.options = util.defaults(options, { gzip: false });
		if (typeof options.gzipOptions !== "object") options.gzipOptions = {};
		this.supports = {
			directory: true,
			symlink: true
		};
		this.engine = engine.pack(options);
		this.compressor = false;
		if (options.gzip) {
			this.compressor = zlib$1.createGzip(options.gzipOptions);
			this.compressor.on("error", this._onCompressorError.bind(this));
		}
	};
	Tar.prototype._onCompressorError = function(err) {
		this.engine.emit("error", err);
	};
	Tar.prototype.append = function(source, data, callback) {
		var self$1 = this;
		data.mtime = data.date;
		function append(err, sourceBuffer) {
			if (err) {
				callback(err);
				return;
			}
			self$1.engine.entry(data, sourceBuffer, function(err$1) {
				callback(err$1, data);
			});
		}
		if (data.sourceType === "buffer") append(null, source);
		else if (data.sourceType === "stream" && data.stats) {
			data.size = data.stats.size;
			var entry = self$1.engine.entry(data, function(err) {
				callback(err, data);
			});
			source.pipe(entry);
		} else if (data.sourceType === "stream") util.collectStream(source, append);
	};
	Tar.prototype.finalize = function() {
		this.engine.finalize();
	};
	Tar.prototype.on = function() {
		return this.engine.on.apply(this.engine, arguments);
	};
	Tar.prototype.pipe = function(destination, options) {
		if (this.compressor) return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
		else return this.engine.pipe.apply(this.engine, arguments);
	};
	Tar.prototype.unpipe = function() {
		if (this.compressor) return this.compressor.unpipe.apply(this.compressor, arguments);
		else return this.engine.unpipe.apply(this.engine, arguments);
	};
	module.exports = Tar;
}));
var require_dist$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function getDefaultExportFromCjs(x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
	}
	var CRC_TABLE = new Int32Array([
		0,
		1996959894,
		3993919788,
		2567524794,
		124634137,
		1886057615,
		3915621685,
		2657392035,
		249268274,
		2044508324,
		3772115230,
		2547177864,
		162941995,
		2125561021,
		3887607047,
		2428444049,
		498536548,
		1789927666,
		4089016648,
		2227061214,
		450548861,
		1843258603,
		4107580753,
		2211677639,
		325883990,
		1684777152,
		4251122042,
		2321926636,
		335633487,
		1661365465,
		4195302755,
		2366115317,
		997073096,
		1281953886,
		3579855332,
		2724688242,
		1006888145,
		1258607687,
		3524101629,
		2768942443,
		901097722,
		1119000684,
		3686517206,
		2898065728,
		853044451,
		1172266101,
		3705015759,
		2882616665,
		651767980,
		1373503546,
		3369554304,
		3218104598,
		565507253,
		1454621731,
		3485111705,
		3099436303,
		671266974,
		1594198024,
		3322730930,
		2970347812,
		795835527,
		1483230225,
		3244367275,
		3060149565,
		1994146192,
		31158534,
		2563907772,
		4023717930,
		1907459465,
		112637215,
		2680153253,
		3904427059,
		2013776290,
		251722036,
		2517215374,
		3775830040,
		2137656763,
		141376813,
		2439277719,
		3865271297,
		1802195444,
		476864866,
		2238001368,
		4066508878,
		1812370925,
		453092731,
		2181625025,
		4111451223,
		1706088902,
		314042704,
		2344532202,
		4240017532,
		1658658271,
		366619977,
		2362670323,
		4224994405,
		1303535960,
		984961486,
		2747007092,
		3569037538,
		1256170817,
		1037604311,
		2765210733,
		3554079995,
		1131014506,
		879679996,
		2909243462,
		3663771856,
		1141124467,
		855842277,
		2852801631,
		3708648649,
		1342533948,
		654459306,
		3188396048,
		3373015174,
		1466479909,
		544179635,
		3110523913,
		3462522015,
		1591671054,
		702138776,
		2966460450,
		3352799412,
		1504918807,
		783551873,
		3082640443,
		3233442989,
		3988292384,
		2596254646,
		62317068,
		1957810842,
		3939845945,
		2647816111,
		81470997,
		1943803523,
		3814918930,
		2489596804,
		225274430,
		2053790376,
		3826175755,
		2466906013,
		167816743,
		2097651377,
		4027552580,
		2265490386,
		503444072,
		1762050814,
		4150417245,
		2154129355,
		426522225,
		1852507879,
		4275313526,
		2312317920,
		282753626,
		1742555852,
		4189708143,
		2394877945,
		397917763,
		1622183637,
		3604390888,
		2714866558,
		953729732,
		1340076626,
		3518719985,
		2797360999,
		1068828381,
		1219638859,
		3624741850,
		2936675148,
		906185462,
		1090812512,
		3747672003,
		2825379669,
		829329135,
		1181335161,
		3412177804,
		3160834842,
		628085408,
		1382605366,
		3423369109,
		3138078467,
		570562233,
		1426400815,
		3317316542,
		2998733608,
		733239954,
		1555261956,
		3268935591,
		3050360625,
		752459403,
		1541320221,
		2607071920,
		3965973030,
		1969922972,
		40735498,
		2617837225,
		3943577151,
		1913087877,
		83908371,
		2512341634,
		3803740692,
		2075208622,
		213261112,
		2463272603,
		3855990285,
		2094854071,
		198958881,
		2262029012,
		4057260610,
		1759359992,
		534414190,
		2176718541,
		4139329115,
		1873836001,
		414664567,
		2282248934,
		4279200368,
		1711684554,
		285281116,
		2405801727,
		4167216745,
		1634467795,
		376229701,
		2685067896,
		3608007406,
		1308918612,
		956543938,
		2808555105,
		3495958263,
		1231636301,
		1047427035,
		2932959818,
		3654703836,
		1088359270,
		936918e3,
		2847714899,
		3736837829,
		1202900863,
		817233897,
		3183342108,
		3401237130,
		1404277552,
		615818150,
		3134207493,
		3453421203,
		1423857449,
		601450431,
		3009837614,
		3294710456,
		1567103746,
		711928724,
		3020668471,
		3272380065,
		1510334235,
		755167117
	]);
	function ensureBuffer(input) {
		if (Buffer.isBuffer(input)) return input;
		if (typeof input === "number") return Buffer.alloc(input);
		else if (typeof input === "string") return Buffer.from(input);
		else throw new Error("input must be buffer, number, or string, received " + typeof input);
	}
	function bufferizeInt(num) {
		const tmp = ensureBuffer(4);
		tmp.writeInt32BE(num, 0);
		return tmp;
	}
	function _crc32(buf, previous) {
		buf = ensureBuffer(buf);
		if (Buffer.isBuffer(previous)) previous = previous.readUInt32BE(0);
		let crc = ~~previous ^ -1;
		for (var n$1 = 0; n$1 < buf.length; n$1++) crc = CRC_TABLE[(crc ^ buf[n$1]) & 255] ^ crc >>> 8;
		return crc ^ -1;
	}
	function crc32() {
		return bufferizeInt(_crc32.apply(null, arguments));
	}
	crc32.signed = function() {
		return _crc32.apply(null, arguments);
	};
	crc32.unsigned = function() {
		return _crc32.apply(null, arguments) >>> 0;
	};
	module.exports = /* @__PURE__ */ getDefaultExportFromCjs(crc32);
}));
var require_json = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* JSON Format Plugin
	*
	* @module plugins/json
	* @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
	* @copyright (c) 2012-2014 Chris Talkington, contributors.
	*/
	var inherits$1 = __require("util").inherits;
	var Transform = require_ours().Transform;
	var crc32 = require_dist$1();
	var util = require_archiver_utils();
	var Json = function(options) {
		if (!(this instanceof Json)) return new Json(options);
		options = this.options = util.defaults(options, {});
		Transform.call(this, options);
		this.supports = {
			directory: true,
			symlink: true
		};
		this.files = [];
	};
	inherits$1(Json, Transform);
	Json.prototype._transform = function(chunk, encoding, callback) {
		callback(null, chunk);
	};
	Json.prototype._writeStringified = function() {
		var fileString = JSON.stringify(this.files);
		this.write(fileString);
	};
	Json.prototype.append = function(source, data, callback) {
		var self$1 = this;
		data.crc32 = 0;
		function onend(err, sourceBuffer) {
			if (err) {
				callback(err);
				return;
			}
			data.size = sourceBuffer.length || 0;
			data.crc32 = crc32.unsigned(sourceBuffer);
			self$1.files.push(data);
			callback(null, data);
		}
		if (data.sourceType === "buffer") onend(null, source);
		else if (data.sourceType === "stream") util.collectStream(source, onend);
	};
	Json.prototype.finalize = function() {
		this._writeStringified();
		this.end();
	};
	module.exports = Json;
}));
var require_archiver = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Archiver Vending
	*
	* @ignore
	* @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
	* @copyright (c) 2012-2014 Chris Talkington, contributors.
	*/
	var Archiver = require_core();
	var formats = {};
	var vending = function(format, options) {
		return vending.create(format, options);
	};
	vending.create = function(format, options) {
		if (formats[format]) {
			var instance = new Archiver(format, options);
			instance.setFormat(format);
			instance.setModule(new formats[format](options));
			return instance;
		} else throw new Error("create(" + format + "): format not registered");
	};
	vending.registerFormat = function(format, module$1) {
		if (formats[format]) throw new Error("register(" + format + "): format already registered");
		if (typeof module$1 !== "function") throw new Error("register(" + format + "): format module invalid");
		if (typeof module$1.prototype.append !== "function" || typeof module$1.prototype.finalize !== "function") throw new Error("register(" + format + "): format module missing methods");
		formats[format] = module$1;
	};
	vending.isRegisteredFormat = function(format) {
		if (formats[format]) return true;
		return false;
	};
	vending.registerFormat("zip", require_zip$1());
	vending.registerFormat("tar", require_tar());
	vending.registerFormat("json", require_json());
	module.exports = vending;
}));
var require_zip = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ZipUploadStream = exports.DEFAULT_COMPRESSION_LEVEL = void 0;
	exports.createZipUploadStream = createZipUploadStream;
	var stream$3 = __importStar(__require("stream"));
	var promises_1$1 = __require("fs/promises");
	var archiver = __importStar(require_archiver());
	var core = __importStar(require_core$1());
	var config_1 = require_config();
	exports.DEFAULT_COMPRESSION_LEVEL = 6;
	var ZipUploadStream = class extends stream$3.Transform {
		constructor(bufferSize) {
			super({ highWaterMark: bufferSize });
		}
		_transform(chunk, enc, cb) {
			cb(null, chunk);
		}
	};
	exports.ZipUploadStream = ZipUploadStream;
	function createZipUploadStream(uploadSpecification_1) {
		return __awaiter(this, arguments, void 0, function* (uploadSpecification, compressionLevel = exports.DEFAULT_COMPRESSION_LEVEL) {
			core.debug(`Creating Artifact archive with compressionLevel: ${compressionLevel}`);
			const zip = archiver.create("zip", {
				highWaterMark: (0, config_1.getUploadChunkSize)(),
				zlib: { level: compressionLevel }
			});
			zip.on("error", zipErrorCallback);
			zip.on("warning", zipWarningCallback);
			zip.on("finish", zipFinishCallback);
			zip.on("end", zipEndCallback);
			for (const file of uploadSpecification) if (file.sourcePath !== null) {
				let sourcePath = file.sourcePath;
				if (file.stats.isSymbolicLink()) sourcePath = yield (0, promises_1$1.realpath)(file.sourcePath);
				zip.file(sourcePath, { name: file.destinationPath });
			} else zip.append("", { name: file.destinationPath });
			const zipUploadStream = new ZipUploadStream((0, config_1.getUploadChunkSize)());
			core.debug(`Zip write high watermark value ${zipUploadStream.writableHighWaterMark}`);
			core.debug(`Zip read high watermark value ${zipUploadStream.readableHighWaterMark}`);
			zip.pipe(zipUploadStream);
			zip.finalize();
			return zipUploadStream;
		});
	}
	var zipErrorCallback = (error) => {
		core.error("An error has occurred while creating the zip file for upload");
		core.info(error);
		throw new Error("An error has occurred during zip creation for the artifact");
	};
	var zipWarningCallback = (error) => {
		if (error.code === "ENOENT") {
			core.warning("ENOENT warning during artifact zip creation. No such file or directory");
			core.info(error);
		} else {
			core.warning(`A non-blocking warning has occurred during artifact zip creation: ${error.code}`);
			core.info(error);
		}
	};
	var zipFinishCallback = () => {
		core.debug("Zip stream for upload has finished.");
	};
	var zipEndCallback = () => {
		core.debug("Zip stream for upload has ended.");
	};
}));
var require_upload_artifact = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.uploadArtifact = uploadArtifact;
	var core = __importStar(require_core$1());
	var retention_1 = require_retention();
	var path_and_artifact_name_validation_1 = require_path_and_artifact_name_validation();
	var artifact_twirp_client_1 = require_artifact_twirp_client();
	var upload_zip_specification_1 = require_upload_zip_specification();
	var util_1 = require_util$5();
	var blob_upload_1 = require_blob_upload();
	var zip_1 = require_zip();
	var generated_1 = require_generated();
	var errors_1 = require_errors$2();
	function uploadArtifact(name$1, files$1, rootDirectory, options) {
		return __awaiter(this, void 0, void 0, function* () {
			(0, path_and_artifact_name_validation_1.validateArtifactName)(name$1);
			(0, upload_zip_specification_1.validateRootDirectory)(rootDirectory);
			const zipSpecification = (0, upload_zip_specification_1.getUploadZipSpecification)(files$1, rootDirectory);
			if (zipSpecification.length === 0) throw new errors_1.FilesNotFoundError(zipSpecification.flatMap((s) => s.sourcePath ? [s.sourcePath] : []));
			const backendIds = (0, util_1.getBackendIdsFromToken)();
			const artifactClient$1 = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
			const createArtifactReq = {
				workflowRunBackendId: backendIds.workflowRunBackendId,
				workflowJobRunBackendId: backendIds.workflowJobRunBackendId,
				name: name$1,
				version: 4
			};
			const expiresAt = (0, retention_1.getExpiration)(options === null || options === void 0 ? void 0 : options.retentionDays);
			if (expiresAt) createArtifactReq.expiresAt = expiresAt;
			const createArtifactResp = yield artifactClient$1.CreateArtifact(createArtifactReq);
			if (!createArtifactResp.ok) throw new errors_1.InvalidResponseError("CreateArtifact: response from backend was not ok");
			const zipUploadStream = yield (0, zip_1.createZipUploadStream)(zipSpecification, options === null || options === void 0 ? void 0 : options.compressionLevel);
			const uploadResult = yield (0, blob_upload_1.uploadZipToBlobStorage)(createArtifactResp.signedUploadUrl, zipUploadStream);
			const finalizeArtifactReq = {
				workflowRunBackendId: backendIds.workflowRunBackendId,
				workflowJobRunBackendId: backendIds.workflowJobRunBackendId,
				name: name$1,
				size: uploadResult.uploadSize ? uploadResult.uploadSize.toString() : "0"
			};
			if (uploadResult.sha256Hash) finalizeArtifactReq.hash = generated_1.StringValue.create({ value: `sha256:${uploadResult.sha256Hash}` });
			core.info(`Finalizing artifact upload`);
			const finalizeArtifactResp = yield artifactClient$1.FinalizeArtifact(finalizeArtifactReq);
			if (!finalizeArtifactResp.ok) throw new errors_1.InvalidResponseError("FinalizeArtifact: response from backend was not ok");
			const artifactId = BigInt(finalizeArtifactResp.artifactId);
			core.info(`Artifact ${name$1}.zip successfully finalized. Artifact ID ${artifactId}`);
			return {
				size: uploadResult.uploadSize,
				digest: uploadResult.sha256Hash,
				id: Number(artifactId)
			};
		});
	}
}));
var require_traverse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Traverse;
	function Traverse(obj) {
		if (!(this instanceof Traverse)) return new Traverse(obj);
		this.value = obj;
	}
	Traverse.prototype.get = function(ps) {
		var node = this.value;
		for (var i = 0; i < ps.length; i++) {
			var key = ps[i];
			if (!Object.hasOwnProperty.call(node, key)) {
				node = void 0;
				break;
			}
			node = node[key];
		}
		return node;
	};
	Traverse.prototype.set = function(ps, value$1) {
		var node = this.value;
		for (var i = 0; i < ps.length - 1; i++) {
			var key = ps[i];
			if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
			node = node[key];
		}
		node[ps[i]] = value$1;
		return value$1;
	};
	Traverse.prototype.map = function(cb) {
		return walk(this.value, cb, true);
	};
	Traverse.prototype.forEach = function(cb) {
		this.value = walk(this.value, cb, false);
		return this.value;
	};
	Traverse.prototype.reduce = function(cb, init) {
		var skip = arguments.length === 1;
		var acc = skip ? this.value : init;
		this.forEach(function(x) {
			if (!this.isRoot || !skip) acc = cb.call(this, acc, x);
		});
		return acc;
	};
	Traverse.prototype.deepEqual = function(obj) {
		if (arguments.length !== 1) throw new Error("deepEqual requires exactly one object to compare against");
		var equal = true;
		var node = obj;
		this.forEach(function(y) {
			var notEqual = (function() {
				equal = false;
			}).bind(this);
			if (!this.isRoot) {
				if (typeof node !== "object") return notEqual();
				node = node[this.key];
			}
			var x = node;
			this.post(function() {
				node = x;
			});
			var toS = function(o$1) {
				return Object.prototype.toString.call(o$1);
			};
			if (this.circular) {
				if (Traverse(obj).get(this.circular.path) !== x) notEqual();
			} else if (typeof x !== typeof y) notEqual();
			else if (x === null || y === null || x === void 0 || y === void 0) {
				if (x !== y) notEqual();
			} else if (x.__proto__ !== y.__proto__) notEqual();
			else if (x === y) {} else if (typeof x === "function") {
				if (x instanceof RegExp) {
					if (x.toString() != y.toString()) notEqual();
				} else if (x !== y) notEqual();
			} else if (typeof x === "object") if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
				if (toS(x) !== toS(y)) notEqual();
			} else if (x instanceof Date || y instanceof Date) {
				if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) notEqual();
			} else {
				var kx = Object.keys(x);
				var ky = Object.keys(y);
				if (kx.length !== ky.length) return notEqual();
				for (var i = 0; i < kx.length; i++) {
					var k = kx[i];
					if (!Object.hasOwnProperty.call(y, k)) notEqual();
				}
			}
		});
		return equal;
	};
	Traverse.prototype.paths = function() {
		var acc = [];
		this.forEach(function(x) {
			acc.push(this.path);
		});
		return acc;
	};
	Traverse.prototype.nodes = function() {
		var acc = [];
		this.forEach(function(x) {
			acc.push(this.node);
		});
		return acc;
	};
	Traverse.prototype.clone = function() {
		var parents = [], nodes = [];
		return (function clone(src) {
			for (var i = 0; i < parents.length; i++) if (parents[i] === src) return nodes[i];
			if (typeof src === "object" && src !== null) {
				var dst = copy(src);
				parents.push(src);
				nodes.push(dst);
				Object.keys(src).forEach(function(key) {
					dst[key] = clone(src[key]);
				});
				parents.pop();
				nodes.pop();
				return dst;
			} else return src;
		})(this.value);
	};
	function walk(root, cb, immutable) {
		var path$5 = [];
		var parents = [];
		var alive = true;
		return (function walker(node_) {
			var node = immutable ? copy(node_) : node_;
			var modifiers = {};
			var state = {
				node,
				node_,
				path: [].concat(path$5),
				parent: parents.slice(-1)[0],
				key: path$5.slice(-1)[0],
				isRoot: path$5.length === 0,
				level: path$5.length,
				circular: null,
				update: function(x) {
					if (!state.isRoot) state.parent.node[state.key] = x;
					state.node = x;
				},
				"delete": function() {
					delete state.parent.node[state.key];
				},
				remove: function() {
					if (Array.isArray(state.parent.node)) state.parent.node.splice(state.key, 1);
					else delete state.parent.node[state.key];
				},
				before: function(f) {
					modifiers.before = f;
				},
				after: function(f) {
					modifiers.after = f;
				},
				pre: function(f) {
					modifiers.pre = f;
				},
				post: function(f) {
					modifiers.post = f;
				},
				stop: function() {
					alive = false;
				}
			};
			if (!alive) return state;
			if (typeof node === "object" && node !== null) {
				state.isLeaf = Object.keys(node).length == 0;
				for (var i = 0; i < parents.length; i++) if (parents[i].node_ === node_) {
					state.circular = parents[i];
					break;
				}
			} else state.isLeaf = true;
			state.notLeaf = !state.isLeaf;
			state.notRoot = !state.isRoot;
			var ret = cb.call(state, state.node);
			if (ret !== void 0 && state.update) state.update(ret);
			if (modifiers.before) modifiers.before.call(state, state.node);
			if (typeof state.node == "object" && state.node !== null && !state.circular) {
				parents.push(state);
				var keys = Object.keys(state.node);
				keys.forEach(function(key, i$1) {
					path$5.push(key);
					if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
					var child = walker(state.node[key]);
					if (immutable && Object.hasOwnProperty.call(state.node, key)) state.node[key] = child.node;
					child.isLast = i$1 == keys.length - 1;
					child.isFirst = i$1 == 0;
					if (modifiers.post) modifiers.post.call(state, child);
					path$5.pop();
				});
				parents.pop();
			}
			if (modifiers.after) modifiers.after.call(state, state.node);
			return state;
		})(root).node;
	}
	Object.keys(Traverse.prototype).forEach(function(key) {
		Traverse[key] = function(obj) {
			var args = [].slice.call(arguments, 1);
			var t$1 = Traverse(obj);
			return t$1[key].apply(t$1, args);
		};
	});
	function copy(src) {
		if (typeof src === "object" && src !== null) {
			var dst;
			if (Array.isArray(src)) dst = [];
			else if (src instanceof Date) dst = new Date(src);
			else if (src instanceof Boolean) dst = new Boolean(src);
			else if (src instanceof Number) dst = new Number(src);
			else if (src instanceof String) dst = new String(src);
			else dst = Object.create(Object.getPrototypeOf(src));
			Object.keys(src).forEach(function(key) {
				dst[key] = src[key];
			});
			return dst;
		} else return src;
	}
}));
var require_chainsaw = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Traverse = require_traverse();
	var EventEmitter$1 = __require("events").EventEmitter;
	module.exports = Chainsaw;
	function Chainsaw(builder) {
		var saw = Chainsaw.saw(builder, {});
		var r$1 = builder.call(saw.handlers, saw);
		if (r$1 !== void 0) saw.handlers = r$1;
		saw.record();
		return saw.chain();
	}
	Chainsaw.light = function ChainsawLight(builder) {
		var saw = Chainsaw.saw(builder, {});
		var r$1 = builder.call(saw.handlers, saw);
		if (r$1 !== void 0) saw.handlers = r$1;
		return saw.chain();
	};
	Chainsaw.saw = function(builder, handlers) {
		var saw = new EventEmitter$1();
		saw.handlers = handlers;
		saw.actions = [];
		saw.chain = function() {
			var ch = Traverse(saw.handlers).map(function(node) {
				if (this.isRoot) return node;
				var ps = this.path;
				if (typeof node === "function") this.update(function() {
					saw.actions.push({
						path: ps,
						args: [].slice.call(arguments)
					});
					return ch;
				});
			});
			process.nextTick(function() {
				saw.emit("begin");
				saw.next();
			});
			return ch;
		};
		saw.pop = function() {
			return saw.actions.shift();
		};
		saw.next = function() {
			var action = saw.pop();
			if (!action) saw.emit("end");
			else if (!action.trap) {
				var node = saw.handlers;
				action.path.forEach(function(key) {
					node = node[key];
				});
				node.apply(saw.handlers, action.args);
			}
		};
		saw.nest = function(cb) {
			var args = [].slice.call(arguments, 1);
			var autonext = true;
			if (typeof cb === "boolean") {
				var autonext = cb;
				cb = args.shift();
			}
			var s = Chainsaw.saw(builder, {});
			var r$1 = builder.call(s.handlers, s);
			if (r$1 !== void 0) s.handlers = r$1;
			if ("undefined" !== typeof saw.step) s.record();
			cb.apply(s.chain(), args);
			if (autonext !== false) s.on("end", saw.next);
		};
		saw.record = function() {
			upgradeChainsaw(saw);
		};
		[
			"trap",
			"down",
			"jump"
		].forEach(function(method) {
			saw[method] = function() {
				throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
			};
		});
		return saw;
	};
	function upgradeChainsaw(saw) {
		saw.step = 0;
		saw.pop = function() {
			return saw.actions[saw.step++];
		};
		saw.trap = function(name$1, cb) {
			var ps = Array.isArray(name$1) ? name$1 : [name$1];
			saw.actions.push({
				path: ps,
				step: saw.step,
				cb,
				trap: true
			});
		};
		saw.down = function(name$1) {
			var ps = (Array.isArray(name$1) ? name$1 : [name$1]).join("/");
			var i = saw.actions.slice(saw.step).map(function(x) {
				if (x.trap && x.step <= saw.step) return false;
				return x.path.join("/") == ps;
			}).indexOf(true);
			if (i >= 0) saw.step += i;
			else saw.step = saw.actions.length;
			var act = saw.actions[saw.step - 1];
			if (act && act.trap) {
				saw.step = act.step;
				act.cb();
			} else saw.next();
		};
		saw.jump = function(step) {
			saw.step = step;
			saw.next();
		};
	}
}));
var require_buffers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Buffers;
	function Buffers(bufs) {
		if (!(this instanceof Buffers)) return new Buffers(bufs);
		this.buffers = bufs || [];
		this.length = this.buffers.reduce(function(size, buf) {
			return size + buf.length;
		}, 0);
	}
	Buffers.prototype.push = function() {
		for (var i = 0; i < arguments.length; i++) if (!Buffer.isBuffer(arguments[i])) throw new TypeError("Tried to push a non-buffer");
		for (var i = 0; i < arguments.length; i++) {
			var buf = arguments[i];
			this.buffers.push(buf);
			this.length += buf.length;
		}
		return this.length;
	};
	Buffers.prototype.unshift = function() {
		for (var i = 0; i < arguments.length; i++) if (!Buffer.isBuffer(arguments[i])) throw new TypeError("Tried to unshift a non-buffer");
		for (var i = 0; i < arguments.length; i++) {
			var buf = arguments[i];
			this.buffers.unshift(buf);
			this.length += buf.length;
		}
		return this.length;
	};
	Buffers.prototype.copy = function(dst, dStart, start, end) {
		return this.slice(start, end).copy(dst, dStart, 0, end - start);
	};
	Buffers.prototype.splice = function(i, howMany) {
		var buffers = this.buffers;
		var index$1 = i >= 0 ? i : this.length - i;
		var reps = [].slice.call(arguments, 2);
		if (howMany === void 0) howMany = this.length - index$1;
		else if (howMany > this.length - index$1) howMany = this.length - index$1;
		for (var i = 0; i < reps.length; i++) this.length += reps[i].length;
		var removed = new Buffers();
		var startBytes = 0;
		for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index$1; ii++) startBytes += buffers[ii].length;
		if (index$1 - startBytes > 0) {
			var start = index$1 - startBytes;
			if (start + howMany < buffers[ii].length) {
				removed.push(buffers[ii].slice(start, start + howMany));
				var orig = buffers[ii];
				var buf0 = new Buffer(start);
				for (var i = 0; i < start; i++) buf0[i] = orig[i];
				var buf1 = new Buffer(orig.length - start - howMany);
				for (var i = start + howMany; i < orig.length; i++) buf1[i - howMany - start] = orig[i];
				if (reps.length > 0) {
					var reps_ = reps.slice();
					reps_.unshift(buf0);
					reps_.push(buf1);
					buffers.splice.apply(buffers, [ii, 1].concat(reps_));
					ii += reps_.length;
					reps = [];
				} else {
					buffers.splice(ii, 1, buf0, buf1);
					ii += 2;
				}
			} else {
				removed.push(buffers[ii].slice(start));
				buffers[ii] = buffers[ii].slice(0, start);
				ii++;
			}
		}
		if (reps.length > 0) {
			buffers.splice.apply(buffers, [ii, 0].concat(reps));
			ii += reps.length;
		}
		while (removed.length < howMany) {
			var buf = buffers[ii];
			var len = buf.length;
			var take = Math.min(len, howMany - removed.length);
			if (take === len) {
				removed.push(buf);
				buffers.splice(ii, 1);
			} else {
				removed.push(buf.slice(0, take));
				buffers[ii] = buffers[ii].slice(take);
			}
		}
		this.length -= removed.length;
		return removed;
	};
	Buffers.prototype.slice = function(i, j) {
		var buffers = this.buffers;
		if (j === void 0) j = this.length;
		if (i === void 0) i = 0;
		if (j > this.length) j = this.length;
		var startBytes = 0;
		for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) startBytes += buffers[si].length;
		var target = new Buffer(j - i);
		var ti = 0;
		for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
			var len = buffers[ii].length;
			var start = ti === 0 ? i - startBytes : 0;
			var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
			buffers[ii].copy(target, ti, start, end);
			ti += end - start;
		}
		return target;
	};
	Buffers.prototype.pos = function(i) {
		if (i < 0 || i >= this.length) throw new Error("oob");
		var l = i, bi = 0, bu = null;
		for (;;) {
			bu = this.buffers[bi];
			if (l < bu.length) return {
				buf: bi,
				offset: l
			};
			else l -= bu.length;
			bi++;
		}
	};
	Buffers.prototype.get = function get$1(i) {
		var pos = this.pos(i);
		return this.buffers[pos.buf].get(pos.offset);
	};
	Buffers.prototype.set = function set$1(i, b) {
		var pos = this.pos(i);
		return this.buffers[pos.buf].set(pos.offset, b);
	};
	Buffers.prototype.indexOf = function(needle, offset) {
		if ("string" === typeof needle) needle = new Buffer(needle);
		else if (needle instanceof Buffer) {} else throw new Error("Invalid type for a search string");
		if (!needle.length) return 0;
		if (!this.length) return -1;
		var i = 0, j = 0, match$3 = 0, mstart, pos = 0;
		if (offset) {
			var p = this.pos(offset);
			i = p.buf;
			j = p.offset;
			pos = offset;
		}
		for (;;) {
			while (j >= this.buffers[i].length) {
				j = 0;
				i++;
				if (i >= this.buffers.length) return -1;
			}
			if (this.buffers[i][j] == needle[match$3]) {
				if (match$3 == 0) mstart = {
					i,
					j,
					pos
				};
				match$3++;
				if (match$3 == needle.length) return mstart.pos;
			} else if (match$3 != 0) {
				i = mstart.i;
				j = mstart.j;
				pos = mstart.pos;
				match$3 = 0;
			}
			j++;
			pos++;
		}
	};
	Buffers.prototype.toBuffer = function() {
		return this.slice();
	};
	Buffers.prototype.toString = function(encoding, start, end) {
		return this.slice(start, end).toString(encoding);
	};
}));
var require_vars = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(store) {
		function getset(name$1, value$1) {
			var node = vars.store;
			var keys = name$1.split(".");
			keys.slice(0, -1).forEach(function(k) {
				if (node[k] === void 0) node[k] = {};
				node = node[k];
			});
			var key = keys[keys.length - 1];
			if (arguments.length == 1) return node[key];
			else return node[key] = value$1;
		}
		var vars = {
			get: function(name$1) {
				return getset(name$1);
			},
			set: function(name$1, value$1) {
				return getset(name$1, value$1);
			},
			store: store || {}
		};
		return vars;
	};
}));
var require_binary$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Chainsaw = require_chainsaw();
	var EventEmitter = __require("events").EventEmitter;
	var Buffers = require_buffers();
	var Vars = require_vars();
	var Stream = __require("stream").Stream;
	exports = module.exports = function(bufOrEm, eventName) {
		if (Buffer.isBuffer(bufOrEm)) return exports.parse(bufOrEm);
		var s = exports.stream();
		if (bufOrEm && bufOrEm.pipe) bufOrEm.pipe(s);
		else if (bufOrEm) {
			bufOrEm.on(eventName || "data", function(buf) {
				s.write(buf);
			});
			bufOrEm.on("end", function() {
				s.end();
			});
		}
		return s;
	};
	exports.stream = function(input) {
		if (input) return exports.apply(null, arguments);
		var pending = null;
		function getBytes(bytes, cb, skip) {
			pending = {
				bytes,
				skip,
				cb: function(buf) {
					pending = null;
					cb(buf);
				}
			};
			dispatch();
		}
		var offset = null;
		function dispatch() {
			if (!pending) {
				if (caughtEnd) done = true;
				return;
			}
			if (typeof pending === "function") pending();
			else {
				var bytes = offset + pending.bytes;
				if (buffers.length >= bytes) {
					var buf;
					if (offset == null) {
						buf = buffers.splice(0, bytes);
						if (!pending.skip) buf = buf.slice();
					} else {
						if (!pending.skip) buf = buffers.slice(offset, bytes);
						offset = bytes;
					}
					if (pending.skip) pending.cb();
					else pending.cb(buf);
				}
			}
		}
		function builder(saw) {
			function next() {
				if (!done) saw.next();
			}
			var self$1 = words(function(bytes, cb) {
				return function(name$1) {
					getBytes(bytes, function(buf) {
						vars.set(name$1, cb(buf));
						next();
					});
				};
			});
			self$1.tap = function(cb) {
				saw.nest(cb, vars.store);
			};
			self$1.into = function(key, cb) {
				if (!vars.get(key)) vars.set(key, {});
				var parent$1 = vars;
				vars = Vars(parent$1.get(key));
				saw.nest(function() {
					cb.apply(this, arguments);
					this.tap(function() {
						vars = parent$1;
					});
				}, vars.store);
			};
			self$1.flush = function() {
				vars.store = {};
				next();
			};
			self$1.loop = function(cb) {
				var end = false;
				saw.nest(false, function loop() {
					this.vars = vars.store;
					cb.call(this, function() {
						end = true;
						next();
					}, vars.store);
					this.tap(function() {
						if (end) saw.next();
						else loop.call(this);
					}.bind(this));
				}, vars.store);
			};
			self$1.buffer = function(name$1, bytes) {
				if (typeof bytes === "string") bytes = vars.get(bytes);
				getBytes(bytes, function(buf) {
					vars.set(name$1, buf);
					next();
				});
			};
			self$1.skip = function(bytes) {
				if (typeof bytes === "string") bytes = vars.get(bytes);
				getBytes(bytes, function() {
					next();
				});
			};
			self$1.scan = function find(name$1, search) {
				if (typeof search === "string") search = new Buffer(search);
				else if (!Buffer.isBuffer(search)) throw new Error("search must be a Buffer or a string");
				var taken = 0;
				pending = function() {
					var pos = buffers.indexOf(search, offset + taken);
					var i = pos - offset - taken;
					if (pos !== -1) {
						pending = null;
						if (offset != null) {
							vars.set(name$1, buffers.slice(offset, offset + taken + i));
							offset += taken + i + search.length;
						} else {
							vars.set(name$1, buffers.slice(0, taken + i));
							buffers.splice(0, taken + i + search.length);
						}
						next();
						dispatch();
					} else i = Math.max(buffers.length - search.length - offset - taken, 0);
					taken += i;
				};
				dispatch();
			};
			self$1.peek = function(cb) {
				offset = 0;
				saw.nest(function() {
					cb.call(this, vars.store);
					this.tap(function() {
						offset = null;
					});
				});
			};
			return self$1;
		}
		var stream$5 = Chainsaw.light(builder);
		stream$5.writable = true;
		var buffers = Buffers();
		stream$5.write = function(buf) {
			buffers.push(buf);
			dispatch();
		};
		var vars = Vars();
		var done = false, caughtEnd = false;
		stream$5.end = function() {
			caughtEnd = true;
		};
		stream$5.pipe = Stream.prototype.pipe;
		Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function(name$1) {
			stream$5[name$1] = EventEmitter.prototype[name$1];
		});
		return stream$5;
	};
	exports.parse = function parse$1(buffer$2) {
		var self$1 = words(function(bytes, cb) {
			return function(name$1) {
				if (offset + bytes <= buffer$2.length) {
					var buf = buffer$2.slice(offset, offset + bytes);
					offset += bytes;
					vars.set(name$1, cb(buf));
				} else vars.set(name$1, null);
				return self$1;
			};
		});
		var offset = 0;
		var vars = Vars();
		self$1.vars = vars.store;
		self$1.tap = function(cb) {
			cb.call(self$1, vars.store);
			return self$1;
		};
		self$1.into = function(key, cb) {
			if (!vars.get(key)) vars.set(key, {});
			var parent$1 = vars;
			vars = Vars(parent$1.get(key));
			cb.call(self$1, vars.store);
			vars = parent$1;
			return self$1;
		};
		self$1.loop = function(cb) {
			var end = false;
			var ender = function() {
				end = true;
			};
			while (end === false) cb.call(self$1, ender, vars.store);
			return self$1;
		};
		self$1.buffer = function(name$1, size) {
			if (typeof size === "string") size = vars.get(size);
			var buf = buffer$2.slice(offset, Math.min(buffer$2.length, offset + size));
			offset += size;
			vars.set(name$1, buf);
			return self$1;
		};
		self$1.skip = function(bytes) {
			if (typeof bytes === "string") bytes = vars.get(bytes);
			offset += bytes;
			return self$1;
		};
		self$1.scan = function(name$1, search) {
			if (typeof search === "string") search = new Buffer(search);
			else if (!Buffer.isBuffer(search)) throw new Error("search must be a Buffer or a string");
			vars.set(name$1, null);
			for (var i = 0; i + offset <= buffer$2.length - search.length + 1; i++) {
				for (var j = 0; j < search.length && buffer$2[offset + i + j] === search[j]; j++);
				if (j === search.length) break;
			}
			vars.set(name$1, buffer$2.slice(offset, offset + i));
			offset += i + search.length;
			return self$1;
		};
		self$1.peek = function(cb) {
			var was = offset;
			cb.call(self$1, vars.store);
			offset = was;
			return self$1;
		};
		self$1.flush = function() {
			vars.store = {};
			return self$1;
		};
		self$1.eof = function() {
			return offset >= buffer$2.length;
		};
		return self$1;
	};
	function decodeLEu(bytes) {
		var acc = 0;
		for (var i = 0; i < bytes.length; i++) acc += Math.pow(256, i) * bytes[i];
		return acc;
	}
	function decodeBEu(bytes) {
		var acc = 0;
		for (var i = 0; i < bytes.length; i++) acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
		return acc;
	}
	function decodeBEs(bytes) {
		var val = decodeBEu(bytes);
		if ((bytes[0] & 128) == 128) val -= Math.pow(256, bytes.length);
		return val;
	}
	function decodeLEs(bytes) {
		var val = decodeLEu(bytes);
		if ((bytes[bytes.length - 1] & 128) == 128) val -= Math.pow(256, bytes.length);
		return val;
	}
	function words(decode) {
		var self$1 = {};
		[
			1,
			2,
			4,
			8
		].forEach(function(bytes) {
			var bits = bytes * 8;
			self$1["word" + bits + "le"] = self$1["word" + bits + "lu"] = decode(bytes, decodeLEu);
			self$1["word" + bits + "ls"] = decode(bytes, decodeLEs);
			self$1["word" + bits + "be"] = self$1["word" + bits + "bu"] = decode(bytes, decodeBEu);
			self$1["word" + bits + "bs"] = decode(bytes, decodeBEs);
		});
		self$1.word8 = self$1.word8u = self$1.word8be;
		self$1.word8s = self$1.word8bs;
		return self$1;
	}
}));
var require_matcher_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Transform$2 = __require("stream").Transform;
	var util$3 = __require("util");
	function MatcherStream(patternDesc, matchFn) {
		if (!(this instanceof MatcherStream)) return new MatcherStream();
		Transform$2.call(this);
		var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
		this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
		this.requiredLength = this.pattern.length;
		if (patternDesc.requiredExtraSize) this.requiredLength += patternDesc.requiredExtraSize;
		this.data = new Buffer("");
		this.bytesSoFar = 0;
		this.matchFn = matchFn;
	}
	util$3.inherits(MatcherStream, Transform$2);
	MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
		if (!(this.data.length >= this.requiredLength)) return;
		var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
		if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
			if (matchIndex > 0) {
				var packet = this.data.slice(0, matchIndex);
				this.push(packet);
				this.bytesSoFar += matchIndex;
				this.data = this.data.slice(matchIndex);
			}
			return;
		}
		if (matchIndex === -1) {
			var packetLen = this.data.length - this.requiredLength + 1;
			var packet = this.data.slice(0, packetLen);
			this.push(packet);
			this.bytesSoFar += packetLen;
			this.data = this.data.slice(packetLen);
			return;
		}
		if (matchIndex > 0) {
			var packet = this.data.slice(0, matchIndex);
			this.data = this.data.slice(matchIndex);
			this.push(packet);
			this.bytesSoFar += matchIndex;
		}
		if (this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true) {
			this.data = new Buffer("");
			return;
		}
		return true;
	};
	MatcherStream.prototype._transform = function(chunk, encoding, cb) {
		this.data = Buffer.concat([this.data, chunk]);
		var firstIteration = true;
		while (this.checkDataChunk(!firstIteration)) firstIteration = false;
		cb();
	};
	MatcherStream.prototype._flush = function(cb) {
		if (this.data.length > 0) {
			var firstIteration = true;
			while (this.checkDataChunk(!firstIteration)) firstIteration = false;
		}
		if (this.data.length > 0) {
			this.push(this.data);
			this.data = null;
		}
		cb();
	};
	module.exports = MatcherStream;
}));
var require_entry = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var stream$2 = __require("stream");
	var inherits = __require("util").inherits;
	function Entry() {
		if (!(this instanceof Entry)) return new Entry();
		stream$2.PassThrough.call(this);
		this.path = null;
		this.type = null;
		this.isDirectory = false;
	}
	inherits(Entry, stream$2.PassThrough);
	Entry.prototype.autodrain = function() {
		return this.pipe(new stream$2.Transform({ transform: function(d, e$1, cb) {
			cb();
		} }));
	};
	module.exports = Entry;
}));
var require_unzip_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var binary = require_binary$1();
	var stream$1 = __require("stream");
	var util$2 = __require("util");
	var zlib = __require("zlib");
	var MatcherStream = require_matcher_stream();
	var Entry = require_entry();
	var states = {
		STREAM_START: 0,
		START: 1,
		LOCAL_FILE_HEADER: 2,
		LOCAL_FILE_HEADER_SUFFIX: 3,
		FILE_DATA: 4,
		FILE_DATA_END: 5,
		DATA_DESCRIPTOR: 6,
		CENTRAL_DIRECTORY_FILE_HEADER: 7,
		CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
		CDIR64_END: 9,
		CDIR64_END_DATA_SECTOR: 10,
		CDIR64_LOCATOR: 11,
		CENTRAL_DIRECTORY_END: 12,
		CENTRAL_DIRECTORY_END_COMMENT: 13,
		TRAILING_JUNK: 14,
		ERROR: 99
	};
	var FOUR_GIGS = 4294967296;
	var SIG_LOCAL_FILE_HEADER = 67324752;
	var SIG_DATA_DESCRIPTOR = 134695760;
	var SIG_CDIR_RECORD = 33639248;
	var SIG_CDIR64_RECORD_END = 101075792;
	var SIG_CDIR64_LOCATOR_END = 117853008;
	var SIG_CDIR_RECORD_END = 101010256;
	function UnzipStream(options) {
		if (!(this instanceof UnzipStream)) return new UnzipStream(options);
		stream$1.Transform.call(this);
		this.options = options || {};
		this.data = new Buffer("");
		this.state = states.STREAM_START;
		this.skippedBytes = 0;
		this.parsedEntity = null;
		this.outStreamInfo = {};
	}
	util$2.inherits(UnzipStream, stream$1.Transform);
	UnzipStream.prototype.processDataChunk = function(chunk) {
		var requiredLength;
		switch (this.state) {
			case states.STREAM_START:
			case states.START:
				requiredLength = 4;
				break;
			case states.LOCAL_FILE_HEADER:
				requiredLength = 26;
				break;
			case states.LOCAL_FILE_HEADER_SUFFIX:
				requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
				break;
			case states.DATA_DESCRIPTOR:
				requiredLength = 12;
				break;
			case states.CENTRAL_DIRECTORY_FILE_HEADER:
				requiredLength = 42;
				break;
			case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
				requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
				break;
			case states.CDIR64_END:
				requiredLength = 52;
				break;
			case states.CDIR64_END_DATA_SECTOR:
				requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
				break;
			case states.CDIR64_LOCATOR:
				requiredLength = 16;
				break;
			case states.CENTRAL_DIRECTORY_END:
				requiredLength = 18;
				break;
			case states.CENTRAL_DIRECTORY_END_COMMENT:
				requiredLength = this.parsedEntity.commentLength;
				break;
			case states.FILE_DATA: return 0;
			case states.FILE_DATA_END: return 0;
			case states.TRAILING_JUNK:
				if (this.options.debug) console.log("found", chunk.length, "bytes of TRAILING_JUNK");
				return chunk.length;
			default: return chunk.length;
		}
		if (chunk.length < requiredLength) return 0;
		switch (this.state) {
			case states.STREAM_START:
			case states.START:
				var signature = chunk.readUInt32LE(0);
				switch (signature) {
					case SIG_LOCAL_FILE_HEADER:
						this.state = states.LOCAL_FILE_HEADER;
						break;
					case SIG_CDIR_RECORD:
						this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
						break;
					case SIG_CDIR64_RECORD_END:
						this.state = states.CDIR64_END;
						break;
					case SIG_CDIR64_LOCATOR_END:
						this.state = states.CDIR64_LOCATOR;
						break;
					case SIG_CDIR_RECORD_END:
						this.state = states.CENTRAL_DIRECTORY_END;
						break;
					default:
						var isStreamStart = this.state === states.STREAM_START;
						if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
							var remaining = signature;
							var toSkip = 4;
							for (var i = 1; i < 4 && remaining !== 0; i++) {
								remaining = remaining >>> 8;
								if ((remaining & 255) === 80) {
									toSkip = i;
									break;
								}
							}
							this.skippedBytes += toSkip;
							if (this.options.debug) console.log("Skipped", this.skippedBytes, "bytes");
							return toSkip;
						}
						this.state = states.ERROR;
						var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
						if (this.options.debug) {
							var sig = chunk.readUInt32LE(0);
							var asString;
							try {
								asString = chunk.slice(0, 4).toString();
							} catch (e$1) {}
							console.log("Unexpected signature in zip file: 0x" + sig.toString(16), "\"" + asString + "\", skipped", this.skippedBytes, "bytes");
						}
						this.emit("error", new Error(errMsg));
						return chunk.length;
				}
				this.skippedBytes = 0;
				return requiredLength;
			case states.LOCAL_FILE_HEADER:
				this.parsedEntity = this._readFile(chunk);
				this.state = states.LOCAL_FILE_HEADER_SUFFIX;
				return requiredLength;
			case states.LOCAL_FILE_HEADER_SUFFIX:
				var entry = new Entry();
				var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
				entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
				var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
				var extra = this._readExtraFields(extraDataBuffer);
				if (extra && extra.parsed) {
					if (extra.parsed.path && !isUtf8) entry.path = extra.parsed.path;
					if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1) this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
					if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1) this.parsedEntity.compressedSize = extra.parsed.compressedSize;
				}
				this.parsedEntity.extra = extra.parsed || {};
				if (this.options.debug) {
					const debugObj = Object.assign({}, this.parsedEntity, {
						path: entry.path,
						flags: "0x" + this.parsedEntity.flags.toString(16),
						extraFields: extra && extra.debug
					});
					console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
				}
				this._prepareOutStream(this.parsedEntity, entry);
				this.emit("entry", entry);
				this.state = states.FILE_DATA;
				return requiredLength;
			case states.CENTRAL_DIRECTORY_FILE_HEADER:
				this.parsedEntity = this._readCentralDirectoryEntry(chunk);
				this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;
				return requiredLength;
			case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
				var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
				var path$5 = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
				var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
				var extra = this._readExtraFields(extraDataBuffer);
				if (extra && extra.parsed && extra.parsed.path && !isUtf8) path$5 = extra.parsed.path;
				this.parsedEntity.extra = extra.parsed;
				var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3;
				var unixAttrs, isSymlink;
				if (isUnix) {
					unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
					isSymlink = (unixAttrs >>> 12 & 10) === 10;
				}
				if (this.options.debug) {
					const debugObj = Object.assign({}, this.parsedEntity, {
						path: path$5,
						flags: "0x" + this.parsedEntity.flags.toString(16),
						unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
						isSymlink,
						extraFields: extra.debug
					});
					console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
				}
				this.state = states.START;
				return requiredLength;
			case states.CDIR64_END:
				this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
				if (this.options.debug) console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
				this.state = states.CDIR64_END_DATA_SECTOR;
				return requiredLength;
			case states.CDIR64_END_DATA_SECTOR:
				this.state = states.START;
				return requiredLength;
			case states.CDIR64_LOCATOR:
				this.state = states.START;
				return requiredLength;
			case states.CENTRAL_DIRECTORY_END:
				this.parsedEntity = this._readEndOfCentralDirectory(chunk);
				if (this.options.debug) console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
				this.state = states.CENTRAL_DIRECTORY_END_COMMENT;
				return requiredLength;
			case states.CENTRAL_DIRECTORY_END_COMMENT:
				if (this.options.debug) console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
				this.state = states.TRAILING_JUNK;
				return requiredLength;
			case states.ERROR: return chunk.length;
			default:
				console.log("didn't handle state #", this.state, "discarding");
				return chunk.length;
		}
	};
	UnzipStream.prototype._prepareOutStream = function(vars, entry) {
		var self$1 = this;
		var isDirectory = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
		entry.path = entry.path.replace(/(?<=^|[/\\]+)[.][.]+(?=[/\\]+|$)/g, ".");
		entry.type = isDirectory ? "Directory" : "File";
		entry.isDirectory = isDirectory;
		var fileSizeKnown = !(vars.flags & 8);
		if (fileSizeKnown) entry.size = vars.uncompressedSize;
		var isVersionSupported = vars.versionsNeededToExtract <= 45;
		this.outStreamInfo = {
			stream: null,
			limit: fileSizeKnown ? vars.compressedSize : -1,
			written: 0
		};
		if (!fileSizeKnown) {
			var pattern$1 = new Buffer(4);
			pattern$1.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
			var zip64Mode = vars.extra.zip64Mode;
			var matcherStream = new MatcherStream({
				pattern: pattern$1,
				requiredExtraSize: zip64Mode ? 20 : 12
			}, function(matchedChunk, sizeSoFar) {
				var vars$1 = self$1._readDataDescriptor(matchedChunk, zip64Mode);
				var compressedSizeMatches = vars$1.compressedSize === sizeSoFar;
				if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
					var overflown = sizeSoFar - FOUR_GIGS;
					while (overflown >= 0) {
						compressedSizeMatches = vars$1.compressedSize === overflown;
						if (compressedSizeMatches) break;
						overflown -= FOUR_GIGS;
					}
				}
				if (!compressedSizeMatches) return;
				self$1.state = states.FILE_DATA_END;
				var sliceOffset = zip64Mode ? 24 : 16;
				if (self$1.data.length > 0) self$1.data = Buffer.concat([matchedChunk.slice(sliceOffset), self$1.data]);
				else self$1.data = matchedChunk.slice(sliceOffset);
				return true;
			});
			this.outStreamInfo.stream = matcherStream;
		} else this.outStreamInfo.stream = new stream$1.PassThrough();
		var isEncrypted = vars.flags & 1 || vars.flags & 64;
		if (isEncrypted || !isVersionSupported) {
			var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
			entry.skip = true;
			setImmediate(() => {
				self$1.emit("error", new Error(message));
			});
			this.outStreamInfo.stream.pipe(new Entry().autodrain());
			return;
		}
		if (vars.compressionMethod > 0) {
			var inflater = zlib.createInflateRaw();
			inflater.on("error", function(err) {
				self$1.state = states.ERROR;
				self$1.emit("error", err);
			});
			this.outStreamInfo.stream.pipe(inflater).pipe(entry);
		} else this.outStreamInfo.stream.pipe(entry);
		if (this._drainAllEntries) entry.autodrain();
	};
	UnzipStream.prototype._readFile = function(data) {
		return binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
	};
	UnzipStream.prototype._readExtraFields = function(data) {
		var extra = {};
		var result = { parsed: extra };
		if (this.options.debug) result.debug = [];
		var index$1 = 0;
		while (index$1 < data.length) {
			var vars = binary.parse(data).skip(index$1).word16lu("extraId").word16lu("extraSize").vars;
			index$1 += 4;
			var fieldType = void 0;
			switch (vars.extraId) {
				case 1:
					fieldType = "Zip64 extended information extra field";
					var z64vars = binary.parse(data.slice(index$1, index$1 + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
					if (z64vars.uncompressedSize !== null) extra.uncompressedSize = z64vars.uncompressedSize;
					if (z64vars.compressedSize !== null) extra.compressedSize = z64vars.compressedSize;
					extra.zip64Mode = true;
					break;
				case 10:
					fieldType = "NTFS extra field";
					break;
				case 21589:
					fieldType = "extended timestamp";
					var timestampFields = data.readUInt8(index$1);
					var offset = 1;
					if (vars.extraSize >= offset + 4 && timestampFields & 1) {
						extra.mtime = /* @__PURE__ */ new Date(data.readUInt32LE(index$1 + offset) * 1e3);
						offset += 4;
					}
					if (vars.extraSize >= offset + 4 && timestampFields & 2) {
						extra.atime = /* @__PURE__ */ new Date(data.readUInt32LE(index$1 + offset) * 1e3);
						offset += 4;
					}
					if (vars.extraSize >= offset + 4 && timestampFields & 4) extra.ctime = /* @__PURE__ */ new Date(data.readUInt32LE(index$1 + offset) * 1e3);
					break;
				case 28789:
					fieldType = "Info-ZIP Unicode Path Extra Field";
					if (data.readUInt8(index$1) === 1) {
						var offset = 1;
						data.readUInt32LE(index$1 + offset);
						offset += 4;
						extra.path = data.slice(index$1 + offset).toString();
					}
					break;
				case 13:
				case 22613:
					fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
					var offset = 0;
					if (vars.extraSize >= 8) {
						var atime = /* @__PURE__ */ new Date(data.readUInt32LE(index$1 + offset) * 1e3);
						offset += 4;
						var mtime = /* @__PURE__ */ new Date(data.readUInt32LE(index$1 + offset) * 1e3);
						offset += 4;
						extra.atime = atime;
						extra.mtime = mtime;
						if (vars.extraSize >= 12) {
							var uid = data.readUInt16LE(index$1 + offset);
							offset += 2;
							var gid = data.readUInt16LE(index$1 + offset);
							offset += 2;
							extra.uid = uid;
							extra.gid = gid;
						}
					}
					break;
				case 30805:
					fieldType = "Info-ZIP UNIX (type 2)";
					var offset = 0;
					if (vars.extraSize >= 4) {
						var uid = data.readUInt16LE(index$1 + offset);
						offset += 2;
						var gid = data.readUInt16LE(index$1 + offset);
						offset += 2;
						extra.uid = uid;
						extra.gid = gid;
					}
					break;
				case 30837:
					fieldType = "Info-ZIP New Unix";
					var offset = 0;
					var extraVer = data.readUInt8(index$1);
					offset += 1;
					if (extraVer === 1) {
						var uidSize = data.readUInt8(index$1 + offset);
						offset += 1;
						if (uidSize <= 6) extra.uid = data.readUIntLE(index$1 + offset, uidSize);
						offset += uidSize;
						var gidSize = data.readUInt8(index$1 + offset);
						offset += 1;
						if (gidSize <= 6) extra.gid = data.readUIntLE(index$1 + offset, gidSize);
					}
					break;
				case 30062:
					fieldType = "ASi Unix";
					var offset = 0;
					if (vars.extraSize >= 14) {
						data.readUInt32LE(index$1 + offset);
						offset += 4;
						var mode = data.readUInt16LE(index$1 + offset);
						offset += 2;
						data.readUInt32LE(index$1 + offset);
						offset += 4;
						var uid = data.readUInt16LE(index$1 + offset);
						offset += 2;
						var gid = data.readUInt16LE(index$1 + offset);
						offset += 2;
						extra.mode = mode;
						extra.uid = uid;
						extra.gid = gid;
						if (vars.extraSize > 14) {
							var start = index$1 + offset;
							var end = index$1 + vars.extraSize - 14;
							extra.symlink = this._decodeString(data.slice(start, end));
						}
					}
					break;
			}
			if (this.options.debug) result.debug.push({
				extraId: "0x" + vars.extraId.toString(16),
				description: fieldType,
				data: data.slice(index$1, index$1 + vars.extraSize).inspect()
			});
			index$1 += vars.extraSize;
		}
		return result;
	};
	UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
		if (zip64Mode) {
			var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
			return vars;
		}
		var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
		return vars;
	};
	UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
		return binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
	};
	UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
		return binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
	};
	UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
		return binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
	};
	var cp437 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ";
	UnzipStream.prototype._decodeString = function(buffer$2, isUtf8) {
		if (isUtf8) return buffer$2.toString("utf8");
		if (this.options.decodeString) return this.options.decodeString(buffer$2);
		let result = "";
		for (var i = 0; i < buffer$2.length; i++) result += cp437[buffer$2[i]];
		return result;
	};
	UnzipStream.prototype._parseOrOutput = function(encoding, cb) {
		var consume;
		while ((consume = this.processDataChunk(this.data)) > 0) {
			this.data = this.data.slice(consume);
			if (this.data.length === 0) break;
		}
		if (this.state === states.FILE_DATA) {
			if (this.outStreamInfo.limit >= 0) {
				var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
				var packet;
				if (remaining < this.data.length) {
					packet = this.data.slice(0, remaining);
					this.data = this.data.slice(remaining);
				} else {
					packet = this.data;
					this.data = new Buffer("");
				}
				this.outStreamInfo.written += packet.length;
				if (this.outStreamInfo.limit === this.outStreamInfo.written) {
					this.state = states.START;
					this.outStreamInfo.stream.end(packet, encoding, cb);
				} else this.outStreamInfo.stream.write(packet, encoding, cb);
			} else {
				var packet = this.data;
				this.data = new Buffer("");
				this.outStreamInfo.written += packet.length;
				var outputStream = this.outStreamInfo.stream;
				outputStream.write(packet, encoding, () => {
					if (this.state === states.FILE_DATA_END) {
						this.state = states.START;
						return outputStream.end(cb);
					}
					cb();
				});
			}
			return;
		}
		cb();
	};
	UnzipStream.prototype.drainAll = function() {
		this._drainAllEntries = true;
	};
	UnzipStream.prototype._transform = function(chunk, encoding, cb) {
		var self$1 = this;
		if (self$1.data.length > 0) self$1.data = Buffer.concat([self$1.data, chunk]);
		else self$1.data = chunk;
		var startDataLength = self$1.data.length;
		var done = function() {
			if (self$1.data.length > 0 && self$1.data.length < startDataLength) {
				startDataLength = self$1.data.length;
				self$1._parseOrOutput(encoding, done);
				return;
			}
			cb();
		};
		self$1._parseOrOutput(encoding, done);
	};
	UnzipStream.prototype._flush = function(cb) {
		var self$1 = this;
		if (self$1.data.length > 0) {
			self$1._parseOrOutput("buffer", function() {
				if (self$1.data.length > 0) return setImmediate(function() {
					self$1._flush(cb);
				});
				cb();
			});
			return;
		}
		if (self$1.state === states.FILE_DATA) return cb(/* @__PURE__ */ new Error("Stream finished in an invalid state, uncompression failed"));
		setImmediate(cb);
	};
	module.exports = UnzipStream;
}));
var require_parser_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Transform$1 = __require("stream").Transform;
	var util$1 = __require("util");
	var UnzipStream = require_unzip_stream();
	function ParserStream(opts) {
		if (!(this instanceof ParserStream)) return new ParserStream(opts);
		Transform$1.call(this, { readableObjectMode: true });
		this.opts = opts || {};
		this.unzipStream = new UnzipStream(this.opts);
		var self$1 = this;
		this.unzipStream.on("entry", function(entry) {
			self$1.push(entry);
		});
		this.unzipStream.on("error", function(error) {
			self$1.emit("error", error);
		});
	}
	util$1.inherits(ParserStream, Transform$1);
	ParserStream.prototype._transform = function(chunk, encoding, cb) {
		this.unzipStream.write(chunk, encoding, cb);
	};
	ParserStream.prototype._flush = function(cb) {
		var self$1 = this;
		this.unzipStream.end(function() {
			process.nextTick(function() {
				self$1.emit("close");
			});
			cb();
		});
	};
	ParserStream.prototype.on = function(eventName, fn) {
		if (eventName === "entry") return Transform$1.prototype.on.call(this, "data", fn);
		return Transform$1.prototype.on.call(this, eventName, fn);
	};
	ParserStream.prototype.drainAll = function() {
		this.unzipStream.drainAll();
		return this.pipe(new Transform$1({
			objectMode: true,
			transform: function(d, e$1, cb) {
				cb();
			}
		}));
	};
	module.exports = ParserStream;
}));
var require_mkdirp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var path$1 = __require("path");
	var fs$2 = __require("fs");
	var _0777 = parseInt("0777", 8);
	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
	function mkdirP(p, opts, f, made) {
		if (typeof opts === "function") {
			f = opts;
			opts = {};
		} else if (!opts || typeof opts !== "object") opts = { mode: opts };
		var mode = opts.mode;
		var xfs = opts.fs || fs$2;
		if (mode === void 0) mode = _0777;
		if (!made) made = null;
		var cb = f || function() {};
		p = path$1.resolve(p);
		xfs.mkdir(p, mode, function(er) {
			if (!er) {
				made = made || p;
				return cb(null, made);
			}
			switch (er.code) {
				case "ENOENT":
					/* istanbul ignore if */
					if (path$1.dirname(p) === p) return cb(er);
					mkdirP(path$1.dirname(p), opts, function(er$1, made$1) {
						/* istanbul ignore if */
						if (er$1) cb(er$1, made$1);
						else mkdirP(p, opts, cb, made$1);
					});
					break;
				default:
					xfs.stat(p, function(er2, stat) {
						if (er2 || !stat.isDirectory()) cb(er, made);
						else cb(null, made);
					});
					break;
			}
		});
	}
	mkdirP.sync = function sync$3(p, opts, made) {
		if (!opts || typeof opts !== "object") opts = { mode: opts };
		var mode = opts.mode;
		var xfs = opts.fs || fs$2;
		if (mode === void 0) mode = _0777;
		if (!made) made = null;
		p = path$1.resolve(p);
		try {
			xfs.mkdirSync(p, mode);
			made = made || p;
		} catch (err0) {
			switch (err0.code) {
				case "ENOENT":
					made = sync$3(path$1.dirname(p), opts, made);
					sync$3(p, opts, made);
					break;
				default:
					var stat;
					try {
						stat = xfs.statSync(p);
					} catch (err1) 					/* istanbul ignore next */ {
						throw err0;
					}
					/* istanbul ignore if */
					if (!stat.isDirectory()) throw err0;
					break;
			}
		}
		return made;
	};
}));
var require_extract = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var fs$1 = __require("fs");
	var path = __require("path");
	var util = __require("util");
	var mkdirp = require_mkdirp();
	var Transform = __require("stream").Transform;
	var UnzipStream = require_unzip_stream();
	function Extract(opts) {
		if (!(this instanceof Extract)) return new Extract(opts);
		Transform.call(this);
		this.opts = opts || {};
		this.unzipStream = new UnzipStream(this.opts);
		this.unfinishedEntries = 0;
		this.afterFlushWait = false;
		this.createdDirectories = {};
		var self$1 = this;
		this.unzipStream.on("entry", this._processEntry.bind(this));
		this.unzipStream.on("error", function(error) {
			self$1.emit("error", error);
		});
	}
	util.inherits(Extract, Transform);
	Extract.prototype._transform = function(chunk, encoding, cb) {
		this.unzipStream.write(chunk, encoding, cb);
	};
	Extract.prototype._flush = function(cb) {
		var self$1 = this;
		var allDone = function() {
			process.nextTick(function() {
				self$1.emit("close");
			});
			cb();
		};
		this.unzipStream.end(function() {
			if (self$1.unfinishedEntries > 0) {
				self$1.afterFlushWait = true;
				return self$1.on("await-finished", allDone);
			}
			allDone();
		});
	};
	Extract.prototype._processEntry = function(entry) {
		var self$1 = this;
		var destPath = path.join(this.opts.path, entry.path);
		var directory = entry.isDirectory ? destPath : path.dirname(destPath);
		this.unfinishedEntries++;
		var writeFileFn = function() {
			var pipedStream = fs$1.createWriteStream(destPath);
			pipedStream.on("close", function() {
				self$1.unfinishedEntries--;
				self$1._notifyAwaiter();
			});
			pipedStream.on("error", function(error) {
				self$1.emit("error", error);
			});
			entry.pipe(pipedStream);
		};
		if (this.createdDirectories[directory] || directory === ".") return writeFileFn();
		mkdirp(directory, function(err) {
			if (err) return self$1.emit("error", err);
			self$1.createdDirectories[directory] = true;
			if (entry.isDirectory) {
				self$1.unfinishedEntries--;
				self$1._notifyAwaiter();
				return;
			}
			writeFileFn();
		});
	};
	Extract.prototype._notifyAwaiter = function() {
		if (this.afterFlushWait && this.unfinishedEntries === 0) {
			this.emit("await-finished");
			this.afterFlushWait = false;
		}
	};
	module.exports = Extract;
}));
var require_unzip = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.Parse = require_parser_stream();
	exports.Extract = require_extract();
}));
var require_download_artifact = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.streamExtractExternal = streamExtractExternal;
	exports.downloadArtifactPublic = downloadArtifactPublic;
	exports.downloadArtifactInternal = downloadArtifactInternal;
	var promises_1 = __importDefault(__require("fs/promises"));
	var crypto$2 = __importStar(__require("crypto"));
	var stream = __importStar(__require("stream"));
	var github = __importStar(require_github());
	var core = __importStar(require_core$1());
	var httpClient = __importStar(require_lib$2());
	var unzip_stream_1 = __importDefault(require_unzip());
	var user_agent_1 = require_user_agent();
	var config_1 = require_config();
	var artifact_twirp_client_1 = require_artifact_twirp_client();
	var generated_1 = require_generated();
	var util_1 = require_util$5();
	var errors_1 = require_errors$2();
	var scrubQueryParameters = (url) => {
		const parsed = new URL(url);
		parsed.search = "";
		return parsed.toString();
	};
	function exists(path$5) {
		return __awaiter(this, void 0, void 0, function* () {
			try {
				yield promises_1.default.access(path$5);
				return true;
			} catch (error) {
				if (error.code === "ENOENT") return false;
				else throw error;
			}
		});
	}
	function streamExtract(url, directory) {
		return __awaiter(this, void 0, void 0, function* () {
			let retryCount = 0;
			while (retryCount < 5) try {
				return yield streamExtractExternal(url, directory);
			} catch (error) {
				retryCount++;
				core.debug(`Failed to download artifact after ${retryCount} retries due to ${error.message}. Retrying in 5 seconds...`);
				yield new Promise((resolve$1) => setTimeout(resolve$1, 5e3));
			}
			throw new Error(`Artifact download failed after ${retryCount} retries.`);
		});
	}
	function streamExtractExternal(url_1$2, directory_1) {
		return __awaiter(this, arguments, void 0, function* (url, directory, opts = { timeout: 30 * 1e3 }) {
			const response = yield new httpClient.HttpClient((0, user_agent_1.getUserAgentString)()).get(url);
			if (response.message.statusCode !== 200) throw new Error(`Unexpected HTTP response from blob storage: ${response.message.statusCode} ${response.message.statusMessage}`);
			let sha256Digest = void 0;
			return new Promise((resolve$1, reject$3) => {
				const timerFn = () => {
					const timeoutError = /* @__PURE__ */ new Error(`Blob storage chunk did not respond in ${opts.timeout}ms`);
					response.message.destroy(timeoutError);
					reject$3(timeoutError);
				};
				const timer = setTimeout(timerFn, opts.timeout);
				const hashStream = crypto$2.createHash("sha256").setEncoding("hex");
				const passThrough = new stream.PassThrough();
				response.message.pipe(passThrough);
				passThrough.pipe(hashStream);
				passThrough.on("data", () => {
					timer.refresh();
				}).on("error", (error) => {
					core.debug(`response.message: Artifact download failed: ${error.message}`);
					clearTimeout(timer);
					reject$3(error);
				}).pipe(unzip_stream_1.default.Extract({ path: directory })).on("close", () => {
					clearTimeout(timer);
					if (hashStream) {
						hashStream.end();
						sha256Digest = hashStream.read();
						core.info(`SHA256 digest of downloaded artifact is ${sha256Digest}`);
					}
					resolve$1({ sha256Digest: `sha256:${sha256Digest}` });
				}).on("error", (error) => {
					reject$3(error);
				});
			});
		});
	}
	function downloadArtifactPublic(artifactId, repositoryOwner, repositoryName, token, options) {
		return __awaiter(this, void 0, void 0, function* () {
			const downloadPath = yield resolveOrCreateDirectory(options === null || options === void 0 ? void 0 : options.path);
			const api = github.getOctokit(token);
			let digestMismatch = false;
			core.info(`Downloading artifact '${artifactId}' from '${repositoryOwner}/${repositoryName}'`);
			const { headers, status } = yield api.rest.actions.downloadArtifact({
				owner: repositoryOwner,
				repo: repositoryName,
				artifact_id: artifactId,
				archive_format: "zip",
				request: { redirect: "manual" }
			});
			if (status !== 302) throw new Error(`Unable to download artifact. Unexpected status: ${status}`);
			const { location } = headers;
			if (!location) throw new Error(`Unable to redirect to artifact download url`);
			core.info(`Redirecting to blob download url: ${scrubQueryParameters(location)}`);
			try {
				core.info(`Starting download of artifact to: ${downloadPath}`);
				const extractResponse = yield streamExtract(location, downloadPath);
				core.info(`Artifact download completed successfully.`);
				if (options === null || options === void 0 ? void 0 : options.expectedHash) {
					if ((options === null || options === void 0 ? void 0 : options.expectedHash) !== extractResponse.sha256Digest) {
						digestMismatch = true;
						core.debug(`Computed digest: ${extractResponse.sha256Digest}`);
						core.debug(`Expected digest: ${options.expectedHash}`);
					}
				}
			} catch (error) {
				throw new Error(`Unable to download and extract artifact: ${error.message}`);
			}
			return {
				downloadPath,
				digestMismatch
			};
		});
	}
	function downloadArtifactInternal(artifactId, options) {
		return __awaiter(this, void 0, void 0, function* () {
			const downloadPath = yield resolveOrCreateDirectory(options === null || options === void 0 ? void 0 : options.path);
			const artifactClient$1 = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
			let digestMismatch = false;
			const { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)();
			const listReq = {
				workflowRunBackendId,
				workflowJobRunBackendId,
				idFilter: generated_1.Int64Value.create({ value: artifactId.toString() })
			};
			const { artifacts } = yield artifactClient$1.ListArtifacts(listReq);
			if (artifacts.length === 0) throw new errors_1.ArtifactNotFoundError(`No artifacts found for ID: ${artifactId}\nAre you trying to download from a different run? Try specifying a github-token with \`actions:read\` scope.`);
			if (artifacts.length > 1) core.warning("Multiple artifacts found, defaulting to first.");
			const signedReq = {
				workflowRunBackendId: artifacts[0].workflowRunBackendId,
				workflowJobRunBackendId: artifacts[0].workflowJobRunBackendId,
				name: artifacts[0].name
			};
			const { signedUrl } = yield artifactClient$1.GetSignedArtifactURL(signedReq);
			core.info(`Redirecting to blob download url: ${scrubQueryParameters(signedUrl)}`);
			try {
				core.info(`Starting download of artifact to: ${downloadPath}`);
				const extractResponse = yield streamExtract(signedUrl, downloadPath);
				core.info(`Artifact download completed successfully.`);
				if (options === null || options === void 0 ? void 0 : options.expectedHash) {
					if ((options === null || options === void 0 ? void 0 : options.expectedHash) !== extractResponse.sha256Digest) {
						digestMismatch = true;
						core.debug(`Computed digest: ${extractResponse.sha256Digest}`);
						core.debug(`Expected digest: ${options.expectedHash}`);
					}
				}
			} catch (error) {
				throw new Error(`Unable to download and extract artifact: ${error.message}`);
			}
			return {
				downloadPath,
				digestMismatch
			};
		});
	}
	function resolveOrCreateDirectory() {
		return __awaiter(this, arguments, void 0, function* (downloadPath = (0, config_1.getGitHubWorkspaceDir)()) {
			if (!(yield exists(downloadPath))) {
				core.debug(`Artifact destination folder does not exist, creating: ${downloadPath}`);
				yield promises_1.default.mkdir(downloadPath, { recursive: true });
			} else core.debug(`Artifact destination folder already exists: ${downloadPath}`);
			return downloadPath;
		});
	}
}));
var require_retry_options = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRetryOptions = getRetryOptions;
	var core = __importStar(require_core$1());
	var defaultMaxRetryNumber = 5;
	var defaultExemptStatusCodes = [
		400,
		401,
		403,
		404,
		422
	];
	function getRetryOptions(defaultOptions, retries = defaultMaxRetryNumber, exemptStatusCodes = defaultExemptStatusCodes) {
		var _a;
		if (retries <= 0) return [{ enabled: false }, defaultOptions.request];
		const retryOptions = { enabled: true };
		if (exemptStatusCodes.length > 0) retryOptions.doNotRetry = exemptStatusCodes;
		const requestOptions = Object.assign(Object.assign({}, defaultOptions.request), { retries });
		core.debug(`GitHub client configured with: (retries: ${requestOptions.retries}, retry-exempt-status-code: ${(_a = retryOptions.doNotRetry) !== null && _a !== void 0 ? _a : "octokit default: [400, 401, 403, 404, 422]"})`);
		return [retryOptions, requestOptions];
	}
}));
var dist_web_exports$1 = /* @__PURE__ */ __export({ requestLog: () => requestLog }, 1);
function requestLog(octokit) {
	octokit.hook.wrap("request", (request$1, options) => {
		octokit.log.debug("request", options);
		const start = Date.now();
		const requestOptions = octokit.request.endpoint.parse(options);
		const path$5 = requestOptions.url.replace(options.baseUrl, "");
		return request$1(options).then((response) => {
			octokit.log.info(`${requestOptions.method} ${path$5} - ${response.status} in ${Date.now() - start}ms`);
			return response;
		}).catch((error) => {
			octokit.log.info(`${requestOptions.method} ${path$5} - ${error.status} in ${Date.now() - start}ms`);
			throw error;
		});
	});
}
var VERSION$1;
var init_dist_web$1 = __esmMin((() => {
	VERSION$1 = "1.0.4";
	requestLog.VERSION = VERSION$1;
}));
var require_light = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global$1.Bottleneck = factory();
	})(exports, (function() {
		"use strict";
		var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
		function getCjsExportFromNamespace(n$1) {
			return n$1 && n$1["default"] || n$1;
		}
		var load = function(received, defaults, onto = {}) {
			var k, ref, v;
			for (k in defaults) {
				v = defaults[k];
				onto[k] = (ref = received[k]) != null ? ref : v;
			}
			return onto;
		};
		var overwrite = function(received, defaults, onto = {}) {
			var k, v;
			for (k in received) {
				v = received[k];
				if (defaults[k] !== void 0) onto[k] = v;
			}
			return onto;
		};
		var parser = {
			load,
			overwrite
		};
		var DLList_1 = class DLList {
			constructor(incr, decr) {
				this.incr = incr;
				this.decr = decr;
				this._first = null;
				this._last = null;
				this.length = 0;
			}
			push(value$1) {
				var node;
				this.length++;
				if (typeof this.incr === "function") this.incr();
				node = {
					value: value$1,
					prev: this._last,
					next: null
				};
				if (this._last != null) {
					this._last.next = node;
					this._last = node;
				} else this._first = this._last = node;
			}
			shift() {
				var value$1;
				if (this._first == null) return;
				else {
					this.length--;
					if (typeof this.decr === "function") this.decr();
				}
				value$1 = this._first.value;
				if ((this._first = this._first.next) != null) this._first.prev = null;
				else this._last = null;
				return value$1;
			}
			first() {
				if (this._first != null) return this._first.value;
			}
			getArray() {
				var node = this._first, ref, results = [];
				while (node != null) results.push((ref = node, node = node.next, ref.value));
				return results;
			}
			forEachShift(cb) {
				var node = this.shift();
				while (node != null) cb(node), node = this.shift();
			}
			debug() {
				var node = this._first, ref, ref1, ref2, results = [];
				while (node != null) results.push((ref = node, node = node.next, {
					value: ref.value,
					prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
					next: (ref2 = ref.next) != null ? ref2.value : void 0
				}));
				return results;
			}
		};
		var Events_1 = class Events {
			constructor(instance) {
				this.instance = instance;
				this._events = {};
				if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) throw new Error("An Emitter already exists for this object");
				this.instance.on = (name$1, cb) => {
					return this._addListener(name$1, "many", cb);
				};
				this.instance.once = (name$1, cb) => {
					return this._addListener(name$1, "once", cb);
				};
				this.instance.removeAllListeners = (name$1 = null) => {
					if (name$1 != null) return delete this._events[name$1];
					else return this._events = {};
				};
			}
			_addListener(name$1, status, cb) {
				var base;
				if ((base = this._events)[name$1] == null) base[name$1] = [];
				this._events[name$1].push({
					cb,
					status
				});
				return this.instance;
			}
			listenerCount(name$1) {
				if (this._events[name$1] != null) return this._events[name$1].length;
				else return 0;
			}
			async trigger(name$1, ...args) {
				var e$1, promises;
				try {
					if (name$1 !== "debug") this.trigger("debug", `Event triggered: ${name$1}`, args);
					if (this._events[name$1] == null) return;
					this._events[name$1] = this._events[name$1].filter(function(listener) {
						return listener.status !== "none";
					});
					promises = this._events[name$1].map(async (listener) => {
						var e$2, returned;
						if (listener.status === "none") return;
						if (listener.status === "once") listener.status = "none";
						try {
							returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;
							if (typeof (returned != null ? returned.then : void 0) === "function") return await returned;
							else return returned;
						} catch (error) {
							e$2 = error;
							this.trigger("error", e$2);
							return null;
						}
					});
					return (await Promise.all(promises)).find(function(x) {
						return x != null;
					});
				} catch (error) {
					e$1 = error;
					this.trigger("error", e$1);
					return null;
				}
			}
		};
		var DLList$1 = DLList_1, Events$1 = Events_1;
		var Queues_1 = class Queues {
			constructor(num_priorities) {
				this.Events = new Events$1(this);
				this._length = 0;
				this._lists = (function() {
					var j, ref, results = [];
					for (j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? ++j : --j) results.push(new DLList$1((() => {
						return this.incr();
					}), (() => {
						return this.decr();
					})));
					return results;
				}).call(this);
			}
			incr() {
				if (this._length++ === 0) return this.Events.trigger("leftzero");
			}
			decr() {
				if (--this._length === 0) return this.Events.trigger("zero");
			}
			push(job) {
				return this._lists[job.options.priority].push(job);
			}
			queued(priority) {
				if (priority != null) return this._lists[priority].length;
				else return this._length;
			}
			shiftAll(fn) {
				return this._lists.forEach(function(list) {
					return list.forEachShift(fn);
				});
			}
			getFirst(arr = this._lists) {
				var j, len, list;
				for (j = 0, len = arr.length; j < len; j++) {
					list = arr[j];
					if (list.length > 0) return list;
				}
				return [];
			}
			shiftLastFrom(priority) {
				return this.getFirst(this._lists.slice(priority).reverse()).shift();
			}
		};
		var BottleneckError_1 = class BottleneckError extends Error {};
		var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES = 10, parser$1;
		DEFAULT_PRIORITY = 5;
		parser$1 = parser;
		BottleneckError$1 = BottleneckError_1;
		Job = class Job$2 {
			constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise$1) {
				this.task = task;
				this.args = args;
				this.rejectOnDrop = rejectOnDrop;
				this.Events = Events;
				this._states = _states;
				this.Promise = Promise$1;
				this.options = parser$1.load(options, jobDefaults);
				this.options.priority = this._sanitizePriority(this.options.priority);
				if (this.options.id === jobDefaults.id) this.options.id = `${this.options.id}-${this._randomIndex()}`;
				this.promise = new this.Promise((_resolve, _reject) => {
					this._resolve = _resolve;
					this._reject = _reject;
				});
				this.retryCount = 0;
			}
			_sanitizePriority(priority) {
				var sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
				if (sProperty < 0) return 0;
				else if (sProperty > NUM_PRIORITIES - 1) return NUM_PRIORITIES - 1;
				else return sProperty;
			}
			_randomIndex() {
				return Math.random().toString(36).slice(2);
			}
			doDrop({ error, message = "This job has been dropped by Bottleneck" } = {}) {
				if (this._states.remove(this.options.id)) {
					if (this.rejectOnDrop) this._reject(error != null ? error : new BottleneckError$1(message));
					this.Events.trigger("dropped", {
						args: this.args,
						options: this.options,
						task: this.task,
						promise: this.promise
					});
					return true;
				} else return false;
			}
			_assertStatus(expected) {
				var status = this._states.jobStatus(this.options.id);
				if (!(status === expected || expected === "DONE" && status === null)) throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
			}
			doReceive() {
				this._states.start(this.options.id);
				return this.Events.trigger("received", {
					args: this.args,
					options: this.options
				});
			}
			doQueue(reachedHWM, blocked) {
				this._assertStatus("RECEIVED");
				this._states.next(this.options.id);
				return this.Events.trigger("queued", {
					args: this.args,
					options: this.options,
					reachedHWM,
					blocked
				});
			}
			doRun() {
				if (this.retryCount === 0) {
					this._assertStatus("QUEUED");
					this._states.next(this.options.id);
				} else this._assertStatus("EXECUTING");
				return this.Events.trigger("scheduled", {
					args: this.args,
					options: this.options
				});
			}
			async doExecute(chained, clearGlobalState, run$1, free) {
				var error, eventInfo, passed;
				if (this.retryCount === 0) {
					this._assertStatus("RUNNING");
					this._states.next(this.options.id);
				} else this._assertStatus("EXECUTING");
				eventInfo = {
					args: this.args,
					options: this.options,
					retryCount: this.retryCount
				};
				this.Events.trigger("executing", eventInfo);
				try {
					passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args));
					if (clearGlobalState()) {
						this.doDone(eventInfo);
						await free(this.options, eventInfo);
						this._assertStatus("DONE");
						return this._resolve(passed);
					}
				} catch (error1) {
					error = error1;
					return this._onFailure(error, eventInfo, clearGlobalState, run$1, free);
				}
			}
			doExpire(clearGlobalState, run$1, free) {
				var error, eventInfo;
				if (this._states.jobStatus(this.options.id === "RUNNING")) this._states.next(this.options.id);
				this._assertStatus("EXECUTING");
				eventInfo = {
					args: this.args,
					options: this.options,
					retryCount: this.retryCount
				};
				error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);
				return this._onFailure(error, eventInfo, clearGlobalState, run$1, free);
			}
			async _onFailure(error, eventInfo, clearGlobalState, run$1, free) {
				var retry$4, retryAfter;
				if (clearGlobalState()) {
					retry$4 = await this.Events.trigger("failed", error, eventInfo);
					if (retry$4 != null) {
						retryAfter = ~~retry$4;
						this.Events.trigger("retry", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);
						this.retryCount++;
						return run$1(retryAfter);
					} else {
						this.doDone(eventInfo);
						await free(this.options, eventInfo);
						this._assertStatus("DONE");
						return this._reject(error);
					}
				}
			}
			doDone(eventInfo) {
				this._assertStatus("EXECUTING");
				this._states.next(this.options.id);
				return this.Events.trigger("done", eventInfo);
			}
		};
		var Job_1 = Job;
		var BottleneckError$2, LocalDatastore, parser$2 = parser;
		BottleneckError$2 = BottleneckError_1;
		LocalDatastore = class LocalDatastore$2 {
			constructor(instance, storeOptions, storeInstanceOptions) {
				this.instance = instance;
				this.storeOptions = storeOptions;
				this.clientId = this.instance._randomIndex();
				parser$2.load(storeInstanceOptions, storeInstanceOptions, this);
				this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
				this._running = 0;
				this._done = 0;
				this._unblockTime = 0;
				this.ready = this.Promise.resolve();
				this.clients = {};
				this._startHeartbeat();
			}
			_startHeartbeat() {
				var base;
				if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) return typeof (base = this.heartbeat = setInterval(() => {
					var amount, incr, maximum, now = Date.now(), reservoir;
					if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
						this._lastReservoirRefresh = now;
						this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
						this.instance._drainAll(this.computeCapacity());
					}
					if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
						({reservoirIncreaseAmount: amount, reservoirIncreaseMaximum: maximum, reservoir} = this.storeOptions);
						this._lastReservoirIncrease = now;
						incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
						if (incr > 0) {
							this.storeOptions.reservoir += incr;
							return this.instance._drainAll(this.computeCapacity());
						}
					}
				}, this.heartbeatInterval)).unref === "function" ? base.unref() : void 0;
				else return clearInterval(this.heartbeat);
			}
			async __publish__(message) {
				await this.yieldLoop();
				return this.instance.Events.trigger("message", message.toString());
			}
			async __disconnect__(flush) {
				await this.yieldLoop();
				clearInterval(this.heartbeat);
				return this.Promise.resolve();
			}
			yieldLoop(t$1 = 0) {
				return new this.Promise(function(resolve$1, reject$3) {
					return setTimeout(resolve$1, t$1);
				});
			}
			computePenalty() {
				var ref;
				return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5e3;
			}
			async __updateSettings__(options) {
				await this.yieldLoop();
				parser$2.overwrite(options, options, this.storeOptions);
				this._startHeartbeat();
				this.instance._drainAll(this.computeCapacity());
				return true;
			}
			async __running__() {
				await this.yieldLoop();
				return this._running;
			}
			async __queued__() {
				await this.yieldLoop();
				return this.instance.queued();
			}
			async __done__() {
				await this.yieldLoop();
				return this._done;
			}
			async __groupCheck__(time) {
				await this.yieldLoop();
				return this._nextRequest + this.timeout < time;
			}
			computeCapacity() {
				var maxConcurrent, reservoir;
				({maxConcurrent, reservoir} = this.storeOptions);
				if (maxConcurrent != null && reservoir != null) return Math.min(maxConcurrent - this._running, reservoir);
				else if (maxConcurrent != null) return maxConcurrent - this._running;
				else if (reservoir != null) return reservoir;
				else return null;
			}
			conditionsCheck(weight) {
				var capacity = this.computeCapacity();
				return capacity == null || weight <= capacity;
			}
			async __incrementReservoir__(incr) {
				var reservoir;
				await this.yieldLoop();
				reservoir = this.storeOptions.reservoir += incr;
				this.instance._drainAll(this.computeCapacity());
				return reservoir;
			}
			async __currentReservoir__() {
				await this.yieldLoop();
				return this.storeOptions.reservoir;
			}
			isBlocked(now) {
				return this._unblockTime >= now;
			}
			check(weight, now) {
				return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
			}
			async __check__(weight) {
				var now;
				await this.yieldLoop();
				now = Date.now();
				return this.check(weight, now);
			}
			async __register__(index$1, weight, expiration) {
				var now, wait;
				await this.yieldLoop();
				now = Date.now();
				if (this.conditionsCheck(weight)) {
					this._running += weight;
					if (this.storeOptions.reservoir != null) this.storeOptions.reservoir -= weight;
					wait = Math.max(this._nextRequest - now, 0);
					this._nextRequest = now + wait + this.storeOptions.minTime;
					return {
						success: true,
						wait,
						reservoir: this.storeOptions.reservoir
					};
				} else return { success: false };
			}
			strategyIsBlock() {
				return this.storeOptions.strategy === 3;
			}
			async __submit__(queueLength, weight) {
				var blocked, now, reachedHWM;
				await this.yieldLoop();
				if (this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent) throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);
				now = Date.now();
				reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now);
				blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));
				if (blocked) {
					this._unblockTime = now + this.computePenalty();
					this._nextRequest = this._unblockTime + this.storeOptions.minTime;
					this.instance._dropAllQueued();
				}
				return {
					reachedHWM,
					blocked,
					strategy: this.storeOptions.strategy
				};
			}
			async __free__(index$1, weight) {
				await this.yieldLoop();
				this._running -= weight;
				this._done += weight;
				this.instance._drainAll(this.computeCapacity());
				return { running: this._running };
			}
		};
		var LocalDatastore_1 = LocalDatastore;
		var BottleneckError$3 = BottleneckError_1;
		var States_1 = class States {
			constructor(status1) {
				this.status = status1;
				this._jobs = {};
				this.counts = this.status.map(function() {
					return 0;
				});
			}
			next(id) {
				var current = this._jobs[id], next = current + 1;
				if (current != null && next < this.status.length) {
					this.counts[current]--;
					this.counts[next]++;
					return this._jobs[id]++;
				} else if (current != null) {
					this.counts[current]--;
					return delete this._jobs[id];
				}
			}
			start(id) {
				var initial = 0;
				this._jobs[id] = initial;
				return this.counts[initial]++;
			}
			remove(id) {
				var current = this._jobs[id];
				if (current != null) {
					this.counts[current]--;
					delete this._jobs[id];
				}
				return current != null;
			}
			jobStatus(id) {
				var ref;
				return (ref = this.status[this._jobs[id]]) != null ? ref : null;
			}
			statusJobs(status) {
				var k, pos, ref, results, v;
				if (status != null) {
					pos = this.status.indexOf(status);
					if (pos < 0) throw new BottleneckError$3(`status must be one of ${this.status.join(", ")}`);
					ref = this._jobs;
					results = [];
					for (k in ref) {
						v = ref[k];
						if (v === pos) results.push(k);
					}
					return results;
				} else return Object.keys(this._jobs);
			}
			statusCounts() {
				return this.counts.reduce(((acc, v, i) => {
					acc[this.status[i]] = v;
					return acc;
				}), {});
			}
		};
		var DLList$2 = DLList_1;
		var Sync_1 = class Sync {
			constructor(name$1, Promise$1) {
				this.schedule = this.schedule.bind(this);
				this.name = name$1;
				this.Promise = Promise$1;
				this._running = 0;
				this._queue = new DLList$2();
			}
			isEmpty() {
				return this._queue.length === 0;
			}
			async _tryToRun() {
				var args, cb, error, reject$3, resolve$1, returned, task;
				if (this._running < 1 && this._queue.length > 0) {
					this._running++;
					({task, args, resolve: resolve$1, reject: reject$3} = this._queue.shift());
					cb = await (async function() {
						try {
							returned = await task(...args);
							return function() {
								return resolve$1(returned);
							};
						} catch (error1) {
							error = error1;
							return function() {
								return reject$3(error);
							};
						}
					})();
					this._running--;
					this._tryToRun();
					return cb();
				}
			}
			schedule(task, ...args) {
				var promise, reject$3, resolve$1 = reject$3 = null;
				promise = new this.Promise(function(_resolve, _reject) {
					resolve$1 = _resolve;
					return reject$3 = _reject;
				});
				this._queue.push({
					task,
					args,
					resolve: resolve$1,
					reject: reject$3
				});
				this._tryToRun();
				return promise;
			}
		};
		var version$1 = "2.19.5";
		var version$1$1 = { version: version$1 };
		var version$2 = /* @__PURE__ */ Object.freeze({
			version: version$1,
			default: version$1$1
		});
		var require$$2 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
		var require$$3 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
		var require$$4 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
		var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3 = parser;
		Events$2 = Events_1;
		RedisConnection$1 = require$$2;
		IORedisConnection$1 = require$$3;
		Scripts$1 = require$$4;
		Group = (function() {
			class Group$1 {
				constructor(limiterOptions = {}) {
					this.deleteKey = this.deleteKey.bind(this);
					this.limiterOptions = limiterOptions;
					parser$3.load(this.limiterOptions, this.defaults, this);
					this.Events = new Events$2(this);
					this.instances = {};
					this.Bottleneck = Bottleneck_1;
					this._startAutoCleanup();
					this.sharedConnection = this.connection != null;
					if (this.connection == null) {
						if (this.limiterOptions.datastore === "redis") this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
						else if (this.limiterOptions.datastore === "ioredis") this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
					}
				}
				key(key = "") {
					var ref;
					return (ref = this.instances[key]) != null ? ref : (() => {
						var limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
							id: `${this.id}-${key}`,
							timeout: this.timeout,
							connection: this.connection
						}));
						this.Events.trigger("created", limiter, key);
						return limiter;
					})();
				}
				async deleteKey(key = "") {
					var deleted, instance = this.instances[key];
					if (this.connection) deleted = await this.connection.__runCommand__(["del", ...Scripts$1.allKeys(`${this.id}-${key}`)]);
					if (instance != null) {
						delete this.instances[key];
						await instance.disconnect();
					}
					return instance != null || deleted > 0;
				}
				limiters() {
					var k, ref = this.instances, results = [], v;
					for (k in ref) {
						v = ref[k];
						results.push({
							key: k,
							limiter: v
						});
					}
					return results;
				}
				keys() {
					return Object.keys(this.instances);
				}
				async clusterKeys() {
					var cursor, end, found, i, k, keys, len, next, start;
					if (this.connection == null) return this.Promise.resolve(this.keys());
					keys = [];
					cursor = null;
					start = `b_${this.id}-`.length;
					end = 9;
					while (cursor !== 0) {
						[next, found] = await this.connection.__runCommand__([
							"scan",
							cursor != null ? cursor : 0,
							"match",
							`b_${this.id}-*_settings`,
							"count",
							1e4
						]);
						cursor = ~~next;
						for (i = 0, len = found.length; i < len; i++) {
							k = found[i];
							keys.push(k.slice(start, -end));
						}
					}
					return keys;
				}
				_startAutoCleanup() {
					var base;
					clearInterval(this.interval);
					return typeof (base = this.interval = setInterval(async () => {
						var e$1, k, ref, results, time = Date.now(), v;
						ref = this.instances;
						results = [];
						for (k in ref) {
							v = ref[k];
							try {
								if (await v._store.__groupCheck__(time)) results.push(this.deleteKey(k));
								else results.push(void 0);
							} catch (error) {
								e$1 = error;
								results.push(v.Events.trigger("error", e$1));
							}
						}
						return results;
					}, this.timeout / 2)).unref === "function" ? base.unref() : void 0;
				}
				updateSettings(options = {}) {
					parser$3.overwrite(options, this.defaults, this);
					parser$3.overwrite(options, options, this.limiterOptions);
					if (options.timeout != null) return this._startAutoCleanup();
				}
				disconnect(flush = true) {
					var ref;
					if (!this.sharedConnection) return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
				}
			}
			Group$1.prototype.defaults = {
				timeout: 1e3 * 60 * 5,
				connection: null,
				Promise,
				id: "group-key"
			};
			return Group$1;
		}).call(commonjsGlobal);
		var Group_1 = Group;
		var Batcher, Events$3, parser$4 = parser;
		Events$3 = Events_1;
		Batcher = (function() {
			class Batcher$1 {
				constructor(options = {}) {
					this.options = options;
					parser$4.load(this.options, this.defaults, this);
					this.Events = new Events$3(this);
					this._arr = [];
					this._resetPromise();
					this._lastFlush = Date.now();
				}
				_resetPromise() {
					return this._promise = new this.Promise((res, rej) => {
						return this._resolve = res;
					});
				}
				_flush() {
					clearTimeout(this._timeout);
					this._lastFlush = Date.now();
					this._resolve();
					this.Events.trigger("batch", this._arr);
					this._arr = [];
					return this._resetPromise();
				}
				add(data) {
					var ret;
					this._arr.push(data);
					ret = this._promise;
					if (this._arr.length === this.maxSize) this._flush();
					else if (this.maxTime != null && this._arr.length === 1) this._timeout = setTimeout(() => {
						return this._flush();
					}, this.maxTime);
					return ret;
				}
			}
			Batcher$1.prototype.defaults = {
				maxTime: null,
				maxSize: null,
				Promise
			};
			return Batcher$1;
		}).call(commonjsGlobal);
		var Batcher_1 = Batcher;
		var require$$4$1 = () => console.log("You must import the full version of Bottleneck in order to use this feature.");
		var require$$8 = getCjsExportFromNamespace(version$2);
		var Bottleneck$1, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5, splice = [].splice;
		NUM_PRIORITIES$1 = 10;
		DEFAULT_PRIORITY$1 = 5;
		parser$5 = parser;
		Queues$1 = Queues_1;
		Job$1 = Job_1;
		LocalDatastore$1 = LocalDatastore_1;
		RedisDatastore$1 = require$$4$1;
		Events$4 = Events_1;
		States$1 = States_1;
		Sync$1 = Sync_1;
		Bottleneck$1 = (function() {
			class Bottleneck$2 {
				constructor(options = {}, ...invalid) {
					var storeInstanceOptions, storeOptions;
					this._addToQueue = this._addToQueue.bind(this);
					this._validateOptions(options, invalid);
					parser$5.load(options, this.instanceDefaults, this);
					this._queues = new Queues$1(NUM_PRIORITIES$1);
					this._scheduled = {};
					this._states = new States$1([
						"RECEIVED",
						"QUEUED",
						"RUNNING",
						"EXECUTING"
					].concat(this.trackDoneStatus ? ["DONE"] : []));
					this._limiter = null;
					this.Events = new Events$4(this);
					this._submitLock = new Sync$1("submit", this.Promise);
					this._registerLock = new Sync$1("register", this.Promise);
					storeOptions = parser$5.load(options, this.storeDefaults, {});
					this._store = (function() {
						if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
							storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});
							return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);
						} else if (this.datastore === "local") {
							storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});
							return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);
						} else throw new Bottleneck$2.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
					}).call(this);
					this._queues.on("leftzero", () => {
						var ref;
						return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
					});
					this._queues.on("zero", () => {
						var ref;
						return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
					});
				}
				_validateOptions(options, invalid) {
					if (!(options != null && typeof options === "object" && invalid.length === 0)) throw new Bottleneck$2.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
				}
				ready() {
					return this._store.ready;
				}
				clients() {
					return this._store.clients;
				}
				channel() {
					return `b_${this.id}`;
				}
				channel_client() {
					return `b_${this.id}_${this._store.clientId}`;
				}
				publish(message) {
					return this._store.__publish__(message);
				}
				disconnect(flush = true) {
					return this._store.__disconnect__(flush);
				}
				chain(_limiter) {
					this._limiter = _limiter;
					return this;
				}
				queued(priority) {
					return this._queues.queued(priority);
				}
				clusterQueued() {
					return this._store.__queued__();
				}
				empty() {
					return this.queued() === 0 && this._submitLock.isEmpty();
				}
				running() {
					return this._store.__running__();
				}
				done() {
					return this._store.__done__();
				}
				jobStatus(id) {
					return this._states.jobStatus(id);
				}
				jobs(status) {
					return this._states.statusJobs(status);
				}
				counts() {
					return this._states.statusCounts();
				}
				_randomIndex() {
					return Math.random().toString(36).slice(2);
				}
				check(weight = 1) {
					return this._store.__check__(weight);
				}
				_clearGlobalState(index$1) {
					if (this._scheduled[index$1] != null) {
						clearTimeout(this._scheduled[index$1].expiration);
						delete this._scheduled[index$1];
						return true;
					} else return false;
				}
				async _free(index$1, job, options, eventInfo) {
					var e$1, running;
					try {
						({running} = await this._store.__free__(index$1, options.weight));
						this.Events.trigger("debug", `Freed ${options.id}`, eventInfo);
						if (running === 0 && this.empty()) return this.Events.trigger("idle");
					} catch (error1) {
						e$1 = error1;
						return this.Events.trigger("error", e$1);
					}
				}
				_run(index$1, job, wait) {
					var clearGlobalState, free, run$1;
					job.doRun();
					clearGlobalState = this._clearGlobalState.bind(this, index$1);
					run$1 = this._run.bind(this, index$1, job);
					free = this._free.bind(this, index$1, job);
					return this._scheduled[index$1] = {
						timeout: setTimeout(() => {
							return job.doExecute(this._limiter, clearGlobalState, run$1, free);
						}, wait),
						expiration: job.options.expiration != null ? setTimeout(function() {
							return job.doExpire(clearGlobalState, run$1, free);
						}, wait + job.options.expiration) : void 0,
						job
					};
				}
				_drainOne(capacity) {
					return this._registerLock.schedule(() => {
						var args, index$1, next, options, queue$2;
						if (this.queued() === 0) return this.Promise.resolve(null);
						queue$2 = this._queues.getFirst();
						({options, args} = next = queue$2.first());
						if (capacity != null && options.weight > capacity) return this.Promise.resolve(null);
						this.Events.trigger("debug", `Draining ${options.id}`, {
							args,
							options
						});
						index$1 = this._randomIndex();
						return this._store.__register__(index$1, options.weight, options.expiration).then(({ success, wait, reservoir }) => {
							var empty$2;
							this.Events.trigger("debug", `Drained ${options.id}`, {
								success,
								args,
								options
							});
							if (success) {
								queue$2.shift();
								empty$2 = this.empty();
								if (empty$2) this.Events.trigger("empty");
								if (reservoir === 0) this.Events.trigger("depleted", empty$2);
								this._run(index$1, next, wait);
								return this.Promise.resolve(options.weight);
							} else return this.Promise.resolve(null);
						});
					});
				}
				_drainAll(capacity, total = 0) {
					return this._drainOne(capacity).then((drained) => {
						var newCapacity;
						if (drained != null) {
							newCapacity = capacity != null ? capacity - drained : capacity;
							return this._drainAll(newCapacity, total + drained);
						} else return this.Promise.resolve(total);
					}).catch((e$1) => {
						return this.Events.trigger("error", e$1);
					});
				}
				_dropAllQueued(message) {
					return this._queues.shiftAll(function(job) {
						return job.doDrop({ message });
					});
				}
				stop(options = {}) {
					var done, waitForExecuting;
					options = parser$5.load(options, this.stopDefaults);
					waitForExecuting = (at) => {
						var finished = () => {
							var counts = this._states.counts;
							return counts[0] + counts[1] + counts[2] + counts[3] === at;
						};
						return new this.Promise((resolve$1, reject$3) => {
							if (finished()) return resolve$1();
							else return this.on("done", () => {
								if (finished()) {
									this.removeAllListeners("done");
									return resolve$1();
								}
							});
						});
					};
					done = options.dropWaitingJobs ? (this._run = function(index$1, next) {
						return next.doDrop({ message: options.dropErrorMessage });
					}, this._drainOne = () => {
						return this.Promise.resolve(null);
					}, this._registerLock.schedule(() => {
						return this._submitLock.schedule(() => {
							var k, ref = this._scheduled, v;
							for (k in ref) {
								v = ref[k];
								if (this.jobStatus(v.job.options.id) === "RUNNING") {
									clearTimeout(v.timeout);
									clearTimeout(v.expiration);
									v.job.doDrop({ message: options.dropErrorMessage });
								}
							}
							this._dropAllQueued(options.dropErrorMessage);
							return waitForExecuting(0);
						});
					})) : this.schedule({
						priority: NUM_PRIORITIES$1 - 1,
						weight: 0
					}, () => {
						return waitForExecuting(1);
					});
					this._receive = function(job) {
						return job._reject(new Bottleneck$2.prototype.BottleneckError(options.enqueueErrorMessage));
					};
					this.stop = () => {
						return this.Promise.reject(new Bottleneck$2.prototype.BottleneckError("stop() has already been called"));
					};
					return done;
				}
				async _addToQueue(job) {
					var args, blocked, error, options, reachedHWM, shifted, strategy;
					({args, options} = job);
					try {
						({reachedHWM, blocked, strategy} = await this._store.__submit__(this.queued(), options.weight));
					} catch (error1) {
						error = error1;
						this.Events.trigger("debug", `Could not queue ${options.id}`, {
							args,
							options,
							error
						});
						job.doDrop({ error });
						return false;
					}
					if (blocked) {
						job.doDrop();
						return true;
					} else if (reachedHWM) {
						shifted = strategy === Bottleneck$2.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck$2.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck$2.prototype.strategy.OVERFLOW ? job : void 0;
						if (shifted != null) shifted.doDrop();
						if (shifted == null || strategy === Bottleneck$2.prototype.strategy.OVERFLOW) {
							if (shifted == null) job.doDrop();
							return reachedHWM;
						}
					}
					job.doQueue(reachedHWM, blocked);
					this._queues.push(job);
					await this._drainAll();
					return reachedHWM;
				}
				_receive(job) {
					if (this._states.jobStatus(job.options.id) != null) {
						job._reject(new Bottleneck$2.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
						return false;
					} else {
						job.doReceive();
						return this._submitLock.schedule(this._addToQueue, job);
					}
				}
				submit(...args) {
					var cb, fn, job, options, ref, ref1, task;
					if (typeof args[0] === "function") {
						ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);
						options = parser$5.load({}, this.jobDefaults);
					} else {
						ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);
						options = parser$5.load(options, this.jobDefaults);
					}
					task = (...args$1) => {
						return new this.Promise(function(resolve$1, reject$3) {
							return fn(...args$1, function(...args$2) {
								return (args$2[0] != null ? reject$3 : resolve$1)(args$2);
							});
						});
					};
					job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
					job.promise.then(function(args$1) {
						return typeof cb === "function" ? cb(...args$1) : void 0;
					}).catch(function(args$1) {
						if (Array.isArray(args$1)) return typeof cb === "function" ? cb(...args$1) : void 0;
						else return typeof cb === "function" ? cb(args$1) : void 0;
					});
					return this._receive(job);
				}
				schedule(...args) {
					var job, options, task;
					if (typeof args[0] === "function") {
						[task, ...args] = args;
						options = {};
					} else [options, task, ...args] = args;
					job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
					this._receive(job);
					return job.promise;
				}
				wrap(fn) {
					var schedule = this.schedule.bind(this), wrapped = function(...args) {
						return schedule(fn.bind(this), ...args);
					};
					wrapped.withOptions = function(options, ...args) {
						return schedule(options, fn, ...args);
					};
					return wrapped;
				}
				async updateSettings(options = {}) {
					await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));
					parser$5.overwrite(options, this.instanceDefaults, this);
					return this;
				}
				currentReservoir() {
					return this._store.__currentReservoir__();
				}
				incrementReservoir(incr = 0) {
					return this._store.__incrementReservoir__(incr);
				}
			}
			Bottleneck$2.default = Bottleneck$2;
			Bottleneck$2.Events = Events$4;
			Bottleneck$2.version = Bottleneck$2.prototype.version = require$$8.version;
			Bottleneck$2.strategy = Bottleneck$2.prototype.strategy = {
				LEAK: 1,
				OVERFLOW: 2,
				OVERFLOW_PRIORITY: 4,
				BLOCK: 3
			};
			Bottleneck$2.BottleneckError = Bottleneck$2.prototype.BottleneckError = BottleneckError_1;
			Bottleneck$2.Group = Bottleneck$2.prototype.Group = Group_1;
			Bottleneck$2.RedisConnection = Bottleneck$2.prototype.RedisConnection = require$$2;
			Bottleneck$2.IORedisConnection = Bottleneck$2.prototype.IORedisConnection = require$$3;
			Bottleneck$2.Batcher = Bottleneck$2.prototype.Batcher = Batcher_1;
			Bottleneck$2.prototype.jobDefaults = {
				priority: DEFAULT_PRIORITY$1,
				weight: 1,
				expiration: null,
				id: "<no-id>"
			};
			Bottleneck$2.prototype.storeDefaults = {
				maxConcurrent: null,
				minTime: 0,
				highWater: null,
				strategy: Bottleneck$2.prototype.strategy.LEAK,
				penalty: null,
				reservoir: null,
				reservoirRefreshInterval: null,
				reservoirRefreshAmount: null,
				reservoirIncreaseInterval: null,
				reservoirIncreaseAmount: null,
				reservoirIncreaseMaximum: null
			};
			Bottleneck$2.prototype.localStoreDefaults = {
				Promise,
				timeout: null,
				heartbeatInterval: 250
			};
			Bottleneck$2.prototype.redisStoreDefaults = {
				Promise,
				timeout: null,
				heartbeatInterval: 5e3,
				clientTimeout: 1e4,
				Redis: null,
				clientOptions: {},
				clusterNodes: null,
				clearDatastore: false,
				connection: null
			};
			Bottleneck$2.prototype.instanceDefaults = {
				datastore: "local",
				connection: null,
				id: "<no-id>",
				rejectOnDrop: true,
				trackDoneStatus: false,
				Promise
			};
			Bottleneck$2.prototype.stopDefaults = {
				enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
				dropWaitingJobs: true,
				dropErrorMessage: "This limiter has been stopped."
			};
			return Bottleneck$2;
		}).call(commonjsGlobal);
		var Bottleneck_1 = Bottleneck$1;
		return Bottleneck_1;
	}));
}));
var dist_web_exports = /* @__PURE__ */ __export({
	VERSION: () => VERSION,
	retry: () => retry
}, 1);
async function errorRequest(octokit, state, error, options) {
	if (!error.request || !error.request.request) throw error;
	if (error.status >= 400 && !state.doNotRetry.includes(error.status)) {
		const retries = options.request.retries != null ? options.request.retries : state.retries;
		const retryAfter = Math.pow((options.request.retryCount || 0) + 1, 2);
		throw octokit.retry.retryRequest(error, retries, retryAfter);
	}
	throw error;
}
async function wrapRequest(state, request$1, options) {
	const limiter = new import_light.default();
	limiter.on("failed", function(error, info) {
		const maxRetries = ~~error.request.request.retries;
		const after = ~~error.request.request.retryAfter;
		options.request.retryCount = info.retryCount + 1;
		if (maxRetries > info.retryCount) return after * state.retryAfterBaseValue;
	});
	return limiter.schedule(request$1, options);
}
function retry(octokit, octokitOptions) {
	const state = Object.assign({
		enabled: true,
		retryAfterBaseValue: 1e3,
		doNotRetry: [
			400,
			401,
			403,
			404,
			422
		],
		retries: 3
	}, octokitOptions.retry);
	if (state.enabled) {
		octokit.hook.error("request", errorRequest.bind(null, octokit, state));
		octokit.hook.wrap("request", wrapRequest.bind(null, state));
	}
	return { retry: { retryRequest: (error, retries, retryAfter) => {
		error.request.request = Object.assign({}, error.request.request, {
			retries,
			retryAfter
		});
		return error;
	} } };
}
var import_light, VERSION;
var init_dist_web = __esmMin((() => {
	import_light = /* @__PURE__ */ __toESM(require_light());
	VERSION = "3.0.9";
	retry.VERSION = VERSION;
}));
var require_get_artifact = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$1, v) {
		Object.defineProperty(o$1, "default", {
			enumerable: true,
			value: v
		});
	}) : function(o$1, v) {
		o$1["default"] = v;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$1) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$2) {
				var ar = [];
				for (var k in o$2) if (Object.prototype.hasOwnProperty.call(o$2, k)) ar[ar.length] = k;
				return ar;
			};
			return ownKeys$1(o$1);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k = ownKeys$1(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getArtifactPublic = getArtifactPublic;
	exports.getArtifactInternal = getArtifactInternal;
	var github_1 = require_github();
	var plugin_retry_1 = (init_dist_web(), __toCommonJS(dist_web_exports));
	var core = __importStar(require_core$1());
	var utils_1 = require_utils$3();
	var retry_options_1 = require_retry_options();
	var plugin_request_log_1 = (init_dist_web$1(), __toCommonJS(dist_web_exports$1));
	var util_1 = require_util$5();
	var user_agent_1 = require_user_agent();
	var artifact_twirp_client_1 = require_artifact_twirp_client();
	var generated_1 = require_generated();
	var errors_1 = require_errors$2();
	function getArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token) {
		return __awaiter(this, void 0, void 0, function* () {
			var _a;
			const [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults);
			const opts = {
				log: void 0,
				userAgent: (0, user_agent_1.getUserAgentString)(),
				previews: void 0,
				retry: retryOpts,
				request: requestOpts
			};
			const getArtifactResp = yield (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog).request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts{?name}", {
				owner: repositoryOwner,
				repo: repositoryName,
				run_id: workflowRunId,
				name: artifactName
			});
			if (getArtifactResp.status !== 200) throw new errors_1.InvalidResponseError(`Invalid response from GitHub API: ${getArtifactResp.status} (${(_a = getArtifactResp === null || getArtifactResp === void 0 ? void 0 : getArtifactResp.headers) === null || _a === void 0 ? void 0 : _a["x-github-request-id"]})`);
			if (getArtifactResp.data.artifacts.length === 0) throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}
        Please ensure that your artifact is not expired and the artifact was uploaded using a compatible version of toolkit/upload-artifact.
        For more information, visit the GitHub Artifacts FAQ: https://github.com/actions/toolkit/blob/main/packages/artifact/docs/faq.md`);
			let artifact = getArtifactResp.data.artifacts[0];
			if (getArtifactResp.data.artifacts.length > 1) {
				artifact = getArtifactResp.data.artifacts.sort((a, b) => b.id - a.id)[0];
				core.debug(`More than one artifact found for a single name, returning newest (id: ${artifact.id})`);
			}
			return { artifact: {
				name: artifact.name,
				id: artifact.id,
				size: artifact.size_in_bytes,
				createdAt: artifact.created_at ? new Date(artifact.created_at) : void 0,
				digest: artifact.digest
			} };
		});
	}
	function getArtifactInternal(artifactName) {
		return __awaiter(this, void 0, void 0, function* () {
			var _a;
			const artifactClient$1 = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
			const { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)();
			const req = {
				workflowRunBackendId,
				workflowJobRunBackendId,
				nameFilter: generated_1.StringValue.create({ value: artifactName })
			};
			const res = yield artifactClient$1.ListArtifacts(req);
			if (res.artifacts.length === 0) throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}
        Please ensure that your artifact is not expired and the artifact was uploaded using a compatible version of toolkit/upload-artifact.
        For more information, visit the GitHub Artifacts FAQ: https://github.com/actions/toolkit/blob/main/packages/artifact/docs/faq.md`);
			let artifact = res.artifacts[0];
			if (res.artifacts.length > 1) {
				artifact = res.artifacts.sort((a, b) => Number(b.databaseId) - Number(a.databaseId))[0];
				core.debug(`More than one artifact found for a single name, returning newest (id: ${artifact.databaseId})`);
			}
			return { artifact: {
				name: artifact.name,
				id: Number(artifact.databaseId),
				size: Number(artifact.size),
				createdAt: artifact.createdAt ? generated_1.Timestamp.toDate(artifact.createdAt) : void 0,
				digest: (_a = artifact.digest) === null || _a === void 0 ? void 0 : _a.value
			} };
		});
	}
}));
var require_delete_artifact = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.deleteArtifactPublic = deleteArtifactPublic;
	exports.deleteArtifactInternal = deleteArtifactInternal;
	var core_1 = require_core$1();
	var github_1 = require_github();
	var user_agent_1 = require_user_agent();
	var retry_options_1 = require_retry_options();
	var utils_1 = require_utils$3();
	var plugin_request_log_1 = (init_dist_web$1(), __toCommonJS(dist_web_exports$1));
	var plugin_retry_1 = (init_dist_web(), __toCommonJS(dist_web_exports));
	var artifact_twirp_client_1 = require_artifact_twirp_client();
	var util_1 = require_util$5();
	var generated_1 = require_generated();
	var get_artifact_1 = require_get_artifact();
	var errors_1 = require_errors$2();
	function deleteArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token) {
		return __awaiter(this, void 0, void 0, function* () {
			var _a;
			const [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults);
			const opts = {
				log: void 0,
				userAgent: (0, user_agent_1.getUserAgentString)(),
				previews: void 0,
				retry: retryOpts,
				request: requestOpts
			};
			const github = (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog);
			const getArtifactResp = yield (0, get_artifact_1.getArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
			const deleteArtifactResp = yield github.rest.actions.deleteArtifact({
				owner: repositoryOwner,
				repo: repositoryName,
				artifact_id: getArtifactResp.artifact.id
			});
			if (deleteArtifactResp.status !== 204) throw new errors_1.InvalidResponseError(`Invalid response from GitHub API: ${deleteArtifactResp.status} (${(_a = deleteArtifactResp === null || deleteArtifactResp === void 0 ? void 0 : deleteArtifactResp.headers) === null || _a === void 0 ? void 0 : _a["x-github-request-id"]})`);
			return { id: getArtifactResp.artifact.id };
		});
	}
	function deleteArtifactInternal(artifactName) {
		return __awaiter(this, void 0, void 0, function* () {
			const artifactClient$1 = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
			const { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)();
			const listReq = {
				workflowRunBackendId,
				workflowJobRunBackendId,
				nameFilter: generated_1.StringValue.create({ value: artifactName })
			};
			const listRes = yield artifactClient$1.ListArtifacts(listReq);
			if (listRes.artifacts.length === 0) throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}`);
			let artifact = listRes.artifacts[0];
			if (listRes.artifacts.length > 1) {
				artifact = listRes.artifacts.sort((a, b) => Number(b.databaseId) - Number(a.databaseId))[0];
				(0, core_1.debug)(`More than one artifact found for a single name, returning newest (id: ${artifact.databaseId})`);
			}
			const req = {
				workflowRunBackendId: artifact.workflowRunBackendId,
				workflowJobRunBackendId: artifact.workflowJobRunBackendId,
				name: artifact.name
			};
			const res = yield artifactClient$1.DeleteArtifact(req);
			(0, core_1.info)(`Artifact '${artifactName}' (ID: ${res.artifactId}) deleted`);
			return { id: Number(res.artifactId) };
		});
	}
}));
var require_list_artifacts = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.listArtifactsPublic = listArtifactsPublic;
	exports.listArtifactsInternal = listArtifactsInternal;
	var core_1 = require_core$1();
	var github_1 = require_github();
	var user_agent_1 = require_user_agent();
	var retry_options_1 = require_retry_options();
	var utils_1 = require_utils$3();
	var plugin_request_log_1 = (init_dist_web$1(), __toCommonJS(dist_web_exports$1));
	var plugin_retry_1 = (init_dist_web(), __toCommonJS(dist_web_exports));
	var artifact_twirp_client_1 = require_artifact_twirp_client();
	var util_1 = require_util$5();
	var config_1 = require_config();
	var generated_1 = require_generated();
	var maximumArtifactCount = (0, config_1.getMaxArtifactListCount)();
	var paginationCount = 100;
	var maxNumberOfPages = Math.ceil(maximumArtifactCount / paginationCount);
	function listArtifactsPublic(workflowRunId_1, repositoryOwner_1, repositoryName_1, token_1) {
		return __awaiter(this, arguments, void 0, function* (workflowRunId, repositoryOwner, repositoryName, token, latest = false) {
			(0, core_1.info)(`Fetching artifact list for workflow run ${workflowRunId} in repository ${repositoryOwner}/${repositoryName}`);
			let artifacts = [];
			const [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults);
			const opts = {
				log: void 0,
				userAgent: (0, user_agent_1.getUserAgentString)(),
				previews: void 0,
				retry: retryOpts,
				request: requestOpts
			};
			const github = (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog);
			let currentPageNumber = 1;
			const { data: listArtifactResponse } = yield github.request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", {
				owner: repositoryOwner,
				repo: repositoryName,
				run_id: workflowRunId,
				per_page: paginationCount,
				page: currentPageNumber
			});
			let numberOfPages = Math.ceil(listArtifactResponse.total_count / paginationCount);
			const totalArtifactCount = listArtifactResponse.total_count;
			if (totalArtifactCount > maximumArtifactCount) {
				(0, core_1.warning)(`Workflow run ${workflowRunId} has ${totalArtifactCount} artifacts, exceeding the limit of ${maximumArtifactCount}. Results will be incomplete as only the first ${maximumArtifactCount} artifacts will be returned`);
				numberOfPages = maxNumberOfPages;
			}
			for (const artifact of listArtifactResponse.artifacts) artifacts.push({
				name: artifact.name,
				id: artifact.id,
				size: artifact.size_in_bytes,
				createdAt: artifact.created_at ? new Date(artifact.created_at) : void 0,
				digest: artifact.digest
			});
			currentPageNumber++;
			for (; currentPageNumber <= numberOfPages; currentPageNumber++) {
				(0, core_1.debug)(`Fetching page ${currentPageNumber} of artifact list`);
				const { data: listArtifactResponse$1 } = yield github.request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", {
					owner: repositoryOwner,
					repo: repositoryName,
					run_id: workflowRunId,
					per_page: paginationCount,
					page: currentPageNumber
				});
				for (const artifact of listArtifactResponse$1.artifacts) artifacts.push({
					name: artifact.name,
					id: artifact.id,
					size: artifact.size_in_bytes,
					createdAt: artifact.created_at ? new Date(artifact.created_at) : void 0,
					digest: artifact.digest
				});
			}
			if (latest) artifacts = filterLatest(artifacts);
			(0, core_1.info)(`Found ${artifacts.length} artifact(s)`);
			return { artifacts };
		});
	}
	function listArtifactsInternal() {
		return __awaiter(this, arguments, void 0, function* (latest = false) {
			const artifactClient$1 = (0, artifact_twirp_client_1.internalArtifactTwirpClient)();
			const { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)();
			const req = {
				workflowRunBackendId,
				workflowJobRunBackendId
			};
			let artifacts = (yield artifactClient$1.ListArtifacts(req)).artifacts.map((artifact) => {
				var _a;
				return {
					name: artifact.name,
					id: Number(artifact.databaseId),
					size: Number(artifact.size),
					createdAt: artifact.createdAt ? generated_1.Timestamp.toDate(artifact.createdAt) : void 0,
					digest: (_a = artifact.digest) === null || _a === void 0 ? void 0 : _a.value
				};
			});
			if (latest) artifacts = filterLatest(artifacts);
			(0, core_1.info)(`Found ${artifacts.length} artifact(s)`);
			return { artifacts };
		});
	}
	function filterLatest(artifacts) {
		artifacts.sort((a, b) => b.id - a.id);
		const latestArtifacts = [];
		const seenArtifactNames = /* @__PURE__ */ new Set();
		for (const artifact of artifacts) if (!seenArtifactNames.has(artifact.name)) {
			latestArtifacts.push(artifact);
			seenArtifactNames.add(artifact.name);
		}
		return latestArtifacts;
	}
}));
var require_client = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value$1) {
			return value$1 instanceof P ? value$1 : new P(function(resolve$1) {
				resolve$1(value$1);
			});
		}
		return new (P || (P = Promise))(function(resolve$1, reject$3) {
			function fulfilled(value$1) {
				try {
					step(generator.next(value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function rejected(value$1) {
				try {
					step(generator["throw"](value$1));
				} catch (e$1) {
					reject$3(e$1);
				}
			}
			function step(result) {
				result.done ? resolve$1(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __rest = exports && exports.__rest || function(s, e$1) {
		var t$1 = {};
		for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e$1.indexOf(p) < 0) t$1[p] = s[p];
		if (s != null && typeof Object.getOwnPropertySymbols === "function") {
			for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e$1.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t$1[p[i]] = s[p[i]];
		}
		return t$1;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DefaultArtifactClient = void 0;
	var core_1 = require_core$1();
	var config_1 = require_config();
	var upload_artifact_1 = require_upload_artifact();
	var download_artifact_1 = require_download_artifact();
	var delete_artifact_1 = require_delete_artifact();
	var get_artifact_1 = require_get_artifact();
	var list_artifacts_1 = require_list_artifacts();
	var errors_1 = require_errors$2();
	var DefaultArtifactClient = class {
		uploadArtifact(name$1, files$1, rootDirectory, options) {
			return __awaiter(this, void 0, void 0, function* () {
				try {
					if ((0, config_1.isGhes)()) throw new errors_1.GHESNotSupportedError();
					return (0, upload_artifact_1.uploadArtifact)(name$1, files$1, rootDirectory, options);
				} catch (error) {
					(0, core_1.warning)(`Artifact upload failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions is operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
					throw error;
				}
			});
		}
		downloadArtifact(artifactId, options) {
			return __awaiter(this, void 0, void 0, function* () {
				try {
					if ((0, config_1.isGhes)()) throw new errors_1.GHESNotSupportedError();
					if (options === null || options === void 0 ? void 0 : options.findBy) {
						const { findBy: { repositoryOwner, repositoryName, token } } = options, downloadOptions = __rest(options, ["findBy"]);
						return (0, download_artifact_1.downloadArtifactPublic)(artifactId, repositoryOwner, repositoryName, token, downloadOptions);
					}
					return (0, download_artifact_1.downloadArtifactInternal)(artifactId, options);
				} catch (error) {
					(0, core_1.warning)(`Download Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
					throw error;
				}
			});
		}
		listArtifacts(options) {
			return __awaiter(this, void 0, void 0, function* () {
				try {
					if ((0, config_1.isGhes)()) throw new errors_1.GHESNotSupportedError();
					if (options === null || options === void 0 ? void 0 : options.findBy) {
						const { findBy: { workflowRunId, repositoryOwner, repositoryName, token } } = options;
						return (0, list_artifacts_1.listArtifactsPublic)(workflowRunId, repositoryOwner, repositoryName, token, options === null || options === void 0 ? void 0 : options.latest);
					}
					return (0, list_artifacts_1.listArtifactsInternal)(options === null || options === void 0 ? void 0 : options.latest);
				} catch (error) {
					(0, core_1.warning)(`Listing Artifacts failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
					throw error;
				}
			});
		}
		getArtifact(artifactName, options) {
			return __awaiter(this, void 0, void 0, function* () {
				try {
					if ((0, config_1.isGhes)()) throw new errors_1.GHESNotSupportedError();
					if (options === null || options === void 0 ? void 0 : options.findBy) {
						const { findBy: { workflowRunId, repositoryOwner, repositoryName, token } } = options;
						return (0, get_artifact_1.getArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
					}
					return (0, get_artifact_1.getArtifactInternal)(artifactName);
				} catch (error) {
					(0, core_1.warning)(`Get Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
					throw error;
				}
			});
		}
		deleteArtifact(artifactName, options) {
			return __awaiter(this, void 0, void 0, function* () {
				try {
					if ((0, config_1.isGhes)()) throw new errors_1.GHESNotSupportedError();
					if (options === null || options === void 0 ? void 0 : options.findBy) {
						const { findBy: { repositoryOwner, repositoryName, workflowRunId, token } } = options;
						return (0, delete_artifact_1.deleteArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
					}
					return (0, delete_artifact_1.deleteArtifactInternal)(artifactName);
				} catch (error) {
					(0, core_1.warning)(`Delete Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
					throw error;
				}
			});
		}
	};
	exports.DefaultArtifactClient = DefaultArtifactClient;
}));
var require_interfaces = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
}));
var import_artifact = (/* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m, k);
		if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m[k];
			}
		};
		Object.defineProperty(o$1, k2, desc);
	}) : (function(o$1, m, k, k2) {
		if (k2 === void 0) k2 = k;
		o$1[k2] = m[k];
	}));
	var __exportStar = exports && exports.__exportStar || function(m, exports$1) {
		for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var client_1 = require_client();
	__exportStar(require_interfaces(), exports);
	__exportStar(require_errors$2(), exports);
	__exportStar(require_client(), exports);
	exports.default = new client_1.DefaultArtifactClient();
})))();
var import_github = /* @__PURE__ */ __toESM(require_github(), 1);
var nixIdentifierPattern = "[a-zA-Z_][a-zA-Z0-9_'-]*";
var attributePathPattern = /* @__PURE__ */ new RegExp(`^${nixIdentifierPattern}(\\.${nixIdentifierPattern})*$`);
var AttributePath = NonEmptyString.pipe(filter$2((s) => !s.startsWith("#") && !s.startsWith(".#"), { message: () => "Attribute path must not start with '#' or '.#' - the reference prefix is added automatically" }), pattern(attributePathPattern, { message: () => "Invalid attribute path format. Expected format: 'packages.x86_64-linux.default' or 'nixosConfigurations.myhost.config.system.build.toplevel'" })).annotations({
	identifier: "AttributePath",
	description: "Nix attribute path (e.g., packages.x86_64-linux.default)",
	examples: [
		"packages.x86_64-linux.default",
		"nixosConfigurations.myhost.config.system.build.toplevel",
		"devShells.x86_64-linux.default"
	]
});
const NixOutputConfigArray = Array$(Struct({
	displayName: NonEmptyString.annotations({ description: "User-friendly name for this comparison" }),
	attribute: AttributePath.annotations({ description: "Nix attribute path (e.g., packages.x86_64-linux.default)" })
}).annotations({ identifier: "NixOutputConfig" })).annotations({ identifier: "NixOutputConfigArray" });
const DiffResultArray = Array$(Struct({
	displayName: NonEmptyString.annotations({ description: "User-friendly name from output config" }),
	attributePath: NonEmptyString.annotations({ description: "Nix attribute path that was compared" }),
	baseRef: NonEmptyString.annotations({ description: "Commit SHA of the base branch" }),
	prRef: NonEmptyString.annotations({ description: "Commit SHA of the PR head" }),
	diff: NonEmptyString.annotations({ description: "Diff output from dix tool" })
}).annotations({ identifier: "DiffResult" })).annotations({ identifier: "DiffResultArray" });
var artifactClient = new import_artifact.DefaultArtifactClient();
var withWarningOption = (effect$1, context$2) => effect$1.pipe(map$4(some$2), catchAll$2((error) => logWarning(`${context$2}: ${String(error)}`).pipe(as(none()))));
var downloadArtifact = (artId, artName, downloadPath, findBy) => tryPromise({
	try: () => artifactClient.downloadArtifact(artId, {
		path: downloadPath,
		findBy
	}),
	catch: (e$1) => new ArtifactError({
		name: artName,
		message: `Failed to download artifact: ${e$1}`
	})
});
var readResultFile = (downloadPath, artName) => tryPromise({
	try: () => fs.readFile(nodePath$1.join(downloadPath, "result.json"), "utf-8"),
	catch: (e$1) => new ArtifactError({
		name: artName,
		message: `Failed to read result file: ${e$1}`
	})
});
var parseJson = (content, artName) => try_({
	try: () => JSON.parse(content),
	catch: (e$1) => new ArtifactError({
		name: artName,
		message: `Failed to parse JSON: ${e$1}`
	})
});
var decodeResults = (parsed, artName) => decodeUnknown(DiffResultArray)(parsed).pipe(mapError$2((error) => new ArtifactError({
	name: artName,
	message: `Invalid format: ${error}`
})));
var downloadAndParseArtifact = (art, downloadPath, findBy) => gen(function* () {
	const artifactDownloadPath = (yield* withWarningOption(downloadArtifact(art.id, art.name, downloadPath, findBy), `Download artifact ${art.name}`)).pipe(flatMap$2((r$1) => fromNullable(r$1.downloadPath)));
	if (isNone(artifactDownloadPath)) {
		yield* logWarning(`Artifact ${art.name} has no download path`);
		return [];
	}
	const contentOption = yield* withWarningOption(readResultFile(artifactDownloadPath.value, art.name), `Read artifact ${art.name}`);
	if (isNone(contentOption)) return [];
	const parsedOption = yield* withWarningOption(parseJson(contentOption.value, art.name), `Parse artifact ${art.name}`);
	if (isNone(parsedOption)) return [];
	return yield* decodeResults(parsedOption.value, art.name).pipe(catchAll$2((error) => logWarning(`Decode artifact ${art.name}: ${String(error)}`).pipe(as([]))));
});
const createArtifactName = (displayName) => {
	return `diff-result-${displayName.replace(/[^a-zA-Z0-9-_]/g, "-")}-${crypto$1.createHash("sha256").update(displayName).digest("hex").slice(0, 6)}`;
};
var ArtifactService = class extends Service()("ArtifactService", { succeed: {
	uploadDiffResults: (results, displayName) => {
		const artifactName = createArtifactName(displayName);
		return gen(function* () {
			const tempDir = yield* tryPromise({
				try: () => fs.mkdtemp(nodePath$1.join(os.tmpdir(), "dix-")),
				catch: (e$1) => new ArtifactError({
					name: artifactName,
					message: `Failed to create temp directory: ${e$1}`
				})
			});
			const resultPath = nodePath$1.join(tempDir, "result.json");
			yield* tryPromise({
				try: () => fs.writeFile(resultPath, JSON.stringify(results, null, 2)),
				catch: (e$1) => new ArtifactError({
					name: artifactName,
					message: `Failed to write results file: ${e$1}`
				})
			});
			yield* tryPromise({
				try: () => artifactClient.uploadArtifact(artifactName, [resultPath], tempDir),
				catch: (e$1) => new ArtifactError({
					name: artifactName,
					message: `Failed to upload artifact: ${e$1}`
				})
			});
			yield* logInfo(`Uploaded artifact: ${artifactName}`);
			return artifactName;
		});
	},
	downloadAllDiffResults: (token, runId, owner, repo) => {
		const downloadPath = nodePath$1.join(os.tmpdir(), "dix-results");
		const findBy = {
			token,
			workflowRunId: runId,
			repositoryOwner: owner,
			repositoryName: repo
		};
		return gen(function* () {
			yield* tryPromise({
				try: () => fs.mkdir(downloadPath, { recursive: true }),
				catch: (e$1) => new ArtifactError({
					name: "download",
					message: `Failed to create download directory: ${e$1}`
				})
			});
			return (yield* forEach((yield* tryPromise({
				try: () => artifactClient.listArtifacts({ findBy }),
				catch: (e$1) => new ArtifactError({
					name: "list",
					message: `Failed to list artifacts: ${e$1}`
				})
			})).artifacts.filter((a) => a.name.startsWith("diff-result-")), (art) => downloadAndParseArtifact(art, downloadPath, findBy), { concurrency: "unbounded" })).flat();
		});
	}
} }) {};
const hasDixChanges = (diff) => {
	if (!diff || diff.trim() === "") return false;
	const baseMatch = diff.match(/^<<<\s*(.+)$/m);
	const prMatch = diff.match(/^>>>\s*(.+)$/m);
	if (!baseMatch || !prMatch) return true;
	return baseMatch[1].trim() !== prMatch[1].trim();
};
var NIX_DIFF_ACTION_MARKER_BASE = "<!-- nix-diff-action";
var getNixDiffActionMarker = (displayName) => displayName ? `${NIX_DIFF_ACTION_MARKER_BASE}:${displayName} -->` : `${NIX_DIFF_ACTION_MARKER_BASE} -->`;
var MAX_COMMENT_LENGTH = 6e4;
var HEADER_FOOTER_OVERHEAD = 300;
var PER_SECTION_OVERHEAD = 300;
const truncateDiff = (diff, maxLength) => {
	if (diff.length <= maxLength) return {
		text: diff,
		truncated: false
	};
	return {
		text: `${diff.slice(0, maxLength)}\n\n... (truncated, ${diff.length} chars total)`,
		truncated: true
	};
};
const sanitizeDisplayName = (text) => text.replace(/[\\`*_{}[\]()#+!|]/g, "");
var calculateMaxDiffPerAttribute = (attributeCount) => {
	const availableForDiffs = MAX_COMMENT_LENGTH - HEADER_FOOTER_OVERHEAD - PER_SECTION_OVERHEAD * attributeCount;
	return Math.max(1e3, Math.floor(availableForDiffs / attributeCount));
};
const checkIfAnyDiffTruncated = (results) => {
	const maxLength = calculateMaxDiffPerAttribute(results.length);
	return results.some((r$1) => r$1.diff.length > maxLength);
};
const formatAggregatedComment = (results, headSha, options) => {
	const maxDiffLength = calculateMaxDiffPerAttribute(results.length);
	const marker = results.length === 1 ? getNixDiffActionMarker(results[0].displayName) : getNixDiffActionMarker();
	const sections = results.map((result) => {
		const { truncated, text } = truncateDiff(result.diff || "No differences found", maxDiffLength);
		const artifactHint = truncated && options?.runId && options?.repoUrl ? `\n\n> **Note**: Diff was truncated. [View full diff in artifacts](${options.repoUrl}/actions/runs/${options.runId})` : "";
		return `### ${sanitizeDisplayName(result.displayName)}

**Attribute**: \`${result.attributePath}\`

<details>
<summary>Diff Output</summary>

\`\`\`
${text}
\`\`\`
${artifactHint}
</details>`;
	}).join("\n\n");
	return `${marker}
## Nix Diff

${options?.repoUrl ? `[Compare changes](${options.repoUrl}/compare/${results[0].baseRef}...${results[0].prRef})` : `\`${results[0].baseRef}...${results[0].prRef}\``}

${sections}

${`---
<sub>Generated by [nix-diff-action](https://github.com/natsukium/nix-diff-action) using [dix](https://github.com/faukah/dix)</sub>
<!-- nix-diff-action-footer sha=${headSha} -->`}`;
};
var listNixDiffComments = (octokit, context$2, prNumber, displayName) => tryPromise({
	try: () => octokit.paginate(octokit.rest.issues.listComments, {
		...context$2.repo,
		issue_number: prNumber
	}),
	catch: (e$1) => new GitHubApiError({
		operation: "listComments",
		message: `Failed to list comments: ${e$1}`
	})
}).pipe(map$4((comments) => {
	const marker = getNixDiffActionMarker(displayName);
	return comments.filter((c) => c.body?.includes(marker));
}));
var findExistingNixDiffComment = (octokit, context$2, prNumber, displayName) => listNixDiffComments(octokit, context$2, prNumber, displayName).pipe(map$4((comments) => fromNullable(comments[0])), map$4(map$5((c) => ({ id: c.id }))));
var findOldNixDiffComments = (octokit, context$2, prNumber, currentHeadSha, displayName) => listNixDiffComments(octokit, context$2, prNumber, displayName).pipe(map$4((comments) => comments.filter((c) => !c.body?.includes(`sha=${currentHeadSha}`)).map((c) => ({
	id: c.id,
	node_id: c.node_id
}))));
var minimizeOldComments = (octokit, context$2, prNumber, currentHeadSha, displayName) => findOldNixDiffComments(octokit, context$2, prNumber, currentHeadSha, displayName).pipe(flatMap$3((oldComments) => forEach(oldComments, (comment) => tryPromise({
	try: () => octokit.graphql(`
                mutation($input: MinimizeCommentInput!) {
                  minimizeComment(input: $input) {
                    minimizedComment {
                      isMinimized
                    }
                  }
                }
                `, { input: {
		subjectId: comment.node_id,
		classifier: "OUTDATED"
	} }),
	catch: (e$1) => new GitHubApiError({
		operation: "minimizeComment",
		message: `Failed to minimize comment ${comment.id}: ${e$1}`
	})
}).pipe(flatMap$3(() => logInfo(`Minimized outdated comment (ID: ${comment.id})`)), catchAll$2((error) => logWarning(`Failed to minimize comment ${comment.id}: ${error.message}`))), { concurrency: "unbounded" })));
var updateComment = (octokit, context$2, commentId, body) => tryPromise({
	try: () => octokit.rest.issues.updateComment({
		...context$2.repo,
		comment_id: commentId,
		body
	}),
	catch: (e$1) => new GitHubApiError({
		operation: "updateComment",
		message: `Failed to update comment: ${e$1}`
	})
});
var createComment = (octokit, context$2, prNumber, body) => tryPromise({
	try: () => octokit.rest.issues.createComment({
		...context$2.repo,
		issue_number: prNumber,
		body
	}),
	catch: (e$1) => new GitHubApiError({
		operation: "createComment",
		message: `Failed to create comment: ${e$1}`
	})
});
var GitHubService = class extends Service()("GitHubService", { succeed: {
	getContext: () => import_github.context,
	getPullRequest: () => gen(function* () {
		const pr = import_github.context.payload.pull_request;
		if (!pr) return yield* fail$2(new NotPullRequestContextError({ message: "This action must be run in a pull request context" }));
		return pr;
	}),
	createOctokit: (token) => import_github.getOctokit(token),
	postAggregatedComment: (octokit, context$2, pr, results, options, formatOptions) => gen(function* () {
		const hasChanges = results.some((r$1) => hasDixChanges(r$1.diff));
		const commentBody = formatAggregatedComment(results, pr.head.sha, formatOptions);
		const displayName = results.length === 1 ? results[0].displayName : void 0;
		if (options.skipNoChange && !hasChanges) return yield* logInfo("No differences found. Skipping comment (skip-no-change is enabled).");
		if (options.commentStrategy === "update") return yield* match$2(yield* findExistingNixDiffComment(octokit, context$2, pr.number, displayName), {
			onNone: () => gen(function* () {
				yield* createComment(octokit, context$2, pr.number, commentBody);
				yield* logInfo("Posted new aggregated diff comment to PR");
			}),
			onSome: (e$1) => gen(function* () {
				yield* updateComment(octokit, context$2, e$1.id, commentBody);
				yield* logInfo("Updated existing diff comment");
			})
		});
		if (options.commentStrategy === "create") yield* minimizeOldComments(octokit, context$2, pr.number, pr.head.sha, displayName);
		yield* createComment(octokit, context$2, pr.number, commentBody);
		yield* logInfo("Posted new aggregated diff comment to PR");
	})
} }) {};
const MainLayer = mergeAll(GitService.Default, NixService.Default, GitHubService.Default, ArtifactService.Default);
var ActionsConfigProvider = pipe(fromEnv(), orElse(() => fromMap(new Map([
	["mode", import_core$2.getInput("mode")],
	["github-token", import_core$2.getInput("github-token")],
	["attributes", import_core$2.getInput("attributes")],
	["directory", import_core$2.getInput("directory")],
	["build", import_core$2.getInput("build")],
	["skip-no-change", import_core$2.getInput("skip-no-change")],
	["comment-strategy", import_core$2.getInput("comment-strategy")]
]))));
var ModeSchema = Literal("full", "diff-only", "comment-only");
var CommentStrategySchema$1 = Literal("create", "update");
const ActionConfig = {
	mode: Config("mode", ModeSchema),
	githubToken: redacted(string("github-token")),
	attributes: string("attributes"),
	directory: string("directory"),
	build: boolean("build"),
	skipNoChange: boolean("skip-no-change"),
	commentStrategy: Config("comment-strategy", CommentStrategySchema$1),
	githubRunId: option(string("GITHUB_RUN_ID"))
};
const ConfigProviderLayer = setConfigProvider(ActionsConfigProvider);
var require_identity = /* @__PURE__ */ __commonJSMin(((exports) => {
	var ALIAS = Symbol.for("yaml.alias");
	var DOC = Symbol.for("yaml.document");
	var MAP = Symbol.for("yaml.map");
	var PAIR = Symbol.for("yaml.pair");
	var SCALAR = Symbol.for("yaml.scalar");
	var SEQ = Symbol.for("yaml.seq");
	var NODE_TYPE = Symbol.for("yaml.node.type");
	var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
	var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
	var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
	var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
	var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
	var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
	function isCollection(node) {
		if (node && typeof node === "object") switch (node[NODE_TYPE]) {
			case MAP:
			case SEQ: return true;
		}
		return false;
	}
	function isNode(node) {
		if (node && typeof node === "object") switch (node[NODE_TYPE]) {
			case ALIAS:
			case MAP:
			case SCALAR:
			case SEQ: return true;
		}
		return false;
	}
	var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
	exports.ALIAS = ALIAS;
	exports.DOC = DOC;
	exports.MAP = MAP;
	exports.NODE_TYPE = NODE_TYPE;
	exports.PAIR = PAIR;
	exports.SCALAR = SCALAR;
	exports.SEQ = SEQ;
	exports.hasAnchor = hasAnchor;
	exports.isAlias = isAlias;
	exports.isCollection = isCollection;
	exports.isDocument = isDocument;
	exports.isMap = isMap;
	exports.isNode = isNode;
	exports.isPair = isPair;
	exports.isScalar = isScalar;
	exports.isSeq = isSeq;
}));
var require_visit = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var BREAK = Symbol("break visit");
	var SKIP = Symbol("skip children");
	var REMOVE = Symbol("remove node");
	function visit(node, visitor) {
		const visitor_ = initVisitor(visitor);
		if (identity.isDocument(node)) {
			if (visit_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE) node.contents = null;
		} else visit_(null, node, visitor_, Object.freeze([]));
	}
	visit.BREAK = BREAK;
	visit.SKIP = SKIP;
	visit.REMOVE = REMOVE;
	function visit_(key, node, visitor, path$5) {
		const ctrl = callVisitor(key, node, visitor, path$5);
		if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
			replaceNode(key, path$5, ctrl);
			return visit_(key, ctrl, visitor, path$5);
		}
		if (typeof ctrl !== "symbol") {
			if (identity.isCollection(node)) {
				path$5 = Object.freeze(path$5.concat(node));
				for (let i = 0; i < node.items.length; ++i) {
					const ci = visit_(i, node.items[i], visitor, path$5);
					if (typeof ci === "number") i = ci - 1;
					else if (ci === BREAK) return BREAK;
					else if (ci === REMOVE) {
						node.items.splice(i, 1);
						i -= 1;
					}
				}
			} else if (identity.isPair(node)) {
				path$5 = Object.freeze(path$5.concat(node));
				const ck = visit_("key", node.key, visitor, path$5);
				if (ck === BREAK) return BREAK;
				else if (ck === REMOVE) node.key = null;
				const cv = visit_("value", node.value, visitor, path$5);
				if (cv === BREAK) return BREAK;
				else if (cv === REMOVE) node.value = null;
			}
		}
		return ctrl;
	}
	async function visitAsync(node, visitor) {
		const visitor_ = initVisitor(visitor);
		if (identity.isDocument(node)) {
			if (await visitAsync_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE) node.contents = null;
		} else await visitAsync_(null, node, visitor_, Object.freeze([]));
	}
	visitAsync.BREAK = BREAK;
	visitAsync.SKIP = SKIP;
	visitAsync.REMOVE = REMOVE;
	async function visitAsync_(key, node, visitor, path$5) {
		const ctrl = await callVisitor(key, node, visitor, path$5);
		if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
			replaceNode(key, path$5, ctrl);
			return visitAsync_(key, ctrl, visitor, path$5);
		}
		if (typeof ctrl !== "symbol") {
			if (identity.isCollection(node)) {
				path$5 = Object.freeze(path$5.concat(node));
				for (let i = 0; i < node.items.length; ++i) {
					const ci = await visitAsync_(i, node.items[i], visitor, path$5);
					if (typeof ci === "number") i = ci - 1;
					else if (ci === BREAK) return BREAK;
					else if (ci === REMOVE) {
						node.items.splice(i, 1);
						i -= 1;
					}
				}
			} else if (identity.isPair(node)) {
				path$5 = Object.freeze(path$5.concat(node));
				const ck = await visitAsync_("key", node.key, visitor, path$5);
				if (ck === BREAK) return BREAK;
				else if (ck === REMOVE) node.key = null;
				const cv = await visitAsync_("value", node.value, visitor, path$5);
				if (cv === BREAK) return BREAK;
				else if (cv === REMOVE) node.value = null;
			}
		}
		return ctrl;
	}
	function initVisitor(visitor) {
		if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) return Object.assign({
			Alias: visitor.Node,
			Map: visitor.Node,
			Scalar: visitor.Node,
			Seq: visitor.Node
		}, visitor.Value && {
			Map: visitor.Value,
			Scalar: visitor.Value,
			Seq: visitor.Value
		}, visitor.Collection && {
			Map: visitor.Collection,
			Seq: visitor.Collection
		}, visitor);
		return visitor;
	}
	function callVisitor(key, node, visitor, path$5) {
		if (typeof visitor === "function") return visitor(key, node, path$5);
		if (identity.isMap(node)) return visitor.Map?.(key, node, path$5);
		if (identity.isSeq(node)) return visitor.Seq?.(key, node, path$5);
		if (identity.isPair(node)) return visitor.Pair?.(key, node, path$5);
		if (identity.isScalar(node)) return visitor.Scalar?.(key, node, path$5);
		if (identity.isAlias(node)) return visitor.Alias?.(key, node, path$5);
	}
	function replaceNode(key, path$5, node) {
		const parent$1 = path$5[path$5.length - 1];
		if (identity.isCollection(parent$1)) parent$1.items[key] = node;
		else if (identity.isPair(parent$1)) if (key === "key") parent$1.key = node;
		else parent$1.value = node;
		else if (identity.isDocument(parent$1)) parent$1.contents = node;
		else {
			const pt = identity.isAlias(parent$1) ? "alias" : "scalar";
			throw new Error(`Cannot replace node with ${pt} parent`);
		}
	}
	exports.visit = visit;
	exports.visitAsync = visitAsync;
}));
var require_directives = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var visit = require_visit();
	var escapeChars = {
		"!": "%21",
		",": "%2C",
		"[": "%5B",
		"]": "%5D",
		"{": "%7B",
		"}": "%7D"
	};
	var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
	var Directives = class Directives {
		constructor(yaml, tags) {
			this.docStart = null;
			this.docEnd = false;
			this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
			this.tags = Object.assign({}, Directives.defaultTags, tags);
		}
		clone() {
			const copy$1 = new Directives(this.yaml, this.tags);
			copy$1.docStart = this.docStart;
			return copy$1;
		}
		atDocument() {
			const res = new Directives(this.yaml, this.tags);
			switch (this.yaml.version) {
				case "1.1":
					this.atNextDocument = true;
					break;
				case "1.2":
					this.atNextDocument = false;
					this.yaml = {
						explicit: Directives.defaultYaml.explicit,
						version: "1.2"
					};
					this.tags = Object.assign({}, Directives.defaultTags);
					break;
			}
			return res;
		}
		add(line, onError) {
			if (this.atNextDocument) {
				this.yaml = {
					explicit: Directives.defaultYaml.explicit,
					version: "1.1"
				};
				this.tags = Object.assign({}, Directives.defaultTags);
				this.atNextDocument = false;
			}
			const parts = line.trim().split(/[ \t]+/);
			const name$1 = parts.shift();
			switch (name$1) {
				case "%TAG": {
					if (parts.length !== 2) {
						onError(0, "%TAG directive should contain exactly two parts");
						if (parts.length < 2) return false;
					}
					const [handle, prefix] = parts;
					this.tags[handle] = prefix;
					return true;
				}
				case "%YAML": {
					this.yaml.explicit = true;
					if (parts.length !== 1) {
						onError(0, "%YAML directive should contain exactly one part");
						return false;
					}
					const [version$1] = parts;
					if (version$1 === "1.1" || version$1 === "1.2") {
						this.yaml.version = version$1;
						return true;
					} else {
						const isValid = /^\d+\.\d+$/.test(version$1);
						onError(6, `Unsupported YAML version ${version$1}`, isValid);
						return false;
					}
				}
				default:
					onError(0, `Unknown directive ${name$1}`, true);
					return false;
			}
		}
		tagName(source, onError) {
			if (source === "!") return "!";
			if (source[0] !== "!") {
				onError(`Not a valid tag: ${source}`);
				return null;
			}
			if (source[1] === "<") {
				const verbatim = source.slice(2, -1);
				if (verbatim === "!" || verbatim === "!!") {
					onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
					return null;
				}
				if (source[source.length - 1] !== ">") onError("Verbatim tags must end with a >");
				return verbatim;
			}
			const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
			if (!suffix) onError(`The ${source} tag has no suffix`);
			const prefix = this.tags[handle];
			if (prefix) try {
				return prefix + decodeURIComponent(suffix);
			} catch (error) {
				onError(String(error));
				return null;
			}
			if (handle === "!") return source;
			onError(`Could not resolve tag: ${source}`);
			return null;
		}
		tagString(tag) {
			for (const [handle, prefix] of Object.entries(this.tags)) if (tag.startsWith(prefix)) return handle + escapeTagName(tag.substring(prefix.length));
			return tag[0] === "!" ? tag : `!<${tag}>`;
		}
		toString(doc) {
			const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
			const tagEntries = Object.entries(this.tags);
			let tagNames;
			if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
				const tags = {};
				visit.visit(doc.contents, (_key, node) => {
					if (identity.isNode(node) && node.tag) tags[node.tag] = true;
				});
				tagNames = Object.keys(tags);
			} else tagNames = [];
			for (const [handle, prefix] of tagEntries) {
				if (handle === "!!" && prefix === "tag:yaml.org,2002:") continue;
				if (!doc || tagNames.some((tn) => tn.startsWith(prefix))) lines.push(`%TAG ${handle} ${prefix}`);
			}
			return lines.join("\n");
		}
	};
	Directives.defaultYaml = {
		explicit: false,
		version: "1.2"
	};
	Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
	exports.Directives = Directives;
}));
var require_anchors = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var visit = require_visit();
	function anchorIsValid(anchor) {
		if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
			const msg = `Anchor must not contain whitespace or control characters: ${JSON.stringify(anchor)}`;
			throw new Error(msg);
		}
		return true;
	}
	function anchorNames(root) {
		const anchors = /* @__PURE__ */ new Set();
		visit.visit(root, { Value(_key, node) {
			if (node.anchor) anchors.add(node.anchor);
		} });
		return anchors;
	}
	function findNewAnchor(prefix, exclude) {
		for (let i = 1;; ++i) {
			const name$1 = `${prefix}${i}`;
			if (!exclude.has(name$1)) return name$1;
		}
	}
	function createNodeAnchors(doc, prefix) {
		const aliasObjects = [];
		const sourceObjects = /* @__PURE__ */ new Map();
		let prevAnchors = null;
		return {
			onAnchor: (source) => {
				aliasObjects.push(source);
				prevAnchors ?? (prevAnchors = anchorNames(doc));
				const anchor = findNewAnchor(prefix, prevAnchors);
				prevAnchors.add(anchor);
				return anchor;
			},
			setAnchors: () => {
				for (const source of aliasObjects) {
					const ref = sourceObjects.get(source);
					if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) ref.node.anchor = ref.anchor;
					else {
						const error = /* @__PURE__ */ new Error("Failed to resolve repeated object (this should not happen)");
						error.source = source;
						throw error;
					}
				}
			},
			sourceObjects
		};
	}
	exports.anchorIsValid = anchorIsValid;
	exports.anchorNames = anchorNames;
	exports.createNodeAnchors = createNodeAnchors;
	exports.findNewAnchor = findNewAnchor;
}));
var require_applyReviver = /* @__PURE__ */ __commonJSMin(((exports) => {
	function applyReviver(reviver, obj, key, val) {
		if (val && typeof val === "object") if (Array.isArray(val)) for (let i = 0, len = val.length; i < len; ++i) {
			const v0 = val[i];
			const v1 = applyReviver(reviver, val, String(i), v0);
			if (v1 === void 0) delete val[i];
			else if (v1 !== v0) val[i] = v1;
		}
		else if (val instanceof Map) for (const k of Array.from(val.keys())) {
			const v0 = val.get(k);
			const v1 = applyReviver(reviver, val, k, v0);
			if (v1 === void 0) val.delete(k);
			else if (v1 !== v0) val.set(k, v1);
		}
		else if (val instanceof Set) for (const v0 of Array.from(val)) {
			const v1 = applyReviver(reviver, val, v0, v0);
			if (v1 === void 0) val.delete(v0);
			else if (v1 !== v0) {
				val.delete(v0);
				val.add(v1);
			}
		}
		else for (const [k, v0] of Object.entries(val)) {
			const v1 = applyReviver(reviver, val, k, v0);
			if (v1 === void 0) delete val[k];
			else if (v1 !== v0) val[k] = v1;
		}
		return reviver.call(obj, key, val);
	}
	exports.applyReviver = applyReviver;
}));
var require_toJS = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	function toJS(value$1, arg, ctx) {
		if (Array.isArray(value$1)) return value$1.map((v, i) => toJS(v, String(i), ctx));
		if (value$1 && typeof value$1.toJSON === "function") {
			if (!ctx || !identity.hasAnchor(value$1)) return value$1.toJSON(arg, ctx);
			const data = {
				aliasCount: 0,
				count: 1,
				res: void 0
			};
			ctx.anchors.set(value$1, data);
			ctx.onCreate = (res$1) => {
				data.res = res$1;
				delete ctx.onCreate;
			};
			const res = value$1.toJSON(arg, ctx);
			if (ctx.onCreate) ctx.onCreate(res);
			return res;
		}
		if (typeof value$1 === "bigint" && !ctx?.keep) return Number(value$1);
		return value$1;
	}
	exports.toJS = toJS;
}));
var require_Node = /* @__PURE__ */ __commonJSMin(((exports) => {
	var applyReviver = require_applyReviver();
	var identity = require_identity();
	var toJS = require_toJS();
	var NodeBase = class {
		constructor(type) {
			Object.defineProperty(this, identity.NODE_TYPE, { value: type });
		}
		clone() {
			const copy$1 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
			if (this.range) copy$1.range = this.range.slice();
			return copy$1;
		}
		toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
			if (!identity.isDocument(doc)) throw new TypeError("A document argument is required");
			const ctx = {
				anchors: /* @__PURE__ */ new Map(),
				doc,
				keep: true,
				mapAsMap: mapAsMap === true,
				mapKeyWarned: false,
				maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
			};
			const res = toJS.toJS(this, "", ctx);
			if (typeof onAnchor === "function") for (const { count, res: res$1 } of ctx.anchors.values()) onAnchor(res$1, count);
			return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
		}
	};
	exports.NodeBase = NodeBase;
}));
var require_Alias = /* @__PURE__ */ __commonJSMin(((exports) => {
	var anchors = require_anchors();
	var visit = require_visit();
	var identity = require_identity();
	var Node = require_Node();
	var toJS = require_toJS();
	var Alias = class extends Node.NodeBase {
		constructor(source) {
			super(identity.ALIAS);
			this.source = source;
			Object.defineProperty(this, "tag", { set() {
				throw new Error("Alias nodes cannot have tags");
			} });
		}
		resolve(doc, ctx) {
			let nodes;
			if (ctx?.aliasResolveCache) nodes = ctx.aliasResolveCache;
			else {
				nodes = [];
				visit.visit(doc, { Node: (_key, node) => {
					if (identity.isAlias(node) || identity.hasAnchor(node)) nodes.push(node);
				} });
				if (ctx) ctx.aliasResolveCache = nodes;
			}
			let found = void 0;
			for (const node of nodes) {
				if (node === this) break;
				if (node.anchor === this.source) found = node;
			}
			return found;
		}
		toJSON(_arg, ctx) {
			if (!ctx) return { source: this.source };
			const { anchors, doc, maxAliasCount } = ctx;
			const source = this.resolve(doc, ctx);
			if (!source) {
				const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
				throw new ReferenceError(msg);
			}
			let data = anchors.get(source);
			if (!data) {
				toJS.toJS(source, null, ctx);
				data = anchors.get(source);
			}
			/* istanbul ignore if */
			if (data?.res === void 0) throw new ReferenceError("This should not happen: Alias anchor was not resolved?");
			if (maxAliasCount >= 0) {
				data.count += 1;
				if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);
				if (data.count * data.aliasCount > maxAliasCount) throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack");
			}
			return data.res;
		}
		toString(ctx, _onComment, _onChompKeep) {
			const src = `*${this.source}`;
			if (ctx) {
				anchors.anchorIsValid(this.source);
				if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
					const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
					throw new Error(msg);
				}
				if (ctx.implicitKey) return `${src} `;
			}
			return src;
		}
	};
	function getAliasCount(doc, node, anchors) {
		if (identity.isAlias(node)) {
			const source = node.resolve(doc);
			const anchor = anchors && source && anchors.get(source);
			return anchor ? anchor.count * anchor.aliasCount : 0;
		} else if (identity.isCollection(node)) {
			let count = 0;
			for (const item of node.items) {
				const c = getAliasCount(doc, item, anchors);
				if (c > count) count = c;
			}
			return count;
		} else if (identity.isPair(node)) {
			const kc = getAliasCount(doc, node.key, anchors);
			const vc = getAliasCount(doc, node.value, anchors);
			return Math.max(kc, vc);
		}
		return 1;
	}
	exports.Alias = Alias;
}));
var require_Scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Node = require_Node();
	var toJS = require_toJS();
	var isScalarValue = (value$1) => !value$1 || typeof value$1 !== "function" && typeof value$1 !== "object";
	var Scalar = class extends Node.NodeBase {
		constructor(value$1) {
			super(identity.SCALAR);
			this.value = value$1;
		}
		toJSON(arg, ctx) {
			return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
		}
		toString() {
			return String(this.value);
		}
	};
	Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
	Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
	Scalar.PLAIN = "PLAIN";
	Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
	Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
	exports.Scalar = Scalar;
	exports.isScalarValue = isScalarValue;
}));
var require_createNode = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Alias = require_Alias();
	var identity = require_identity();
	var Scalar = require_Scalar();
	var defaultTagPrefix = "tag:yaml.org,2002:";
	function findTagObject(value$1, tagName, tags) {
		if (tagName) {
			const match$3 = tags.filter((t$1) => t$1.tag === tagName);
			const tagObj = match$3.find((t$1) => !t$1.format) ?? match$3[0];
			if (!tagObj) throw new Error(`Tag ${tagName} not found`);
			return tagObj;
		}
		return tags.find((t$1) => t$1.identify?.(value$1) && !t$1.format);
	}
	function createNode(value$1, tagName, ctx) {
		if (identity.isDocument(value$1)) value$1 = value$1.contents;
		if (identity.isNode(value$1)) return value$1;
		if (identity.isPair(value$1)) {
			const map$6 = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
			map$6.items.push(value$1);
			return map$6;
		}
		if (value$1 instanceof String || value$1 instanceof Number || value$1 instanceof Boolean || typeof BigInt !== "undefined" && value$1 instanceof BigInt) value$1 = value$1.valueOf();
		const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
		let ref = void 0;
		if (aliasDuplicateObjects && value$1 && typeof value$1 === "object") {
			ref = sourceObjects.get(value$1);
			if (ref) {
				ref.anchor ?? (ref.anchor = onAnchor(value$1));
				return new Alias.Alias(ref.anchor);
			} else {
				ref = {
					anchor: null,
					node: null
				};
				sourceObjects.set(value$1, ref);
			}
		}
		if (tagName?.startsWith("!!")) tagName = defaultTagPrefix + tagName.slice(2);
		let tagObj = findTagObject(value$1, tagName, schema.tags);
		if (!tagObj) {
			if (value$1 && typeof value$1.toJSON === "function") value$1 = value$1.toJSON();
			if (!value$1 || typeof value$1 !== "object") {
				const node$1 = new Scalar.Scalar(value$1);
				if (ref) ref.node = node$1;
				return node$1;
			}
			tagObj = value$1 instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value$1) ? schema[identity.SEQ] : schema[identity.MAP];
		}
		if (onTagObj) {
			onTagObj(tagObj);
			delete ctx.onTagObj;
		}
		const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value$1, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value$1, ctx) : new Scalar.Scalar(value$1);
		if (tagName) node.tag = tagName;
		else if (!tagObj.default) node.tag = tagObj.tag;
		if (ref) ref.node = node;
		return node;
	}
	exports.createNode = createNode;
}));
var require_Collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	var createNode = require_createNode();
	var identity = require_identity();
	var Node = require_Node();
	function collectionFromPath(schema, path$5, value$1) {
		let v = value$1;
		for (let i = path$5.length - 1; i >= 0; --i) {
			const k = path$5[i];
			if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
				const a = [];
				a[k] = v;
				v = a;
			} else v = new Map([[k, v]]);
		}
		return createNode.createNode(v, void 0, {
			aliasDuplicateObjects: false,
			keepUndefined: false,
			onAnchor: () => {
				throw new Error("This should not happen, please report a bug.");
			},
			schema,
			sourceObjects: /* @__PURE__ */ new Map()
		});
	}
	var isEmptyPath = (path$5) => path$5 == null || typeof path$5 === "object" && !!path$5[Symbol.iterator]().next().done;
	var Collection = class extends Node.NodeBase {
		constructor(type, schema) {
			super(type);
			Object.defineProperty(this, "schema", {
				value: schema,
				configurable: true,
				enumerable: false,
				writable: true
			});
		}
		clone(schema) {
			const copy$1 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
			if (schema) copy$1.schema = schema;
			copy$1.items = copy$1.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
			if (this.range) copy$1.range = this.range.slice();
			return copy$1;
		}
		addIn(path$5, value$1) {
			if (isEmptyPath(path$5)) this.add(value$1);
			else {
				const [key, ...rest] = path$5;
				const node = this.get(key, true);
				if (identity.isCollection(node)) node.addIn(rest, value$1);
				else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value$1));
				else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
			}
		}
		deleteIn(path$5) {
			const [key, ...rest] = path$5;
			if (rest.length === 0) return this.delete(key);
			const node = this.get(key, true);
			if (identity.isCollection(node)) return node.deleteIn(rest);
			else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
		}
		getIn(path$5, keepScalar) {
			const [key, ...rest] = path$5;
			const node = this.get(key, true);
			if (rest.length === 0) return !keepScalar && identity.isScalar(node) ? node.value : node;
			else return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
		}
		hasAllNullValues(allowScalar) {
			return this.items.every((node) => {
				if (!identity.isPair(node)) return false;
				const n$1 = node.value;
				return n$1 == null || allowScalar && identity.isScalar(n$1) && n$1.value == null && !n$1.commentBefore && !n$1.comment && !n$1.tag;
			});
		}
		hasIn(path$5) {
			const [key, ...rest] = path$5;
			if (rest.length === 0) return this.has(key);
			const node = this.get(key, true);
			return identity.isCollection(node) ? node.hasIn(rest) : false;
		}
		setIn(path$5, value$1) {
			const [key, ...rest] = path$5;
			if (rest.length === 0) this.set(key, value$1);
			else {
				const node = this.get(key, true);
				if (identity.isCollection(node)) node.setIn(rest, value$1);
				else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value$1));
				else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
			}
		}
	};
	exports.Collection = Collection;
	exports.collectionFromPath = collectionFromPath;
	exports.isEmptyPath = isEmptyPath;
}));
var require_stringifyComment = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
	function indentComment(comment, indent) {
		if (/^\n+$/.test(comment)) return comment.substring(1);
		return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
	}
	var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
	exports.indentComment = indentComment;
	exports.lineComment = lineComment;
	exports.stringifyComment = stringifyComment;
}));
var require_foldFlowLines = /* @__PURE__ */ __commonJSMin(((exports) => {
	var FOLD_FLOW = "flow";
	var FOLD_BLOCK = "block";
	var FOLD_QUOTED = "quoted";
	function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
		if (!lineWidth || lineWidth < 0) return text;
		if (lineWidth < minContentWidth) minContentWidth = 0;
		const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
		if (text.length <= endStep) return text;
		const folds = [];
		const escapedFolds = {};
		let end = lineWidth - indent.length;
		if (typeof indentAtStart === "number") if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
		else end = lineWidth - indentAtStart;
		let split = void 0;
		let prev = void 0;
		let overflow = false;
		let i = -1;
		let escStart = -1;
		let escEnd = -1;
		if (mode === FOLD_BLOCK) {
			i = consumeMoreIndentedLines(text, i, indent.length);
			if (i !== -1) end = i + endStep;
		}
		for (let ch; ch = text[i += 1];) {
			if (mode === FOLD_QUOTED && ch === "\\") {
				escStart = i;
				switch (text[i + 1]) {
					case "x":
						i += 3;
						break;
					case "u":
						i += 5;
						break;
					case "U":
						i += 9;
						break;
					default: i += 1;
				}
				escEnd = i;
			}
			if (ch === "\n") {
				if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i, indent.length);
				end = i + indent.length + endStep;
				split = void 0;
			} else {
				if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
					const next = text[i + 1];
					if (next && next !== " " && next !== "\n" && next !== "	") split = i;
				}
				if (i >= end) if (split) {
					folds.push(split);
					end = split + endStep;
					split = void 0;
				} else if (mode === FOLD_QUOTED) {
					while (prev === " " || prev === "	") {
						prev = ch;
						ch = text[i += 1];
						overflow = true;
					}
					const j = i > escEnd + 1 ? i - 2 : escStart - 1;
					if (escapedFolds[j]) return text;
					folds.push(j);
					escapedFolds[j] = true;
					end = j + endStep;
					split = void 0;
				} else overflow = true;
			}
			prev = ch;
		}
		if (overflow && onOverflow) onOverflow();
		if (folds.length === 0) return text;
		if (onFold) onFold();
		let res = text.slice(0, folds[0]);
		for (let i$1 = 0; i$1 < folds.length; ++i$1) {
			const fold = folds[i$1];
			const end$1 = folds[i$1 + 1] || text.length;
			if (fold === 0) res = `\n${indent}${text.slice(0, end$1)}`;
			else {
				if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
				res += `\n${indent}${text.slice(fold + 1, end$1)}`;
			}
		}
		return res;
	}
	function consumeMoreIndentedLines(text, i, indent) {
		let end = i;
		let start = i + 1;
		let ch = text[start];
		while (ch === " " || ch === "	") if (i < start + indent) ch = text[++i];
		else {
			do
				ch = text[++i];
			while (ch && ch !== "\n");
			end = i;
			start = i + 1;
			ch = text[start];
		}
		return end;
	}
	exports.FOLD_BLOCK = FOLD_BLOCK;
	exports.FOLD_FLOW = FOLD_FLOW;
	exports.FOLD_QUOTED = FOLD_QUOTED;
	exports.foldFlowLines = foldFlowLines;
}));
var require_stringifyString = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var foldFlowLines = require_foldFlowLines();
	var getFoldOptions = (ctx, isBlock) => ({
		indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
		lineWidth: ctx.options.lineWidth,
		minContentWidth: ctx.options.minContentWidth
	});
	var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
	function lineLengthOverLimit(str, lineWidth, indentLength) {
		if (!lineWidth || lineWidth < 0) return false;
		const limit = lineWidth - indentLength;
		const strLen = str.length;
		if (strLen <= limit) return false;
		for (let i = 0, start = 0; i < strLen; ++i) if (str[i] === "\n") {
			if (i - start > limit) return true;
			start = i + 1;
			if (strLen - start <= limit) return false;
		}
		return true;
	}
	function doubleQuotedString(value$1, ctx) {
		const json = JSON.stringify(value$1);
		if (ctx.options.doubleQuotedAsJSON) return json;
		const { implicitKey } = ctx;
		const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
		const indent = ctx.indent || (containsDocumentMarker(value$1) ? "  " : "");
		let str = "";
		let start = 0;
		for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
			if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
				str += json.slice(start, i) + "\\ ";
				i += 1;
				start = i;
				ch = "\\";
			}
			if (ch === "\\") switch (json[i + 1]) {
				case "u":
					{
						str += json.slice(start, i);
						const code = json.substr(i + 2, 4);
						switch (code) {
							case "0000":
								str += "\\0";
								break;
							case "0007":
								str += "\\a";
								break;
							case "000b":
								str += "\\v";
								break;
							case "001b":
								str += "\\e";
								break;
							case "0085":
								str += "\\N";
								break;
							case "00a0":
								str += "\\_";
								break;
							case "2028":
								str += "\\L";
								break;
							case "2029":
								str += "\\P";
								break;
							default: if (code.substr(0, 2) === "00") str += "\\x" + code.substr(2);
							else str += json.substr(i, 6);
						}
						i += 5;
						start = i + 1;
					}
					break;
				case "n":
					if (implicitKey || json[i + 2] === "\"" || json.length < minMultiLineLength) i += 1;
					else {
						str += json.slice(start, i) + "\n\n";
						while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== "\"") {
							str += "\n";
							i += 2;
						}
						str += indent;
						if (json[i + 2] === " ") str += "\\";
						i += 1;
						start = i + 1;
					}
					break;
				default: i += 1;
			}
		}
		str = start ? str + json.slice(start) : json;
		return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
	}
	function singleQuotedString(value$1, ctx) {
		if (ctx.options.singleQuote === false || ctx.implicitKey && value$1.includes("\n") || /[ \t]\n|\n[ \t]/.test(value$1)) return doubleQuotedString(value$1, ctx);
		const indent = ctx.indent || (containsDocumentMarker(value$1) ? "  " : "");
		const res = "'" + value$1.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
		return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
	}
	function quotedString(value$1, ctx) {
		const { singleQuote } = ctx.options;
		let qs;
		if (singleQuote === false) qs = doubleQuotedString;
		else {
			const hasDouble = value$1.includes("\"");
			const hasSingle = value$1.includes("'");
			if (hasDouble && !hasSingle) qs = singleQuotedString;
			else if (hasSingle && !hasDouble) qs = doubleQuotedString;
			else qs = singleQuote ? singleQuotedString : doubleQuotedString;
		}
		return qs(value$1, ctx);
	}
	var blockEndNewlines;
	try {
		blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
	} catch {
		blockEndNewlines = /\n+(?!\n|$)/g;
	}
	function blockString({ comment, type, value: value$1 }, ctx, onComment, onChompKeep) {
		const { blockQuote, commentString, lineWidth } = ctx.options;
		if (!blockQuote || /\n[\t ]+$/.test(value$1)) return quotedString(value$1, ctx);
		const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value$1) ? "  " : "");
		const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value$1, lineWidth, indent.length);
		if (!value$1) return literal ? "|\n" : ">\n";
		let chomp;
		let endStart;
		for (endStart = value$1.length; endStart > 0; --endStart) {
			const ch = value$1[endStart - 1];
			if (ch !== "\n" && ch !== "	" && ch !== " ") break;
		}
		let end = value$1.substring(endStart);
		const endNlPos = end.indexOf("\n");
		if (endNlPos === -1) chomp = "-";
		else if (value$1 === end || endNlPos !== end.length - 1) {
			chomp = "+";
			if (onChompKeep) onChompKeep();
		} else chomp = "";
		if (end) {
			value$1 = value$1.slice(0, -end.length);
			if (end[end.length - 1] === "\n") end = end.slice(0, -1);
			end = end.replace(blockEndNewlines, `$&${indent}`);
		}
		let startWithSpace = false;
		let startEnd;
		let startNlPos = -1;
		for (startEnd = 0; startEnd < value$1.length; ++startEnd) {
			const ch = value$1[startEnd];
			if (ch === " ") startWithSpace = true;
			else if (ch === "\n") startNlPos = startEnd;
			else break;
		}
		let start = value$1.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
		if (start) {
			value$1 = value$1.substring(start.length);
			start = start.replace(/\n+/g, `$&${indent}`);
		}
		let header = (startWithSpace ? indent ? "2" : "1" : "") + chomp;
		if (comment) {
			header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
			if (onComment) onComment();
		}
		if (!literal) {
			const foldedValue = value$1.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
			let literalFallback = false;
			const foldOptions = getFoldOptions(ctx, true);
			if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) foldOptions.onOverflow = () => {
				literalFallback = true;
			};
			const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
			if (!literalFallback) return `>${header}\n${indent}${body}`;
		}
		value$1 = value$1.replace(/\n+/g, `$&${indent}`);
		return `|${header}\n${indent}${start}${value$1}${end}`;
	}
	function plainString(item, ctx, onComment, onChompKeep) {
		const { type, value: value$1 } = item;
		const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
		if (implicitKey && value$1.includes("\n") || inFlow && /[[\]{},]/.test(value$1)) return quotedString(value$1, ctx);
		if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value$1)) return implicitKey || inFlow || !value$1.includes("\n") ? quotedString(value$1, ctx) : blockString(item, ctx, onComment, onChompKeep);
		if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value$1.includes("\n")) return blockString(item, ctx, onComment, onChompKeep);
		if (containsDocumentMarker(value$1)) {
			if (indent === "") {
				ctx.forceBlockIndent = true;
				return blockString(item, ctx, onComment, onChompKeep);
			} else if (implicitKey && indent === indentStep) return quotedString(value$1, ctx);
		}
		const str = value$1.replace(/\n+/g, `$&\n${indent}`);
		if (actualString) {
			const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
			const { compat, tags } = ctx.doc.schema;
			if (tags.some(test) || compat?.some(test)) return quotedString(value$1, ctx);
		}
		return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
	}
	function stringifyString(item, ctx, onComment, onChompKeep) {
		const { implicitKey, inFlow } = ctx;
		const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
		let { type } = item;
		if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
			if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = Scalar.Scalar.QUOTE_DOUBLE;
		}
		const _stringify = (_type) => {
			switch (_type) {
				case Scalar.Scalar.BLOCK_FOLDED:
				case Scalar.Scalar.BLOCK_LITERAL: return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
				case Scalar.Scalar.QUOTE_DOUBLE: return doubleQuotedString(ss.value, ctx);
				case Scalar.Scalar.QUOTE_SINGLE: return singleQuotedString(ss.value, ctx);
				case Scalar.Scalar.PLAIN: return plainString(ss, ctx, onComment, onChompKeep);
				default: return null;
			}
		};
		let res = _stringify(type);
		if (res === null) {
			const { defaultKeyType, defaultStringType } = ctx.options;
			const t$1 = implicitKey && defaultKeyType || defaultStringType;
			res = _stringify(t$1);
			if (res === null) throw new Error(`Unsupported default string type ${t$1}`);
		}
		return res;
	}
	exports.stringifyString = stringifyString;
}));
var require_stringify = /* @__PURE__ */ __commonJSMin(((exports) => {
	var anchors = require_anchors();
	var identity = require_identity();
	var stringifyComment = require_stringifyComment();
	var stringifyString = require_stringifyString();
	function createStringifyContext(doc, options) {
		const opt = Object.assign({
			blockQuote: true,
			commentString: stringifyComment.stringifyComment,
			defaultKeyType: null,
			defaultStringType: "PLAIN",
			directives: null,
			doubleQuotedAsJSON: false,
			doubleQuotedMinMultiLineLength: 40,
			falseStr: "false",
			flowCollectionPadding: true,
			indentSeq: true,
			lineWidth: 80,
			minContentWidth: 20,
			nullStr: "null",
			simpleKeys: false,
			singleQuote: null,
			trueStr: "true",
			verifyAliasOrder: true
		}, doc.schema.toStringOptions, options);
		let inFlow;
		switch (opt.collectionStyle) {
			case "block":
				inFlow = false;
				break;
			case "flow":
				inFlow = true;
				break;
			default: inFlow = null;
		}
		return {
			anchors: /* @__PURE__ */ new Set(),
			doc,
			flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
			indent: "",
			indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
			inFlow,
			options: opt
		};
	}
	function getTagObject(tags, item) {
		if (item.tag) {
			const match$3 = tags.filter((t$1) => t$1.tag === item.tag);
			if (match$3.length > 0) return match$3.find((t$1) => t$1.format === item.format) ?? match$3[0];
		}
		let tagObj = void 0;
		let obj;
		if (identity.isScalar(item)) {
			obj = item.value;
			let match$3 = tags.filter((t$1) => t$1.identify?.(obj));
			if (match$3.length > 1) {
				const testMatch = match$3.filter((t$1) => t$1.test);
				if (testMatch.length > 0) match$3 = testMatch;
			}
			tagObj = match$3.find((t$1) => t$1.format === item.format) ?? match$3.find((t$1) => !t$1.format);
		} else {
			obj = item;
			tagObj = tags.find((t$1) => t$1.nodeClass && obj instanceof t$1.nodeClass);
		}
		if (!tagObj) {
			const name$1 = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
			throw new Error(`Tag not resolved for ${name$1} value`);
		}
		return tagObj;
	}
	function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
		if (!doc.directives) return "";
		const props = [];
		const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
		if (anchor && anchors.anchorIsValid(anchor)) {
			anchors$1.add(anchor);
			props.push(`&${anchor}`);
		}
		const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
		if (tag) props.push(doc.directives.tagString(tag));
		return props.join(" ");
	}
	function stringify(item, ctx, onComment, onChompKeep) {
		if (identity.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
		if (identity.isAlias(item)) {
			if (ctx.doc.directives) return item.toString(ctx);
			if (ctx.resolvedAliases?.has(item)) throw new TypeError(`Cannot stringify circular structure without alias nodes`);
			else {
				if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
				else ctx.resolvedAliases = new Set([item]);
				item = item.resolve(ctx.doc);
			}
		}
		let tagObj = void 0;
		const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o$1) => tagObj = o$1 });
		tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
		const props = stringifyProps(node, tagObj, ctx);
		if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
		const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
		if (!props) return str;
		return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
	}
	exports.createStringifyContext = createStringifyContext;
	exports.stringify = stringify;
}));
var require_stringifyPair = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Scalar = require_Scalar();
	var stringify = require_stringify();
	var stringifyComment = require_stringifyComment();
	function stringifyPair({ key, value: value$1 }, ctx, onComment, onChompKeep) {
		const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
		let keyComment = identity.isNode(key) && key.comment || null;
		if (simpleKeys) {
			if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
			if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") throw new Error("With simple keys, collection cannot be used as a key value");
		}
		let explicitKey = !simpleKeys && (!key || keyComment && value$1 == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
		ctx = Object.assign({}, ctx, {
			allNullValues: false,
			implicitKey: !explicitKey && (simpleKeys || !allNullValues),
			indent: indent + indentStep
		});
		let keyCommentDone = false;
		let chompKeep = false;
		let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
		if (!explicitKey && !ctx.inFlow && str.length > 1024) {
			if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
			explicitKey = true;
		}
		if (ctx.inFlow) {
			if (allNullValues || value$1 == null) {
				if (keyCommentDone && onComment) onComment();
				return str === "" ? "?" : explicitKey ? `? ${str}` : str;
			}
		} else if (allNullValues && !simpleKeys || value$1 == null && explicitKey) {
			str = `? ${str}`;
			if (keyComment && !keyCommentDone) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
			else if (chompKeep && onChompKeep) onChompKeep();
			return str;
		}
		if (keyCommentDone) keyComment = null;
		if (explicitKey) {
			if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
			str = `? ${str}\n${indent}:`;
		} else {
			str = `${str}:`;
			if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
		}
		let vsb, vcb, valueComment;
		if (identity.isNode(value$1)) {
			vsb = !!value$1.spaceBefore;
			vcb = value$1.commentBefore;
			valueComment = value$1.comment;
		} else {
			vsb = false;
			vcb = null;
			valueComment = null;
			if (value$1 && typeof value$1 === "object") value$1 = doc.createNode(value$1);
		}
		ctx.implicitKey = false;
		if (!explicitKey && !keyComment && identity.isScalar(value$1)) ctx.indentAtStart = str.length + 1;
		chompKeep = false;
		if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value$1) && !value$1.flow && !value$1.tag && !value$1.anchor) ctx.indent = ctx.indent.substring(2);
		let valueCommentDone = false;
		const valueStr = stringify.stringify(value$1, ctx, () => valueCommentDone = true, () => chompKeep = true);
		let ws = " ";
		if (keyComment || vsb || vcb) {
			ws = vsb ? "\n" : "";
			if (vcb) {
				const cs = commentString(vcb);
				ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
			}
			if (valueStr === "" && !ctx.inFlow) {
				if (ws === "\n" && valueComment) ws = "\n\n";
			} else ws += `\n${ctx.indent}`;
		} else if (!explicitKey && identity.isCollection(value$1)) {
			const vs0 = valueStr[0];
			const nl0 = valueStr.indexOf("\n");
			const hasNewline = nl0 !== -1;
			const flow = ctx.inFlow ?? value$1.flow ?? value$1.items.length === 0;
			if (hasNewline || !flow) {
				let hasPropsLine = false;
				if (hasNewline && (vs0 === "&" || vs0 === "!")) {
					let sp0 = valueStr.indexOf(" ");
					if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") sp0 = valueStr.indexOf(" ", sp0 + 1);
					if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
				}
				if (!hasPropsLine) ws = `\n${ctx.indent}`;
			}
		} else if (valueStr === "" || valueStr[0] === "\n") ws = "";
		str += ws + valueStr;
		if (ctx.inFlow) {
			if (valueCommentDone && onComment) onComment();
		} else if (valueComment && !valueCommentDone) str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
		else if (chompKeep && onChompKeep) onChompKeep();
		return str;
	}
	exports.stringifyPair = stringifyPair;
}));
var require_log = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_process$2 = __require("process");
	function debug(logLevel, ...messages) {
		if (logLevel === "debug") console.log(...messages);
	}
	function warn(logLevel, warning) {
		if (logLevel === "debug" || logLevel === "warn") if (typeof node_process$2.emitWarning === "function") node_process$2.emitWarning(warning);
		else console.warn(warning);
	}
	exports.debug = debug;
	exports.warn = warn;
}));
var require_merge = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Scalar = require_Scalar();
	var MERGE_KEY = "<<";
	var merge = {
		identify: (value$1) => value$1 === MERGE_KEY || typeof value$1 === "symbol" && value$1.description === MERGE_KEY,
		default: "key",
		tag: "tag:yaml.org,2002:merge",
		test: /^<<$/,
		resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), { addToJSMap: addMergeToJSMap }),
		stringify: () => MERGE_KEY
	};
	var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
	function addMergeToJSMap(ctx, map$6, value$1) {
		value$1 = ctx && identity.isAlias(value$1) ? value$1.resolve(ctx.doc) : value$1;
		if (identity.isSeq(value$1)) for (const it of value$1.items) mergeValue(ctx, map$6, it);
		else if (Array.isArray(value$1)) for (const it of value$1) mergeValue(ctx, map$6, it);
		else mergeValue(ctx, map$6, value$1);
	}
	function mergeValue(ctx, map$6, value$1) {
		const source = ctx && identity.isAlias(value$1) ? value$1.resolve(ctx.doc) : value$1;
		if (!identity.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
		const srcMap = source.toJSON(null, ctx, Map);
		for (const [key, value$2] of srcMap) if (map$6 instanceof Map) {
			if (!map$6.has(key)) map$6.set(key, value$2);
		} else if (map$6 instanceof Set) map$6.add(key);
		else if (!Object.prototype.hasOwnProperty.call(map$6, key)) Object.defineProperty(map$6, key, {
			value: value$2,
			writable: true,
			enumerable: true,
			configurable: true
		});
		return map$6;
	}
	exports.addMergeToJSMap = addMergeToJSMap;
	exports.isMergeKey = isMergeKey;
	exports.merge = merge;
}));
var require_addPairToJSMap = /* @__PURE__ */ __commonJSMin(((exports) => {
	var log = require_log();
	var merge = require_merge();
	var stringify = require_stringify();
	var identity = require_identity();
	var toJS = require_toJS();
	function addPairToJSMap(ctx, map$6, { key, value: value$1 }) {
		if (identity.isNode(key) && key.addToJSMap) key.addToJSMap(ctx, map$6, value$1);
		else if (merge.isMergeKey(ctx, key)) merge.addMergeToJSMap(ctx, map$6, value$1);
		else {
			const jsKey = toJS.toJS(key, "", ctx);
			if (map$6 instanceof Map) map$6.set(jsKey, toJS.toJS(value$1, jsKey, ctx));
			else if (map$6 instanceof Set) map$6.add(jsKey);
			else {
				const stringKey = stringifyKey(key, jsKey, ctx);
				const jsValue = toJS.toJS(value$1, stringKey, ctx);
				if (stringKey in map$6) Object.defineProperty(map$6, stringKey, {
					value: jsValue,
					writable: true,
					enumerable: true,
					configurable: true
				});
				else map$6[stringKey] = jsValue;
			}
		}
		return map$6;
	}
	function stringifyKey(key, jsKey, ctx) {
		if (jsKey === null) return "";
		if (typeof jsKey !== "object") return String(jsKey);
		if (identity.isNode(key) && ctx?.doc) {
			const strCtx = stringify.createStringifyContext(ctx.doc, {});
			strCtx.anchors = /* @__PURE__ */ new Set();
			for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
			strCtx.inFlow = true;
			strCtx.inStringifyKey = true;
			const strKey = key.toString(strCtx);
			if (!ctx.mapKeyWarned) {
				let jsonStr = JSON.stringify(strKey);
				if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + "...\"";
				log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
				ctx.mapKeyWarned = true;
			}
			return strKey;
		}
		return JSON.stringify(jsKey);
	}
	exports.addPairToJSMap = addPairToJSMap;
}));
var require_Pair = /* @__PURE__ */ __commonJSMin(((exports) => {
	var createNode = require_createNode();
	var stringifyPair = require_stringifyPair();
	var addPairToJSMap = require_addPairToJSMap();
	var identity = require_identity();
	function createPair(key, value$1, ctx) {
		return new Pair(createNode.createNode(key, void 0, ctx), createNode.createNode(value$1, void 0, ctx));
	}
	var Pair = class Pair {
		constructor(key, value$1 = null) {
			Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
			this.key = key;
			this.value = value$1;
		}
		clone(schema) {
			let { key, value: value$1 } = this;
			if (identity.isNode(key)) key = key.clone(schema);
			if (identity.isNode(value$1)) value$1 = value$1.clone(schema);
			return new Pair(key, value$1);
		}
		toJSON(_$1, ctx) {
			const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
			return addPairToJSMap.addPairToJSMap(ctx, pair, this);
		}
		toString(ctx, onComment, onChompKeep) {
			return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
		}
	};
	exports.Pair = Pair;
	exports.createPair = createPair;
}));
var require_stringifyCollection = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var stringify = require_stringify();
	var stringifyComment = require_stringifyComment();
	function stringifyCollection(collection, ctx, options) {
		return (ctx.inFlow ?? collection.flow ? stringifyFlowCollection : stringifyBlockCollection)(collection, ctx, options);
	}
	function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
		const { indent, options: { commentString } } = ctx;
		const itemCtx = Object.assign({}, ctx, {
			indent: itemIndent,
			type: null
		});
		let chompKeep = false;
		const lines = [];
		for (let i = 0; i < items.length; ++i) {
			const item = items[i];
			let comment$1 = null;
			if (identity.isNode(item)) {
				if (!chompKeep && item.spaceBefore) lines.push("");
				addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
				if (item.comment) comment$1 = item.comment;
			} else if (identity.isPair(item)) {
				const ik = identity.isNode(item.key) ? item.key : null;
				if (ik) {
					if (!chompKeep && ik.spaceBefore) lines.push("");
					addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
				}
			}
			chompKeep = false;
			let str$1 = stringify.stringify(item, itemCtx, () => comment$1 = null, () => chompKeep = true);
			if (comment$1) str$1 += stringifyComment.lineComment(str$1, itemIndent, commentString(comment$1));
			if (chompKeep && comment$1) chompKeep = false;
			lines.push(blockItemPrefix + str$1);
		}
		let str;
		if (lines.length === 0) str = flowChars.start + flowChars.end;
		else {
			str = lines[0];
			for (let i = 1; i < lines.length; ++i) {
				const line = lines[i];
				str += line ? `\n${indent}${line}` : "\n";
			}
		}
		if (comment) {
			str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
			if (onComment) onComment();
		} else if (chompKeep && onChompKeep) onChompKeep();
		return str;
	}
	function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
		const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
		itemIndent += indentStep;
		const itemCtx = Object.assign({}, ctx, {
			indent: itemIndent,
			inFlow: true,
			type: null
		});
		let reqNewline = false;
		let linesAtValue = 0;
		const lines = [];
		for (let i = 0; i < items.length; ++i) {
			const item = items[i];
			let comment = null;
			if (identity.isNode(item)) {
				if (item.spaceBefore) lines.push("");
				addCommentBefore(ctx, lines, item.commentBefore, false);
				if (item.comment) comment = item.comment;
			} else if (identity.isPair(item)) {
				const ik = identity.isNode(item.key) ? item.key : null;
				if (ik) {
					if (ik.spaceBefore) lines.push("");
					addCommentBefore(ctx, lines, ik.commentBefore, false);
					if (ik.comment) reqNewline = true;
				}
				const iv = identity.isNode(item.value) ? item.value : null;
				if (iv) {
					if (iv.comment) comment = iv.comment;
					if (iv.commentBefore) reqNewline = true;
				} else if (item.value == null && ik?.comment) comment = ik.comment;
			}
			if (comment) reqNewline = true;
			let str = stringify.stringify(item, itemCtx, () => comment = null);
			if (i < items.length - 1) str += ",";
			if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
			if (!reqNewline && (lines.length > linesAtValue || str.includes("\n"))) reqNewline = true;
			lines.push(str);
			linesAtValue = lines.length;
		}
		const { start, end } = flowChars;
		if (lines.length === 0) return start + end;
		else {
			if (!reqNewline) {
				const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
				reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
			}
			if (reqNewline) {
				let str = start;
				for (const line of lines) str += line ? `\n${indentStep}${indent}${line}` : "\n";
				return `${str}\n${indent}${end}`;
			} else return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
		}
	}
	function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
		if (comment && chompKeep) comment = comment.replace(/^\n+/, "");
		if (comment) {
			const ic = stringifyComment.indentComment(commentString(comment), indent);
			lines.push(ic.trimStart());
		}
	}
	exports.stringifyCollection = stringifyCollection;
}));
var require_YAMLMap = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyCollection = require_stringifyCollection();
	var addPairToJSMap = require_addPairToJSMap();
	var Collection = require_Collection();
	var identity = require_identity();
	var Pair = require_Pair();
	var Scalar = require_Scalar();
	function findPair(items, key) {
		const k = identity.isScalar(key) ? key.value : key;
		for (const it of items) if (identity.isPair(it)) {
			if (it.key === key || it.key === k) return it;
			if (identity.isScalar(it.key) && it.key.value === k) return it;
		}
	}
	var YAMLMap = class extends Collection.Collection {
		static get tagName() {
			return "tag:yaml.org,2002:map";
		}
		constructor(schema) {
			super(identity.MAP, schema);
			this.items = [];
		}
		static from(schema, obj, ctx) {
			const { keepUndefined, replacer } = ctx;
			const map$6 = new this(schema);
			const add = (key, value$1) => {
				if (typeof replacer === "function") value$1 = replacer.call(obj, key, value$1);
				else if (Array.isArray(replacer) && !replacer.includes(key)) return;
				if (value$1 !== void 0 || keepUndefined) map$6.items.push(Pair.createPair(key, value$1, ctx));
			};
			if (obj instanceof Map) for (const [key, value$1] of obj) add(key, value$1);
			else if (obj && typeof obj === "object") for (const key of Object.keys(obj)) add(key, obj[key]);
			if (typeof schema.sortMapEntries === "function") map$6.items.sort(schema.sortMapEntries);
			return map$6;
		}
		add(pair, overwrite) {
			let _pair;
			if (identity.isPair(pair)) _pair = pair;
			else if (!pair || typeof pair !== "object" || !("key" in pair)) _pair = new Pair.Pair(pair, pair?.value);
			else _pair = new Pair.Pair(pair.key, pair.value);
			const prev = findPair(this.items, _pair.key);
			const sortEntries = this.schema?.sortMapEntries;
			if (prev) {
				if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
				if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value)) prev.value.value = _pair.value;
				else prev.value = _pair.value;
			} else if (sortEntries) {
				const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
				if (i === -1) this.items.push(_pair);
				else this.items.splice(i, 0, _pair);
			} else this.items.push(_pair);
		}
		delete(key) {
			const it = findPair(this.items, key);
			if (!it) return false;
			return this.items.splice(this.items.indexOf(it), 1).length > 0;
		}
		get(key, keepScalar) {
			const node = findPair(this.items, key)?.value;
			return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
		}
		has(key) {
			return !!findPair(this.items, key);
		}
		set(key, value$1) {
			this.add(new Pair.Pair(key, value$1), true);
		}
		toJSON(_$1, ctx, Type) {
			const map$6 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
			if (ctx?.onCreate) ctx.onCreate(map$6);
			for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map$6, item);
			return map$6;
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			for (const item of this.items) if (!identity.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
			if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, { allNullValues: true });
			return stringifyCollection.stringifyCollection(this, ctx, {
				blockItemPrefix: "",
				flowChars: {
					start: "{",
					end: "}"
				},
				itemIndent: ctx.indent || "",
				onChompKeep,
				onComment
			});
		}
	};
	exports.YAMLMap = YAMLMap;
	exports.findPair = findPair;
}));
var require_map = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var YAMLMap = require_YAMLMap();
	exports.map = {
		collection: "map",
		default: true,
		nodeClass: YAMLMap.YAMLMap,
		tag: "tag:yaml.org,2002:map",
		resolve(map$6, onError) {
			if (!identity.isMap(map$6)) onError("Expected a mapping for this tag");
			return map$6;
		},
		createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
	};
}));
var require_YAMLSeq = /* @__PURE__ */ __commonJSMin(((exports) => {
	var createNode = require_createNode();
	var stringifyCollection = require_stringifyCollection();
	var Collection = require_Collection();
	var identity = require_identity();
	var Scalar = require_Scalar();
	var toJS = require_toJS();
	var YAMLSeq = class extends Collection.Collection {
		static get tagName() {
			return "tag:yaml.org,2002:seq";
		}
		constructor(schema) {
			super(identity.SEQ, schema);
			this.items = [];
		}
		add(value$1) {
			this.items.push(value$1);
		}
		delete(key) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") return false;
			return this.items.splice(idx, 1).length > 0;
		}
		get(key, keepScalar) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") return void 0;
			const it = this.items[idx];
			return !keepScalar && identity.isScalar(it) ? it.value : it;
		}
		has(key) {
			const idx = asItemIndex(key);
			return typeof idx === "number" && idx < this.items.length;
		}
		set(key, value$1) {
			const idx = asItemIndex(key);
			if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
			const prev = this.items[idx];
			if (identity.isScalar(prev) && Scalar.isScalarValue(value$1)) prev.value = value$1;
			else this.items[idx] = value$1;
		}
		toJSON(_$1, ctx) {
			const seq$1 = [];
			if (ctx?.onCreate) ctx.onCreate(seq$1);
			let i = 0;
			for (const item of this.items) seq$1.push(toJS.toJS(item, String(i++), ctx));
			return seq$1;
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			return stringifyCollection.stringifyCollection(this, ctx, {
				blockItemPrefix: "- ",
				flowChars: {
					start: "[",
					end: "]"
				},
				itemIndent: (ctx.indent || "") + "  ",
				onChompKeep,
				onComment
			});
		}
		static from(schema, obj, ctx) {
			const { replacer } = ctx;
			const seq$1 = new this(schema);
			if (obj && Symbol.iterator in Object(obj)) {
				let i = 0;
				for (let it of obj) {
					if (typeof replacer === "function") {
						const key = obj instanceof Set ? it : String(i++);
						it = replacer.call(obj, key, it);
					}
					seq$1.items.push(createNode.createNode(it, void 0, ctx));
				}
			}
			return seq$1;
		}
	};
	function asItemIndex(key) {
		let idx = identity.isScalar(key) ? key.value : key;
		if (idx && typeof idx === "string") idx = Number(idx);
		return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
	}
	exports.YAMLSeq = YAMLSeq;
}));
var require_seq = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var YAMLSeq = require_YAMLSeq();
	exports.seq = {
		collection: "seq",
		default: true,
		nodeClass: YAMLSeq.YAMLSeq,
		tag: "tag:yaml.org,2002:seq",
		resolve(seq$1, onError) {
			if (!identity.isSeq(seq$1)) onError("Expected a sequence for this tag");
			return seq$1;
		},
		createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
	};
}));
var require_string = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyString = require_stringifyString();
	exports.string = {
		identify: (value$1) => typeof value$1 === "string",
		default: true,
		tag: "tag:yaml.org,2002:str",
		resolve: (str) => str,
		stringify(item, ctx, onComment, onChompKeep) {
			ctx = Object.assign({ actualString: true }, ctx);
			return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
		}
	};
}));
var require_null = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var nullTag = {
		identify: (value$1) => value$1 == null,
		createNode: () => new Scalar.Scalar(null),
		default: true,
		tag: "tag:yaml.org,2002:null",
		test: /^(?:~|[Nn]ull|NULL)?$/,
		resolve: () => new Scalar.Scalar(null),
		stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
	};
	exports.nullTag = nullTag;
}));
var require_bool$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var boolTag = {
		identify: (value$1) => typeof value$1 === "boolean",
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
		resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
		stringify({ source, value: value$1 }, ctx) {
			if (source && boolTag.test.test(source)) {
				if (value$1 === (source[0] === "t" || source[0] === "T")) return source;
			}
			return value$1 ? ctx.options.trueStr : ctx.options.falseStr;
		}
	};
	exports.boolTag = boolTag;
}));
var require_stringifyNumber = /* @__PURE__ */ __commonJSMin(((exports) => {
	function stringifyNumber({ format, minFractionDigits, tag, value: value$1 }) {
		if (typeof value$1 === "bigint") return String(value$1);
		const num = typeof value$1 === "number" ? value$1 : Number(value$1);
		if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
		let n$1 = Object.is(value$1, -0) ? "-0" : JSON.stringify(value$1);
		if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n$1)) {
			let i = n$1.indexOf(".");
			if (i < 0) {
				i = n$1.length;
				n$1 += ".";
			}
			let d = minFractionDigits - (n$1.length - i - 1);
			while (d-- > 0) n$1 += "0";
		}
		return n$1;
	}
	exports.stringifyNumber = stringifyNumber;
}));
var require_float$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var stringifyNumber = require_stringifyNumber();
	var floatNaN = {
		identify: (value$1) => typeof value$1 === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
		resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
		stringify: stringifyNumber.stringifyNumber
	};
	var floatExp = {
		identify: (value$1) => typeof value$1 === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "EXP",
		test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
		resolve: (str) => parseFloat(str),
		stringify(node) {
			const num = Number(node.value);
			return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
		}
	};
	exports.float = {
		identify: (value$1) => typeof value$1 === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
		resolve(str) {
			const node = new Scalar.Scalar(parseFloat(str));
			const dot = str.indexOf(".");
			if (dot !== -1 && str[str.length - 1] === "0") node.minFractionDigits = str.length - dot - 1;
			return node;
		},
		stringify: stringifyNumber.stringifyNumber
	};
	exports.floatExp = floatExp;
	exports.floatNaN = floatNaN;
}));
var require_int$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyNumber = require_stringifyNumber();
	var intIdentify = (value$1) => typeof value$1 === "bigint" || Number.isInteger(value$1);
	var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
	function intStringify(node, radix, prefix) {
		const { value: value$1 } = node;
		if (intIdentify(value$1) && value$1 >= 0) return prefix + value$1.toString(radix);
		return stringifyNumber.stringifyNumber(node);
	}
	var intOct = {
		identify: (value$1) => intIdentify(value$1) && value$1 >= 0,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "OCT",
		test: /^0o[0-7]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
		stringify: (node) => intStringify(node, 8, "0o")
	};
	var int = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		test: /^[-+]?[0-9]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
		stringify: stringifyNumber.stringifyNumber
	};
	var intHex = {
		identify: (value$1) => intIdentify(value$1) && value$1 >= 0,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "HEX",
		test: /^0x[0-9a-fA-F]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
		stringify: (node) => intStringify(node, 16, "0x")
	};
	exports.int = int;
	exports.intHex = intHex;
	exports.intOct = intOct;
}));
var require_schema$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var map = require_map();
	var _null = require_null();
	var seq = require_seq();
	var string = require_string();
	var bool = require_bool$1();
	var float = require_float$1();
	var int = require_int$1();
	exports.schema = [
		map.map,
		seq.seq,
		string.string,
		_null.nullTag,
		bool.boolTag,
		int.intOct,
		int.int,
		int.intHex,
		float.floatNaN,
		float.floatExp,
		float.float
	];
}));
var require_schema$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var map = require_map();
	var seq = require_seq();
	function intIdentify(value$1) {
		return typeof value$1 === "bigint" || Number.isInteger(value$1);
	}
	var stringifyJSON = ({ value: value$1 }) => JSON.stringify(value$1);
	var jsonScalars = [
		{
			identify: (value$1) => typeof value$1 === "string",
			default: true,
			tag: "tag:yaml.org,2002:str",
			resolve: (str) => str,
			stringify: stringifyJSON
		},
		{
			identify: (value$1) => value$1 == null,
			createNode: () => new Scalar.Scalar(null),
			default: true,
			tag: "tag:yaml.org,2002:null",
			test: /^null$/,
			resolve: () => null,
			stringify: stringifyJSON
		},
		{
			identify: (value$1) => typeof value$1 === "boolean",
			default: true,
			tag: "tag:yaml.org,2002:bool",
			test: /^true$|^false$/,
			resolve: (str) => str === "true",
			stringify: stringifyJSON
		},
		{
			identify: intIdentify,
			default: true,
			tag: "tag:yaml.org,2002:int",
			test: /^-?(?:0|[1-9][0-9]*)$/,
			resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
			stringify: ({ value: value$1 }) => intIdentify(value$1) ? value$1.toString() : JSON.stringify(value$1)
		},
		{
			identify: (value$1) => typeof value$1 === "number",
			default: true,
			tag: "tag:yaml.org,2002:float",
			test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
			resolve: (str) => parseFloat(str),
			stringify: stringifyJSON
		}
	];
	exports.schema = [map.map, seq.seq].concat(jsonScalars, {
		default: true,
		tag: "",
		test: /^/,
		resolve(str, onError) {
			onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
			return str;
		}
	});
}));
var require_binary = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_buffer = __require("buffer");
	var Scalar = require_Scalar();
	var stringifyString = require_stringifyString();
	exports.binary = {
		identify: (value$1) => value$1 instanceof Uint8Array,
		default: false,
		tag: "tag:yaml.org,2002:binary",
		resolve(src, onError) {
			if (typeof node_buffer.Buffer === "function") return node_buffer.Buffer.from(src, "base64");
			else if (typeof atob === "function") {
				const str = atob(src.replace(/[\n\r]/g, ""));
				const buffer$2 = new Uint8Array(str.length);
				for (let i = 0; i < str.length; ++i) buffer$2[i] = str.charCodeAt(i);
				return buffer$2;
			} else {
				onError("This environment does not support reading binary tags; either Buffer or atob is required");
				return src;
			}
		},
		stringify({ comment, type, value: value$1 }, ctx, onComment, onChompKeep) {
			if (!value$1) return "";
			const buf = value$1;
			let str;
			if (typeof node_buffer.Buffer === "function") str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
			else if (typeof btoa === "function") {
				let s = "";
				for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
				str = btoa(s);
			} else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
			type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
			if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
				const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
				const n$1 = Math.ceil(str.length / lineWidth);
				const lines = new Array(n$1);
				for (let i = 0, o$1 = 0; i < n$1; ++i, o$1 += lineWidth) lines[i] = str.substr(o$1, lineWidth);
				str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
			}
			return stringifyString.stringifyString({
				comment,
				type,
				value: str
			}, ctx, onComment, onChompKeep);
		}
	};
}));
var require_pairs = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Pair = require_Pair();
	var Scalar = require_Scalar();
	var YAMLSeq = require_YAMLSeq();
	function resolvePairs(seq$1, onError) {
		if (identity.isSeq(seq$1)) for (let i = 0; i < seq$1.items.length; ++i) {
			let item = seq$1.items[i];
			if (identity.isPair(item)) continue;
			else if (identity.isMap(item)) {
				if (item.items.length > 1) onError("Each pair must have its own sequence indicator");
				const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
				if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore;
				if (item.comment) {
					const cn = pair.value ?? pair.key;
					cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
				}
				item = pair;
			}
			seq$1.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
		}
		else onError("Expected a sequence for this tag");
		return seq$1;
	}
	function createPairs(schema, iterable, ctx) {
		const { replacer } = ctx;
		const pairs = new YAMLSeq.YAMLSeq(schema);
		pairs.tag = "tag:yaml.org,2002:pairs";
		let i = 0;
		if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
			if (typeof replacer === "function") it = replacer.call(iterable, String(i++), it);
			let key, value$1;
			if (Array.isArray(it)) if (it.length === 2) {
				key = it[0];
				value$1 = it[1];
			} else throw new TypeError(`Expected [key, value] tuple: ${it}`);
			else if (it && it instanceof Object) {
				const keys = Object.keys(it);
				if (keys.length === 1) {
					key = keys[0];
					value$1 = it[key];
				} else throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
			} else key = it;
			pairs.items.push(Pair.createPair(key, value$1, ctx));
		}
		return pairs;
	}
	var pairs = {
		collection: "seq",
		default: false,
		tag: "tag:yaml.org,2002:pairs",
		resolve: resolvePairs,
		createNode: createPairs
	};
	exports.createPairs = createPairs;
	exports.pairs = pairs;
	exports.resolvePairs = resolvePairs;
}));
var require_omap = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var toJS = require_toJS();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	var pairs = require_pairs();
	var YAMLOMap = class YAMLOMap extends YAMLSeq.YAMLSeq {
		constructor() {
			super();
			this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
			this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
			this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
			this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
			this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
			this.tag = YAMLOMap.tag;
		}
		toJSON(_$1, ctx) {
			if (!ctx) return super.toJSON(_$1);
			const map$6 = /* @__PURE__ */ new Map();
			if (ctx?.onCreate) ctx.onCreate(map$6);
			for (const pair of this.items) {
				let key, value$1;
				if (identity.isPair(pair)) {
					key = toJS.toJS(pair.key, "", ctx);
					value$1 = toJS.toJS(pair.value, key, ctx);
				} else key = toJS.toJS(pair, "", ctx);
				if (map$6.has(key)) throw new Error("Ordered maps must not include duplicate keys");
				map$6.set(key, value$1);
			}
			return map$6;
		}
		static from(schema, iterable, ctx) {
			const pairs$1 = pairs.createPairs(schema, iterable, ctx);
			const omap = new this();
			omap.items = pairs$1.items;
			return omap;
		}
	};
	YAMLOMap.tag = "tag:yaml.org,2002:omap";
	var omap = {
		collection: "seq",
		identify: (value$1) => value$1 instanceof Map,
		nodeClass: YAMLOMap,
		default: false,
		tag: "tag:yaml.org,2002:omap",
		resolve(seq$1, onError) {
			const pairs$1 = pairs.resolvePairs(seq$1, onError);
			const seenKeys = [];
			for (const { key } of pairs$1.items) if (identity.isScalar(key)) if (seenKeys.includes(key.value)) onError(`Ordered maps must not include duplicate keys: ${key.value}`);
			else seenKeys.push(key.value);
			return Object.assign(new YAMLOMap(), pairs$1);
		},
		createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
	};
	exports.YAMLOMap = YAMLOMap;
	exports.omap = omap;
}));
var require_bool = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	function boolStringify({ value: value$1, source }, ctx) {
		if (source && (value$1 ? trueTag : falseTag).test.test(source)) return source;
		return value$1 ? ctx.options.trueStr : ctx.options.falseStr;
	}
	var trueTag = {
		identify: (value$1) => value$1 === true,
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
		resolve: () => new Scalar.Scalar(true),
		stringify: boolStringify
	};
	var falseTag = {
		identify: (value$1) => value$1 === false,
		default: true,
		tag: "tag:yaml.org,2002:bool",
		test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
		resolve: () => new Scalar.Scalar(false),
		stringify: boolStringify
	};
	exports.falseTag = falseTag;
	exports.trueTag = trueTag;
}));
var require_float = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var stringifyNumber = require_stringifyNumber();
	var floatNaN = {
		identify: (value$1) => typeof value$1 === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
		resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
		stringify: stringifyNumber.stringifyNumber
	};
	var floatExp = {
		identify: (value$1) => typeof value$1 === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "EXP",
		test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
		resolve: (str) => parseFloat(str.replace(/_/g, "")),
		stringify(node) {
			const num = Number(node.value);
			return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
		}
	};
	exports.float = {
		identify: (value$1) => typeof value$1 === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
		resolve(str) {
			const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
			const dot = str.indexOf(".");
			if (dot !== -1) {
				const f = str.substring(dot + 1).replace(/_/g, "");
				if (f[f.length - 1] === "0") node.minFractionDigits = f.length;
			}
			return node;
		},
		stringify: stringifyNumber.stringifyNumber
	};
	exports.floatExp = floatExp;
	exports.floatNaN = floatNaN;
}));
var require_int = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyNumber = require_stringifyNumber();
	var intIdentify = (value$1) => typeof value$1 === "bigint" || Number.isInteger(value$1);
	function intResolve(str, offset, radix, { intAsBigInt }) {
		const sign = str[0];
		if (sign === "-" || sign === "+") offset += 1;
		str = str.substring(offset).replace(/_/g, "");
		if (intAsBigInt) {
			switch (radix) {
				case 2:
					str = `0b${str}`;
					break;
				case 8:
					str = `0o${str}`;
					break;
				case 16:
					str = `0x${str}`;
					break;
			}
			const n$2 = BigInt(str);
			return sign === "-" ? BigInt(-1) * n$2 : n$2;
		}
		const n$1 = parseInt(str, radix);
		return sign === "-" ? -1 * n$1 : n$1;
	}
	function intStringify(node, radix, prefix) {
		const { value: value$1 } = node;
		if (intIdentify(value$1)) {
			const str = value$1.toString(radix);
			return value$1 < 0 ? "-" + prefix + str.substr(1) : prefix + str;
		}
		return stringifyNumber.stringifyNumber(node);
	}
	var intBin = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "BIN",
		test: /^[-+]?0b[0-1_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
		stringify: (node) => intStringify(node, 2, "0b")
	};
	var intOct = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "OCT",
		test: /^[-+]?0[0-7_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
		stringify: (node) => intStringify(node, 8, "0")
	};
	var int = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		test: /^[-+]?[0-9][0-9_]*$/,
		resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
		stringify: stringifyNumber.stringifyNumber
	};
	var intHex = {
		identify: intIdentify,
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "HEX",
		test: /^[-+]?0x[0-9a-fA-F_]+$/,
		resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
		stringify: (node) => intStringify(node, 16, "0x")
	};
	exports.int = int;
	exports.intBin = intBin;
	exports.intHex = intHex;
	exports.intOct = intOct;
}));
var require_set = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Pair = require_Pair();
	var YAMLMap = require_YAMLMap();
	var YAMLSet = class YAMLSet extends YAMLMap.YAMLMap {
		constructor(schema) {
			super(schema);
			this.tag = YAMLSet.tag;
		}
		add(key) {
			let pair;
			if (identity.isPair(key)) pair = key;
			else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null) pair = new Pair.Pair(key.key, null);
			else pair = new Pair.Pair(key, null);
			if (!YAMLMap.findPair(this.items, pair.key)) this.items.push(pair);
		}
		get(key, keepPair) {
			const pair = YAMLMap.findPair(this.items, key);
			return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
		}
		set(key, value$1) {
			if (typeof value$1 !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value$1}`);
			const prev = YAMLMap.findPair(this.items, key);
			if (prev && !value$1) this.items.splice(this.items.indexOf(prev), 1);
			else if (!prev && value$1) this.items.push(new Pair.Pair(key));
		}
		toJSON(_$1, ctx) {
			return super.toJSON(_$1, ctx, Set);
		}
		toString(ctx, onComment, onChompKeep) {
			if (!ctx) return JSON.stringify(this);
			if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
			else throw new Error("Set items must all have null values");
		}
		static from(schema, iterable, ctx) {
			const { replacer } = ctx;
			const set$1 = new this(schema);
			if (iterable && Symbol.iterator in Object(iterable)) for (let value$1 of iterable) {
				if (typeof replacer === "function") value$1 = replacer.call(iterable, value$1, value$1);
				set$1.items.push(Pair.createPair(value$1, null, ctx));
			}
			return set$1;
		}
	};
	YAMLSet.tag = "tag:yaml.org,2002:set";
	var set = {
		collection: "map",
		identify: (value$1) => value$1 instanceof Set,
		nodeClass: YAMLSet,
		default: false,
		tag: "tag:yaml.org,2002:set",
		createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
		resolve(map$6, onError) {
			if (identity.isMap(map$6)) if (map$6.hasAllNullValues(true)) return Object.assign(new YAMLSet(), map$6);
			else onError("Set items must all have null values");
			else onError("Expected a mapping for this tag");
			return map$6;
		}
	};
	exports.YAMLSet = YAMLSet;
	exports.set = set;
}));
var require_timestamp = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringifyNumber = require_stringifyNumber();
	function parseSexagesimal(str, asBigInt) {
		const sign = str[0];
		const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
		const num = (n$1) => asBigInt ? BigInt(n$1) : Number(n$1);
		const res = parts.replace(/_/g, "").split(":").reduce((res$1, p) => res$1 * num(60) + num(p), num(0));
		return sign === "-" ? num(-1) * res : res;
	}
	function stringifySexagesimal(node) {
		let { value: value$1 } = node;
		let num = (n$1) => n$1;
		if (typeof value$1 === "bigint") num = (n$1) => BigInt(n$1);
		else if (isNaN(value$1) || !isFinite(value$1)) return stringifyNumber.stringifyNumber(node);
		let sign = "";
		if (value$1 < 0) {
			sign = "-";
			value$1 *= num(-1);
		}
		const _60 = num(60);
		const parts = [value$1 % _60];
		if (value$1 < 60) parts.unshift(0);
		else {
			value$1 = (value$1 - parts[0]) / _60;
			parts.unshift(value$1 % _60);
			if (value$1 >= 60) {
				value$1 = (value$1 - parts[0]) / _60;
				parts.unshift(value$1);
			}
		}
		return sign + parts.map((n$1) => String(n$1).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
	}
	var intTime = {
		identify: (value$1) => typeof value$1 === "bigint" || Number.isInteger(value$1),
		default: true,
		tag: "tag:yaml.org,2002:int",
		format: "TIME",
		test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
		resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
		stringify: stringifySexagesimal
	};
	var floatTime = {
		identify: (value$1) => typeof value$1 === "number",
		default: true,
		tag: "tag:yaml.org,2002:float",
		format: "TIME",
		test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
		resolve: (str) => parseSexagesimal(str, false),
		stringify: stringifySexagesimal
	};
	var timestamp = {
		identify: (value$1) => value$1 instanceof Date,
		default: true,
		tag: "tag:yaml.org,2002:timestamp",
		test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
		resolve(str) {
			const match$3 = str.match(timestamp.test);
			if (!match$3) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
			const [, year, month, day, hour, minute, second] = match$3.map(Number);
			const millisec = match$3[7] ? Number((match$3[7] + "00").substr(1, 3)) : 0;
			let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
			const tz = match$3[8];
			if (tz && tz !== "Z") {
				let d = parseSexagesimal(tz, false);
				if (Math.abs(d) < 30) d *= 60;
				date -= 6e4 * d;
			}
			return new Date(date);
		},
		stringify: ({ value: value$1 }) => value$1?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
	};
	exports.floatTime = floatTime;
	exports.intTime = intTime;
	exports.timestamp = timestamp;
}));
var require_schema = /* @__PURE__ */ __commonJSMin(((exports) => {
	var map = require_map();
	var _null = require_null();
	var seq = require_seq();
	var string = require_string();
	var binary = require_binary();
	var bool = require_bool();
	var float = require_float();
	var int = require_int();
	var merge = require_merge();
	var omap = require_omap();
	var pairs = require_pairs();
	var set = require_set();
	var timestamp = require_timestamp();
	exports.schema = [
		map.map,
		seq.seq,
		string.string,
		_null.nullTag,
		bool.trueTag,
		bool.falseTag,
		int.intBin,
		int.intOct,
		int.int,
		int.intHex,
		float.floatNaN,
		float.floatExp,
		float.float,
		binary.binary,
		merge.merge,
		omap.omap,
		pairs.pairs,
		set.set,
		timestamp.intTime,
		timestamp.floatTime,
		timestamp.timestamp
	];
}));
var require_tags = /* @__PURE__ */ __commonJSMin(((exports) => {
	var map = require_map();
	var _null = require_null();
	var seq = require_seq();
	var string = require_string();
	var bool = require_bool$1();
	var float = require_float$1();
	var int = require_int$1();
	var schema = require_schema$2();
	var schema$1 = require_schema$1();
	var binary = require_binary();
	var merge = require_merge();
	var omap = require_omap();
	var pairs = require_pairs();
	var schema$2 = require_schema();
	var set = require_set();
	var timestamp = require_timestamp();
	var schemas = new Map([
		["core", schema.schema],
		["failsafe", [
			map.map,
			seq.seq,
			string.string
		]],
		["json", schema$1.schema],
		["yaml11", schema$2.schema],
		["yaml-1.1", schema$2.schema]
	]);
	var tagsByName = {
		binary: binary.binary,
		bool: bool.boolTag,
		float: float.float,
		floatExp: float.floatExp,
		floatNaN: float.floatNaN,
		floatTime: timestamp.floatTime,
		int: int.int,
		intHex: int.intHex,
		intOct: int.intOct,
		intTime: timestamp.intTime,
		map: map.map,
		merge: merge.merge,
		null: _null.nullTag,
		omap: omap.omap,
		pairs: pairs.pairs,
		seq: seq.seq,
		set: set.set,
		timestamp: timestamp.timestamp
	};
	var coreKnownTags = {
		"tag:yaml.org,2002:binary": binary.binary,
		"tag:yaml.org,2002:merge": merge.merge,
		"tag:yaml.org,2002:omap": omap.omap,
		"tag:yaml.org,2002:pairs": pairs.pairs,
		"tag:yaml.org,2002:set": set.set,
		"tag:yaml.org,2002:timestamp": timestamp.timestamp
	};
	function getTags(customTags, schemaName, addMergeTag) {
		const schemaTags = schemas.get(schemaName);
		if (schemaTags && !customTags) return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
		let tags = schemaTags;
		if (!tags) if (Array.isArray(customTags)) tags = [];
		else {
			const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
			throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
		}
		if (Array.isArray(customTags)) for (const tag of customTags) tags = tags.concat(tag);
		else if (typeof customTags === "function") tags = customTags(tags.slice());
		if (addMergeTag) tags = tags.concat(merge.merge);
		return tags.reduce((tags$1, tag) => {
			const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
			if (!tagObj) {
				const tagName = JSON.stringify(tag);
				const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
				throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
			}
			if (!tags$1.includes(tagObj)) tags$1.push(tagObj);
			return tags$1;
		}, []);
	}
	exports.coreKnownTags = coreKnownTags;
	exports.getTags = getTags;
}));
var require_Schema = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var map = require_map();
	var seq = require_seq();
	var string = require_string();
	var tags = require_tags();
	var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
	exports.Schema = class Schema {
		constructor({ compat, customTags, merge: merge$3, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
			this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
			this.name = typeof schema === "string" && schema || "core";
			this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
			this.tags = tags.getTags(customTags, this.name, merge$3);
			this.toStringOptions = toStringDefaults ?? null;
			Object.defineProperty(this, identity.MAP, { value: map.map });
			Object.defineProperty(this, identity.SCALAR, { value: string.string });
			Object.defineProperty(this, identity.SEQ, { value: seq.seq });
			this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
		}
		clone() {
			const copy$1 = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
			copy$1.tags = this.tags.slice();
			return copy$1;
		}
	};
}));
var require_stringifyDocument = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var stringify = require_stringify();
	var stringifyComment = require_stringifyComment();
	function stringifyDocument(doc, options) {
		const lines = [];
		let hasDirectives = options.directives === true;
		if (options.directives !== false && doc.directives) {
			const dir$1 = doc.directives.toString(doc);
			if (dir$1) {
				lines.push(dir$1);
				hasDirectives = true;
			} else if (doc.directives.docStart) hasDirectives = true;
		}
		if (hasDirectives) lines.push("---");
		const ctx = stringify.createStringifyContext(doc, options);
		const { commentString } = ctx.options;
		if (doc.commentBefore) {
			if (lines.length !== 1) lines.unshift("");
			const cs = commentString(doc.commentBefore);
			lines.unshift(stringifyComment.indentComment(cs, ""));
		}
		let chompKeep = false;
		let contentComment = null;
		if (doc.contents) {
			if (identity.isNode(doc.contents)) {
				if (doc.contents.spaceBefore && hasDirectives) lines.push("");
				if (doc.contents.commentBefore) {
					const cs = commentString(doc.contents.commentBefore);
					lines.push(stringifyComment.indentComment(cs, ""));
				}
				ctx.forceBlockIndent = !!doc.comment;
				contentComment = doc.contents.comment;
			}
			const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
			let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
			if (contentComment) body += stringifyComment.lineComment(body, "", commentString(contentComment));
			if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") lines[lines.length - 1] = `--- ${body}`;
			else lines.push(body);
		} else lines.push(stringify.stringify(doc.contents, ctx));
		if (doc.directives?.docEnd) if (doc.comment) {
			const cs = commentString(doc.comment);
			if (cs.includes("\n")) {
				lines.push("...");
				lines.push(stringifyComment.indentComment(cs, ""));
			} else lines.push(`... ${cs}`);
		} else lines.push("...");
		else {
			let dc = doc.comment;
			if (dc && chompKeep) dc = dc.replace(/^\n+/, "");
			if (dc) {
				if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
				lines.push(stringifyComment.indentComment(commentString(dc), ""));
			}
		}
		return lines.join("\n") + "\n";
	}
	exports.stringifyDocument = stringifyDocument;
}));
var require_Document = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Alias = require_Alias();
	var Collection = require_Collection();
	var identity = require_identity();
	var Pair = require_Pair();
	var toJS = require_toJS();
	var Schema = require_Schema();
	var stringifyDocument = require_stringifyDocument();
	var anchors = require_anchors();
	var applyReviver = require_applyReviver();
	var createNode = require_createNode();
	var directives = require_directives();
	var Document = class Document {
		constructor(value$1, replacer, options) {
			this.commentBefore = null;
			this.comment = null;
			this.errors = [];
			this.warnings = [];
			Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
			let _replacer = null;
			if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
			else if (options === void 0 && replacer) {
				options = replacer;
				replacer = void 0;
			}
			const opt = Object.assign({
				intAsBigInt: false,
				keepSourceTokens: false,
				logLevel: "warn",
				prettyErrors: true,
				strict: true,
				stringKeys: false,
				uniqueKeys: true,
				version: "1.2"
			}, options);
			this.options = opt;
			let { version: version$1 } = opt;
			if (options?._directives) {
				this.directives = options._directives.atDocument();
				if (this.directives.yaml.explicit) version$1 = this.directives.yaml.version;
			} else this.directives = new directives.Directives({ version: version$1 });
			this.setSchema(version$1, options);
			this.contents = value$1 === void 0 ? null : this.createNode(value$1, _replacer, options);
		}
		clone() {
			const copy$1 = Object.create(Document.prototype, { [identity.NODE_TYPE]: { value: identity.DOC } });
			copy$1.commentBefore = this.commentBefore;
			copy$1.comment = this.comment;
			copy$1.errors = this.errors.slice();
			copy$1.warnings = this.warnings.slice();
			copy$1.options = Object.assign({}, this.options);
			if (this.directives) copy$1.directives = this.directives.clone();
			copy$1.schema = this.schema.clone();
			copy$1.contents = identity.isNode(this.contents) ? this.contents.clone(copy$1.schema) : this.contents;
			if (this.range) copy$1.range = this.range.slice();
			return copy$1;
		}
		add(value$1) {
			if (assertCollection(this.contents)) this.contents.add(value$1);
		}
		addIn(path$5, value$1) {
			if (assertCollection(this.contents)) this.contents.addIn(path$5, value$1);
		}
		createAlias(node, name$1) {
			if (!node.anchor) {
				const prev = anchors.anchorNames(this);
				node.anchor = !name$1 || prev.has(name$1) ? anchors.findNewAnchor(name$1 || "a", prev) : name$1;
			}
			return new Alias.Alias(node.anchor);
		}
		createNode(value$1, replacer, options) {
			let _replacer = void 0;
			if (typeof replacer === "function") {
				value$1 = replacer.call({ "": value$1 }, "", value$1);
				_replacer = replacer;
			} else if (Array.isArray(replacer)) {
				const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
				const asStr = replacer.filter(keyToStr).map(String);
				if (asStr.length > 0) replacer = replacer.concat(asStr);
				_replacer = replacer;
			} else if (options === void 0 && replacer) {
				options = replacer;
				replacer = void 0;
			}
			const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
			const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
			const ctx = {
				aliasDuplicateObjects: aliasDuplicateObjects ?? true,
				keepUndefined: keepUndefined ?? false,
				onAnchor,
				onTagObj,
				replacer: _replacer,
				schema: this.schema,
				sourceObjects
			};
			const node = createNode.createNode(value$1, tag, ctx);
			if (flow && identity.isCollection(node)) node.flow = true;
			setAnchors();
			return node;
		}
		createPair(key, value$1, options = {}) {
			const k = this.createNode(key, null, options);
			const v = this.createNode(value$1, null, options);
			return new Pair.Pair(k, v);
		}
		delete(key) {
			return assertCollection(this.contents) ? this.contents.delete(key) : false;
		}
		deleteIn(path$5) {
			if (Collection.isEmptyPath(path$5)) {
				if (this.contents == null) return false;
				this.contents = null;
				return true;
			}
			return assertCollection(this.contents) ? this.contents.deleteIn(path$5) : false;
		}
		get(key, keepScalar) {
			return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
		}
		getIn(path$5, keepScalar) {
			if (Collection.isEmptyPath(path$5)) return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
			return identity.isCollection(this.contents) ? this.contents.getIn(path$5, keepScalar) : void 0;
		}
		has(key) {
			return identity.isCollection(this.contents) ? this.contents.has(key) : false;
		}
		hasIn(path$5) {
			if (Collection.isEmptyPath(path$5)) return this.contents !== void 0;
			return identity.isCollection(this.contents) ? this.contents.hasIn(path$5) : false;
		}
		set(key, value$1) {
			if (this.contents == null) this.contents = Collection.collectionFromPath(this.schema, [key], value$1);
			else if (assertCollection(this.contents)) this.contents.set(key, value$1);
		}
		setIn(path$5, value$1) {
			if (Collection.isEmptyPath(path$5)) this.contents = value$1;
			else if (this.contents == null) this.contents = Collection.collectionFromPath(this.schema, Array.from(path$5), value$1);
			else if (assertCollection(this.contents)) this.contents.setIn(path$5, value$1);
		}
		setSchema(version$1, options = {}) {
			if (typeof version$1 === "number") version$1 = String(version$1);
			let opt;
			switch (version$1) {
				case "1.1":
					if (this.directives) this.directives.yaml.version = "1.1";
					else this.directives = new directives.Directives({ version: "1.1" });
					opt = {
						resolveKnownTags: false,
						schema: "yaml-1.1"
					};
					break;
				case "1.2":
				case "next":
					if (this.directives) this.directives.yaml.version = version$1;
					else this.directives = new directives.Directives({ version: version$1 });
					opt = {
						resolveKnownTags: true,
						schema: "core"
					};
					break;
				case null:
					if (this.directives) delete this.directives;
					opt = null;
					break;
				default: {
					const sv = JSON.stringify(version$1);
					throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
				}
			}
			if (options.schema instanceof Object) this.schema = options.schema;
			else if (opt) this.schema = new Schema.Schema(Object.assign(opt, options));
			else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
		}
		toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
			const ctx = {
				anchors: /* @__PURE__ */ new Map(),
				doc: this,
				keep: !json,
				mapAsMap: mapAsMap === true,
				mapKeyWarned: false,
				maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
			};
			const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
			if (typeof onAnchor === "function") for (const { count, res: res$1 } of ctx.anchors.values()) onAnchor(res$1, count);
			return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
		}
		toJSON(jsonArg, onAnchor) {
			return this.toJS({
				json: true,
				jsonArg,
				mapAsMap: false,
				onAnchor
			});
		}
		toString(options = {}) {
			if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
			if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
				const s = JSON.stringify(options.indent);
				throw new Error(`"indent" option must be a positive integer, not ${s}`);
			}
			return stringifyDocument.stringifyDocument(this, options);
		}
	};
	function assertCollection(contents) {
		if (identity.isCollection(contents)) return true;
		throw new Error("Expected a YAML collection as document contents");
	}
	exports.Document = Document;
}));
var require_errors = /* @__PURE__ */ __commonJSMin(((exports) => {
	var YAMLError = class extends Error {
		constructor(name$1, pos, code, message) {
			super();
			this.name = name$1;
			this.code = code;
			this.message = message;
			this.pos = pos;
		}
	};
	var YAMLParseError = class extends YAMLError {
		constructor(pos, code, message) {
			super("YAMLParseError", pos, code, message);
		}
	};
	var YAMLWarning = class extends YAMLError {
		constructor(pos, code, message) {
			super("YAMLWarning", pos, code, message);
		}
	};
	var prettifyError = (src, lc) => (error) => {
		if (error.pos[0] === -1) return;
		error.linePos = error.pos.map((pos) => lc.linePos(pos));
		const { line, col } = error.linePos[0];
		error.message += ` at line ${line}, column ${col}`;
		let ci = col - 1;
		let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
		if (ci >= 60 && lineStr.length > 80) {
			const trimStart = Math.min(ci - 39, lineStr.length - 79);
			lineStr = "" + lineStr.substring(trimStart);
			ci -= trimStart - 1;
		}
		if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + "";
		if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
			let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
			if (prev.length > 80) prev = prev.substring(0, 79) + "\n";
			lineStr = prev + lineStr;
		}
		if (/[^ ]/.test(lineStr)) {
			let count = 1;
			const end = error.linePos[1];
			if (end?.line === line && end.col > col) count = Math.max(1, Math.min(end.col - col, 80 - ci));
			const pointer = " ".repeat(ci) + "^".repeat(count);
			error.message += `:\n\n${lineStr}\n${pointer}\n`;
		}
	};
	exports.YAMLError = YAMLError;
	exports.YAMLParseError = YAMLParseError;
	exports.YAMLWarning = YAMLWarning;
	exports.prettifyError = prettifyError;
}));
var require_resolve_props = /* @__PURE__ */ __commonJSMin(((exports) => {
	function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
		let spaceBefore = false;
		let atNewline = startOnNewline;
		let hasSpace = startOnNewline;
		let comment = "";
		let commentSep = "";
		let hasNewline = false;
		let reqSpace = false;
		let tab = null;
		let anchor = null;
		let tag = null;
		let newlineAfterProp = null;
		let comma = null;
		let found = null;
		let start = null;
		for (const token of tokens) {
			if (reqSpace) {
				if (token.type !== "space" && token.type !== "newline" && token.type !== "comma") onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
				reqSpace = false;
			}
			if (tab) {
				if (atNewline && token.type !== "comment" && token.type !== "newline") onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
				tab = null;
			}
			switch (token.type) {
				case "space":
					if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) tab = token;
					hasSpace = true;
					break;
				case "comment": {
					if (!hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
					const cb = token.source.substring(1) || " ";
					if (!comment) comment = cb;
					else comment += commentSep + cb;
					commentSep = "";
					atNewline = false;
					break;
				}
				case "newline":
					if (atNewline) {
						if (comment) comment += token.source;
						else if (!found || indicator !== "seq-item-ind") spaceBefore = true;
					} else commentSep += token.source;
					atNewline = true;
					hasNewline = true;
					if (anchor || tag) newlineAfterProp = token;
					hasSpace = true;
					break;
				case "anchor":
					if (anchor) onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
					if (token.source.endsWith(":")) onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
					anchor = token;
					start ?? (start = token.offset);
					atNewline = false;
					hasSpace = false;
					reqSpace = true;
					break;
				case "tag":
					if (tag) onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
					tag = token;
					start ?? (start = token.offset);
					atNewline = false;
					hasSpace = false;
					reqSpace = true;
					break;
				case indicator:
					if (anchor || tag) onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
					if (found) onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
					found = token;
					atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
					hasSpace = false;
					break;
				case "comma": if (flow) {
					if (comma) onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
					comma = token;
					atNewline = false;
					hasSpace = false;
					break;
				}
				default:
					onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
					atNewline = false;
					hasSpace = false;
			}
		}
		const last = tokens[tokens.length - 1];
		const end = last ? last.offset + last.source.length : offset;
		if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
		if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq")) onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
		return {
			comma,
			found,
			spaceBefore,
			comment,
			hasNewline,
			anchor,
			tag,
			newlineAfterProp,
			end,
			start: start ?? end
		};
	}
	exports.resolveProps = resolveProps;
}));
var require_util_contains_newline = /* @__PURE__ */ __commonJSMin(((exports) => {
	function containsNewline(key) {
		if (!key) return null;
		switch (key.type) {
			case "alias":
			case "scalar":
			case "double-quoted-scalar":
			case "single-quoted-scalar":
				if (key.source.includes("\n")) return true;
				if (key.end) {
					for (const st of key.end) if (st.type === "newline") return true;
				}
				return false;
			case "flow-collection":
				for (const it of key.items) {
					for (const st of it.start) if (st.type === "newline") return true;
					if (it.sep) {
						for (const st of it.sep) if (st.type === "newline") return true;
					}
					if (containsNewline(it.key) || containsNewline(it.value)) return true;
				}
				return false;
			default: return true;
		}
	}
	exports.containsNewline = containsNewline;
}));
var require_util_flow_indent_check = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilContainsNewline = require_util_contains_newline();
	function flowIndentCheck(indent, fc, onError) {
		if (fc?.type === "flow-collection") {
			const end = fc.end[0];
			if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) onError(end, "BAD_INDENT", "Flow end indicator should be more indented than parent", true);
		}
	}
	exports.flowIndentCheck = flowIndentCheck;
}));
var require_util_map_includes = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	function mapIncludes(ctx, items, search) {
		const { uniqueKeys } = ctx.options;
		if (uniqueKeys === false) return false;
		const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
		return items.some((pair) => isEqual(pair.key, search));
	}
	exports.mapIncludes = mapIncludes;
}));
var require_resolve_block_map = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Pair = require_Pair();
	var YAMLMap = require_YAMLMap();
	var resolveProps = require_resolve_props();
	var utilContainsNewline = require_util_contains_newline();
	var utilFlowIndentCheck = require_util_flow_indent_check();
	var utilMapIncludes = require_util_map_includes();
	var startColMsg = "All mapping items must start at the same column";
	function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
		const map$6 = new (tag?.nodeClass ?? YAMLMap.YAMLMap)(ctx.schema);
		if (ctx.atRoot) ctx.atRoot = false;
		let offset = bm.offset;
		let commentEnd = null;
		for (const collItem of bm.items) {
			const { start, key, sep, value: value$1 } = collItem;
			const keyProps = resolveProps.resolveProps(start, {
				indicator: "explicit-key-ind",
				next: key ?? sep?.[0],
				offset,
				onError,
				parentIndent: bm.indent,
				startOnNewline: true
			});
			const implicitKey = !keyProps.found;
			if (implicitKey) {
				if (key) {
					if (key.type === "block-seq") onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
					else if ("indent" in key && key.indent !== bm.indent) onError(offset, "BAD_INDENT", startColMsg);
				}
				if (!keyProps.anchor && !keyProps.tag && !sep) {
					commentEnd = keyProps.end;
					if (keyProps.comment) if (map$6.comment) map$6.comment += "\n" + keyProps.comment;
					else map$6.comment = keyProps.comment;
					continue;
				}
				if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
			} else if (keyProps.found?.indent !== bm.indent) onError(offset, "BAD_INDENT", startColMsg);
			ctx.atKey = true;
			const keyStart = keyProps.end;
			const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
			if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
			ctx.atKey = false;
			if (utilMapIncludes.mapIncludes(ctx, map$6.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
			const valueProps = resolveProps.resolveProps(sep ?? [], {
				indicator: "map-value-ind",
				next: value$1,
				offset: keyNode.range[2],
				onError,
				parentIndent: bm.indent,
				startOnNewline: !key || key.type === "block-scalar"
			});
			offset = valueProps.end;
			if (valueProps.found) {
				if (implicitKey) {
					if (value$1?.type === "block-map" && !valueProps.hasNewline) onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
					if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
				}
				const valueNode = value$1 ? composeNode(ctx, value$1, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
				if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, value$1, onError);
				offset = valueNode.range[2];
				const pair = new Pair.Pair(keyNode, valueNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				map$6.items.push(pair);
			} else {
				if (implicitKey) onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
				if (valueProps.comment) if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
				else keyNode.comment = valueProps.comment;
				const pair = new Pair.Pair(keyNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				map$6.items.push(pair);
			}
		}
		if (commentEnd && commentEnd < offset) onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
		map$6.range = [
			bm.offset,
			offset,
			commentEnd ?? offset
		];
		return map$6;
	}
	exports.resolveBlockMap = resolveBlockMap;
}));
var require_resolve_block_seq = /* @__PURE__ */ __commonJSMin(((exports) => {
	var YAMLSeq = require_YAMLSeq();
	var resolveProps = require_resolve_props();
	var utilFlowIndentCheck = require_util_flow_indent_check();
	function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
		const seq$1 = new (tag?.nodeClass ?? YAMLSeq.YAMLSeq)(ctx.schema);
		if (ctx.atRoot) ctx.atRoot = false;
		if (ctx.atKey) ctx.atKey = false;
		let offset = bs.offset;
		let commentEnd = null;
		for (const { start, value: value$1 } of bs.items) {
			const props = resolveProps.resolveProps(start, {
				indicator: "seq-item-ind",
				next: value$1,
				offset,
				onError,
				parentIndent: bs.indent,
				startOnNewline: true
			});
			if (!props.found) if (props.anchor || props.tag || value$1) if (value$1?.type === "block-seq") onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
			else onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
			else {
				commentEnd = props.end;
				if (props.comment) seq$1.comment = props.comment;
				continue;
			}
			const node = value$1 ? composeNode(ctx, value$1, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
			if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bs.indent, value$1, onError);
			offset = node.range[2];
			seq$1.items.push(node);
		}
		seq$1.range = [
			bs.offset,
			offset,
			commentEnd ?? offset
		];
		return seq$1;
	}
	exports.resolveBlockSeq = resolveBlockSeq;
}));
var require_resolve_end = /* @__PURE__ */ __commonJSMin(((exports) => {
	function resolveEnd(end, offset, reqSpace, onError) {
		let comment = "";
		if (end) {
			let hasSpace = false;
			let sep = "";
			for (const token of end) {
				const { source, type } = token;
				switch (type) {
					case "space":
						hasSpace = true;
						break;
					case "comment": {
						if (reqSpace && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
						const cb = source.substring(1) || " ";
						if (!comment) comment = cb;
						else comment += sep + cb;
						sep = "";
						break;
					}
					case "newline":
						if (comment) sep += source;
						hasSpace = true;
						break;
					default: onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
				}
				offset += source.length;
			}
		}
		return {
			comment,
			offset
		};
	}
	exports.resolveEnd = resolveEnd;
}));
var require_resolve_flow_collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Pair = require_Pair();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	var resolveEnd = require_resolve_end();
	var resolveProps = require_resolve_props();
	var utilContainsNewline = require_util_contains_newline();
	var utilMapIncludes = require_util_map_includes();
	var blockMsg = "Block collections are not allowed within flow collections";
	var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
	function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
		const isMap = fc.start.source === "{";
		const fcName = isMap ? "flow map" : "flow sequence";
		const coll = new (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq))(ctx.schema);
		coll.flow = true;
		const atRoot = ctx.atRoot;
		if (atRoot) ctx.atRoot = false;
		if (ctx.atKey) ctx.atKey = false;
		let offset = fc.offset + fc.start.source.length;
		for (let i = 0; i < fc.items.length; ++i) {
			const collItem = fc.items[i];
			const { start, key, sep, value: value$1 } = collItem;
			const props = resolveProps.resolveProps(start, {
				flow: fcName,
				indicator: "explicit-key-ind",
				next: key ?? sep?.[0],
				offset,
				onError,
				parentIndent: fc.indent,
				startOnNewline: false
			});
			if (!props.found) {
				if (!props.anchor && !props.tag && !sep && !value$1) {
					if (i === 0 && props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
					else if (i < fc.items.length - 1) onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
					if (props.comment) if (coll.comment) coll.comment += "\n" + props.comment;
					else coll.comment = props.comment;
					offset = props.end;
					continue;
				}
				if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key)) onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
			}
			if (i === 0) {
				if (props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
			} else {
				if (!props.comma) onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
				if (props.comment) {
					let prevItemComment = "";
					loop: for (const st of start) switch (st.type) {
						case "comma":
						case "space": break;
						case "comment":
							prevItemComment = st.source.substring(1);
							break loop;
						default: break loop;
					}
					if (prevItemComment) {
						let prev = coll.items[coll.items.length - 1];
						if (identity.isPair(prev)) prev = prev.value ?? prev.key;
						if (prev.comment) prev.comment += "\n" + prevItemComment;
						else prev.comment = prevItemComment;
						props.comment = props.comment.substring(prevItemComment.length + 1);
					}
				}
			}
			if (!isMap && !sep && !props.found) {
				const valueNode = value$1 ? composeNode(ctx, value$1, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
				coll.items.push(valueNode);
				offset = valueNode.range[2];
				if (isBlock(value$1)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
			} else {
				ctx.atKey = true;
				const keyStart = props.end;
				const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
				if (isBlock(key)) onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
				ctx.atKey = false;
				const valueProps = resolveProps.resolveProps(sep ?? [], {
					flow: fcName,
					indicator: "map-value-ind",
					next: value$1,
					offset: keyNode.range[2],
					onError,
					parentIndent: fc.indent,
					startOnNewline: false
				});
				if (valueProps.found) {
					if (!isMap && !props.found && ctx.options.strict) {
						if (sep) for (const st of sep) {
							if (st === valueProps.found) break;
							if (st.type === "newline") {
								onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
								break;
							}
						}
						if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
					}
				} else if (value$1) if ("source" in value$1 && value$1.source?.[0] === ":") onError(value$1, "MISSING_CHAR", `Missing space after : in ${fcName}`);
				else onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
				const valueNode = value$1 ? composeNode(ctx, value$1, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
				if (valueNode) {
					if (isBlock(value$1)) onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
				} else if (valueProps.comment) if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
				else keyNode.comment = valueProps.comment;
				const pair = new Pair.Pair(keyNode, valueNode);
				if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
				if (isMap) {
					const map$6 = coll;
					if (utilMapIncludes.mapIncludes(ctx, map$6.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
					map$6.items.push(pair);
				} else {
					const map$6 = new YAMLMap.YAMLMap(ctx.schema);
					map$6.flow = true;
					map$6.items.push(pair);
					const endRange = (valueNode ?? keyNode).range;
					map$6.range = [
						keyNode.range[0],
						endRange[1],
						endRange[2]
					];
					coll.items.push(map$6);
				}
				offset = valueNode ? valueNode.range[2] : valueProps.end;
			}
		}
		const expectedEnd = isMap ? "}" : "]";
		const [ce, ...ee] = fc.end;
		let cePos = offset;
		if (ce?.source === expectedEnd) cePos = ce.offset + ce.source.length;
		else {
			const name$1 = fcName[0].toUpperCase() + fcName.substring(1);
			const msg = atRoot ? `${name$1} must end with a ${expectedEnd}` : `${name$1} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
			onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
			if (ce && ce.source.length !== 1) ee.unshift(ce);
		}
		if (ee.length > 0) {
			const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
			if (end.comment) if (coll.comment) coll.comment += "\n" + end.comment;
			else coll.comment = end.comment;
			coll.range = [
				fc.offset,
				cePos,
				end.offset
			];
		} else coll.range = [
			fc.offset,
			cePos,
			cePos
		];
		return coll;
	}
	exports.resolveFlowCollection = resolveFlowCollection;
}));
var require_compose_collection = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Scalar = require_Scalar();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	var resolveBlockMap = require_resolve_block_map();
	var resolveBlockSeq = require_resolve_block_seq();
	var resolveFlowCollection = require_resolve_flow_collection();
	function resolveCollection(CN, ctx, token, onError, tagName, tag) {
		const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
		const Coll = coll.constructor;
		if (tagName === "!" || tagName === Coll.tagName) {
			coll.tag = Coll.tagName;
			return coll;
		}
		if (tagName) coll.tag = tagName;
		return coll;
	}
	function composeCollection(CN, ctx, token, props, onError) {
		const tagToken = props.tag;
		const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
		if (token.type === "block-seq") {
			const { anchor, newlineAfterProp: nl } = props;
			const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
			if (lastProp && (!nl || nl.offset < lastProp.offset)) onError(lastProp, "MISSING_CHAR", "Missing newline after block sequence props");
		}
		const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
		if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") return resolveCollection(CN, ctx, token, onError, tagName);
		let tag = ctx.schema.tags.find((t$1) => t$1.tag === tagName && t$1.collection === expType);
		if (!tag) {
			const kt = ctx.schema.knownTags[tagName];
			if (kt?.collection === expType) {
				ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
				tag = kt;
			} else {
				if (kt) onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
				else onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
				return resolveCollection(CN, ctx, token, onError, tagName);
			}
		}
		const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
		const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
		const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
		node.range = coll.range;
		node.tag = tagName;
		if (tag?.format) node.format = tag.format;
		return node;
	}
	exports.composeCollection = composeCollection;
}));
var require_resolve_block_scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	function resolveBlockScalar(ctx, scalar, onError) {
		const start = scalar.offset;
		const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
		if (!header) return {
			value: "",
			type: null,
			comment: "",
			range: [
				start,
				start,
				start
			]
		};
		const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
		const lines = scalar.source ? splitLines(scalar.source) : [];
		let chompStart = lines.length;
		for (let i = lines.length - 1; i >= 0; --i) {
			const content = lines[i][1];
			if (content === "" || content === "\r") chompStart = i;
			else break;
		}
		if (chompStart === 0) {
			const value$2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
			let end$1 = start + header.length;
			if (scalar.source) end$1 += scalar.source.length;
			return {
				value: value$2,
				type,
				comment: header.comment,
				range: [
					start,
					end$1,
					end$1
				]
			};
		}
		let trimIndent = scalar.indent + header.indent;
		let offset = scalar.offset + header.length;
		let contentStart = 0;
		for (let i = 0; i < chompStart; ++i) {
			const [indent, content] = lines[i];
			if (content === "" || content === "\r") {
				if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
			} else {
				if (indent.length < trimIndent) onError(offset + indent.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator");
				if (header.indent === 0) trimIndent = indent.length;
				contentStart = i;
				if (trimIndent === 0 && !ctx.atRoot) onError(offset, "BAD_INDENT", "Block scalar values in collections must be indented");
				break;
			}
			offset += indent.length + content.length + 1;
		}
		for (let i = lines.length - 1; i >= chompStart; --i) if (lines[i][0].length > trimIndent) chompStart = i + 1;
		let value$1 = "";
		let sep = "";
		let prevMoreIndented = false;
		for (let i = 0; i < contentStart; ++i) value$1 += lines[i][0].slice(trimIndent) + "\n";
		for (let i = contentStart; i < chompStart; ++i) {
			let [indent, content] = lines[i];
			offset += indent.length + content.length + 1;
			const crlf = content[content.length - 1] === "\r";
			if (crlf) content = content.slice(0, -1);
			/* istanbul ignore if already caught in lexer */
			if (content && indent.length < trimIndent) {
				const message = `Block scalar lines must not be less indented than their ${header.indent ? "explicit indentation indicator" : "first line"}`;
				onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
				indent = "";
			}
			if (type === Scalar.Scalar.BLOCK_LITERAL) {
				value$1 += sep + indent.slice(trimIndent) + content;
				sep = "\n";
			} else if (indent.length > trimIndent || content[0] === "	") {
				if (sep === " ") sep = "\n";
				else if (!prevMoreIndented && sep === "\n") sep = "\n\n";
				value$1 += sep + indent.slice(trimIndent) + content;
				sep = "\n";
				prevMoreIndented = true;
			} else if (content === "") if (sep === "\n") value$1 += "\n";
			else sep = "\n";
			else {
				value$1 += sep + content;
				sep = " ";
				prevMoreIndented = false;
			}
		}
		switch (header.chomp) {
			case "-": break;
			case "+":
				for (let i = chompStart; i < lines.length; ++i) value$1 += "\n" + lines[i][0].slice(trimIndent);
				if (value$1[value$1.length - 1] !== "\n") value$1 += "\n";
				break;
			default: value$1 += "\n";
		}
		const end = start + header.length + scalar.source.length;
		return {
			value: value$1,
			type,
			comment: header.comment,
			range: [
				start,
				end,
				end
			]
		};
	}
	function parseBlockScalarHeader({ offset, props }, strict, onError) {
		/* istanbul ignore if should not happen */
		if (props[0].type !== "block-scalar-header") {
			onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
			return null;
		}
		const { source } = props[0];
		const mode = source[0];
		let indent = 0;
		let chomp = "";
		let error = -1;
		for (let i = 1; i < source.length; ++i) {
			const ch = source[i];
			if (!chomp && (ch === "-" || ch === "+")) chomp = ch;
			else {
				const n$1 = Number(ch);
				if (!indent && n$1) indent = n$1;
				else if (error === -1) error = offset + i;
			}
		}
		if (error !== -1) onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
		let hasSpace = false;
		let comment = "";
		let length = source.length;
		for (let i = 1; i < props.length; ++i) {
			const token = props[i];
			switch (token.type) {
				case "space": hasSpace = true;
				case "newline":
					length += token.source.length;
					break;
				case "comment":
					if (strict && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
					length += token.source.length;
					comment = token.source.substring(1);
					break;
				case "error":
					onError(token, "UNEXPECTED_TOKEN", token.message);
					length += token.source.length;
					break;
				default: {
					onError(token, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${token.type}`);
					const ts = token.source;
					if (ts && typeof ts === "string") length += ts.length;
				}
			}
		}
		return {
			mode,
			indent,
			chomp,
			comment,
			length
		};
	}
	function splitLines(source) {
		const split = source.split(/\n( *)/);
		const first = split[0];
		const m = first.match(/^( *)/);
		const lines = [m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first]];
		for (let i = 1; i < split.length; i += 2) lines.push([split[i], split[i + 1]]);
		return lines;
	}
	exports.resolveBlockScalar = resolveBlockScalar;
}));
var require_resolve_flow_scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Scalar = require_Scalar();
	var resolveEnd = require_resolve_end();
	function resolveFlowScalar(scalar, strict, onError) {
		const { offset, type, source, end } = scalar;
		let _type;
		let value$1;
		const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
		switch (type) {
			case "scalar":
				_type = Scalar.Scalar.PLAIN;
				value$1 = plainValue(source, _onError);
				break;
			case "single-quoted-scalar":
				_type = Scalar.Scalar.QUOTE_SINGLE;
				value$1 = singleQuotedValue(source, _onError);
				break;
			case "double-quoted-scalar":
				_type = Scalar.Scalar.QUOTE_DOUBLE;
				value$1 = doubleQuotedValue(source, _onError);
				break;
			default:
				onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
				return {
					value: "",
					type: null,
					comment: "",
					range: [
						offset,
						offset + source.length,
						offset + source.length
					]
				};
		}
		const valueEnd = offset + source.length;
		const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
		return {
			value: value$1,
			type: _type,
			comment: re.comment,
			range: [
				offset,
				valueEnd,
				re.offset
			]
		};
	}
	function plainValue(source, onError) {
		let badChar = "";
		switch (source[0]) {
			case "	":
				badChar = "a tab character";
				break;
			case ",":
				badChar = "flow indicator character ,";
				break;
			case "%":
				badChar = "directive indicator character %";
				break;
			case "|":
			case ">":
				badChar = `block scalar indicator ${source[0]}`;
				break;
			case "@":
			case "`":
				badChar = `reserved character ${source[0]}`;
				break;
		}
		if (badChar) onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
		return foldLines(source);
	}
	function singleQuotedValue(source, onError) {
		if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
		return foldLines(source.slice(1, -1)).replace(/''/g, "'");
	}
	function foldLines(source) {
		let first, line;
		try {
			first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
			line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
		} catch {
			first = /(.*?)[ \t]*\r?\n/sy;
			line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
		}
		let match$3 = first.exec(source);
		if (!match$3) return source;
		let res = match$3[1];
		let sep = " ";
		let pos = first.lastIndex;
		line.lastIndex = pos;
		while (match$3 = line.exec(source)) {
			if (match$3[1] === "") if (sep === "\n") res += sep;
			else sep = "\n";
			else {
				res += sep + match$3[1];
				sep = " ";
			}
			pos = line.lastIndex;
		}
		const last = /[ \t]*(.*)/sy;
		last.lastIndex = pos;
		match$3 = last.exec(source);
		return res + sep + (match$3?.[1] ?? "");
	}
	function doubleQuotedValue(source, onError) {
		let res = "";
		for (let i = 1; i < source.length - 1; ++i) {
			const ch = source[i];
			if (ch === "\r" && source[i + 1] === "\n") continue;
			if (ch === "\n") {
				const { fold, offset } = foldNewline(source, i);
				res += fold;
				i = offset;
			} else if (ch === "\\") {
				let next = source[++i];
				const cc = escapeCodes[next];
				if (cc) res += cc;
				else if (next === "\n") {
					next = source[i + 1];
					while (next === " " || next === "	") next = source[++i + 1];
				} else if (next === "\r" && source[i + 1] === "\n") {
					next = source[++i + 1];
					while (next === " " || next === "	") next = source[++i + 1];
				} else if (next === "x" || next === "u" || next === "U") {
					const length = {
						x: 2,
						u: 4,
						U: 8
					}[next];
					res += parseCharCode(source, i + 1, length, onError);
					i += length;
				} else {
					const raw = source.substr(i - 1, 2);
					onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
					res += raw;
				}
			} else if (ch === " " || ch === "	") {
				const wsStart = i;
				let next = source[i + 1];
				while (next === " " || next === "	") next = source[++i + 1];
				if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n")) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
			} else res += ch;
		}
		if (source[source.length - 1] !== "\"" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing \"quote");
		return res;
	}
	function foldNewline(source, offset) {
		let fold = "";
		let ch = source[offset + 1];
		while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
			if (ch === "\r" && source[offset + 2] !== "\n") break;
			if (ch === "\n") fold += "\n";
			offset += 1;
			ch = source[offset + 1];
		}
		if (!fold) fold = " ";
		return {
			fold,
			offset
		};
	}
	var escapeCodes = {
		"0": "\0",
		a: "\x07",
		b: "\b",
		e: "\x1B",
		f: "\f",
		n: "\n",
		r: "\r",
		t: "	",
		v: "\v",
		N: "",
		_: "\xA0",
		L: "\u2028",
		P: "\u2029",
		" ": " ",
		"\"": "\"",
		"/": "/",
		"\\": "\\",
		"	": "	"
	};
	function parseCharCode(source, offset, length, onError) {
		const cc = source.substr(offset, length);
		const code = cc.length === length && /^[0-9a-fA-F]+$/.test(cc) ? parseInt(cc, 16) : NaN;
		if (isNaN(code)) {
			const raw = source.substr(offset - 2, length + 2);
			onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
			return raw;
		}
		return String.fromCodePoint(code);
	}
	exports.resolveFlowScalar = resolveFlowScalar;
}));
var require_compose_scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var identity = require_identity();
	var Scalar = require_Scalar();
	var resolveBlockScalar = require_resolve_block_scalar();
	var resolveFlowScalar = require_resolve_flow_scalar();
	function composeScalar(ctx, token, tagToken, onError) {
		const { value: value$1, type, comment, range: range$1 } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
		const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
		let tag;
		if (ctx.options.stringKeys && ctx.atKey) tag = ctx.schema[identity.SCALAR];
		else if (tagName) tag = findScalarTagByName(ctx.schema, value$1, tagName, tagToken, onError);
		else if (token.type === "scalar") tag = findScalarTagByTest(ctx, value$1, token, onError);
		else tag = ctx.schema[identity.SCALAR];
		let scalar;
		try {
			const res = tag.resolve(value$1, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
			scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
		} catch (error) {
			const msg = error instanceof Error ? error.message : String(error);
			onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
			scalar = new Scalar.Scalar(value$1);
		}
		scalar.range = range$1;
		scalar.source = value$1;
		if (type) scalar.type = type;
		if (tagName) scalar.tag = tagName;
		if (tag.format) scalar.format = tag.format;
		if (comment) scalar.comment = comment;
		return scalar;
	}
	function findScalarTagByName(schema, value$1, tagName, tagToken, onError) {
		if (tagName === "!") return schema[identity.SCALAR];
		const matchWithTest = [];
		for (const tag of schema.tags) if (!tag.collection && tag.tag === tagName) if (tag.default && tag.test) matchWithTest.push(tag);
		else return tag;
		for (const tag of matchWithTest) if (tag.test?.test(value$1)) return tag;
		const kt = schema.knownTags[tagName];
		if (kt && !kt.collection) {
			schema.tags.push(Object.assign({}, kt, {
				default: false,
				test: void 0
			}));
			return kt;
		}
		onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
		return schema[identity.SCALAR];
	}
	function findScalarTagByTest({ atKey, directives, schema }, value$1, token, onError) {
		const tag = schema.tags.find((tag$1) => (tag$1.default === true || atKey && tag$1.default === "key") && tag$1.test?.test(value$1)) || schema[identity.SCALAR];
		if (schema.compat) {
			const compat = schema.compat.find((tag$1) => tag$1.default && tag$1.test?.test(value$1)) ?? schema[identity.SCALAR];
			if (tag.tag !== compat.tag) onError(token, "TAG_RESOLVE_FAILED", `Value may be parsed as either ${directives.tagString(tag.tag)} or ${directives.tagString(compat.tag)}`, true);
		}
		return tag;
	}
	exports.composeScalar = composeScalar;
}));
var require_util_empty_scalar_position = /* @__PURE__ */ __commonJSMin(((exports) => {
	function emptyScalarPosition(offset, before, pos) {
		if (before) {
			pos ?? (pos = before.length);
			for (let i = pos - 1; i >= 0; --i) {
				let st = before[i];
				switch (st.type) {
					case "space":
					case "comment":
					case "newline":
						offset -= st.source.length;
						continue;
				}
				st = before[++i];
				while (st?.type === "space") {
					offset += st.source.length;
					st = before[++i];
				}
				break;
			}
		}
		return offset;
	}
	exports.emptyScalarPosition = emptyScalarPosition;
}));
var require_compose_node = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Alias = require_Alias();
	var identity = require_identity();
	var composeCollection = require_compose_collection();
	var composeScalar = require_compose_scalar();
	var resolveEnd = require_resolve_end();
	var utilEmptyScalarPosition = require_util_empty_scalar_position();
	var CN = {
		composeNode,
		composeEmptyNode
	};
	function composeNode(ctx, token, props, onError) {
		const atKey = ctx.atKey;
		const { spaceBefore, comment, anchor, tag } = props;
		let node;
		let isSrcToken = true;
		switch (token.type) {
			case "alias":
				node = composeAlias(ctx, token, onError);
				if (anchor || tag) onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
				break;
			case "scalar":
			case "single-quoted-scalar":
			case "double-quoted-scalar":
			case "block-scalar":
				node = composeScalar.composeScalar(ctx, token, tag, onError);
				if (anchor) node.anchor = anchor.source.substring(1);
				break;
			case "block-map":
			case "block-seq":
			case "flow-collection":
				node = composeCollection.composeCollection(CN, ctx, token, props, onError);
				if (anchor) node.anchor = anchor.source.substring(1);
				break;
			default:
				onError(token, "UNEXPECTED_TOKEN", token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`);
				node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
				isSrcToken = false;
		}
		if (anchor && node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
		if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) onError(tag ?? token, "NON_STRING_KEY", "With stringKeys, all keys must be strings");
		if (spaceBefore) node.spaceBefore = true;
		if (comment) if (token.type === "scalar" && token.source === "") node.comment = comment;
		else node.commentBefore = comment;
		if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
		return node;
	}
	function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
		const token = {
			type: "scalar",
			offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
			indent: -1,
			source: ""
		};
		const node = composeScalar.composeScalar(ctx, token, tag, onError);
		if (anchor) {
			node.anchor = anchor.source.substring(1);
			if (node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
		}
		if (spaceBefore) node.spaceBefore = true;
		if (comment) {
			node.comment = comment;
			node.range[2] = end;
		}
		return node;
	}
	function composeAlias({ options }, { offset, source, end }, onError) {
		const alias = new Alias.Alias(source.substring(1));
		if (alias.source === "") onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
		if (alias.source.endsWith(":")) onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
		const valueEnd = offset + source.length;
		const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
		alias.range = [
			offset,
			valueEnd,
			re.offset
		];
		if (re.comment) alias.comment = re.comment;
		return alias;
	}
	exports.composeEmptyNode = composeEmptyNode;
	exports.composeNode = composeNode;
}));
var require_compose_doc = /* @__PURE__ */ __commonJSMin(((exports) => {
	var Document = require_Document();
	var composeNode = require_compose_node();
	var resolveEnd = require_resolve_end();
	var resolveProps = require_resolve_props();
	function composeDoc(options, directives, { offset, start, value: value$1, end }, onError) {
		const opts = Object.assign({ _directives: directives }, options);
		const doc = new Document.Document(void 0, opts);
		const ctx = {
			atKey: false,
			atRoot: true,
			directives: doc.directives,
			options: doc.options,
			schema: doc.schema
		};
		const props = resolveProps.resolveProps(start, {
			indicator: "doc-start",
			next: value$1 ?? end?.[0],
			offset,
			onError,
			parentIndent: 0,
			startOnNewline: true
		});
		if (props.found) {
			doc.directives.docStart = true;
			if (value$1 && (value$1.type === "block-map" || value$1.type === "block-seq") && !props.hasNewline) onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
		}
		doc.contents = value$1 ? composeNode.composeNode(ctx, value$1, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
		const contentEnd = doc.contents.range[2];
		const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
		if (re.comment) doc.comment = re.comment;
		doc.range = [
			offset,
			contentEnd,
			re.offset
		];
		return doc;
	}
	exports.composeDoc = composeDoc;
}));
var require_composer = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_process$1 = __require("process");
	var directives = require_directives();
	var Document = require_Document();
	var errors = require_errors();
	var identity = require_identity();
	var composeDoc = require_compose_doc();
	var resolveEnd = require_resolve_end();
	function getErrorPos(src) {
		if (typeof src === "number") return [src, src + 1];
		if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];
		const { offset, source } = src;
		return [offset, offset + (typeof source === "string" ? source.length : 1)];
	}
	function parsePrelude(prelude) {
		let comment = "";
		let atComment = false;
		let afterEmptyLine = false;
		for (let i = 0; i < prelude.length; ++i) {
			const source = prelude[i];
			switch (source[0]) {
				case "#":
					comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
					atComment = true;
					afterEmptyLine = false;
					break;
				case "%":
					if (prelude[i + 1]?.[0] !== "#") i += 1;
					atComment = false;
					break;
				default:
					if (!atComment) afterEmptyLine = true;
					atComment = false;
			}
		}
		return {
			comment,
			afterEmptyLine
		};
	}
	var Composer = class {
		constructor(options = {}) {
			this.doc = null;
			this.atDirectives = false;
			this.prelude = [];
			this.errors = [];
			this.warnings = [];
			this.onError = (source, code, message, warning) => {
				const pos = getErrorPos(source);
				if (warning) this.warnings.push(new errors.YAMLWarning(pos, code, message));
				else this.errors.push(new errors.YAMLParseError(pos, code, message));
			};
			this.directives = new directives.Directives({ version: options.version || "1.2" });
			this.options = options;
		}
		decorate(doc, afterDoc) {
			const { comment, afterEmptyLine } = parsePrelude(this.prelude);
			if (comment) {
				const dc = doc.contents;
				if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
				else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment;
				else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
					let it = dc.items[0];
					if (identity.isPair(it)) it = it.key;
					const cb = it.commentBefore;
					it.commentBefore = cb ? `${comment}\n${cb}` : comment;
				} else {
					const cb = dc.commentBefore;
					dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
				}
			}
			if (afterDoc) {
				Array.prototype.push.apply(doc.errors, this.errors);
				Array.prototype.push.apply(doc.warnings, this.warnings);
			} else {
				doc.errors = this.errors;
				doc.warnings = this.warnings;
			}
			this.prelude = [];
			this.errors = [];
			this.warnings = [];
		}
		streamInfo() {
			return {
				comment: parsePrelude(this.prelude).comment,
				directives: this.directives,
				errors: this.errors,
				warnings: this.warnings
			};
		}
		*compose(tokens, forceDoc = false, endOffset = -1) {
			for (const token of tokens) yield* this.next(token);
			yield* this.end(forceDoc, endOffset);
		}
		*next(token) {
			if (node_process$1.env.LOG_STREAM) console.dir(token, { depth: null });
			switch (token.type) {
				case "directive":
					this.directives.add(token.source, (offset, message, warning) => {
						const pos = getErrorPos(token);
						pos[0] += offset;
						this.onError(pos, "BAD_DIRECTIVE", message, warning);
					});
					this.prelude.push(token.source);
					this.atDirectives = true;
					break;
				case "document": {
					const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
					if (this.atDirectives && !doc.directives.docStart) this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
					this.decorate(doc, false);
					if (this.doc) yield this.doc;
					this.doc = doc;
					this.atDirectives = false;
					break;
				}
				case "byte-order-mark":
				case "space": break;
				case "comment":
				case "newline":
					this.prelude.push(token.source);
					break;
				case "error": {
					const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
					const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
					if (this.atDirectives || !this.doc) this.errors.push(error);
					else this.doc.errors.push(error);
					break;
				}
				case "doc-end": {
					if (!this.doc) {
						this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", "Unexpected doc-end without preceding document"));
						break;
					}
					this.doc.directives.docEnd = true;
					const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
					this.decorate(this.doc, true);
					if (end.comment) {
						const dc = this.doc.comment;
						this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
					}
					this.doc.range[2] = end.offset;
					break;
				}
				default: this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
			}
		}
		*end(forceDoc = false, endOffset = -1) {
			if (this.doc) {
				this.decorate(this.doc, true);
				yield this.doc;
				this.doc = null;
			} else if (forceDoc) {
				const opts = Object.assign({ _directives: this.directives }, this.options);
				const doc = new Document.Document(void 0, opts);
				if (this.atDirectives) this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
				doc.range = [
					0,
					endOffset,
					endOffset
				];
				this.decorate(doc, false);
				yield doc;
			}
		}
	};
	exports.Composer = Composer;
}));
var require_cst_scalar = /* @__PURE__ */ __commonJSMin(((exports) => {
	var resolveBlockScalar = require_resolve_block_scalar();
	var resolveFlowScalar = require_resolve_flow_scalar();
	var errors = require_errors();
	var stringifyString = require_stringifyString();
	function resolveAsScalar(token, strict = true, onError) {
		if (token) {
			const _onError = (pos, code, message) => {
				const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
				if (onError) onError(offset, code, message);
				else throw new errors.YAMLParseError([offset, offset + 1], code, message);
			};
			switch (token.type) {
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
				case "block-scalar": return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
			}
		}
		return null;
	}
	function createScalarToken(value$1, context$2) {
		const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context$2;
		const source = stringifyString.stringifyString({
			type,
			value: value$1
		}, {
			implicitKey,
			indent: indent > 0 ? " ".repeat(indent) : "",
			inFlow,
			options: {
				blockQuote: true,
				lineWidth: -1
			}
		});
		const end = context$2.end ?? [{
			type: "newline",
			offset: -1,
			indent,
			source: "\n"
		}];
		switch (source[0]) {
			case "|":
			case ">": {
				const he = source.indexOf("\n");
				const head = source.substring(0, he);
				const body = source.substring(he + 1) + "\n";
				const props = [{
					type: "block-scalar-header",
					offset,
					indent,
					source: head
				}];
				if (!addEndtoBlockProps(props, end)) props.push({
					type: "newline",
					offset: -1,
					indent,
					source: "\n"
				});
				return {
					type: "block-scalar",
					offset,
					indent,
					props,
					source: body
				};
			}
			case "\"": return {
				type: "double-quoted-scalar",
				offset,
				indent,
				source,
				end
			};
			case "'": return {
				type: "single-quoted-scalar",
				offset,
				indent,
				source,
				end
			};
			default: return {
				type: "scalar",
				offset,
				indent,
				source,
				end
			};
		}
	}
	function setScalarValue(token, value$1, context$2 = {}) {
		let { afterKey = false, implicitKey = false, inFlow = false, type } = context$2;
		let indent = "indent" in token ? token.indent : null;
		if (afterKey && typeof indent === "number") indent += 2;
		if (!type) switch (token.type) {
			case "single-quoted-scalar":
				type = "QUOTE_SINGLE";
				break;
			case "double-quoted-scalar":
				type = "QUOTE_DOUBLE";
				break;
			case "block-scalar": {
				const header = token.props[0];
				if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
				type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
				break;
			}
			default: type = "PLAIN";
		}
		const source = stringifyString.stringifyString({
			type,
			value: value$1
		}, {
			implicitKey: implicitKey || indent === null,
			indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
			inFlow,
			options: {
				blockQuote: true,
				lineWidth: -1
			}
		});
		switch (source[0]) {
			case "|":
			case ">":
				setBlockScalarValue(token, source);
				break;
			case "\"":
				setFlowScalarValue(token, source, "double-quoted-scalar");
				break;
			case "'":
				setFlowScalarValue(token, source, "single-quoted-scalar");
				break;
			default: setFlowScalarValue(token, source, "scalar");
		}
	}
	function setBlockScalarValue(token, source) {
		const he = source.indexOf("\n");
		const head = source.substring(0, he);
		const body = source.substring(he + 1) + "\n";
		if (token.type === "block-scalar") {
			const header = token.props[0];
			if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
			header.source = head;
			token.source = body;
		} else {
			const { offset } = token;
			const indent = "indent" in token ? token.indent : -1;
			const props = [{
				type: "block-scalar-header",
				offset,
				indent,
				source: head
			}];
			if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0)) props.push({
				type: "newline",
				offset: -1,
				indent,
				source: "\n"
			});
			for (const key of Object.keys(token)) if (key !== "type" && key !== "offset") delete token[key];
			Object.assign(token, {
				type: "block-scalar",
				indent,
				props,
				source: body
			});
		}
	}
	function addEndtoBlockProps(props, end) {
		if (end) for (const st of end) switch (st.type) {
			case "space":
			case "comment":
				props.push(st);
				break;
			case "newline":
				props.push(st);
				return true;
		}
		return false;
	}
	function setFlowScalarValue(token, source, type) {
		switch (token.type) {
			case "scalar":
			case "double-quoted-scalar":
			case "single-quoted-scalar":
				token.type = type;
				token.source = source;
				break;
			case "block-scalar": {
				const end = token.props.slice(1);
				let oa = source.length;
				if (token.props[0].type === "block-scalar-header") oa -= token.props[0].source.length;
				for (const tok of end) tok.offset += oa;
				delete token.props;
				Object.assign(token, {
					type,
					source,
					end
				});
				break;
			}
			case "block-map":
			case "block-seq": {
				const nl = {
					type: "newline",
					offset: token.offset + source.length,
					indent: token.indent,
					source: "\n"
				};
				delete token.items;
				Object.assign(token, {
					type,
					source,
					end: [nl]
				});
				break;
			}
			default: {
				const indent = "indent" in token ? token.indent : -1;
				const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
				for (const key of Object.keys(token)) if (key !== "type" && key !== "offset") delete token[key];
				Object.assign(token, {
					type,
					indent,
					source,
					end
				});
			}
		}
	}
	exports.createScalarToken = createScalarToken;
	exports.resolveAsScalar = resolveAsScalar;
	exports.setScalarValue = setScalarValue;
}));
var require_cst_stringify = /* @__PURE__ */ __commonJSMin(((exports) => {
	var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
	function stringifyToken(token) {
		switch (token.type) {
			case "block-scalar": {
				let res = "";
				for (const tok of token.props) res += stringifyToken(tok);
				return res + token.source;
			}
			case "block-map":
			case "block-seq": {
				let res = "";
				for (const item of token.items) res += stringifyItem(item);
				return res;
			}
			case "flow-collection": {
				let res = token.start.source;
				for (const item of token.items) res += stringifyItem(item);
				for (const st of token.end) res += st.source;
				return res;
			}
			case "document": {
				let res = stringifyItem(token);
				if (token.end) for (const st of token.end) res += st.source;
				return res;
			}
			default: {
				let res = token.source;
				if ("end" in token && token.end) for (const st of token.end) res += st.source;
				return res;
			}
		}
	}
	function stringifyItem({ start, key, sep, value: value$1 }) {
		let res = "";
		for (const st of start) res += st.source;
		if (key) res += stringifyToken(key);
		if (sep) for (const st of sep) res += st.source;
		if (value$1) res += stringifyToken(value$1);
		return res;
	}
	exports.stringify = stringify;
}));
var require_cst_visit = /* @__PURE__ */ __commonJSMin(((exports) => {
	var BREAK = Symbol("break visit");
	var SKIP = Symbol("skip children");
	var REMOVE = Symbol("remove item");
	function visit(cst, visitor) {
		if ("type" in cst && cst.type === "document") cst = {
			start: cst.start,
			value: cst.value
		};
		_visit(Object.freeze([]), cst, visitor);
	}
	visit.BREAK = BREAK;
	visit.SKIP = SKIP;
	visit.REMOVE = REMOVE;
	visit.itemAtPath = (cst, path$5) => {
		let item = cst;
		for (const [field, index$1] of path$5) {
			const tok = item?.[field];
			if (tok && "items" in tok) item = tok.items[index$1];
			else return void 0;
		}
		return item;
	};
	visit.parentCollection = (cst, path$5) => {
		const parent$1 = visit.itemAtPath(cst, path$5.slice(0, -1));
		const field = path$5[path$5.length - 1][0];
		const coll = parent$1?.[field];
		if (coll && "items" in coll) return coll;
		throw new Error("Parent collection not found");
	};
	function _visit(path$5, item, visitor) {
		let ctrl = visitor(item, path$5);
		if (typeof ctrl === "symbol") return ctrl;
		for (const field of ["key", "value"]) {
			const token = item[field];
			if (token && "items" in token) {
				for (let i = 0; i < token.items.length; ++i) {
					const ci = _visit(Object.freeze(path$5.concat([[field, i]])), token.items[i], visitor);
					if (typeof ci === "number") i = ci - 1;
					else if (ci === BREAK) return BREAK;
					else if (ci === REMOVE) {
						token.items.splice(i, 1);
						i -= 1;
					}
				}
				if (typeof ctrl === "function" && field === "key") ctrl = ctrl(item, path$5);
			}
		}
		return typeof ctrl === "function" ? ctrl(item, path$5) : ctrl;
	}
	exports.visit = visit;
}));
var require_cst = /* @__PURE__ */ __commonJSMin(((exports) => {
	var cstScalar = require_cst_scalar();
	var cstStringify = require_cst_stringify();
	var cstVisit = require_cst_visit();
	var BOM = "";
	var DOCUMENT = "";
	var FLOW_END = "";
	var SCALAR = "";
	var isCollection = (token) => !!token && "items" in token;
	var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
	/* istanbul ignore next */
	function prettyToken(token) {
		switch (token) {
			case BOM: return "<BOM>";
			case DOCUMENT: return "<DOC>";
			case FLOW_END: return "<FLOW_END>";
			case SCALAR: return "<SCALAR>";
			default: return JSON.stringify(token);
		}
	}
	function tokenType(source) {
		switch (source) {
			case BOM: return "byte-order-mark";
			case DOCUMENT: return "doc-mode";
			case FLOW_END: return "flow-error-end";
			case SCALAR: return "scalar";
			case "---": return "doc-start";
			case "...": return "doc-end";
			case "":
			case "\n":
			case "\r\n": return "newline";
			case "-": return "seq-item-ind";
			case "?": return "explicit-key-ind";
			case ":": return "map-value-ind";
			case "{": return "flow-map-start";
			case "}": return "flow-map-end";
			case "[": return "flow-seq-start";
			case "]": return "flow-seq-end";
			case ",": return "comma";
		}
		switch (source[0]) {
			case " ":
			case "	": return "space";
			case "#": return "comment";
			case "%": return "directive-line";
			case "*": return "alias";
			case "&": return "anchor";
			case "!": return "tag";
			case "'": return "single-quoted-scalar";
			case "\"": return "double-quoted-scalar";
			case "|":
			case ">": return "block-scalar-header";
		}
		return null;
	}
	exports.createScalarToken = cstScalar.createScalarToken;
	exports.resolveAsScalar = cstScalar.resolveAsScalar;
	exports.setScalarValue = cstScalar.setScalarValue;
	exports.stringify = cstStringify.stringify;
	exports.visit = cstVisit.visit;
	exports.BOM = BOM;
	exports.DOCUMENT = DOCUMENT;
	exports.FLOW_END = FLOW_END;
	exports.SCALAR = SCALAR;
	exports.isCollection = isCollection;
	exports.isScalar = isScalar;
	exports.prettyToken = prettyToken;
	exports.tokenType = tokenType;
}));
var require_lexer = /* @__PURE__ */ __commonJSMin(((exports) => {
	var cst = require_cst();
	function isEmpty(ch) {
		switch (ch) {
			case void 0:
			case " ":
			case "\n":
			case "\r":
			case "	": return true;
			default: return false;
		}
	}
	var hexDigits = /* @__PURE__ */ new Set("0123456789ABCDEFabcdef");
	var tagChars = /* @__PURE__ */ new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
	var flowIndicatorChars = /* @__PURE__ */ new Set(",[]{}");
	var invalidAnchorChars = /* @__PURE__ */ new Set(" ,[]{}\n\r	");
	var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
	var Lexer = class {
		constructor() {
			this.atEnd = false;
			this.blockScalarIndent = -1;
			this.blockScalarKeep = false;
			this.buffer = "";
			this.flowKey = false;
			this.flowLevel = 0;
			this.indentNext = 0;
			this.indentValue = 0;
			this.lineEndPos = null;
			this.next = null;
			this.pos = 0;
		}
		*lex(source, incomplete = false) {
			if (source) {
				if (typeof source !== "string") throw TypeError("source is not a string");
				this.buffer = this.buffer ? this.buffer + source : source;
				this.lineEndPos = null;
			}
			this.atEnd = !incomplete;
			let next = this.next ?? "stream";
			while (next && (incomplete || this.hasChars(1))) next = yield* this.parseNext(next);
		}
		atLineEnd() {
			let i = this.pos;
			let ch = this.buffer[i];
			while (ch === " " || ch === "	") ch = this.buffer[++i];
			if (!ch || ch === "#" || ch === "\n") return true;
			if (ch === "\r") return this.buffer[i + 1] === "\n";
			return false;
		}
		charAt(n$1) {
			return this.buffer[this.pos + n$1];
		}
		continueScalar(offset) {
			let ch = this.buffer[offset];
			if (this.indentNext > 0) {
				let indent = 0;
				while (ch === " ") ch = this.buffer[++indent + offset];
				if (ch === "\r") {
					const next = this.buffer[indent + offset + 1];
					if (next === "\n" || !next && !this.atEnd) return offset + indent + 1;
				}
				return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
			}
			if (ch === "-" || ch === ".") {
				const dt = this.buffer.substr(offset, 3);
				if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3])) return -1;
			}
			return offset;
		}
		getLine() {
			let end = this.lineEndPos;
			if (typeof end !== "number" || end !== -1 && end < this.pos) {
				end = this.buffer.indexOf("\n", this.pos);
				this.lineEndPos = end;
			}
			if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
			if (this.buffer[end - 1] === "\r") end -= 1;
			return this.buffer.substring(this.pos, end);
		}
		hasChars(n$1) {
			return this.pos + n$1 <= this.buffer.length;
		}
		setNext(state) {
			this.buffer = this.buffer.substring(this.pos);
			this.pos = 0;
			this.lineEndPos = null;
			this.next = state;
			return null;
		}
		peek(n$1) {
			return this.buffer.substr(this.pos, n$1);
		}
		*parseNext(next) {
			switch (next) {
				case "stream": return yield* this.parseStream();
				case "line-start": return yield* this.parseLineStart();
				case "block-start": return yield* this.parseBlockStart();
				case "doc": return yield* this.parseDocument();
				case "flow": return yield* this.parseFlowCollection();
				case "quoted-scalar": return yield* this.parseQuotedScalar();
				case "block-scalar": return yield* this.parseBlockScalar();
				case "plain-scalar": return yield* this.parsePlainScalar();
			}
		}
		*parseStream() {
			let line = this.getLine();
			if (line === null) return this.setNext("stream");
			if (line[0] === cst.BOM) {
				yield* this.pushCount(1);
				line = line.substring(1);
			}
			if (line[0] === "%") {
				let dirEnd = line.length;
				let cs = line.indexOf("#");
				while (cs !== -1) {
					const ch = line[cs - 1];
					if (ch === " " || ch === "	") {
						dirEnd = cs - 1;
						break;
					} else cs = line.indexOf("#", cs + 1);
				}
				while (true) {
					const ch = line[dirEnd - 1];
					if (ch === " " || ch === "	") dirEnd -= 1;
					else break;
				}
				const n$1 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
				yield* this.pushCount(line.length - n$1);
				this.pushNewline();
				return "stream";
			}
			if (this.atLineEnd()) {
				const sp = yield* this.pushSpaces(true);
				yield* this.pushCount(line.length - sp);
				yield* this.pushNewline();
				return "stream";
			}
			yield cst.DOCUMENT;
			return yield* this.parseLineStart();
		}
		*parseLineStart() {
			const ch = this.charAt(0);
			if (!ch && !this.atEnd) return this.setNext("line-start");
			if (ch === "-" || ch === ".") {
				if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
				const s = this.peek(3);
				if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
					yield* this.pushCount(3);
					this.indentValue = 0;
					this.indentNext = 0;
					return s === "---" ? "doc" : "stream";
				}
			}
			this.indentValue = yield* this.pushSpaces(false);
			if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
			return yield* this.parseBlockStart();
		}
		*parseBlockStart() {
			const [ch0, ch1] = this.peek(2);
			if (!ch1 && !this.atEnd) return this.setNext("block-start");
			if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
				const n$1 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
				this.indentNext = this.indentValue + 1;
				this.indentValue += n$1;
				return yield* this.parseBlockStart();
			}
			return "doc";
		}
		*parseDocument() {
			yield* this.pushSpaces(true);
			const line = this.getLine();
			if (line === null) return this.setNext("doc");
			let n$1 = yield* this.pushIndicators();
			switch (line[n$1]) {
				case "#": yield* this.pushCount(line.length - n$1);
				case void 0:
					yield* this.pushNewline();
					return yield* this.parseLineStart();
				case "{":
				case "[":
					yield* this.pushCount(1);
					this.flowKey = false;
					this.flowLevel = 1;
					return "flow";
				case "}":
				case "]":
					yield* this.pushCount(1);
					return "doc";
				case "*":
					yield* this.pushUntil(isNotAnchorChar);
					return "doc";
				case "\"":
				case "'": return yield* this.parseQuotedScalar();
				case "|":
				case ">":
					n$1 += yield* this.parseBlockScalarHeader();
					n$1 += yield* this.pushSpaces(true);
					yield* this.pushCount(line.length - n$1);
					yield* this.pushNewline();
					return yield* this.parseBlockScalar();
				default: return yield* this.parsePlainScalar();
			}
		}
		*parseFlowCollection() {
			let nl, sp;
			let indent = -1;
			do {
				nl = yield* this.pushNewline();
				if (nl > 0) {
					sp = yield* this.pushSpaces(false);
					this.indentValue = indent = sp;
				} else sp = 0;
				sp += yield* this.pushSpaces(true);
			} while (nl + sp > 0);
			const line = this.getLine();
			if (line === null) return this.setNext("flow");
			if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
				if (!(indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}"))) {
					this.flowLevel = 0;
					yield cst.FLOW_END;
					return yield* this.parseLineStart();
				}
			}
			let n$1 = 0;
			while (line[n$1] === ",") {
				n$1 += yield* this.pushCount(1);
				n$1 += yield* this.pushSpaces(true);
				this.flowKey = false;
			}
			n$1 += yield* this.pushIndicators();
			switch (line[n$1]) {
				case void 0: return "flow";
				case "#":
					yield* this.pushCount(line.length - n$1);
					return "flow";
				case "{":
				case "[":
					yield* this.pushCount(1);
					this.flowKey = false;
					this.flowLevel += 1;
					return "flow";
				case "}":
				case "]":
					yield* this.pushCount(1);
					this.flowKey = true;
					this.flowLevel -= 1;
					return this.flowLevel ? "flow" : "doc";
				case "*":
					yield* this.pushUntil(isNotAnchorChar);
					return "flow";
				case "\"":
				case "'":
					this.flowKey = true;
					return yield* this.parseQuotedScalar();
				case ":": {
					const next = this.charAt(1);
					if (this.flowKey || isEmpty(next) || next === ",") {
						this.flowKey = false;
						yield* this.pushCount(1);
						yield* this.pushSpaces(true);
						return "flow";
					}
				}
				default:
					this.flowKey = false;
					return yield* this.parsePlainScalar();
			}
		}
		*parseQuotedScalar() {
			const quote = this.charAt(0);
			let end = this.buffer.indexOf(quote, this.pos + 1);
			if (quote === "'") while (end !== -1 && this.buffer[end + 1] === "'") end = this.buffer.indexOf("'", end + 2);
			else while (end !== -1) {
				let n$1 = 0;
				while (this.buffer[end - 1 - n$1] === "\\") n$1 += 1;
				if (n$1 % 2 === 0) break;
				end = this.buffer.indexOf("\"", end + 1);
			}
			const qb = this.buffer.substring(0, end);
			let nl = qb.indexOf("\n", this.pos);
			if (nl !== -1) {
				while (nl !== -1) {
					const cs = this.continueScalar(nl + 1);
					if (cs === -1) break;
					nl = qb.indexOf("\n", cs);
				}
				if (nl !== -1) end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
			}
			if (end === -1) {
				if (!this.atEnd) return this.setNext("quoted-scalar");
				end = this.buffer.length;
			}
			yield* this.pushToIndex(end + 1, false);
			return this.flowLevel ? "flow" : "doc";
		}
		*parseBlockScalarHeader() {
			this.blockScalarIndent = -1;
			this.blockScalarKeep = false;
			let i = this.pos;
			while (true) {
				const ch = this.buffer[++i];
				if (ch === "+") this.blockScalarKeep = true;
				else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1;
				else if (ch !== "-") break;
			}
			return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
		}
		*parseBlockScalar() {
			let nl = this.pos - 1;
			let indent = 0;
			let ch;
			loop: for (let i$1 = this.pos; ch = this.buffer[i$1]; ++i$1) switch (ch) {
				case " ":
					indent += 1;
					break;
				case "\n":
					nl = i$1;
					indent = 0;
					break;
				case "\r": {
					const next = this.buffer[i$1 + 1];
					if (!next && !this.atEnd) return this.setNext("block-scalar");
					if (next === "\n") break;
				}
				default: break loop;
			}
			if (!ch && !this.atEnd) return this.setNext("block-scalar");
			if (indent >= this.indentNext) {
				if (this.blockScalarIndent === -1) this.indentNext = indent;
				else this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
				do {
					const cs = this.continueScalar(nl + 1);
					if (cs === -1) break;
					nl = this.buffer.indexOf("\n", cs);
				} while (nl !== -1);
				if (nl === -1) {
					if (!this.atEnd) return this.setNext("block-scalar");
					nl = this.buffer.length;
				}
			}
			let i = nl + 1;
			ch = this.buffer[i];
			while (ch === " ") ch = this.buffer[++i];
			if (ch === "	") {
				while (ch === "	" || ch === " " || ch === "\r" || ch === "\n") ch = this.buffer[++i];
				nl = i - 1;
			} else if (!this.blockScalarKeep) do {
				let i$1 = nl - 1;
				let ch$1 = this.buffer[i$1];
				if (ch$1 === "\r") ch$1 = this.buffer[--i$1];
				const lastChar = i$1;
				while (ch$1 === " ") ch$1 = this.buffer[--i$1];
				if (ch$1 === "\n" && i$1 >= this.pos && i$1 + 1 + indent > lastChar) nl = i$1;
				else break;
			} while (true);
			yield cst.SCALAR;
			yield* this.pushToIndex(nl + 1, true);
			return yield* this.parseLineStart();
		}
		*parsePlainScalar() {
			const inFlow = this.flowLevel > 0;
			let end = this.pos - 1;
			let i = this.pos - 1;
			let ch;
			while (ch = this.buffer[++i]) if (ch === ":") {
				const next = this.buffer[i + 1];
				if (isEmpty(next) || inFlow && flowIndicatorChars.has(next)) break;
				end = i;
			} else if (isEmpty(ch)) {
				let next = this.buffer[i + 1];
				if (ch === "\r") if (next === "\n") {
					i += 1;
					ch = "\n";
					next = this.buffer[i + 1];
				} else end = i;
				if (next === "#" || inFlow && flowIndicatorChars.has(next)) break;
				if (ch === "\n") {
					const cs = this.continueScalar(i + 1);
					if (cs === -1) break;
					i = Math.max(i, cs - 2);
				}
			} else {
				if (inFlow && flowIndicatorChars.has(ch)) break;
				end = i;
			}
			if (!ch && !this.atEnd) return this.setNext("plain-scalar");
			yield cst.SCALAR;
			yield* this.pushToIndex(end + 1, true);
			return inFlow ? "flow" : "doc";
		}
		*pushCount(n$1) {
			if (n$1 > 0) {
				yield this.buffer.substr(this.pos, n$1);
				this.pos += n$1;
				return n$1;
			}
			return 0;
		}
		*pushToIndex(i, allowEmpty) {
			const s = this.buffer.slice(this.pos, i);
			if (s) {
				yield s;
				this.pos += s.length;
				return s.length;
			} else if (allowEmpty) yield "";
			return 0;
		}
		*pushIndicators() {
			switch (this.charAt(0)) {
				case "!": return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
				case "&": return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
				case "-":
				case "?":
				case ":": {
					const inFlow = this.flowLevel > 0;
					const ch1 = this.charAt(1);
					if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
						if (!inFlow) this.indentNext = this.indentValue + 1;
						else if (this.flowKey) this.flowKey = false;
						return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
					}
				}
			}
			return 0;
		}
		*pushTag() {
			if (this.charAt(1) === "<") {
				let i = this.pos + 2;
				let ch = this.buffer[i];
				while (!isEmpty(ch) && ch !== ">") ch = this.buffer[++i];
				return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
			} else {
				let i = this.pos + 1;
				let ch = this.buffer[i];
				while (ch) if (tagChars.has(ch)) ch = this.buffer[++i];
				else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) ch = this.buffer[i += 3];
				else break;
				return yield* this.pushToIndex(i, false);
			}
		}
		*pushNewline() {
			const ch = this.buffer[this.pos];
			if (ch === "\n") return yield* this.pushCount(1);
			else if (ch === "\r" && this.charAt(1) === "\n") return yield* this.pushCount(2);
			else return 0;
		}
		*pushSpaces(allowTabs) {
			let i = this.pos - 1;
			let ch;
			do
				ch = this.buffer[++i];
			while (ch === " " || allowTabs && ch === "	");
			const n$1 = i - this.pos;
			if (n$1 > 0) {
				yield this.buffer.substr(this.pos, n$1);
				this.pos = i;
			}
			return n$1;
		}
		*pushUntil(test) {
			let i = this.pos;
			let ch = this.buffer[i];
			while (!test(ch)) ch = this.buffer[++i];
			return yield* this.pushToIndex(i, false);
		}
	};
	exports.Lexer = Lexer;
}));
var require_line_counter = /* @__PURE__ */ __commonJSMin(((exports) => {
	var LineCounter = class {
		constructor() {
			this.lineStarts = [];
			this.addNewLine = (offset) => this.lineStarts.push(offset);
			this.linePos = (offset) => {
				let low = 0;
				let high = this.lineStarts.length;
				while (low < high) {
					const mid = low + high >> 1;
					if (this.lineStarts[mid] < offset) low = mid + 1;
					else high = mid;
				}
				if (this.lineStarts[low] === offset) return {
					line: low + 1,
					col: 1
				};
				if (low === 0) return {
					line: 0,
					col: offset
				};
				const start = this.lineStarts[low - 1];
				return {
					line: low,
					col: offset - start + 1
				};
			};
		}
	};
	exports.LineCounter = LineCounter;
}));
var require_parser = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_process = __require("process");
	var cst = require_cst();
	var lexer = require_lexer();
	function includesToken(list, type) {
		for (let i = 0; i < list.length; ++i) if (list[i].type === type) return true;
		return false;
	}
	function findNonEmptyIndex(list) {
		for (let i = 0; i < list.length; ++i) switch (list[i].type) {
			case "space":
			case "comment":
			case "newline": break;
			default: return i;
		}
		return -1;
	}
	function isFlowToken(token) {
		switch (token?.type) {
			case "alias":
			case "scalar":
			case "single-quoted-scalar":
			case "double-quoted-scalar":
			case "flow-collection": return true;
			default: return false;
		}
	}
	function getPrevProps(parent$1) {
		switch (parent$1.type) {
			case "document": return parent$1.start;
			case "block-map": {
				const it = parent$1.items[parent$1.items.length - 1];
				return it.sep ?? it.start;
			}
			case "block-seq": return parent$1.items[parent$1.items.length - 1].start;
			default: return [];
		}
	}
	function getFirstKeyStartProps(prev) {
		if (prev.length === 0) return [];
		let i = prev.length;
		loop: while (--i >= 0) switch (prev[i].type) {
			case "doc-start":
			case "explicit-key-ind":
			case "map-value-ind":
			case "seq-item-ind":
			case "newline": break loop;
		}
		while (prev[++i]?.type === "space");
		return prev.splice(i, prev.length);
	}
	function fixFlowSeqItems(fc) {
		if (fc.start.type === "flow-seq-start") {
			for (const it of fc.items) if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
				if (it.key) it.value = it.key;
				delete it.key;
				if (isFlowToken(it.value)) if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
				else it.value.end = it.sep;
				else Array.prototype.push.apply(it.start, it.sep);
				delete it.sep;
			}
		}
	}
	var Parser = class {
		constructor(onNewLine) {
			this.atNewLine = true;
			this.atScalar = false;
			this.indent = 0;
			this.offset = 0;
			this.onKeyLine = false;
			this.stack = [];
			this.source = "";
			this.type = "";
			this.lexer = new lexer.Lexer();
			this.onNewLine = onNewLine;
		}
		*parse(source, incomplete = false) {
			if (this.onNewLine && this.offset === 0) this.onNewLine(0);
			for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
			if (!incomplete) yield* this.end();
		}
		*next(source) {
			this.source = source;
			if (node_process.env.LOG_TOKENS) console.log("|", cst.prettyToken(source));
			if (this.atScalar) {
				this.atScalar = false;
				yield* this.step();
				this.offset += source.length;
				return;
			}
			const type = cst.tokenType(source);
			if (!type) {
				const message = `Not a YAML token: ${source}`;
				yield* this.pop({
					type: "error",
					offset: this.offset,
					message,
					source
				});
				this.offset += source.length;
			} else if (type === "scalar") {
				this.atNewLine = false;
				this.atScalar = true;
				this.type = "scalar";
			} else {
				this.type = type;
				yield* this.step();
				switch (type) {
					case "newline":
						this.atNewLine = true;
						this.indent = 0;
						if (this.onNewLine) this.onNewLine(this.offset + source.length);
						break;
					case "space":
						if (this.atNewLine && source[0] === " ") this.indent += source.length;
						break;
					case "explicit-key-ind":
					case "map-value-ind":
					case "seq-item-ind":
						if (this.atNewLine) this.indent += source.length;
						break;
					case "doc-mode":
					case "flow-error-end": return;
					default: this.atNewLine = false;
				}
				this.offset += source.length;
			}
		}
		*end() {
			while (this.stack.length > 0) yield* this.pop();
		}
		get sourceToken() {
			return {
				type: this.type,
				offset: this.offset,
				indent: this.indent,
				source: this.source
			};
		}
		*step() {
			const top = this.peek(1);
			if (this.type === "doc-end" && top?.type !== "doc-end") {
				while (this.stack.length > 0) yield* this.pop();
				this.stack.push({
					type: "doc-end",
					offset: this.offset,
					source: this.source
				});
				return;
			}
			if (!top) return yield* this.stream();
			switch (top.type) {
				case "document": return yield* this.document(top);
				case "alias":
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return yield* this.scalar(top);
				case "block-scalar": return yield* this.blockScalar(top);
				case "block-map": return yield* this.blockMap(top);
				case "block-seq": return yield* this.blockSequence(top);
				case "flow-collection": return yield* this.flowCollection(top);
				case "doc-end": return yield* this.documentEnd(top);
			}
			/* istanbul ignore next should not happen */
			yield* this.pop();
		}
		peek(n$1) {
			return this.stack[this.stack.length - n$1];
		}
		*pop(error) {
			const token = error ?? this.stack.pop();
			/* istanbul ignore if should not happen */
			if (!token) yield {
				type: "error",
				offset: this.offset,
				source: "",
				message: "Tried to pop an empty stack"
			};
			else if (this.stack.length === 0) yield token;
			else {
				const top = this.peek(1);
				if (token.type === "block-scalar") token.indent = "indent" in top ? top.indent : 0;
				else if (token.type === "flow-collection" && top.type === "document") token.indent = 0;
				if (token.type === "flow-collection") fixFlowSeqItems(token);
				switch (top.type) {
					case "document":
						top.value = token;
						break;
					case "block-scalar":
						top.props.push(token);
						break;
					case "block-map": {
						const it = top.items[top.items.length - 1];
						if (it.value) {
							top.items.push({
								start: [],
								key: token,
								sep: []
							});
							this.onKeyLine = true;
							return;
						} else if (it.sep) it.value = token;
						else {
							Object.assign(it, {
								key: token,
								sep: []
							});
							this.onKeyLine = !it.explicitKey;
							return;
						}
						break;
					}
					case "block-seq": {
						const it = top.items[top.items.length - 1];
						if (it.value) top.items.push({
							start: [],
							value: token
						});
						else it.value = token;
						break;
					}
					case "flow-collection": {
						const it = top.items[top.items.length - 1];
						if (!it || it.value) top.items.push({
							start: [],
							key: token,
							sep: []
						});
						else if (it.sep) it.value = token;
						else Object.assign(it, {
							key: token,
							sep: []
						});
						return;
					}
					default:
						yield* this.pop();
						yield* this.pop(token);
				}
				if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
					const last = token.items[token.items.length - 1];
					if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
						if (top.type === "document") top.end = last.start;
						else top.items.push({ start: last.start });
						token.items.splice(-1, 1);
					}
				}
			}
		}
		*stream() {
			switch (this.type) {
				case "directive-line":
					yield {
						type: "directive",
						offset: this.offset,
						source: this.source
					};
					return;
				case "byte-order-mark":
				case "space":
				case "comment":
				case "newline":
					yield this.sourceToken;
					return;
				case "doc-mode":
				case "doc-start": {
					const doc = {
						type: "document",
						offset: this.offset,
						start: []
					};
					if (this.type === "doc-start") doc.start.push(this.sourceToken);
					this.stack.push(doc);
					return;
				}
			}
			yield {
				type: "error",
				offset: this.offset,
				message: `Unexpected ${this.type} token in YAML stream`,
				source: this.source
			};
		}
		*document(doc) {
			if (doc.value) return yield* this.lineEnd(doc);
			switch (this.type) {
				case "doc-start":
					if (findNonEmptyIndex(doc.start) !== -1) {
						yield* this.pop();
						yield* this.step();
					} else doc.start.push(this.sourceToken);
					return;
				case "anchor":
				case "tag":
				case "space":
				case "comment":
				case "newline":
					doc.start.push(this.sourceToken);
					return;
			}
			const bv = this.startBlockValue(doc);
			if (bv) this.stack.push(bv);
			else yield {
				type: "error",
				offset: this.offset,
				message: `Unexpected ${this.type} token in YAML document`,
				source: this.source
			};
		}
		*scalar(scalar) {
			if (this.type === "map-value-ind") {
				const start = getFirstKeyStartProps(getPrevProps(this.peek(2)));
				let sep;
				if (scalar.end) {
					sep = scalar.end;
					sep.push(this.sourceToken);
					delete scalar.end;
				} else sep = [this.sourceToken];
				const map$6 = {
					type: "block-map",
					offset: scalar.offset,
					indent: scalar.indent,
					items: [{
						start,
						key: scalar,
						sep
					}]
				};
				this.onKeyLine = true;
				this.stack[this.stack.length - 1] = map$6;
			} else yield* this.lineEnd(scalar);
		}
		*blockScalar(scalar) {
			switch (this.type) {
				case "space":
				case "comment":
				case "newline":
					scalar.props.push(this.sourceToken);
					return;
				case "scalar":
					scalar.source = this.source;
					this.atNewLine = true;
					this.indent = 0;
					if (this.onNewLine) {
						let nl = this.source.indexOf("\n") + 1;
						while (nl !== 0) {
							this.onNewLine(this.offset + nl);
							nl = this.source.indexOf("\n", nl) + 1;
						}
					}
					yield* this.pop();
					break;
				default:
					yield* this.pop();
					yield* this.step();
			}
		}
		*blockMap(map$6) {
			const it = map$6.items[map$6.items.length - 1];
			switch (this.type) {
				case "newline":
					this.onKeyLine = false;
					if (it.value) {
						const end = "end" in it.value ? it.value.end : void 0;
						if ((Array.isArray(end) ? end[end.length - 1] : void 0)?.type === "comment") end?.push(this.sourceToken);
						else map$6.items.push({ start: [this.sourceToken] });
					} else if (it.sep) it.sep.push(this.sourceToken);
					else it.start.push(this.sourceToken);
					return;
				case "space":
				case "comment":
					if (it.value) map$6.items.push({ start: [this.sourceToken] });
					else if (it.sep) it.sep.push(this.sourceToken);
					else {
						if (this.atIndentedComment(it.start, map$6.indent)) {
							const end = map$6.items[map$6.items.length - 2]?.value?.end;
							if (Array.isArray(end)) {
								Array.prototype.push.apply(end, it.start);
								end.push(this.sourceToken);
								map$6.items.pop();
								return;
							}
						}
						it.start.push(this.sourceToken);
					}
					return;
			}
			if (this.indent >= map$6.indent) {
				const atMapIndent = !this.onKeyLine && this.indent === map$6.indent;
				const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
				let start = [];
				if (atNextItem && it.sep && !it.value) {
					const nl = [];
					for (let i = 0; i < it.sep.length; ++i) {
						const st = it.sep[i];
						switch (st.type) {
							case "newline":
								nl.push(i);
								break;
							case "space": break;
							case "comment":
								if (st.indent > map$6.indent) nl.length = 0;
								break;
							default: nl.length = 0;
						}
					}
					if (nl.length >= 2) start = it.sep.splice(nl[1]);
				}
				switch (this.type) {
					case "anchor":
					case "tag":
						if (atNextItem || it.value) {
							start.push(this.sourceToken);
							map$6.items.push({ start });
							this.onKeyLine = true;
						} else if (it.sep) it.sep.push(this.sourceToken);
						else it.start.push(this.sourceToken);
						return;
					case "explicit-key-ind":
						if (!it.sep && !it.explicitKey) {
							it.start.push(this.sourceToken);
							it.explicitKey = true;
						} else if (atNextItem || it.value) {
							start.push(this.sourceToken);
							map$6.items.push({
								start,
								explicitKey: true
							});
						} else this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start: [this.sourceToken],
								explicitKey: true
							}]
						});
						this.onKeyLine = true;
						return;
					case "map-value-ind":
						if (it.explicitKey) if (!it.sep) if (includesToken(it.start, "newline")) Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						else {
							const start$1 = getFirstKeyStartProps(it.start);
							this.stack.push({
								type: "block-map",
								offset: this.offset,
								indent: this.indent,
								items: [{
									start: start$1,
									key: null,
									sep: [this.sourceToken]
								}]
							});
						}
						else if (it.value) map$6.items.push({
							start: [],
							key: null,
							sep: [this.sourceToken]
						});
						else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start,
								key: null,
								sep: [this.sourceToken]
							}]
						});
						else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
							const start$1 = getFirstKeyStartProps(it.start);
							const key = it.key;
							const sep = it.sep;
							sep.push(this.sourceToken);
							delete it.key;
							delete it.sep;
							this.stack.push({
								type: "block-map",
								offset: this.offset,
								indent: this.indent,
								items: [{
									start: start$1,
									key,
									sep
								}]
							});
						} else if (start.length > 0) it.sep = it.sep.concat(start, this.sourceToken);
						else it.sep.push(this.sourceToken);
						else if (!it.sep) Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						else if (it.value || atNextItem) map$6.items.push({
							start,
							key: null,
							sep: [this.sourceToken]
						});
						else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
							type: "block-map",
							offset: this.offset,
							indent: this.indent,
							items: [{
								start: [],
								key: null,
								sep: [this.sourceToken]
							}]
						});
						else it.sep.push(this.sourceToken);
						this.onKeyLine = true;
						return;
					case "alias":
					case "scalar":
					case "single-quoted-scalar":
					case "double-quoted-scalar": {
						const fs$7 = this.flowScalar(this.type);
						if (atNextItem || it.value) {
							map$6.items.push({
								start,
								key: fs$7,
								sep: []
							});
							this.onKeyLine = true;
						} else if (it.sep) this.stack.push(fs$7);
						else {
							Object.assign(it, {
								key: fs$7,
								sep: []
							});
							this.onKeyLine = true;
						}
						return;
					}
					default: {
						const bv = this.startBlockValue(map$6);
						if (bv) {
							if (bv.type === "block-seq") {
								if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
									yield* this.pop({
										type: "error",
										offset: this.offset,
										message: "Unexpected block-seq-ind on same line with key",
										source: this.source
									});
									return;
								}
							} else if (atMapIndent) map$6.items.push({ start });
							this.stack.push(bv);
							return;
						}
					}
				}
			}
			yield* this.pop();
			yield* this.step();
		}
		*blockSequence(seq$1) {
			const it = seq$1.items[seq$1.items.length - 1];
			switch (this.type) {
				case "newline":
					if (it.value) {
						const end = "end" in it.value ? it.value.end : void 0;
						if ((Array.isArray(end) ? end[end.length - 1] : void 0)?.type === "comment") end?.push(this.sourceToken);
						else seq$1.items.push({ start: [this.sourceToken] });
					} else it.start.push(this.sourceToken);
					return;
				case "space":
				case "comment":
					if (it.value) seq$1.items.push({ start: [this.sourceToken] });
					else {
						if (this.atIndentedComment(it.start, seq$1.indent)) {
							const end = seq$1.items[seq$1.items.length - 2]?.value?.end;
							if (Array.isArray(end)) {
								Array.prototype.push.apply(end, it.start);
								end.push(this.sourceToken);
								seq$1.items.pop();
								return;
							}
						}
						it.start.push(this.sourceToken);
					}
					return;
				case "anchor":
				case "tag":
					if (it.value || this.indent <= seq$1.indent) break;
					it.start.push(this.sourceToken);
					return;
				case "seq-item-ind":
					if (this.indent !== seq$1.indent) break;
					if (it.value || includesToken(it.start, "seq-item-ind")) seq$1.items.push({ start: [this.sourceToken] });
					else it.start.push(this.sourceToken);
					return;
			}
			if (this.indent > seq$1.indent) {
				const bv = this.startBlockValue(seq$1);
				if (bv) {
					this.stack.push(bv);
					return;
				}
			}
			yield* this.pop();
			yield* this.step();
		}
		*flowCollection(fc) {
			const it = fc.items[fc.items.length - 1];
			if (this.type === "flow-error-end") {
				let top;
				do {
					yield* this.pop();
					top = this.peek(1);
				} while (top?.type === "flow-collection");
			} else if (fc.end.length === 0) {
				switch (this.type) {
					case "comma":
					case "explicit-key-ind":
						if (!it || it.sep) fc.items.push({ start: [this.sourceToken] });
						else it.start.push(this.sourceToken);
						return;
					case "map-value-ind":
						if (!it || it.value) fc.items.push({
							start: [],
							key: null,
							sep: [this.sourceToken]
						});
						else if (it.sep) it.sep.push(this.sourceToken);
						else Object.assign(it, {
							key: null,
							sep: [this.sourceToken]
						});
						return;
					case "space":
					case "comment":
					case "newline":
					case "anchor":
					case "tag":
						if (!it || it.value) fc.items.push({ start: [this.sourceToken] });
						else if (it.sep) it.sep.push(this.sourceToken);
						else it.start.push(this.sourceToken);
						return;
					case "alias":
					case "scalar":
					case "single-quoted-scalar":
					case "double-quoted-scalar": {
						const fs$7 = this.flowScalar(this.type);
						if (!it || it.value) fc.items.push({
							start: [],
							key: fs$7,
							sep: []
						});
						else if (it.sep) this.stack.push(fs$7);
						else Object.assign(it, {
							key: fs$7,
							sep: []
						});
						return;
					}
					case "flow-map-end":
					case "flow-seq-end":
						fc.end.push(this.sourceToken);
						return;
				}
				const bv = this.startBlockValue(fc);
				/* istanbul ignore else should not happen */
				if (bv) this.stack.push(bv);
				else {
					yield* this.pop();
					yield* this.step();
				}
			} else {
				const parent$1 = this.peek(2);
				if (parent$1.type === "block-map" && (this.type === "map-value-ind" && parent$1.indent === fc.indent || this.type === "newline" && !parent$1.items[parent$1.items.length - 1].sep)) {
					yield* this.pop();
					yield* this.step();
				} else if (this.type === "map-value-ind" && parent$1.type !== "flow-collection") {
					const start = getFirstKeyStartProps(getPrevProps(parent$1));
					fixFlowSeqItems(fc);
					const sep = fc.end.splice(1, fc.end.length);
					sep.push(this.sourceToken);
					const map$6 = {
						type: "block-map",
						offset: fc.offset,
						indent: fc.indent,
						items: [{
							start,
							key: fc,
							sep
						}]
					};
					this.onKeyLine = true;
					this.stack[this.stack.length - 1] = map$6;
				} else yield* this.lineEnd(fc);
			}
		}
		flowScalar(type) {
			if (this.onNewLine) {
				let nl = this.source.indexOf("\n") + 1;
				while (nl !== 0) {
					this.onNewLine(this.offset + nl);
					nl = this.source.indexOf("\n", nl) + 1;
				}
			}
			return {
				type,
				offset: this.offset,
				indent: this.indent,
				source: this.source
			};
		}
		startBlockValue(parent$1) {
			switch (this.type) {
				case "alias":
				case "scalar":
				case "single-quoted-scalar":
				case "double-quoted-scalar": return this.flowScalar(this.type);
				case "block-scalar-header": return {
					type: "block-scalar",
					offset: this.offset,
					indent: this.indent,
					props: [this.sourceToken],
					source: ""
				};
				case "flow-map-start":
				case "flow-seq-start": return {
					type: "flow-collection",
					offset: this.offset,
					indent: this.indent,
					start: this.sourceToken,
					items: [],
					end: []
				};
				case "seq-item-ind": return {
					type: "block-seq",
					offset: this.offset,
					indent: this.indent,
					items: [{ start: [this.sourceToken] }]
				};
				case "explicit-key-ind": {
					this.onKeyLine = true;
					const start = getFirstKeyStartProps(getPrevProps(parent$1));
					start.push(this.sourceToken);
					return {
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start,
							explicitKey: true
						}]
					};
				}
				case "map-value-ind": {
					this.onKeyLine = true;
					const start = getFirstKeyStartProps(getPrevProps(parent$1));
					return {
						type: "block-map",
						offset: this.offset,
						indent: this.indent,
						items: [{
							start,
							key: null,
							sep: [this.sourceToken]
						}]
					};
				}
			}
			return null;
		}
		atIndentedComment(start, indent) {
			if (this.type !== "comment") return false;
			if (this.indent <= indent) return false;
			return start.every((st) => st.type === "newline" || st.type === "space");
		}
		*documentEnd(docEnd) {
			if (this.type !== "doc-mode") {
				if (docEnd.end) docEnd.end.push(this.sourceToken);
				else docEnd.end = [this.sourceToken];
				if (this.type === "newline") yield* this.pop();
			}
		}
		*lineEnd(token) {
			switch (this.type) {
				case "comma":
				case "doc-start":
				case "doc-end":
				case "flow-seq-end":
				case "flow-map-end":
				case "map-value-ind":
					yield* this.pop();
					yield* this.step();
					break;
				case "newline": this.onKeyLine = false;
				case "space":
				case "comment":
				default:
					if (token.end) token.end.push(this.sourceToken);
					else token.end = [this.sourceToken];
					if (this.type === "newline") yield* this.pop();
			}
		}
	};
	exports.Parser = Parser;
}));
var require_public_api = /* @__PURE__ */ __commonJSMin(((exports) => {
	var composer = require_composer();
	var Document = require_Document();
	var errors = require_errors();
	var log = require_log();
	var identity = require_identity();
	var lineCounter = require_line_counter();
	var parser = require_parser();
	function parseOptions(options) {
		const prettyErrors = options.prettyErrors !== false;
		return {
			lineCounter: options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null,
			prettyErrors
		};
	}
	function parseAllDocuments(source, options = {}) {
		const { lineCounter, prettyErrors } = parseOptions(options);
		const parser$1 = new parser.Parser(lineCounter?.addNewLine);
		const composer$1 = new composer.Composer(options);
		const docs = Array.from(composer$1.compose(parser$1.parse(source)));
		if (prettyErrors && lineCounter) for (const doc of docs) {
			doc.errors.forEach(errors.prettifyError(source, lineCounter));
			doc.warnings.forEach(errors.prettifyError(source, lineCounter));
		}
		if (docs.length > 0) return docs;
		return Object.assign([], { empty: true }, composer$1.streamInfo());
	}
	function parseDocument(source, options = {}) {
		const { lineCounter, prettyErrors } = parseOptions(options);
		const parser$1 = new parser.Parser(lineCounter?.addNewLine);
		const composer$1 = new composer.Composer(options);
		let doc = null;
		for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) if (!doc) doc = _doc;
		else if (doc.options.logLevel !== "silent") {
			doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
			break;
		}
		if (prettyErrors && lineCounter) {
			doc.errors.forEach(errors.prettifyError(source, lineCounter));
			doc.warnings.forEach(errors.prettifyError(source, lineCounter));
		}
		return doc;
	}
	function parse(src, reviver, options) {
		let _reviver = void 0;
		if (typeof reviver === "function") _reviver = reviver;
		else if (options === void 0 && reviver && typeof reviver === "object") options = reviver;
		const doc = parseDocument(src, options);
		if (!doc) return null;
		doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
		if (doc.errors.length > 0) if (doc.options.logLevel !== "silent") throw doc.errors[0];
		else doc.errors = [];
		return doc.toJS(Object.assign({ reviver: _reviver }, options));
	}
	function stringify(value$1, replacer, options) {
		let _replacer = null;
		if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
		else if (options === void 0 && replacer) options = replacer;
		if (typeof options === "string") options = options.length;
		if (typeof options === "number") {
			const indent = Math.round(options);
			options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
		}
		if (value$1 === void 0) {
			const { keepUndefined } = options ?? replacer ?? {};
			if (!keepUndefined) return void 0;
		}
		if (identity.isDocument(value$1) && !_replacer) return value$1.toString(options);
		return new Document.Document(value$1, _replacer, options).toString(options);
	}
	exports.parse = parse;
	exports.parseAllDocuments = parseAllDocuments;
	exports.parseDocument = parseDocument;
	exports.stringify = stringify;
}));
var import_dist = (/* @__PURE__ */ __commonJSMin(((exports) => {
	var composer = require_composer();
	var Document = require_Document();
	var Schema = require_Schema();
	var errors = require_errors();
	var Alias = require_Alias();
	var identity = require_identity();
	var Pair = require_Pair();
	var Scalar = require_Scalar();
	var YAMLMap = require_YAMLMap();
	var YAMLSeq = require_YAMLSeq();
	require_cst();
	var lexer = require_lexer();
	var lineCounter = require_line_counter();
	var parser = require_parser();
	var publicApi = require_public_api();
	var visit = require_visit();
	exports.Composer = composer.Composer;
	exports.Document = Document.Document;
	exports.Schema = Schema.Schema;
	exports.YAMLError = errors.YAMLError;
	exports.YAMLParseError = errors.YAMLParseError;
	exports.YAMLWarning = errors.YAMLWarning;
	exports.Alias = Alias.Alias;
	exports.isAlias = identity.isAlias;
	exports.isCollection = identity.isCollection;
	exports.isDocument = identity.isDocument;
	exports.isMap = identity.isMap;
	exports.isNode = identity.isNode;
	exports.isPair = identity.isPair;
	exports.isScalar = identity.isScalar;
	exports.isSeq = identity.isSeq;
	exports.Pair = Pair.Pair;
	exports.Scalar = Scalar.Scalar;
	exports.YAMLMap = YAMLMap.YAMLMap;
	exports.YAMLSeq = YAMLSeq.YAMLSeq;
	exports.Lexer = lexer.Lexer;
	exports.LineCounter = lineCounter.LineCounter;
	exports.Parser = parser.Parser;
	exports.parse = publicApi.parse;
	exports.parseAllDocuments = publicApi.parseAllDocuments;
	exports.parseDocument = publicApi.parseDocument;
	exports.stringify = publicApi.stringify;
	exports.visit = visit.visit;
	exports.visitAsync = visit.visitAsync;
})))();
var import_core$1 = /* @__PURE__ */ __toESM(require_core$1(), 1);
const getGithubToken = gen(function* () {
	return value(yield* ActionConfig.githubToken);
});
const getAttributesInput = ActionConfig.attributes.pipe(mapError$2(() => new MissingAttributesError({ message: "attributes input is required" })));
const setDiffOutput = (results) => {
	if (results.length > 0) {
		const diffOutputs = results.map((r$1) => ({
			displayName: r$1.displayName,
			diff: r$1.diff
		}));
		import_core$1.setOutput("diff", JSON.stringify(diffOutputs));
	}
};
const loadDiffPipelineConfig = gen(function* () {
	const attributesInput = yield* getAttributesInput;
	const directoryInput = yield* ActionConfig.directory;
	const build$2 = yield* ActionConfig.build;
	const runIdOption = yield* ActionConfig.githubRunId;
	const runId = getOrElse(runIdOption, () => crypto$1.randomUUID());
	const cwd = yield* sync$2(() => process.cwd());
	return {
		attributes: yield* parseAttributes(attributesInput),
		directory: yield* validateDirectory(directoryInput, cwd),
		build: build$2,
		runId,
		runIdOption,
		cwd
	};
});
const runDiffPipeline = gen(function* () {
	const pr = yield* (yield* GitHubService).getPullRequest();
	const config = yield* loadDiffPipelineConfig;
	return {
		config,
		results: yield* scoped$2(processDiffResults({
			attributes: config.attributes,
			build: config.build,
			directory: config.directory,
			baseRef: pr.base.ref,
			baseSha: pr.base.sha,
			headSha: pr.head.sha,
			cwd: config.cwd,
			runId: config.runId
		}))
	};
});
const postComment = (params) => gen(function* () {
	const githubService = yield* GitHubService;
	const context$2 = githubService.getContext();
	const pr = yield* githubService.getPullRequest();
	const willTruncate = checkIfAnyDiffTruncated(params.results);
	const repoUrl = `https://github.com/${context$2.repo.owner}/${context$2.repo.repo}`;
	const formatOptions = willTruncate && params.showArtifactLinkWhenTruncated ? {
		runId: params.runId,
		repoUrl
	} : { repoUrl };
	yield* githubService.postAggregatedComment(githubService.createOctokit(params.token), context$2, pr, params.results, {
		skipNoChange: params.skipNoChange,
		commentStrategy: params.commentStrategy
	}, formatOptions);
});
const loadCommentConfig = gen(function* () {
	return {
		skipNoChange: yield* ActionConfig.skipNoChange,
		commentStrategy: yield* parseCommentStrategy(yield* ActionConfig.commentStrategy)
	};
});
var processNixOutput = (config, baseFlakeRef, prFlakeRef, baseSha, headSha, build$2, worktreePath) => gen(function* () {
	const nix = yield* NixService;
	yield* logInfo(`Processing ${config.displayName}: ${baseFlakeRef}#${config.attribute} vs ${prFlakeRef}#${config.attribute}`);
	const { basePath, prPath } = yield* all({
		basePath: nix.getNixPath(`${baseFlakeRef}#${config.attribute}`, build$2),
		prPath: nix.getNixPath(`${prFlakeRef}#${config.attribute}`, build$2)
	});
	yield* logInfo(`Base path: ${basePath}`);
	yield* logInfo(`PR path: ${prPath}`);
	const diff = yield* nix.getDixDiff(basePath, prPath, worktreePath);
	return {
		displayName: config.displayName,
		attributePath: config.attribute,
		baseRef: baseSha,
		prRef: headSha,
		diff
	};
});
const processDiffResults = (options) => gen(function* () {
	const git = yield* GitService;
	const nix = yield* NixService;
	const worktree = yield* git.createWorktree(options.baseRef, options.runId);
	const relativePath = nodePath$1.relative(options.cwd, options.directory);
	const baseFlakeRef = relativePath === "" || relativePath === "." ? `path:${worktree.path}` : `path:${worktree.path}?dir=${relativePath}`;
	const prFlakeRef = options.directory;
	yield* all([nix.prefetchFlakeInputs(baseFlakeRef), nix.prefetchFlakeInputs(prFlakeRef)], { concurrency: 2 });
	return yield* forEach(options.attributes, (config) => processNixOutput(config, baseFlakeRef, prFlakeRef, options.baseSha, options.headSha, options.build, worktree.path));
});
const runFull = gen(function* () {
	const artifactService = yield* ArtifactService;
	const token = yield* getGithubToken;
	const commentConfig = yield* loadCommentConfig;
	const { config, results } = yield* runDiffPipeline;
	yield* artifactService.uploadDiffResults(results, "full");
	yield* postComment({
		results,
		runId: config.runId,
		skipNoChange: commentConfig.skipNoChange,
		commentStrategy: commentConfig.commentStrategy,
		token,
		showArtifactLinkWhenTruncated: isSome(config.runIdOption)
	});
	setDiffOutput(results);
});
const runDiff = gen(function* () {
	const artifactService = yield* ArtifactService;
	const { config, results } = yield* runDiffPipeline;
	setDiffOutput(results);
	yield* artifactService.uploadDiffResults(results, config.attributes[0].displayName);
});
const runComment = gen(function* () {
	const githubService = yield* GitHubService;
	const artifactService = yield* ArtifactService;
	const context$2 = githubService.getContext();
	const token = yield* getGithubToken;
	const commentConfig = yield* loadCommentConfig;
	yield* postComment({
		results: yield* artifactService.downloadAllDiffResults(token, context$2.runId, context$2.repo.owner, context$2.repo.repo),
		runId: String(context$2.runId),
		skipNoChange: commentConfig.skipNoChange,
		commentStrategy: commentConfig.commentStrategy,
		token,
		showArtifactLinkWhenTruncated: true
	});
});
const parseAttributes = (input) => gen(function* () {
	const parsed = yield* try_({
		try: () => (0, import_dist.parse)(input),
		catch: (e$1) => new AttributeParseError({ message: `YAML parse error: ${e$1 instanceof Error ? e$1.message : String(e$1)}` })
	});
	if (!Array.isArray(parsed)) return yield* fail$2(new AttributeParseError({ message: "attributes must be a YAML array" }));
	return yield* decodeUnknown(NixOutputConfigArray)(parsed).pipe(mapError$2((e$1) => new AttributeParseError({ message: `Invalid attributes format: ${e$1.message}` })));
});
var CommentStrategySchema = Literal("create", "update");
const parseCommentStrategy = (input) => decodeUnknown(CommentStrategySchema)(input).pipe(mapError$2(() => new InvalidCommentStrategyError({ value: input })));
const validateDirectory = (directory, workspaceRoot) => {
	const resolvedPath = nodePath.resolve(workspaceRoot, directory);
	const normalizedWorkspace = nodePath.resolve(workspaceRoot);
	return resolvedPath.startsWith(normalizedWorkspace + nodePath.sep) || resolvedPath === normalizedWorkspace ? succeed$2(resolvedPath) : fail$2(new InvalidDirectoryError({ message: `directory must be within the workspace. Got: ${directory} (resolved to ${resolvedPath})` }));
};
var import_core = /* @__PURE__ */ __toESM(require_core$1(), 1);
var program = gen(function* () {
	switch (yield* ActionConfig.mode) {
		case "full": return yield* runFull;
		case "diff-only": return yield* runDiff;
		case "comment-only": return yield* runComment;
	}
});
var setFailed = (message) => sync$2(() => import_core.setFailed(message));
const run = () => program.pipe(tapError$2((error) => logError("Action failed", { error: typeof error === "object" && error !== null && "_tag" in error ? error._tag : "Unknown" })), catchTags({
	InvalidModeError: (e$1) => setFailed(`Invalid mode: ${e$1.mode}`),
	NotPullRequestContextError: (e$1) => setFailed(e$1.message),
	MissingAttributesError: (e$1) => setFailed(e$1.message),
	AttributeParseError: (e$1) => setFailed(e$1.message),
	InvalidCommentStrategyError: (e$1) => setFailed(`Invalid comment strategy: ${e$1.value}`),
	InvalidDirectoryError: (e$1) => setFailed(e$1.message),
	GitWorktreeError: (e$1) => setFailed(`Git ${e$1.operation} failed: ${e$1.message}`),
	NixPathInfoError: (e$1) => setFailed(`Nix path-info failed for ${e$1.flakeRef}: ${e$1.message}`),
	NixBuildError: (e$1) => setFailed(`Nix build failed for ${e$1.flakeRef}: ${e$1.message}`),
	NixDixError: (e$1) => setFailed(`Nix dix failed comparing ${e$1.basePath} vs ${e$1.prPath}: ${e$1.message}`),
	GitHubApiError: (e$1) => setFailed(`GitHub ${e$1.operation} failed: ${e$1.message}`),
	ArtifactError: (e$1) => setFailed(`Artifact ${e$1.name} failed: ${e$1.message}`)
}), catchIf(isConfigError, (e$1) => setFailed(`Configuration error: ${e$1}`)), catchAll$2((error) => setFailed(`Unexpected error: ${error}`)), scoped$2, provide$2(merge$1(MainLayer, ConfigProviderLayer)), runPromise);
run();
export {};

//# sourceMappingURL=index.js.map