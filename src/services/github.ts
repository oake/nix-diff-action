import * as github from "@actions/github";
import { Effect, Option } from "effect";
import { NotPullRequestContextError, GitHubApiError } from "../errors.js";
import type { GitHubContext, Octokit, PullRequestPayload, CommentOptions } from "../types.js";
import type { DiffResult } from "../schemas.js";
import { hasDixChanges } from "./utils.js";

const NIX_DIFF_ACTION_MARKER_BASE = "<!-- nix-diff-action";

// Generate marker for identifying nix-diff-action comments
//
// Why single vs multiple attribute matters:
// - Single attribute: Use displayName-specific marker (<!-- nix-diff-action:host1 -->)
//   This enables matrix strategy where each job posts its own comment with `comment-strategy: update`.
//   Each comment can be updated independently without affecting others.
//
// - Multiple attributes: Use generic marker (<!-- nix-diff-action -->)
//   Results order may vary (e.g., comment-only mode downloads artifacts in parallel),
//   so we can't reliably use a specific displayName. Generic marker ensures
//   the aggregated comment is always found and updated correctly.
const getNixDiffActionMarker = (displayName?: string): string =>
  displayName
    ? `${NIX_DIFF_ACTION_MARKER_BASE}:${displayName} -->`
    : `${NIX_DIFF_ACTION_MARKER_BASE} -->`;

// GitHub comment size limit is ~65,536 characters. Use a conservative limit.
const MAX_COMMENT_LENGTH = 60000;
// Overhead for header, footer, and per-section markup
const HEADER_FOOTER_OVERHEAD = 300;
const PER_SECTION_OVERHEAD = 300;

export type TruncateResult = {
  text: string;
  truncated: boolean;
};

export const truncateDiff = (diff: string, maxLength: number): TruncateResult => {
  if (diff.length <= maxLength) return { text: diff, truncated: false };
  return {
    text: `${diff.slice(0, maxLength)}\n\n... (truncated, ${diff.length} chars total)`,
    truncated: true,
  };
};

// Remove markdown special characters to prevent formatting disruption
// Preserves Unicode letters (日本語 etc.), numbers, hyphens, dots, and spaces
export const sanitizeDisplayName = (text: string): string =>
  text.replace(/[\\`*_{}[\]()#+!|]/g, "");

// Calculate max diff length per attribute based on total limit and count
const calculateMaxDiffPerAttribute = (attributeCount: number): number => {
  const availableForDiffs =
    MAX_COMMENT_LENGTH - HEADER_FOOTER_OVERHEAD - PER_SECTION_OVERHEAD * attributeCount;
  return Math.max(1000, Math.floor(availableForDiffs / attributeCount));
};

// Check if any diff in results would be truncated
export const checkIfAnyDiffTruncated = (results: readonly DiffResult[]): boolean => {
  const maxLength = calculateMaxDiffPerAttribute(results.length);
  return results.some((r) => r.diff.length > maxLength);
};

export type FormatCommentOptions = {
  runId?: string;
  repoUrl?: string;
};

export const formatAggregatedComment = (
  results: readonly DiffResult[],
  headSha: string,
  options?: FormatCommentOptions,
): string => {
  const maxDiffLength = calculateMaxDiffPerAttribute(results.length);
  // Single attribute: displayName-specific marker for matrix + update strategy
  // Multiple attributes: generic marker (results order may vary in comment-only mode)
  const marker =
    results.length === 1
      ? getNixDiffActionMarker(results[0].displayName)
      : getNixDiffActionMarker();

  const sections = results
    .map((result) => {
      const { truncated, text } = truncateDiff(
        result.diff || "No differences found",
        maxDiffLength,
      );
      const artifactHint =
        truncated && options?.runId && options?.repoUrl
          ? `\n\n> **Note**: Diff was truncated. [View full diff in artifacts](${options.repoUrl}/actions/runs/${options.runId})`
          : "";

      return `### ${sanitizeDisplayName(result.displayName)}

**Attribute**: \`${result.attributePath}\`

<details>
<summary>Diff Output</summary>

\`\`\`
${text}
\`\`\`
${artifactHint}
</details>`;
    })
    .join("\n\n");

  // Format compare link once for the entire comment
  const compareDisplay = options?.repoUrl
    ? `[Compare changes](${options.repoUrl}/compare/${results[0].baseRef}...${results[0].prRef})`
    : `\`${results[0].baseRef}...${results[0].prRef}\``;

  const footer = `---
<sub>Generated by [nix-diff-action](https://github.com/natsukium/nix-diff-action) using [dix](https://github.com/faukah/dix)</sub>
<!-- nix-diff-action-footer sha=${headSha} -->`;

  return `${marker}
## Nix Diff

${compareDisplay}

${sections}

${footer}`;
};

// Common: list all comments with nix-diff-action marker
// If displayName is provided, search for displayName-specific marker
const listNixDiffComments = (
  octokit: Octokit,
  context: GitHubContext,
  prNumber: number,
  displayName?: string,
) =>
  Effect.tryPromise({
    try: () =>
      octokit.paginate(octokit.rest.issues.listComments, {
        ...context.repo,
        issue_number: prNumber,
      }),
    catch: (e) =>
      new GitHubApiError({
        operation: "listComments",
        message: `Failed to list comments: ${e}`,
      }),
  }).pipe(
    Effect.map((comments) => {
      const marker = getNixDiffActionMarker(displayName);
      return comments.filter((c) => c.body?.includes(marker));
    }),
  );

const findExistingNixDiffComment = (
  octokit: Octokit,
  context: GitHubContext,
  prNumber: number,
  displayName?: string,
): Effect.Effect<Option.Option<{ id: number }>, GitHubApiError> =>
  listNixDiffComments(octokit, context, prNumber, displayName).pipe(
    Effect.map((comments) => Option.fromNullable(comments[0])),
    Effect.map(Option.map((c) => ({ id: c.id }))),
  );

const findOldNixDiffComments = (
  octokit: Octokit,
  context: GitHubContext,
  prNumber: number,
  currentHeadSha: string,
  displayName?: string,
): Effect.Effect<Array<{ id: number; node_id: string }>, GitHubApiError> =>
  listNixDiffComments(octokit, context, prNumber, displayName).pipe(
    Effect.map((comments) =>
      comments
        .filter((c) => !c.body?.includes(`sha=${currentHeadSha}`))
        .map((c) => ({ id: c.id, node_id: c.node_id })),
    ),
  );

const minimizeOldComments = (
  octokit: Octokit,
  context: GitHubContext,
  prNumber: number,
  currentHeadSha: string,
  displayName?: string,
): Effect.Effect<void, GitHubApiError> =>
  findOldNixDiffComments(octokit, context, prNumber, currentHeadSha, displayName).pipe(
    Effect.flatMap((oldComments) =>
      Effect.forEach(
        oldComments,
        (comment) =>
          Effect.tryPromise({
            try: () =>
              octokit.graphql(
                `
                mutation($input: MinimizeCommentInput!) {
                  minimizeComment(input: $input) {
                    minimizedComment {
                      isMinimized
                    }
                  }
                }
                `,
                {
                  input: {
                    subjectId: comment.node_id,
                    classifier: "OUTDATED",
                  },
                },
              ),
            catch: (e) =>
              new GitHubApiError({
                operation: "minimizeComment",
                message: `Failed to minimize comment ${comment.id}: ${e}`,
              }),
          }).pipe(
            Effect.flatMap(() => Effect.logInfo(`Minimized outdated comment (ID: ${comment.id})`)),
            Effect.catchAll((error) =>
              Effect.logWarning(`Failed to minimize comment ${comment.id}: ${error.message}`),
            ),
          ),
        { concurrency: "unbounded" },
      ),
    ),
  );

const updateComment = (octokit: Octokit, context: GitHubContext, commentId: number, body: string) =>
  Effect.tryPromise({
    try: () =>
      octokit.rest.issues.updateComment({
        ...context.repo,
        comment_id: commentId,
        body,
      }),
    catch: (e) =>
      new GitHubApiError({
        operation: "updateComment",
        message: `Failed to update comment: ${e}`,
      }),
  });

const createComment = (octokit: Octokit, context: GitHubContext, prNumber: number, body: string) =>
  Effect.tryPromise({
    try: () =>
      octokit.rest.issues.createComment({
        ...context.repo,
        issue_number: prNumber,
        body,
      }),
    catch: (e) =>
      new GitHubApiError({
        operation: "createComment",
        message: `Failed to create comment: ${e}`,
      }),
  });

export class GitHubService extends Effect.Service<GitHubService>()("GitHubService", {
  succeed: {
    getContext: (): GitHubContext => github.context,

    getPullRequest: (): Effect.Effect<PullRequestPayload, NotPullRequestContextError> =>
      Effect.gen(function* () {
        const pr = github.context.payload.pull_request;
        if (!pr) {
          return yield* Effect.fail(
            new NotPullRequestContextError({
              message: "This action must be run in a pull request context",
            }),
          );
        }
        return pr as PullRequestPayload;
      }),

    createOctokit: (token: string): Octokit => github.getOctokit(token),

    postAggregatedComment: (
      octokit: Octokit,
      context: GitHubContext,
      pr: PullRequestPayload,
      results: readonly DiffResult[],
      options: CommentOptions,
      formatOptions?: FormatCommentOptions,
    ): Effect.Effect<void, GitHubApiError> =>
      Effect.gen(function* () {
        const hasChanges = results.some((r) => hasDixChanges(r.diff));
        const commentBody = formatAggregatedComment(results, pr.head.sha, formatOptions);
        // Use displayName-specific marker for single attribute
        const displayName = results.length === 1 ? results[0].displayName : undefined;

        if (options.skipNoChange && !hasChanges) {
          return yield* Effect.logInfo(
            "No differences found. Skipping comment (skip-no-change is enabled).",
          );
        }

        if (options.commentStrategy === "update") {
          const existing = yield* findExistingNixDiffComment(
            octokit,
            context,
            pr.number,
            displayName,
          );
          return yield* Option.match(existing, {
            onNone: () =>
              Effect.gen(function* () {
                yield* createComment(octokit, context, pr.number, commentBody);
                yield* Effect.logInfo("Posted new aggregated diff comment to PR");
              }),
            onSome: (e) =>
              Effect.gen(function* () {
                yield* updateComment(octokit, context, e.id, commentBody);
                yield* Effect.logInfo("Updated existing diff comment");
              }),
          });
        }

        if (options.commentStrategy === "create") {
          yield* minimizeOldComments(octokit, context, pr.number, pr.head.sha, displayName);
        }
        yield* createComment(octokit, context, pr.number, commentBody);
        yield* Effect.logInfo("Posted new aggregated diff comment to PR");
      }),
  },
}) {}
